

<!DOCTYPE html>

<html lang="es" data-content_root="../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>2.2.2. Archivos y directorios &#8212; documentación de Linuxnomicón - rolling</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=03e43079" />
    <link rel="stylesheet" type="text/css" href="../../_static/classic.css?v=2bf1fcf8" />
    <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
    
    <script src="../../_static/documentation_options.js?v=a621b78a"></script>
    <script src="../../_static/doctools.js?v=9bcbadda"></script>
    <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../_static/translations.js?v=f85f4cfb"></script>
    
    <link rel="index" title="Índice" href="../../genindex.html" />
    <link rel="search" title="Búsqueda" href="../../search.html" />
    <link rel="next" title="2.2.3. Dispositivos" href="04.devices.html" />
    <link rel="prev" title="2.2.1. El sistema de archivos" href="01.filesystem.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="Related">
      <h3>Navegación</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="Índice General"
             accesskey="I">índice</a></li>
        <li class="right" >
          <a href="04.devices.html" title="2.2.3. Dispositivos"
             accesskey="N">siguiente</a> |</li>
        <li class="right" >
          <a href="01.filesystem.html" title="2.2.1. El sistema de archivos"
             accesskey="P">anterior</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">documentación de Linuxnomicón - rolling</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" ><span class="section-number">2. </span>Conceptos básicos</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="index.html" accesskey="U"><span class="section-number">2.2. </span>Acceso a la información</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href=""><span class="section-number">2.2.2. </span>Archivos y directorios</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="archivos-y-directorios">
<span id="fic-dir"></span><h1><span class="section-number">2.2.2. </span>Archivos y directorios<a class="headerlink" href="#archivos-y-directorios" title="Link to this heading">¶</a></h1>
<section id="bicheando">
<h2><span class="section-number">2.2.2.1. </span>Bicheando<a class="headerlink" href="#bicheando" title="Link to this heading">¶</a></h2>
<section id="dentro-de-directorios">
<h3><span class="section-number">2.2.2.1.1. </span>… dentro de directorios<a class="headerlink" href="#dentro-de-directorios" title="Link to this heading">¶</a></h3>
<p>Nuestra intención ahora es echarle un vistazo a los comandos que nos permiten
tanto comprobar cuál es el contenido de un archivo como comprobar cuál es el
contenido de un directorio.</p>
<p>Por supuesto, para hacer referencia a archivos y directorios es indispensable
conocer <a class="reference external" href="rutas">cómo referirse a ellos</a>.</p>
<span id="pwd"></span><dl id="index-0">
<dt><em class="manpage"><a class="manpage reference external" href="https://manpages.debian.org/pwd">pwd</a></em></dt><dd><p>Nos permite conocer en qué directorio estamos:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span><span class="nb">pwd</span>
<span class="go">/home/usuario</span>
</pre></div>
</div>
</dd>
</dl>
<span id="ls"></span><dl id="index-1">
<dt><em class="manpage"><a class="manpage reference external" href="https://manpages.debian.org/ls">ls</a></em></dt><dd><p>El comando fundamental para ver el contenido de un directorio es <strong class="command">ls</strong>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">ls [opciones] [&lt;nombre1&gt; [&lt;nombre2&gt; ...]]</span>
</pre></div>
</div>
<p>Su sintaxis permite añadir opciones (muchísimas) y el directorio (también
archivo que queremos consultar). Pueden incluirse varios y en ese caso se
mostrarán todos ellos. Por ejemplo:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>ls<span class="w"> </span>/sbin
</pre></div>
</div>
<p>Mostrará el contenido del directorio <code class="file docutils literal notranslate"><span class="pre">/sbin</span></code>. Al ser un directorio es
posible también acabar el nombre con la barra:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>ls<span class="w"> </span>/sbin/
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>Dependiendo del contexto (o sea, del programa que estemos ejecutando) será
o no indiferente rematar el nombre del directorio con la barra. En el caso
de <strong class="command">ls</strong>, sólo hay diferencia cuando el archivo es un <a class="reference internal" href="#symlink"><span class="std std-ref">enlace
simbólico</span></a> que apunta a un directorio: si se añade la barra,
se mostrará el contenido del directorio apuntado; y si no se añade, el
propio enlace simbólico.</p>
</div>
<p>También se puede usar <strong class="command">ls</strong> con un archivo:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>ls<span class="w"> </span>/bin/cp
<span class="go">/bin/cp</span>
</pre></div>
</div>
<p>En este caso, se muestra el nombre del archivo con lo que, usado así y si no se
usan comodines o expandibles, no tiene más utilidad que saber si el archivo
existe. Una opción que le da sentido a <em>mirar</em> un archivo con <strong class="command">ls</strong> es
<code class="docutils literal notranslate"><span class="pre">-l</span></code>, que permite obtener cierta información del archivo o directorio que se
consulte:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>ls<span class="w"> </span>-l<span class="w"> </span>/bin/cp
<span class="go">-rwxr-xr-x 1 root root 124932 ene 14  2015 /bin/cp</span>
</pre></div>
</div>
<p>Para cada archivo que consultemos, <strong class="command">ls</strong> nos devuelve:</p>
<ul>
<li><p>El <strong>tipo</strong> de archivo, representado por el primer carácter:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Carácter</p></th>
<th class="head"><p>Tipo de archivo</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>-</p></td>
<td><p>Archivo regular</p></td>
</tr>
<tr class="row-odd"><td><p>d</p></td>
<td><p>Directorio</p></td>
</tr>
<tr class="row-even"><td><p>l</p></td>
<td><p><a class="reference internal" href="#symlink"><span class="std std-ref">Enlace simbólico</span></a></p></td>
</tr>
<tr class="row-odd"><td><p>p</p></td>
<td><p><a class="reference internal" href="../08.redirecciones/01basica.html#pipeline"><span class="std std-ref">Tubería</span></a></p></td>
</tr>
<tr class="row-even"><td><p>b</p></td>
<td><p><a class="reference internal" href="04.devices.html#blockdevice"><span class="std std-ref">Dispositivo de bloques</span></a></p></td>
</tr>
<tr class="row-odd"><td><p>c</p></td>
<td><p><a class="reference internal" href="04.devices.html#chardevice"><span class="std std-ref">Dispositivo de caracteres</span></a></p></td>
</tr>
<tr class="row-even"><td><p>s</p></td>
<td><p>Socket</p></td>
</tr>
</tbody>
</table>
</li>
<li><p>Los nueve siguientes caracteres representan los <a class="reference internal" href="../05.seguridad/05b.permisos.html#ugo"><span class="std std-ref">permisos</span></a>,
que se tratarán más adelante.</p></li>
<li><p>El siguiente campo, que es un número, representa el número de
<strong>referencias</strong> al archivo en el sistema de archivos. Para entender esto,
tomemos primero un archivo vacío (que podemos crear con <a class="reference internal" href="#touch">touch</a>):</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>touch<span class="w"> </span>vacio
<span class="gp">$ </span>ls<span class="w"> </span>-l<span class="w"> </span>vacio
<span class="go">-rw-rw-r-- 1 usuario usuario 0 oct 14 10:02 vacio</span>
</pre></div>
</div>
<p>Este archivo recién creado ocupará un espacio físico en disco y sólo tiene
una referencia en el sistema de archivos: a través del nombre <em>vacío</em>.
Consecuentemente el número de enlaces es <em>1</em>. Sin embargo, en los sistemas
unix existen los llamados <a class="reference internal" href="#hardlink"><span class="std std-ref">enlaces duros</span></a>, que permiten
asociar ese mismo espacio de disco a otro nombre (véanse <a class="reference internal" href="#ln"><span class="std std-ref">ln</span></a> o
<a class="reference internal" href="#cp">cp</a> más adelante):</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>ln<span class="w"> </span>vacio<span class="w"> </span>mismo.vacio
<span class="gp">$ </span>ls<span class="w"> </span>-l<span class="w"> </span>vacio<span class="w"> </span>mismo.vacio
<span class="go">-rw-rw-r-- 2 profesor profesor 0 oct 14 10:02 mismo.vacio</span>
<span class="go">-rw-rw-r-- 2 profesor profesor 0 oct 14 10:02 vacio</span>
</pre></div>
</div>
<p>Ahora hay dos nombres refiriéndose al mismo espacio, por lo que aparece un
<em>2</em>. De hecho, si comprobamos qué <a class="reference internal" href="../../guias/0222.som/02.ssoo/02.gestion/04.files.html#sf-fis"><span class="std std-ref">inodo</span></a> refieren ambos
nombres, veremos que el mismo:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>ls<span class="w"> </span>-1i<span class="w"> </span>vacio<span class="w"> </span>mismo.vacio
<span class="go">669 mismo.vacio</span>
<span class="go">669 vacio</span>
</pre></div>
</div>
<p>En el caso de los directorios, el concepto es el mismo (referencias al
propio directorio), aunque no está asociado al concepto de enlaces duros.
En principio, al crear un directorio:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>mkdir<span class="w"> </span>directorio
</pre></div>
</div>
<p>hay dos referencias a él: la referencia a él que se hace en el directorio
raíz:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>ls<span class="w"> </span>-d<span class="w"> </span>directorio
<span class="go">directorio</span>
</pre></div>
</div>
<p>y la referencia a él que hace él mismo (el punto <strong>.</strong>):</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>ls<span class="w"> </span>-a<span class="w"> </span>directorio
<span class="go">. ..</span>
</pre></div>
</div>
<p>Consecuentemente, al crearse un directorio habrá dos referencias a él:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>ls<span class="w"> </span>-ld<span class="w"> </span>directorio
<span class="go">drwxrwxr-x 2 usuario usuario 4096 oct 14 12:38 directorio</span>
</pre></div>
</div>
<p>Y cada vez que creemos un subdirectorio, se generará otra referencia:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>mkdir<span class="w"> </span>directorio/subdirectorio
<span class="gp">$ </span>ls<span class="w"> </span>directorio/subdirectorio
<span class="go">. ..</span>
</pre></div>
</div>
<p>En este caso, los dos puntos (<strong>..</strong>) de <code class="file docutils literal notranslate"><span class="pre">directorio/subdirectorio</span></code>,
al referirse a su directorio padre, se refieren a <code class="file docutils literal notranslate"><span class="pre">directorio</span></code>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>ls<span class="w"> </span>-d<span class="w"> </span>directorio
<span class="go">drwxrwxr-x 3 usuario usuario 4096 oct 14 12:38 directorio</span>
</pre></div>
</div>
<p>En cambio, crear un nuevo archivo dentro del directorio no provoca ninguna
referencia:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>touch<span class="w"> </span>directorio/otro.vacio.mas
<span class="gp">$ </span>ls<span class="w"> </span>-d<span class="w"> </span>directorio
<span class="go">drwxrwxr-x 3 usuario usuario 4096 oct 14 12:38 directorio</span>
</pre></div>
</div>
<p>En conclusión, el número representa:</p>
<ul class="simple">
<li><p>Para <em>archivos</em>, representa el número de enlaces (duros) al propio
archivo.</p></li>
<li><p>Para <em>directorios</em>, <strong>2</strong> más el número de subdirectorios que contiene.</p></li>
</ul>
<div class="admonition caution">
<p class="admonition-title">Prudencia</p>
<p>En lo referente a directorios, el sistema de archivos <abbr title="B-Tree Filesystem">BTRFS</abbr>
no considera dentro de las cuentas para el número las referencias de «.»
o «..». Como para directorios no se pueden hacer enlaces duros, este
campo siempre valdrá <strong>1</strong>.  Véase <a class="reference external" href="https://www.spinics.net/lists/linux-btrfs/msg98964.html">Hard link count reported by &quot;ls -l&quot;
is wrong</a>.</p>
</div>
</li>
<li><p>Los dos siguientes campos son el <strong>usuario propietario</strong> y el <strong>grupo
propietario</strong>, cuya explicación diferiremos hasta explicar los <a class="reference external" href="Permisos">permisos</a></p></li>
<li><p>El número que se muestra a continuación es el <strong>tamaño</strong>.</p></li>
<li><p>El siguiente dato es la <strong>fecha</strong> de modificación.</p></li>
<li><p>El último campo el <strong>nombre</strong> del archivo.</p></li>
</ul>
<p>Otra opción útil es <code class="docutils literal notranslate"><span class="pre">-d</span></code>. El comportamiento de <strong class="command">ls</strong> es mostrar el
propio archivo, si es un archivo; o el contenido del directorio, si es un
directorio. Esta opción permite ver el propio directorio, y no su contenido y
puede ser útil si lo que buscamos es conocer información sobre él (permisos o
propietarios, por ejemplo):</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>ls<span class="w"> </span>-ld<span class="w"> </span>/
<span class="go">drwxr-xr-x 22 root root 4096 jul 21  2015 /</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">-l</span></code> muestra el tamaño en <em>bytes</em>, lo cual es engorroso cuando el tamaño es
grande. Para paliar esto, existe la opción <code class="docutils literal notranslate"><span class="pre">-h</span></code>, que representa el tamaño en
las unidades más adecuadas:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>ls<span class="w"> </span>-lh<span class="w"> </span>Documentos
<span class="go">-rw-rw-r-- 1 usuario usuario  473K jun 24 09:11 BOJA1.pdf</span>
<span class="go">-rw-rw-r-- 1 usuario usuario  2,6M oct  6 12:50 CuadranteFotos.pdf</span>
<span class="go">-rw-rw-r-- 1 usuario usuario   30K oct  5 17:53 Distribucion.pdf</span>
</pre></div>
</div>
<p>Por defecto, <strong class="command">ls</strong> ordena los archivos alfabéticamente, pero en
ocasiones puede resultarnos útil otro tipo de ordenación:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">-r</span></code> invierte el orden.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">-t</span></code> ordena de más reciente a más antiguo. Es obvio, que si se quieren
ver los más recientes al final del listado, puede usarse <kbd class="kbd docutils literal notranslate">-tr</kbd>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">-X</span></code> ordena alfabéticamente según la extensión.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">-S</span></code> ordena por tamaño de mayor a menor.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">group-directories-first</span></code> muestra antes los directorios que los archivos.</p></li>
</ul>
</dd>
</dl>
<span id="stat"></span><dl id="index-2">
<dt><em class="manpage"><a class="manpage reference external" href="https://manpages.debian.org/stat(1)">stat(1)</a></em></dt><dd><p>Además de <kbd class="kbd docutils literal notranslate">ls</kbd> <kbd class="kbd docutils literal notranslate"></kbd>-<kbd class="kbd docutils literal notranslate">l</kbd> otro modo de obtener información sobre archivos es el
comando <strong class="command">stat</strong>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>stat<span class="w"> </span>.
<span class="go">Fichero: «.»</span>
<span class="go">   Tamaño: 4096       Bloques: 8          Bloque E/S: 4096   directorio</span>
<span class="go">   Dispositivo: 801h/2049d Nodo-i: 524290      Enlaces: 36</span>
<span class="go">Acceso: (0755/drwxr-xr-x)  Uid: ( 1000/ usuario)   Gid: ( 1000/ usuario)</span>
<span class="go">Acceso: 2016-10-14 13:32:41.571887432 +0200</span>
<span class="go">Modificación: 2016-10-14 13:36:51.769082058 +0200</span>
<span class="go">      Cambio: 2016-10-14 13:36:51.769082058 +0200</span>
<span class="go">    Creación: -</span>
</pre></div>
</div>
<p>Este comando es más prolijo que la opción <code class="docutils literal notranslate"><span class="pre">-l</span></code> de <strong class="command">ls</strong> y entre otras
cosas ofrece cuatro fechas distintas:</p>
<ul>
<li><p>Fecha de <strong>modificación</strong>, que indica el último momento en que se modificó
el contenido de un archivo.</p></li>
<li><p>Fecha de <strong>acceso</strong>, que indica el último momento en que se accedió (leyó)
el archivo. Esta es la teoría, porque en la práctica hacer registro en el
disco duro (o sea, escribir) cada vez que se accede a un archivo o
directorio provoca que baje mucho el rendimiento del sistema, así que lo
habitual es que <em>Linux</em> monte los sistemas de archivos con la opción
<em>noatime</em>, para que la fecha de acceso sólo se actualice o una vez al día o
cuando se modifica el archivo.</p></li>
<li><p>Fecha de <strong>cambio</strong> que indica el último momento en que la metainformación
del archivo sufrió algún cambio (propietario, permiso, números de enlaces,
etc.).</p></li>
<li><p>Fecha de <strong>creación</strong> que indica el momento en que se creó el archivo. Esta
fecha no forma parte del <a class="reference external" href="https://pubs.opengroup.org/onlinepubs/9699919799.2018edition/">estándar POSIX</a>, por lo
que las versiones antiguas de <em>Linux</em> y sus sistemas de archivos no se
preocuparon en un principio de ella y la salida de la orden que mostramos
es una muestra de ello.</p>
<div class="admonition-curiosidad admonition">
<p class="admonition-title">Curiosidad</p>
<p>Los antiguos sistemas de archivos de <em>Linux</em> (<em>ext2</em>, <em>ext3</em>) no tenían
soporte para ella, y sólo <em>ext4</em> (estable en 2008) la introdujo. Sin
embargo, el núcleo de <em>Linux</em> siguió sin soportarla. Sólo a partir de su
versión 4.11 (abril de 2017) le dio pleno soporte. Hubo que esperar a
2018 para que las herramientas includas en <a class="reference external" href="https://www.gnu.org/software/coreutils/coreutils">coreutils</a> supieran cómo
obtenerla tal  <a class="reference external" href="https://unix.stackexchange.com/a/119699">como expone Stéphane Chazelas en una respuesta de
unix.stackexchange.com</a><a class="footnote-reference brackets" href="#id4" id="id1" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a>.</p>
<p>En <em>Debian</em>, al menos a partir de <em>Bookworm</em>, se ha comenzado a
poder consultar la fecha de creación de los archivos.</p>
</div>
</li>
</ul>
<p>Una opción interesante de <strong class="command">stat</strong> es <code class="docutils literal notranslate"><span class="pre">-c</span></code> que permite indicar el
formato de salida del resultado de la consulta. Para expresar este formato cada
propiedad se representa de la forma <code class="docutils literal notranslate"><span class="pre">%&lt;letra&gt;</span></code>. Por ejemplo, <code class="docutils literal notranslate"><span class="pre">%U</span></code>
representa el nombre del propietario y <code class="docutils literal notranslate"><span class="pre">%u</span></code>, uid del propietario. Así pues:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>stat<span class="w"> </span>-c<span class="w"> </span><span class="s2">&quot;%U/%u&quot;</span><span class="w"> </span>archivo
<span class="go">usuario/1000</span>
</pre></div>
</div>
<p>En la página del manual se desglosan las letras que corresponden a cada
propiedad.</p>
</dd>
</dl>
<span id="tree"></span><dl id="index-3">
<dt><em class="manpage"><a class="manpage reference external" href="https://manpages.debian.org/tree">tree</a></em></dt><dd><p>Muestra los contenidos de un directorio en forma arborescente:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">tree [&lt;opciones&gt;] [&lt;directorio&gt;]</span>
</pre></div>
</div>
<p>El directorio que se indica como argumento es aquel del que se desean mostrar
los contenidos. Si no se indica se sobrentiende el directorio actual. Dispone
de muchas opciones. Algunas interesantes son:</p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">-d</span></code></dt><dd><p>Sólo muestra directorios y no archivos.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">-L</span></code></dt><dd><p>Nivel de profundidad. <strong class="command">tree</strong> es recursivo, así que muestra los
directorios y los directorios de los directorios y así sucesivamente hasta
que ya no quedan directorios que mostrar. Con esta opción podemos indicar
en qué nivel parar. Por ejemplo:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>tree<span class="w"> </span>-dL<span class="w"> </span><span class="m">1</span><span class="w"> </span>/
</pre></div>
</div>
<p>Sólo nos mostrará los subdirectorios del directorio raíz, sin profundizar
más.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">-a</span></code></dt><dd><p>Como la opción de <a class="reference internal" href="#ls"><span class="std std-ref">ls</span></a>, muestra también los archivos ocultos.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>Requiere la instalación del paquete homónimo.</p>
</div>
</dd>
</dl>
<span id="file"></span><dl id="index-4">
<dt><em class="manpage"><a class="manpage reference external" href="https://manpages.debian.org/file">file</a></em></dt><dd><p>Por lo general, las extensiones se usan para saber de qué tipo es un archivo,
pero no tienen por qué haber sido bien elegidas. <strong class="command">file</strong> es un comando
que intenta averiguar de qué tipo es, basándose en su contenido:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>file<span class="w"> </span>primera_carlista.mp4
<span class="go">primera_carlista.mp4: ISO Media, MP4 Base Media v1 [IS0 14496-12:2003]</span>
</pre></div>
</div>
<p>Si se usa la opción <kbd class="kbd docutils literal notranslate">-i</kbd>, devuelve el <a class="reference internal" href="../99.misc/06.mimetypes.html#mimetypes"><span class="std std-ref">tipo MIME</span></a>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>file<span class="w"> </span>-i<span class="w"> </span>primera_carlista.mp4
<span class="go">primera_carlista.mp4: video/mp4; charset=binary</span>
</pre></div>
</div>
</dd>
</dl>
<span id="which"></span><dl id="index-5">
<dt><em class="manpage"><a class="manpage reference external" href="https://manpages.debian.org/which">which</a></em></dt><dd><p>Dentro de los comandos que nos permiten gulismear en el árbol de directorios
está <strong class="command">which</strong>. Básicamente, busca dónde se encuentran los programas
que podemos ejecutar a través de la línea de comandos<a class="footnote-reference brackets" href="#id5" id="id2" role="doc-noteref"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></a>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>which<span class="w"> </span>ls
<span class="go">/bin/ls</span>
</pre></div>
</div>
<p id="index-6">Una alternativa (que es muy útil al programar porque cumple con el estándar
<em>POSIX</em>) es:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span><span class="nb">command</span><span class="w"> </span>-v<span class="w"> </span>ls
<span class="go">/bin/ls</span>
</pre></div>
</div>
</dd>
</dl>
<span id="whereis"></span><dl id="index-7">
<dt><em class="manpage"><a class="manpage reference external" href="https://manpages.debian.org/whereis">whereis</a></em></dt><dd><p><strong class="command">ls</strong> puede usarse para comprobar si un archivo se encuentra o no en un
directorio. Sin embargo, si no sabemos a ciencia cierta en qué directorio se
encuentra, el comando puede resultar o tedioso o, directamente, bastante inútil.
Ya se ha citado <a class="reference internal" href="#which"><span class="std std-ref">which</span></a>, pero está limitado a ejecutables. Un comando más
exhaustivo es <strong class="command">whereis</strong>, que es capaz de encontrar ejecutables, códigos
fuente y páginas del manual en los directorios en los que suelen encontrarse:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>whereis<span class="w"> </span>ls
<span class="go">ls: /bin/ls /usr/share/man/man1/ls.1.gz</span>
</pre></div>
</div>
</dd>
</dl>
<span id="find"></span><dl id="index-8">
<dt><em class="manpage"><a class="manpage reference external" href="https://manpages.debian.org/find">find</a></em></dt><dd><p>Sin embargo, <strong class="command">whereis</strong> no es suficiente si lo que queremos es buscar un
archivo cualquiera. Para ello puede usarse el comando <strong class="command">find</strong> que
permite hacer una búsqueda bastante exhaustiva y, por tanto, tiene una ingente
cantidad de opciones.</p>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>Los argumentos de <strong class="command">find</strong> no siguen el estándar POSIX.</p>
</div>
<p>En general, la sintaxis del comando es la siguiente:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">find [-P|-H|-L] [&lt;directorio&gt;] [opciones]</span>
</pre></div>
</div>
<p>Las tras primeras opciones hacen referencia a cómo <strong class="command">find</strong> tratará los
<a class="reference internal" href="#symlink"><span class="std std-ref">enlaces simbólicos</span></a>. la predeterminada es <code class="docutils literal notranslate"><span class="pre">-P</span></code> que implica no
seguirlos.</p>
<p>El <em>directorio</em> es aquel bajo el cual <strong class="command">find</strong> buscará lo que se le
exprese con las opciones que se pasen a continuación. La búsqueda es recursiva,
de modo que <strong class="command">find</strong> buscará dentro de los subdirectorios. El orden es
importante y, de hecho, el directorio debe expresarse antes que las opciones. Si
no se indica, se sobrentiende que es el directorio actual (o sea, <kbd class="kbd docutils literal notranslate">.</kbd>).</p>
<p>Las opciones son muy variadas: algunas permiten modificar el comportamiento del
comando; otras seleccionar archivos casi según cualquier criterio imaginable; y
otras realizar una operación (como imprimir por pantalla o borrar). El orden no
es indistinto y deben colocarse según se han enunciado: primero las de
modificación, luego las de selección y, por último, la de operación. Si no se
especifica ninguna acción, se sobreentiende que se desea imprimir (<code class="docutils literal notranslate"><span class="pre">-print</span></code>).
En este documento sólo se describirán las opciones más relevantes:</p>
<p>Opciones de <strong>modificación</strong>:</p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">-maxdepth</span> <span class="pre">&lt;N&gt;</span></code>:</dt><dd><p>Realiza la búsqueda sólo profundizando hasta el nivel <em>N</em>. Por ejemplo, un
nivel <em>1</em> buscará dentro del directorio que se haya usado como punto de
partido, pero no dentro de los subdirectorios. Esta opción debe colocarse
antes de</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">-mount</span></code>:</dt><dd><p>No busca en subdirectorios que pertenezcan a sistemas de archivos
distintos al del directorio de punto de partida.</p>
</dd>
<dt>Opciones de <strong>selección</strong>:</dt><dd><p>Estas opciones se evalúan a verdadero o falso. Si la evaluación sobre un
archivo resulta verdadera, el archivo se seleccionará.</p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">-name</span> <span class="pre">&lt;expresion&gt;</span></code>:</dt><dd><p>permite buscar archivos por su nombre según la expresión que se indique. Esta
expresión sigue las mismas reglas que las indicadas <a class="reference internal" href="../07.avanzada/08.interpretaciones.html#comodines"><span class="std std-ref">aquí</span></a>.
La variante <kbd class="kbd docutils literal notranslate">-iname</kbd> obra del mismo modo, pero sin tener en cuenta
mayúsculas o minúsculas.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">-path</span> <span class="pre">&lt;expresion&gt;</span></code>:</dt><dd><p>busca archivos atendiendo a toda su ruta y no sólo al nombre. Existe
también la variante <kbd class="kbd docutils literal notranslate">ipath</kbd> para no distinguir mayúsculas de
minúsculas. En cuanto a la ruta, debe considerarse que esta se expresa
como ruta relativa al directorio que se tome como punto de partida. Por
ejemplo, si el directorio es <kbd class="kbd docutils literal notranslate">.</kbd> las rutas de todos los archivos
encontrados empezarán por <code class="docutils literal notranslate"><span class="pre">./</span></code>; si <kbd class="kbd docutils literal notranslate">dir</kbd>, todas empezarán por
<code class="docutils literal notranslate"><span class="pre">dir/</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">-regex</span> <span class="pre">&lt;expresion_regular&gt;</span></code>:</dt><dd><p>Como <kbd class="kbd docutils literal notranslate">-path</kbd> pero la expresión se evaluará como una <a class="reference internal" href="../10.texto/01.regex.html#regex"><span class="std std-ref">expresión regular</span></a>. <kbd class="kbd docutils literal notranslate">iregex</kbd> cumple la misma función pero sin distinguir
mayúsculas de minúsculas. Relacionada con estas dos expresiones existe la
opción <kbd class="kbd docutils literal notranslate">-regexptype</kbd>, que permite indicar qué tipo de expresiones
regulares se usarán. Para saber qué tipos estan soportados puede hacerse lo
siguiente:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>find<span class="w"> </span>-regextype<span class="w"> </span><span class="nb">help</span>
</pre></div>
</div>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">-type</span> <span class="pre">f|d|l|p|b|c|s</span></code>:</dt><dd><p>restringe la búsqueda al tipo de archivo indicado. El carácter es el mismo
que el que muestra la opción <code class="docutils literal notranslate"><span class="pre">-l</span></code> de <a class="reference internal" href="#ls">ls</a>, excepto en el caso de los
archivos regulares que se usa la <kbd class="kbd docutils literal notranslate">f</kbd> en vez del guión.`</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">-samefile</span> <span class="pre">&lt;archivo&gt;</span></code>:</dt><dd><p>busca los otros <a class="reference internal" href="#hardlink"><span class="std std-ref">enlaces duros</span></a> del archivo indicado.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">-empty</span></code>:</dt><dd><p>el archivo (o directorio) está vacío.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">-mtime</span> <span class="pre">&lt;n&gt;</span></code>:</dt><dd><p>el archivo se modificó hace <em>n</em> días. Si se hace negativo el número,
significa hace menos de <em>n</em> días; y, si incluye un signo <em>+</em> explícito,
hace más de <em>n</em> días. Las opciones <code class="docutils literal notranslate"><span class="pre">-atime</span></code> y <code class="docutils literal notranslate"><span class="pre">-ctime</span></code> sirven para lo
mismo pero usando las fechas de acceso y cambio.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">-newer</span> <span class="pre">&lt;archivo&gt;</span></code>:</dt><dd><p>busca los archivos modificados después del archivo de referencia
proporcionado como argumento. <code class="docutils literal notranslate"><span class="pre">anewer</span></code> y <code class="docutils literal notranslate"><span class="pre">cnewer</span></code> sirven para lo
mismo, pero usando las fechas de acceso y cambio.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">-group</span> <span class="pre">&lt;grupo&gt;</span></code>:</dt><dd><p>busca archivos cuyo grupo propietario sea el indicado (puede usarse el
nombre o el <em>gid</em>).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">-user</span> <span class="pre">&lt;usuario&gt;</span></code>:</dt><dd><p>busca archivos propiedad del usuario indicado (puede usarse el usuario o
el <em>uid</em>).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">-links</span> <span class="pre">&lt;n&gt;</span></code>:</dt><dd><p>busca archivos que tengan <em>n</em> enlaces. Pueden usarse los signos <em>-</em> y <em>+</em>
con el mismo significado que para <kbd class="kbd docutils literal notranslate">mtime</kbd>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">-size</span> <span class="pre">&lt;n&gt;&lt;unidad&gt;</span></code>:</dt><dd><p>busca archivos de un tamaño determinado. En cuanto a la cantidad pueden
usarse los signos <em>-</em> y <em>+</em> para indicar menor y mayor como en otros
casos. En cuanto a la unidad se pueden indicar:</p>
<ul class="simple">
<li><p><strong>b</strong>, bloques de 512 <em>bytes</em>.</p></li>
<li><p><strong>c</strong>, <em>bytes</em>.</p></li>
<li><p><strong>k</strong>, <em>kilobytes</em>.</p></li>
<li><p><strong>M</strong>, <em>megabytes</em>.</p></li>
<li><p><strong>G</strong>, <em>gigabytes</em>.</p></li>
</ul>
</dd>
</dl>
</dd>
<dt>Opciones de <strong>operación</strong>:</dt><dd><p>Pueden indicarse varias operaciones que se ejecutarán una detrás de otra.</p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">-print</span></code>:</dt><dd><p>imprime en pantalla los archivos seleccionados, uno por línea. Hay
variantes de esta opción, pero hay una indispensable en ciertos casos que
es <kbd class="kbd docutils literal notranslate">print0</kbd> que imprime de modo que el carácter que separa un
archivo
de otro es el carácter nulo.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">-delete</span></code>:</dt><dd><p>borra el archivo indicado. Si el archivo es un directorio, debe estar
vacío.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">-exec</span> <span class="pre">&lt;comando&gt;</span> <span class="pre">'{}'</span> <span class="pre">+</span></code>:</dt><dd><p>ejecuta el comando indicado sobre los archivos seleccionados. El “{}” representa
tales archivos que se usaran como argumentos para comando.  Al incluir
el signo <code class="docutils literal notranslate"><span class="pre">+</span></code>, no se ejecuta un comando por cada archivo, sino que se
procura ejecutar el comando incluyendo el mayor número de archivos
posibles en cada invocación. Por ejemplo:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>print<span class="w"> </span>.<span class="w"> </span>-type<span class="w"> </span>f<span class="w"> </span>-exec<span class="w"> </span>file<span class="w"> </span>-i<span class="w"> </span><span class="s1">&#39;{}&#39;</span><span class="w"> </span>+
<span class="go">./hola2:         inode/x-empty; charset=binary</span>
<span class="go">./a 1:           inode/x-empty; charset=binary</span>
<span class="go">./tmux.txt:      text/x-fortran; charset=utf-8</span>
<span class="go">./hola:          inode/x-empty; charset=binary</span>
</pre></div>
</div>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">-ok</span> <span class="pre">&lt;command&gt;</span> <span class="pre">'{}'</span> <span class="pre">\;</span></code>:</dt><dd><p>ejecuta el comando para cada uno de los archivos seleccionados, pero
pregunta antes si se quiere efectuar cada operación o no. Existe también
una versión de <code class="docutils literal notranslate"><span class="pre">-exec</span></code> que remata en punto y coma, pero por ser menos
eficiente que la referida, se ha callado.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">-prune</span></code>:</dt><dd><p>no hace nada en especial más que impedir que <strong class="command">find</strong> descienda si
el archivo seleccionado es un directorio. Puede usarse para evitar revisar
los contenidos de un archivo.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">-quit</span></code>:</dt><dd><p>sale inmediatamente de <strong class="command">find</strong></p>
</dd>
</dl>
</dd>
</dl>
<p>Faltan opciones, pero con las indicadas hay materia para entretenerse. Aún queda
por explicar los operadores, pero antes es útil ilustrar con algunos ejemplos el
uso:</p>
<ol class="arabic">
<li><p>Buscar todos los archivos <code class="docutils literal notranslate"><span class="pre">.pdf</span></code> bajo el directorio de trabajo:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>find<span class="w"> </span>-iname<span class="w"> </span><span class="s1">&#39;*.pdf&#39;</span>
</pre></div>
</div>
<p>Como no se especifica acción alguna, se sobreentiende <code class="docutils literal notranslate"><span class="pre">-print</span></code>.</p>
</li>
<li><p>Lo mismo, pero especificando que se buscan archivos regulares y no
cualquier otra cosa (enlaces simbólicos, por ejemplo):</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>find<span class="w"> </span>-type<span class="w"> </span>f<span class="w"> </span>-iname<span class="w"> </span><span class="s1">&#39;*.pdf&#39;</span>
</pre></div>
</div>
</li>
<li><p>Buscar un archivo llamado <code class="file docutils literal notranslate"><span class="pre">deseable.txt</span></code> bajo el directorio de
trabajo y para la búsqueda nada más encontrarlo:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>find<span class="w"> </span>-type<span class="w"> </span>f<span class="w"> </span>-name<span class="w"> </span><span class="s1">&#39;deseable.txt&#39;</span><span class="w"> </span>-print<span class="w"> </span>-quit
</pre></div>
</div>
<p>En este caso, para cada archivo encontrado, primero se imprime y luego se
acaba la ejecución. Por tanto, nada más encontrar e imprimir el primer
archivo, se dejará de buscar. Puede ser útil si sabemos de antemano que el
archivo es único.</p>
</li>
<li><p>Muestra el tipo de los archivos del directorio actual:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>find<span class="w"> </span>-maxdepth<span class="w"> </span><span class="m">1</span><span class="w"> </span>-type<span class="w"> </span>f<span class="w"> </span>-exec<span class="w"> </span>file<span class="w"> </span><span class="s1">&#39;{}&#39;</span><span class="w"> </span>+
</pre></div>
</div>
</li>
<li><p>Borra los archivos vacíos que se encuentran bajo el directorio actual:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>find<span class="w"> </span>-type<span class="w"> </span>f<span class="w"> </span>-empty<span class="w"> </span>-delete
</pre></div>
</div>
</li>
<li><p>Como en el caso anterior, pero preguntando primero:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>find<span class="w"> </span>-type<span class="w"> </span>f<span class="w"> </span>-empty<span class="w"> </span>-ok<span class="w"> </span>rm<span class="w"> </span>-f<span class="w"> </span><span class="s1">&#39;{}&#39;</span><span class="w"> </span><span class="se">\;</span>
</pre></div>
</div>
</li>
<li><p>Busca bajo el directorio <code class="file docutils literal notranslate"><span class="pre">/home/store/video</span></code> los archivos mayores a
500MB:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>find<span class="w"> </span>/home/store/video<span class="w"> </span>-type<span class="w"> </span>f<span class="w"> </span>-size<span class="w"> </span>+500M
</pre></div>
</div>
</li>
<li><p>Busca bajo el directorio actual los archivos con más de un enlace:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>find<span class="w"> </span>-type<span class="w"> </span>f<span class="w"> </span>-links<span class="w"> </span>+1
</pre></div>
</div>
</li>
</ol>
<p>Estas pueden ser búsquedas útiles con <strong class="command">find</strong>, pero… <em>no se vayan
todavía, que aún hay más</em>. Si se analizan algunos ejemplos, se observará que
se han dado dos o más condiciones o incluso dos o más acciones y estas siempre
eran acumulativas:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>find<span class="w"> </span>-type<span class="w"> </span>f<span class="w"> </span>-empty<span class="w"> </span>-delete
</pre></div>
</div>
<p>En este ejemplo se buscan archivos que sean regulares (<kbd class="kbd docutils literal notranslate">-type</kbd> <kbd class="kbd docutils literal notranslate">f</kbd>) <strong>y</strong>
que, además, estén vacios. Es decir, que si hablamos en términos lógicos hay un
opèrador <em>and</em> implícito entre una y otra condición. También lo hay entre las
condiciones y la acción <code class="docutils literal notranslate"><span class="pre">-delete</span></code> (<em>y me lo imprimes</em>), porque las acciones,
además de hacer algo, devuelven un valor siempre verdadero.</p>
<p>Pues bien, en <strong class="command">find</strong> podemos usar los operadores <code class="docutils literal notranslate"><span class="pre">-a</span></code> (<em>and</em>), <code class="docutils literal notranslate"><span class="pre">-o</span></code>
(<em>or</em>) o <code class="docutils literal notranslate"><span class="pre">!</span></code> (<em>not</em>) y los paréntesis para agrupar. Esto convierte a
<strong class="command">find</strong> en infinitamente más poderoso. Por ejemplo:</p>
<ol class="arabic">
<li><p>Busca todos los archivos que no estén vacíos:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>find<span class="w"> </span>-empty<span class="w"> </span>-o<span class="w"> </span>-print
</pre></div>
</div>
<p>La razón de que este funcione es que <strong class="command">find</strong> evalúa como
habitualmente se hace en programación cuando hay un <em>or</em>: sólo se evalua
la segunda expresión si la primera era falsa. Por tanto, si el archivo
está vacío no se hace nada, pues no hay ninguna acción indicada y ahi se
para de evaluar para el archivo en cuestión; pero si no está vacío, se
evalúa la segunda expresión y, consecuentemente, se imprime el nombre del
archivo.</p>
<p>Por supuesto esto mismo se podría haber logrado así:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>find<span class="w"> </span><span class="se">\!</span><span class="w"> </span>-empty<span class="w"> </span>-print
</pre></div>
</div>
<p>que es más inmediato. pero hacerlo de otro modo ilustra mejor cómo
evalúa <strong class="command">find</strong>. En este último caso, además, podemos ahorrarnos
<kbd class="kbd docutils literal notranslate">-print</kbd>.</p>
</li>
<li><p>Busca archivos <code class="docutils literal notranslate"><span class="pre">.pdf</span></code> bajo el directorio actual, pero desecha los
subdirectorios que se llaman <em>backup</em>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>find<span class="w"> </span>-type<span class="w"> </span>d<span class="w"> </span>-name<span class="w"> </span>backup<span class="w"> </span>-prune<span class="w"> </span>-o<span class="w"> </span>-name<span class="w"> </span><span class="s1">&#39;*.pdf&#39;</span><span class="w"> </span>-print
</pre></div>
</div>
<p>El razonamiento es análogo al del anterior ejemplo, pero en este caso ha
sido necesario añadir <code class="docutils literal notranslate"><span class="pre">-prune</span></code>. La razón es que el hecho de que no se
imprima un directorio, no implica que no se entre en él y se revisen sus
contenidos, por lo que es necesaria la acción <kbd class="kbd docutils literal notranslate">-prune</kbd> para descartarlo
por completo. Antes se omitió este <kbd class="kbd docutils literal notranslate">-prune</kbd> porque al concordar la
expresión con directorios vacíos, esto implica que no tengan nada dentro.</p>
</li>
<li><p>Busca archivos regulares y enlaces simbólicos:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>find<span class="w"> </span><span class="se">\(</span><span class="w"> </span>-type<span class="w"> </span>f<span class="w"> </span>-o<span class="w"> </span>-type<span class="w"> </span>l<span class="w"> </span><span class="se">\)</span><span class="w"> </span>-print
</pre></div>
</div>
<p>Es necesario agrupar para que ambas condiciones se apliquen a la misma
acción <kbd class="kbd docutils literal notranslate">-print</kbd>. No incluir los paréntesis implicaría no hacer nada para
los archivos regulares y, en caso contrario, comprobar que es un enlace
simbólico e imprimir, o sea, imprimir sólo enlaces simbólicos.</p>
</li>
</ol>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p><strong class="command">find</strong> puede ser muy útil a la hora de seleccionar archivos de los
que se desea realizar copia de seguridad al ser mucho más versátil que las
opciones que <a class="reference internal" href="../11.backup/02.empaquetado.html#tar"><span class="std std-ref">tar</span></a> da para ello.</p>
</div>
</dd>
</dl>
<span id="du"></span><dl id="index-9">
<dt><em class="manpage"><a class="manpage reference external" href="https://manpages.debian.org/du">du</a></em></dt><dd><p>Sirve para estimar el espacio de disco que ocupan los directorios (o archivos)
que se le pasan como argumento. Entiéndase que el espacio de ocupación que
proporciona para los directorios es el espacio que ocupan todos sus
contenidos. Por defecto, desglosa el espacio de cada uno de los
subdirectorios que se encuentra, así que por lo general es usarlo con la
opción <kbd class="kbd docutils literal notranslate">-s</kbd> que devuelve solamente el espacio ocupado por el archivo que se
le ha dado como argumento. Además dispone de una opción <kbd class="kbd docutils literal notranslate">-h</kbd> que se
comporta como la de <strong class="command">ls</strong>. Por tanto:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>du<span class="w"> </span>-hs<span class="w"> </span>~
<span class="go">3,4G  /home/josem</span>
</pre></div>
</div>
<p>Nos devolverá el espacio total ocupado por nuestro directorio personal. Es
útil añadir la opción <kbd class="kbd docutils literal notranslate">-x</kbd> que no tiene en cuenta los subdirectorios que
monten otros sistemas de archivos.</p>
</dd>
</dl>
</section>
<section id="y-dentro-de-archivos">
<h3><span class="section-number">2.2.2.1.2. </span>… y dentro de archivos<a class="headerlink" href="#y-dentro-de-archivos" title="Link to this heading">¶</a></h3>
<span id="cat"></span><dl id="index-10">
<dt><em class="manpage"><a class="manpage reference external" href="https://manpages.debian.org/cat">cat</a></em></dt><dd><p>El comando más simple que permite consultar el contenido de un archivo es
<strong class="command">cat</strong>: simplemente escupe por pantalla, carácter a carácter, el
contenido. Si el archivo es <em>texto plano</em> podremos leerlo, si es un archivo
binario veremos caracteres ininteligibles y, si nuestra intención era echar un
vistazo, habrá servidor de poco:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>cat<span class="w"> </span>saludo.txt
<span class="go">Hola</span>
</pre></div>
</div>
<p>Suponiendo que hubiéramos escrito previamente un archivo que contuviera
únicamente la palabra <em>Hola</em>. Si se escriben dos o más archivos como argumento,
<strong class="command">cat</strong> los concatena:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>cat<span class="w"> </span>saludo.txt<span class="w"> </span>despedida.txt
<span class="go">Hola</span>
<span class="go">Adiós</span>
</pre></div>
</div>
<p>Es posible también usarlo sin indicar archivo alguno: en este caso recibirá los
datos a través de la entrada estándar (véase <a class="reference internal" href="../08.redirecciones/index.html#ioredirect"><span class="std std-ref">redirecciones</span></a>).</p>
<p>De entre sus opciones, es útil a veces <kbd class="kbd docutils literal notranslate">-n</kbd>, que numera las líneas al
mostrarlas.</p>
</dd>
</dl>
<span id="more"></span><dl id="index-11">
<dt><em class="manpage"><a class="manpage reference external" href="https://manpages.debian.org/more">more</a></em></dt><dd><p>Sin embargo, <strong class="command">cat</strong> tiene el inconveniente de mostrar el archivo de una
sola tacada, por lo que si el archivo es largo se escapará por la parte superior
de la pantalla. Para remediarlo, puede usarse <strong class="command">more</strong> que es un
paginador que al llenarse la pantalla hará una pausa:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>more<span class="w"> </span>archivo_larguisimo
</pre></div>
</div>
<p>y quedará esperando a que pulsemos <kbd class="kbd docutils literal notranslate">Enter</kbd>
(avancar una línea) o <kbd class="kbd docutils literal notranslate">Espacio</kbd> (avanzar una pantalla). Por contra, con
<kbd class="kbd docutils literal notranslate">b</kbd> retrocede una pantalla, aunque esto última sólo si se trata de un
archivo y no un flujo procedente de <a class="reference internal" href="../08.redirecciones/01basica.html#pipeline"><span class="std std-ref">una tubería</span></a>. También
puede escribirse una barra (<kbd class="kbd docutils literal notranslate">/</kbd>) seguida de una <a class="reference internal" href="../10.texto/01.regex.html#regex"><span class="std std-ref">expresión regular</span></a> para buscar la primera ocurrencia que concuerde con dicha expresión,</p>
<p>Se saldrá del programa al acabarse el archivo o al pulsarse <kbd class="kbd docutils literal notranslate">q</kbd>.</p>
</dd>
</dl>
<span id="less"></span><dl id="index-12">
<dt><em class="manpage"><a class="manpage reference external" href="https://manpages.debian.org/less">less</a></em></dt><dd><p>Otro paginador que mejora las prestaciones de <strong class="command">more</strong> y permite
retroceder incluso cuando pagina flujos  de texto. Consúltese la página del
manual.</p>
<p>Tanto <strong class="command">cat</strong>, como <strong class="command">more</strong>, como <strong class="command">less</strong> suelen tener
ejecutables equivalentes para mostrar archivos que hayan sido comprimidos sin
necesidad de descomprimirlos previamente:</p>
</dd>
</dl>
<ul class="simple" id="index-13">
<li><p><strong class="command">zcat</strong>, <strong class="command">zmore</strong> y <strong class="command">zless</strong> para comprimidos con
<a class="reference internal" href="../11.backup/01.compresion.html#gzip"><span class="std std-ref">gzip</span></a> (extensión <kbd class="kbd docutils literal notranslate">.gz</kbd>).</p></li>
<li><p><strong class="command">bzcat</strong>, <strong class="command">bzmore</strong> y <strong class="command">bzless</strong> para comprimidos con
<a class="reference internal" href="../11.backup/01.compresion.html#bzip2"><span class="std std-ref">bzip2</span></a> (extensión <kbd class="kbd docutils literal notranslate">.bz</kbd> o <kbd class="kbd docutils literal notranslate">.bzip2</kbd>).</p></li>
<li><p><strong class="command">xzcat</strong>, <strong class="command">xzmore</strong> y <strong class="command">xzless</strong> para comprimidos con
<a class="reference internal" href="../11.backup/01.compresion.html#xz"><span class="std std-ref">xz</span></a> (extensión <kbd class="kbd docutils literal notranslate">.xz</kbd>).</p></li>
<li><p><strong class="command">zstdcat</strong> y <strong class="command">zstdless</strong> para compimidos con <a class="reference internal" href="../11.backup/01.compresion.html#zstd"><span class="std std-ref">zstd</span></a> (extensión <kbd class="kbd docutils literal notranslate">.zst</kbd>).</p></li>
</ul>
<span id="head"></span><dl id="index-14">
<dt><em class="manpage"><a class="manpage reference external" href="https://manpages.debian.org/head">head</a></em></dt><dd><p>Cuando no se quiere inspeccionar todo el archivo sino sólo su comienzo, es útil
el comando <strong class="command">head</strong>, que permite indicar cuáles de las primeras líneas de
un texto se desean mostrar:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>head<span class="w"> </span>/etc/passwd
</pre></div>
</div>
<p>Si no se especifica nada, se muestran 10 líneas. Si se quiere mostrar un número
distinto es posible hacerlo con la opción <kbd class="kbd docutils literal notranslate">-n</kbd>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>head<span class="w"> </span>-n20<span class="w"> </span>/etc/passwd
</pre></div>
</div>
<p>El ejemplo, mostrará 20 líneas. Es posible también mostrar todas las líneas
menos las <em>n</em> últimas, haciendo negativo el argumento de <kbd class="kbd docutils literal notranslate">-n</kbd>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>head<span class="w"> </span>-n-1<span class="w"> </span>/etc/passwd
</pre></div>
</div>
<p>Esto mostraría todas las líneas menos la última.</p>
<p>Como con los comandos anteriores, si no se indica nombre alguno de archivo, se
intenta tomar datos de la entrada estándar.</p>
</dd>
</dl>
<span id="tail"></span><dl id="index-15">
<dt><em class="manpage"><a class="manpage reference external" href="https://manpages.debian.org/tail">tail</a></em></dt><dd><p>Como contrapartida a este último comand, <strong class="command">tail</strong> permite mostrar las
últimas líneas del archivo. Si no se especifica cuántas:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>tail<span class="w"> </span>/etc/passwd
</pre></div>
</div>
<p>mostrará las diez últimas, pero puede variarse este número usando la opción
<code class="docutils literal notranslate"><span class="pre">-n</span></code>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>tail<span class="w"> </span>-n15<span class="w"> </span>/etc/passwd
</pre></div>
</div>
<p>Si se incluye antes del número el signo <em>+</em>, se motrará a partir de dicha
línea:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>tail<span class="w"> </span>-n+15<span class="w"> </span>/etc/passwd
</pre></div>
</div>
<p>De nuevo, no indicar archivo implica que se quiere leer de la entrda estándar.</p>
<p><strong class="command">tail</strong>, además, admite la opción <kbd class="kbd docutils literal notranslate">-f</kbd>, que es muy útil cuando se
quiere monitorizar porque muestra las últimas 10 líneas del archivo (o cualquier
otro número si se usa además <kbd class="kbd docutils literal notranslate">-n</kbd>) y queda esperando a que el archivo se
actualice con nuevas líneas:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp"># </span>tail<span class="w"> </span>-f<span class="w"> </span>/var/log/syslog
</pre></div>
</div>
</dd>
</dl>
<span id="watch"></span><dl id="index-16">
<dt><em class="manpage"><a class="manpage reference external" href="https://manpages.debian.org/watch">watch</a></em></dt><dd><p>No es un comando propiamente para ver el contenido de un archivo, sino para
refrescar cada cierto tiempo (por defecto, cada dos segundos) la salida por
pantalla de una orden. Así si hacemos:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>watch<span class="w"> </span>-n1<span class="w"> </span><span class="s2">&quot;cat /proc/net/dev&quot;</span>
</pre></div>
</div>
<p>se nos mostrará el contenido del archivo <code class="file docutils literal notranslate"><span class="pre">/proc/net/dev</span></code> (ya que eso
es lo que hace <a class="reference internal" href="#cat"><span class="std std-ref">cat</span></a>) e irá refrescando ese contenido cada
segundo. En tal archivo es en donde el núcleo apunta el tráfico de red que
pasa por cada interfaz, por lo que el efecto será tener una visión en tiempo
casi real de las estadísticas de tráfico de red. Por la misma razón:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>watch<span class="w"> </span><span class="s2">&quot;ls -l /var/log&quot;</span>
</pre></div>
</div>
<p>mostrará el contenido del directorio <code class="file docutils literal notranslate"><span class="pre">/var/log</span></code> e irá refrescado cada
dos segundos la salida.</p>
</dd>
</dl>
</section>
</section>
<section id="creando-contenidos">
<h2><span class="section-number">2.2.2.2. </span>Creando contenidos<a class="headerlink" href="#creando-contenidos" title="Link to this heading">¶</a></h2>
<span id="mkdir"></span><dl id="index-17">
<dt><em class="manpage"><a class="manpage reference external" href="https://manpages.debian.org/mkdir">mkdir</a></em></dt><dd><p>La acción más sencilla para alterar nuestro sistema de archivos es crear un
nuevo directorio:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>mkdir<span class="w"> </span>nuevo
</pre></div>
</div>
<p>Se pueden indicar varios directorios en una misma línea:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>mkdir<span class="w"> </span>nuevo<span class="w"> </span>nuevo/dentro<span class="w"> </span>otro.nuevo
</pre></div>
</div>
<p>Obsérvese que para crear <code class="file docutils literal notranslate"><span class="pre">nuevo/dentro</span></code> es necesario que exista
previamente file:<cite>nuevo</cite>, de ahí el orden. Sin embargo, <strong class="command">mkdir</strong> tiene
la opción <code class="docutils literal notranslate"><span class="pre">-p</span></code> que crear un directorio, creando previamente todos los directorios
necesarios:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>mkdir<span class="w"> </span>-p<span class="w">  </span>nuevo/dentro
</pre></div>
</div>
</dd>
</dl>
<span id="rmdir"></span><dl id="index-18">
<dt><em class="manpage"><a class="manpage reference external" href="https://manpages.debian.org/rmdir">rmdir</a></em></dt><dd><p>En contraposición, <strong class="command">rmdir</strong> elimina directorios, pero sólo si están
vacíos:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>rmdir<span class="w"> </span>nuevo/dentro
</pre></div>
</div>
<p>SI se usa la opción <code class="docutils literal notranslate"><span class="pre">-p</span></code> borra directorios padre, si estos se quedan vacíos:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>rmdir<span class="w"> </span>-p<span class="w"> </span>nuevo/dentro
</pre></div>
</div>
</dd>
</dl>
<span id="touch"></span><dl id="index-19">
<dt><em class="manpage"><a class="manpage reference external" href="https://manpages.debian.org/touch">touch</a></em></dt><dd><p>En general, para crear un archivo de un determinado tipo lo que debe hacerse es usar una
aplicación adecuada. Ahora bien, cuando se quiere crear un archivo vacío, muy
comúnmente se usa <strong class="command">touch</strong>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>touch<span class="w"> </span>estoy.vacio
<span class="gp">$ </span>ls<span class="w"> </span>-l<span class="w"> </span>estoy.vacio
<span class="go">-rw-r--r-- 1 usuario usuario 0 oct 15 20:08 estoy.vacio</span>
</pre></div>
</div>
<p>En realidad, esta no es la función principal de <strong class="command">touch</strong>, sino un efecto
secundario, consecuencia de que el archivo no existe. Su tarea principal es
cambiar las fechas de un archivo: o la de modificación (<code class="docutils literal notranslate"><span class="pre">-m</span></code>) o la de acceso
(<code class="docutils literal notranslate"><span class="pre">-a</span></code>) o ambas a la vez (no incluir ninguna de las anteriores opciones).</p>
<p>Las fechas se fijan al momento en que se ejecuta el comando, a menos que se
indique una fecha distinta a través de <code class="docutils literal notranslate"><span class="pre">-t</span></code>. En todo caso, La de cambio
siempre será la del momento de la acción:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>touch<span class="w"> </span>-t<span class="w"> </span><span class="m">200109110915</span><span class="w"> </span>estoy.vacio
<span class="gp">$ </span>stat<span class="w"> </span>estoy.vacio
<span class="go">  Fichero: «estoy.vacio»</span>
<span class="go">    Tamaño: 0             Bloques: 0          Bloque E/S: 1024   fichero</span>
<span class="go">    regular vacío</span>
<span class="go">  Dispositivo: fd02h/64770d       Nodo-i: 28          Enlaces: 1</span>
<span class="go">  Acceso: (0644/-rw-r--r--)  Uid: ( 1000/ usuario)   Gid: ( 1000/ usuario)</span>
<span class="go">        Acceso: 2001-09-11 09:15:00.000000000 +0200</span>
<span class="go">  Modificación: 2001-09-11 09:15:00.000000000 +0200</span>
<span class="go">        Cambio: 2016-10-15 20:31:07.000000000 +0200</span>
<span class="go">      Creación: -</span>
</pre></div>
</div>
</dd>
</dl>
<span id="rm"></span><dl id="index-20">
<dt><em class="manpage"><a class="manpage reference external" href="https://manpages.debian.org/rm">rm</a></em></dt><dd><p>Si, en vez de crear un archivo, queremos borrarlo, podemos usar el comando
<strong class="command">rm</strong>. Su forma más elemental de uso es indicar como argumento el
nombre del archivo a borrar:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>rm<span class="w"> </span>archivo_a_borrar
</pre></div>
</div>
<p>aunque pueden incluirse varios nombres en una misma orden.</p>
<p>Como por error podemos borrar un archivo sin querer, <strong class="command">rm</strong> proporciona
la opción <code class="docutils literal notranslate"><span class="pre">-i</span></code>, que pide confirmación antes de hacerlo. En oposición está <code class="docutils literal notranslate"><span class="pre">-f</span></code>,
que no lo hace. Cuando se usan ambas prevalece la última que se indicó.</p>
<p>Además, el comando sirve en principio para borrar archivos, por lo que si se
intenta borrar un directorio, fallará. Para evitar esto, puede usarse el
comando <code class="docutils literal notranslate"><span class="pre">-r</span></code> que borrará directorios con todo su contenido:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>rm<span class="w"> </span>-r<span class="w"> </span>directorio
</pre></div>
</div>
<p>Es habitual usar <code class="docutils literal notranslate"><span class="pre">-r</span></code> junto a <code class="docutils literal notranslate"><span class="pre">-f</span></code> para evitar preguntas continuas de
confirmación, ya que la orden recursiva puede implicar muchísimos borrados.</p>
<div class="admonition tip">
<p class="admonition-title">Truco</p>
<p>Es sumamente aconsejable colocar <kbd class="kbd docutils literal notranslate">-rf</kbd> al final de la orden después
de haber incluido las rutas de borrado, y no antes. Eso evita que
accidentalmente pulsemos <kbd class="kbd docutils literal notranslate">Enter</kbd> antes de acabar de terminar de
escribir la ruta y borremos accidentalmente más de la cuenta.</p>
</div>
</dd>
</dl>
<span id="mv"></span><dl id="index-21">
<dt><em class="manpage"><a class="manpage reference external" href="https://manpages.debian.org/mv">mv</a></em></dt><dd><p>Otra operación habitual con archivos (o directorios) es moverlos de lugar, para
lo cual existe el comando <strong class="command">mv</strong>. La sintaxis general es la siguiente:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>mv<span class="w"> </span><span class="o">[</span>opciones<span class="o">]</span><span class="w"> </span>&lt;origen&gt;<span class="w"> </span>&lt;destino&gt;
</pre></div>
</div>
<p>Es decir, el archivo se mueve desde un origen a un destino. El origen es el
propio archivo, mientras que el destino puede existir o no. Para entender cómo
se comporta <strong class="command">mv</strong> es mejor usar el siguiente ejemplo:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>touch<span class="w"> </span>fic1<span class="w"> </span>fic2
<span class="gp">$ </span>mkdir<span class="w"> </span>dir1<span class="w"> </span>dir2
</pre></div>
</div>
<p>Es decir, creamos dos archivos y dos directorios. En este caso:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>mv<span class="w"> </span>fic1<span class="w"> </span>dir1
<span class="gp">$ </span>ls<span class="w"> </span>dir1
<span class="go">fic1</span>
</pre></div>
</div>
<p>el destino existe y es un directorio, por lo que el efecto que movemos
<code class="file docutils literal notranslate"><span class="pre">fic1</span></code> dentro del directorio de destino <code class="file docutils literal notranslate"><span class="pre">dir1</span></code>. En cambio, si el
destino no existe:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>mv<span class="w"> </span>dir1/fic1<span class="w"> </span>dir2/fic.renombrado
<span class="gp">$ </span>ls<span class="w"> </span>dir2
<span class="go">fic.renombrado</span>
</pre></div>
</div>
<p>Lo que hacemos es cambiar el nombre. Por último, si el destino existe, pero
es un archivo, sobrescribimos:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>mv<span class="w"> </span>dir2/fic.renombrado<span class="w"> </span>fic2
<span class="go">ls dir1 dir2 fic2</span>
</pre></div>
</div>
<p>Si tomáramos como origen un directorio en vez de un archivo las consecuencias
son las mismas, excepto que no tiene sentido el caso en que el destino es un
archivo, porque un directorio no puede sobrescribir un archivo, así que la orden
fallará.</p>
<p>También es posible indicar más de dos argumentos. En ese caso el último
argumento se considerará el destino y todos los anteriores archivos de origen.
Para que la orden funcione el destino debe ser un directorio y existir; así lo
que haremos será mover todos los orígenes dentro de tal directorio de destino.</p>
<p>Resumidamente, podemos verlo así:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Origen</p></th>
<th class="head"><p>Destino</p></th>
<th class="head"><p>Acción</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>F</p></td>
<td><p>F</p></td>
<td><p>El archivo se mueve al destino. Si este existe,
sobreescribe; si no, cambia de nombre.</p></td>
</tr>
<tr class="row-odd"><td><p>F</p></td>
<td><p>D</p></td>
<td><p>El archivo se mueve dentro del directorio.</p></td>
</tr>
<tr class="row-even"><td><p>D</p></td>
<td><p>F</p></td>
<td><p><strong>Error</strong>.</p></td>
</tr>
<tr class="row-odd"><td><p>D</p></td>
<td><p>D</p></td>
<td><p>El origen se mueve dentro del directorio de destino. Si
no existe, cambia el nombre, a menos que al destino le
incluyamos la barra final, en cuyo caso se producirá un
error.</p></td>
</tr>
</tbody>
</table>
<p>Al igual que <strong class="command">rm</strong>, <strong class="command">mv</strong> tiene también las opciones <code class="docutils literal notranslate"><span class="pre">-i</span></code> y
<code class="docutils literal notranslate"><span class="pre">-f</span></code>.</p>
<div class="admonition note" id="diff-bsd-gnu-mv">
<p class="admonition-title">Nota</p>
<p>En los sistemas <abbr title="Berkeley Software Distribution">BSD</abbr>, cuando el origen es un directorio y acaba en
barra, el comportamiento de <strong class="command">mv</strong> (y de <strong class="command">cp</strong>), cambia.
Cuando el directorio de destino existe, no se mueve el propio directorio
origen dentro del de destino, sino su contenido.</p>
</div>
</dd>
</dl>
<span id="cp"></span><dl id="index-22">
<dt><em class="manpage"><a class="manpage reference external" href="https://manpages.debian.org/cp">cp</a></em></dt><dd><p>Si lo que se pretende es hacer una copia, de manera que al acabar tengamos el
original y una copia, existe el comando <strong class="command">cp</strong>. Su funcionamiento es
similar al de <strong class="command">mv</strong> excepto por hecho de que no perdemos el archivo
original. Por tanto, es válido todo lo ya indicado, pero, además, dispone de
algunas otras opciones útiles.</p>
<p>Cuando movemos un archivo, no cambia sus propiedades (fechas, permisos,
propietarios, etc.), excepto la fecha de cambio. Por contra, cuando se copia un
archivo, muchas propiedades si pueden cambiar: por ejemplo, las fechas de acceso
y modificación pasan a reflejar el momento de la copia o el propietario em la
copia es aquel que la realiza. La opción <code class="docutils literal notranslate"><span class="pre">-p</span></code> (de <em>preservar</em>) intenta que las
propiedades cambien lo menos posible. De este modo, se conservaran las fechas
(excepto la de cambio) y, si la copia la hace el administrador, se preservará
incluso el propietario:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>touch<span class="w"> </span>-t<span class="w"> </span><span class="m">201109301130</span><span class="w"> </span>f1
<span class="gp">$ </span>ls<span class="w"> </span>-l<span class="w"> </span>f1
<span class="go">-rw-r--r-- 1 usuario usuario 0 sep 30  2011 f1</span>
<span class="gp">$ </span>cp<span class="w"> </span>f1<span class="w"> </span>fc.normal
<span class="gp">$ </span>cp<span class="w"> </span>-p<span class="w"> </span>f1<span class="w"> </span>fc.preservado
<span class="gp">$ </span>ls<span class="w"> </span>-l<span class="w"> </span>f*
<span class="go">-rw-r--r-- 1 usuario usuario 0 sep 30  2011 f1</span>
<span class="go">-rw-r--r-- 1 usuario usuario 0 oct 16 10:00 fc.normal</span>
<span class="go">-rw-r--r-- 1 usuario usuario 0 sep 30  2011 fc.preservado</span>
</pre></div>
</div>
<p>En principio, <code class="file docutils literal notranslate"><span class="pre">cp</span></code> copia archivos, pero es posible copiar también
directorios añadiendo la opción <code class="docutils literal notranslate"><span class="pre">-r</span></code>.</p>
<p>En particular, cuando se quiere hacer una copia exacta de un directorio con todo
lo que contiene, preservando sus propiedades, es conveniente usar la opción
<code class="docutils literal notranslate"><span class="pre">-a</span></code>, que incluye <code class="docutils literal notranslate"><span class="pre">-p</span></code><a class="footnote-reference brackets" href="#id6" id="id3" role="doc-noteref"><span class="fn-bracket">[</span>3<span class="fn-bracket">]</span></a> y <code class="docutils literal notranslate"><span class="pre">-r</span></code>.</p>
<p id="hardlink">Hay una última opción muy interesante: <code class="docutils literal notranslate"><span class="pre">-l</span></code>, que en vez de crear una copia
crea un <strong>enlace duro</strong>. De este modo, no hacemos una copia de la información,
sino que creamos un nueva referencia (un nuevo nombre) para la misma
información:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>cp<span class="w"> </span>-l<span class="w"> </span>f1<span class="w"> </span>f1.alternativo
<span class="gp">$ </span>ls<span class="w"> </span>-l<span class="w"> </span>f1*
<span class="go">-rw-r--r-- 2 usuario usuario 0 sep 30  2011 f1</span>
<span class="go">-rw-r--r-- 2 usuario usuario 0 sep 30  2011 f1.alternativo</span>
</pre></div>
</div>
<p>Para entender el concepto de <em class="dfn">enlace duro</em> obsérve el siguiente gráfico:</p>
<img alt="Concepto de enlace duro y simbólico" src="../../_images/enlaces.png" />
<p>Supongamos que el recuadro grande representa todo el espacio físico de un
sistema de archivos. Dentro de este sistema de archivos, se encuentra un
archivo que está referenciado a través de dos nombres (<em>nombre1</em> y
<em>nombre2</em>). Al crear un enlace duro lo que estamos haciendo es crear una
nueva referencia a partir de una que ya existía. En el sistema de archivos,
no hay dos archivos, sino un único archivo con dos nombres. La limitación es
que ambas referencias sólo pueden existir dentro del mismo sistema de
archivos. Por ese motivo, si intentamos crear un enlace duro en otro sistema
de archivos, obtendremos un error. Supongamos que <code class="file docutils literal notranslate"><span class="pre">/home</span></code> y
<code class="file docutils literal notranslate"><span class="pre">/tmp</span></code> están en distinto sistema de archivos:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span><span class="nb">cd</span>
<span class="gp">$ </span>touch<span class="w"> </span>f1
<span class="gp">$ </span><span class="nb">cd</span><span class="w"> </span>/tmp
<span class="gp">$ </span>cp<span class="w"> </span>-l<span class="w"> </span>~/f1<span class="w"> </span>.
<span class="go">cp: crea el enlace duro &#39;./f1&#39; a &#39;/home/josem/f1&#39;: Enlace cruzado entre dispositivos no permitido</span>
</pre></div>
</div>
<p>No pueden hacerse enlaces duros de directorios. Obsérvese, además, que ningún
nombre es <em>más importante que otro</em>: el archivo se borrará definitivamente,
mientras exista alguna referencia a él. Dicho de otro modo, no hay ningún
nombre (referencia) <em>original</em> al que estén subordinados el resto de nombres.</p>
</dd>
</dl>
<span id="install"></span><dl id="index-23">
<dt><em class="manpage"><a class="manpage reference external" href="https://manpages.debian.org/install">install</a></em></dt><dd><p>Copia archivos (no directorios) permitiendo definir cuáles son los permisos
que tendrá la copia:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>install<span class="w"> </span>-m755<span class="w"> </span>/usr/share/doc/mutt/examples/mutt_oauth2.py<span class="w"> </span>~/bin/
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>Obviamente, el uso de esta orden requiere conocer los <a class="reference internal" href="../05.seguridad/05b.permisos.html#ugo"><span class="std std-ref">permisos en Linux</span></a>.</p>
</div>
<p>Como en el caso de <a class="reference internal" href="#cp"><span class="std std-ref">cp</span></a>, si el destino es un directorio, este debe
existir y podrán definirse varios orígenes que se copiaran dentro de él.</p>
</dd>
</dl>
<span id="ln"></span><dl id="index-24">
<dt><em class="manpage"><a class="manpage reference external" href="https://manpages.debian.org/ln">ln</a></em></dt><dd><p>Una alternativa para crear enlaces es <strong class="command">ln</strong>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>touch<span class="w"> </span>nombre1
<span class="gp">$ </span>ln<span class="w"> </span>nombre1<span class="w"> </span>nombre2
<span class="gp">$ </span>ls<span class="w"> </span>-l<span class="w"> </span>nombre*
<span class="go">-rw-r--r-- 2 usuario usuario 0 oct 16 13:13 nombre1</span>
<span class="go">-rw-r--r-- 2 usuario usuario 0 oct 16 13:13 nombre2</span>
</pre></div>
</div>
<p id="symlink">Ahora bien, existe otro tipo de enlace, el <em class="dfn">enlace simbólico</em>. En este
caso, el nombre no referencia directamente al archivo en sí (esto es, al
espacio ocupado de disco), sino a un nombre de archivo. En el dibujo se
expresa esta idea haciendo que <em>simbólico</em> señale a <em>nombre1</em>. Para crearlos
puede usarse la opción <code class="docutils literal notranslate"><span class="pre">-s</span></code>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>ln<span class="w"> </span>-s<span class="w"> </span>nombre1<span class="w"> </span>simbolico
<span class="gp">$ </span>ls<span class="w"> </span>-l<span class="w"> </span>simbolico
<span class="go">lrwxrwxrwx 1 usuario usuario 7 oct 16 13:21 simbolico -&gt; nombre1</span>
</pre></div>
</div>
<p>Hay varias diferencias con el otro tipo de enlace:</p>
<ol class="arabic">
<li><p>Existen dos archivos distintos: el archivo original y el enlace simbólico.</p></li>
<li><p>Los enlaces simbólicos se pueden hacer entre distintos sistemas de
archivos.</p></li>
<li><p>Pueden enlazarse directorios.</p></li>
<li><p>Si se borra el archivo original (o simplemente, se cambia su nombre), el
enlace simbólico referenciará un nombre de archivo que ya no existe, por
lo que quedará huérfano:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>rm<span class="w"> </span>nombre1
<span class="gp">$ </span>ls<span class="w"> </span>-l
<span class="go">lrwxrwxrwx 1 usuario usuario 7 oct 16 13:21 simbolico -&gt; nombre1</span>
<span class="gp">$ </span>cat<span class="w"> </span>simbolico
<span class="go">cat: simbolico: No existe el archivo o el directorio</span>
</pre></div>
</div>
<p>Sin embargo, si volvemos a crear una archivo distinto con el nombre que
tenía el anterior, entonces la referencia volverá a cobrar sentido y
podremos alcanzar el nuevo archivo usando el enlace simbólico:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span><span class="nb">echo</span><span class="w"> </span><span class="s2">&quot;Soy otro archivo distinto&quot;</span><span class="w"> </span>&gt;<span class="w"> </span>nombre1
<span class="gp">$ </span>cat<span class="w"> </span>simbolico
<span class="go">Soy otro archivo distinto</span>
</pre></div>
</div>
</li>
</ol>
<div class="admonition warning">
<p class="admonition-title">Advertencia</p>
<p>Ha de tenerse cuidado al crear enlaces simbólicos cuando se usa
una ruta relativa para expresar el archivo apuntado. Esta ruta relativa no
se expresa respecto al directorio de trabajo, sino respecto al propio
enlace simbólico. Retomando el ejemplo anterior:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span><span class="nb">cd</span>
<span class="gp">$ </span>touch<span class="w"> </span>nombre1
<span class="gp">$ </span><span class="nb">cd</span><span class="w"> </span>/tmp
<span class="gp">$ </span>ln<span class="w"> </span>-s<span class="w"> </span>nombre1<span class="w"> </span>~/simbolico
</pre></div>
</div>
<p>Como se quiere usar una ruta relativa, <code class="file docutils literal notranslate"><span class="pre">nombre1</span></code> debe expresarse
respecto al directorio donde se desea crear <code class="file docutils literal notranslate"><span class="pre">simbólico</span></code>. Por tanto,
la ruta relativa consiste en escribir simplemente el nombre, aunque
nuestro directorio de trabajo sea <code class="file docutils literal notranslate"><span class="pre">/tmp</span></code> y no el directorio
personal.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>Aunque sólo se pueden crear enlaces duros de archivos, es lícito
usar la opción <code class="docutils literal notranslate"><span class="pre">-l</span></code> de <strong class="command">cp</strong> al copiar directorios con todo su
contenido.  En ese caso, <strong class="command">cp</strong> creara un nuevo directorio al
copiar el directorio y enlaces duros al copiar los archivos.</p>
</div>
</dd>
</dl>
<span id="realpath"></span><dl id="index-25">
<dt><em class="manpage"><a class="manpage reference external" href="https://manpages.debian.org/realpath">realpath</a></em></dt><dd><p>Devuelve la ruta absoluta (resolviendo enlaces simbólicos si los hubiera)
del archivo dado como argumento:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span><span class="nb">pwd</span>
<span class="go">/home/usuario</span>
<span class="gp">$ </span>realpath<span class="w"> </span>no.existe
<span class="go">/home/usuario/no.existe</span>
</pre></div>
</div>
<p>Puede requerirse que el archivo exista incluyendo la opción <kbd class="kbd docutils literal notranslate">-e</kbd>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>realpath<span class="w"> </span>-e<span class="w"> </span>no.existe
<span class="go">realpath: «no.existe»: No existe el archivo o el directorio</span>
</pre></div>
</div>
</dd>
</dl>
<span id="readlink"></span><dl id="index-26">
<dt><em class="manpage"><a class="manpage reference external" href="https://manpages.debian.org/readlink">readlink</a></em></dt><dd><p>Resuelve el enlace simbólico devolviendo el archivo al que apunta:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>touch<span class="w"> </span>soy.un.archivo
<span class="gp">$ </span>ln<span class="w"> </span>-s<span class="w"> </span>soy.un.archivo<span class="w"> </span>soy.un.enlace.simbolico
<span class="gp">$ </span>readlink<span class="w"> </span>soy.un.enlace.simbolico
<span class="go">soy.un.archivo</span>
</pre></div>
</div>
<p>Si se usa como argumento un archivo que no es un enlace simbólico, no
imprimirá nada y devolverá un error a la <em>shell</em>.</p>
<p>Si el enlace simbólico apunta a otro enlace simbólico se devolverá este
segundo enlace, con lo que no se sabrá a ciencia cierta cuál es el
archivo al que se está apuntando en realidad. Para ello existe la opción
<kbd class="kbd docutils literal notranslate">-f</kbd> que, además, siempre muestra la ruta absoluta:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>ln<span class="w"> </span>-s<span class="w"> </span>soy.un.enlace.simbolico<span class="w"> </span>soy.otro.enlace
<span class="gp">$ </span>readlink<span class="w"> </span>soy.otro.enlace
<span class="go">soy.un.enlace.simbolico</span>
<span class="gp">$ </span>readlink<span class="w"> </span>-f<span class="w"> </span>soy.otro.enlace
<span class="go">/home/usuario/soy.un.archivo</span>
</pre></div>
</div>
<p>En este caso, tiene sentido usar como argumento cualquier archivo: no se
generará un error, sino que se mostrará su ruta absoluta:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>readlink<span class="w"> </span>-f<span class="w"> </span>soy.un.archivo
<span class="go">/home/usuario/soy.un.archivo</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>Por tanto, la opción <kbd class="kbd docutils literal notranslate">-f</kbd> hace que sea equivalente a
<a class="reference internal" href="#realpath"><span class="std std-ref">realpath</span></a>.</p>
</div>
</dd>
</dl>
<p id="index-29"><span id="index-28"></span><span id="index-27"></span>Cuando se usa una interfaz de texto, gran parte de los archivos que se manejan
son de texto, así que una de las herramientas más socorridas son los <em>editores de
texto</em>. En cualquier sistema <em>unix</em> suele venir de serie <strong class="program">vi</strong> o su
<em>primo de Zumosol</em> <a class="reference external" href="http://www.vim.org">vim</a>, pero los neófitos suelen
preferir <strong class="program">nano</strong>, un clónico mejorado del antiguo editor
<strong class="program">pico</strong>. También es muy usado <a class="reference external" href="https://www.gnu.org/software/emacs/">emacs</a>.</p>
</section>
<section id="ejercicios-sobre-manipulacion-de-archivos">
<span id="ej-fic"></span><h2><span class="section-number">2.2.2.3. </span>Ejercicios sobre manipulación de archivos<a class="headerlink" href="#ejercicios-sobre-manipulacion-de-archivos" title="Link to this heading">¶</a></h2>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>Especifique convenientemente si usa el administrador o no.</p>
</div>
<ol class="loweralpha">
<li><p>Lleve a cabo las siguienes tareas:</p>
<ol class="arabic">
<li><p>Crear un fichero vacío llamado <code class="file docutils literal notranslate"><span class="pre">estoy.en.blanco</span></code> dentro del directorio
personal del usuario.</p></li>
<li><p>Hacer una copia de este fichero en el directorio temporal con nombre
<code class="file docutils literal notranslate"><span class="pre">sigo.en.blanco</span></code>. Use rutas relativas tanto para el origen como para
el destino.</p></li>
<li><p>Del archivo original hacer un enlace duro en el directorio temporal conservando el nombre.
¿Es posible en el sistema en que está trabajando? ¿Por qué?</p></li>
<li><p>Crear la siguiente estructura de directorios:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>/tmp
  +---- DIR1
  |      +------ DIR11
  |      +------ DIR12
  +---- DIR2
  +---- DIR3
    +------ DIR31
    +------ DIR32
    +------ DIR33
</pre></div>
</div>
</li>
<li><p>Cambiar al directorio temporal usando ruta absoluta.</p></li>
<li><p>Mover <code class="file docutils literal notranslate"><span class="pre">sigo.en.blanco</span></code> al directorio <code class="file docutils literal notranslate"><span class="pre">DIR33</span></code>.</p></li>
<li><p>Manteniendo el mismo nombre, hacer un enlace simbólico a
<code class="file docutils literal notranslate"><span class="pre">sigo.en.blanco</span></code> en el directorio personal</p></li>
<li><p>Mover el directorio <code class="file docutils literal notranslate"><span class="pre">DIR33</span></code> dentro de <code class="file docutils literal notranslate"><span class="pre">DIR12</span></code>.</p></li>
<li><p>Copiar todo el árbol que cuelga de <code class="file docutils literal notranslate"><span class="pre">DIR1</span></code> dentro de <code class="file docutils literal notranslate"><span class="pre">DIR32</span></code>.</p></li>
<li><p>Borrar todo lo que se ha hecho.</p></li>
</ol>
</li>
<li><p>Haga esta otra tanda de ejercicios, sabiendo que comienza a hacerlos estando
en su directorio personal:</p>
<ol class="arabic">
<li><p>Consulte el contenido de <code class="file docutils literal notranslate"><span class="pre">/usr/sbin</span></code> usando ruta relativa.</p></li>
<li><p>Encuentre los ficheros de extensión <code class="file docutils literal notranslate"><span class="pre">.txt.gz</span></code> contenidos dentro
de la parte del árbol de directorios que cualga de <code class="file docutils literal notranslate"><span class="pre">/usr/share/doc</span></code>.</p></li>
<li><p>Entre en el directorio temporal usando ruta relativa.</p></li>
<li><p>Consulte cuáles son los permisos del directorio raíz. Utilice ruta
relativa y dos órdenes distintas.</p></li>
<li><p>Cree la siguiente estructura de archivos (vacíos) y directorios:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>+ /tmp
    +--- dirA
    |     +-- fichero1.txt
    |     +-- dirAA
    |     |     +-- fichero2.txt
    |     |     +-- fichero3.txt
    |     |
    |     +-- dirAB
    |     +-- dirAC
    |           +-- fichero4.txt
    +--- dirB
</pre></div>
</div>
</li>
<li><p>Mueva <code class="file docutils literal notranslate"><span class="pre">dirAA</span></code> dentro de <code class="file docutils literal notranslate"><span class="pre">dirB</span></code>.</p></li>
<li><p>Buscar todos los ficheros de texto plano (extensión <code class="file docutils literal notranslate"><span class="pre">.txt</span></code>)
contenidos en el directorio temporal.</p></li>
<li><p>Hacer en enlace duro dentro de <code class="file docutils literal notranslate"><span class="pre">dirAB</span></code> del archivo
<code class="file docutils literal notranslate"><span class="pre">fichero3.txt</span></code>.</p></li>
<li><p>Hacer un enlace simbólico en <code class="file docutils literal notranslate"><span class="pre">dirB</span></code> de <code class="file docutils literal notranslate"><span class="pre">fichero1.txt</span></code> y llamar
a dicho enlace <code class="file docutils literal notranslate"><span class="pre">unfichero.txt</span></code>.</p></li>
<li><p>Borrar todo lo creado.</p></li>
</ol>
</li>
</ol>
<p class="rubric">Notas al pie</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id4" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id1">1</a><span class="fn-bracket">]</span></span>
<p>El texto se escribió originariamente antes de esta fecha, razón por la
cual no aparece fecha de creación en la salida de <a class="reference internal" href="#stat"><span class="std std-ref">stat</span></a>.</p>
</aside>
<aside class="footnote brackets" id="id5" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id2">2</a><span class="fn-bracket">]</span></span>
<p><strong class="command">which</strong> no busca todos los programas que hay en nuestro árbol de
directorios, ya que estos pueden encontrarse en cualquier lugar
arbitrario. Véase la variable <a class="reference internal" href="../07.avanzada/08.interpretaciones.html#path"><span class="std std-ref">PATH</span></a>, para saber más al
respecto.</p>
</aside>
<aside class="footnote brackets" id="id6" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id3">3</a><span class="fn-bracket">]</span></span>
<p>En realidad,  <code class="docutils literal notranslate"><span class="pre">-p</span></code> no preserva algunas propiedades como los atributos
extendidos. Usar <code class="docutils literal notranslate"><span class="pre">-a</span></code> implica, más bien, <kbd class="kbd docutils literal notranslate">-</kbd>-<kbd class="kbd docutils literal notranslate">preserve=all</kbd>.</p>
</aside>
</aside>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
  <div>
    <h3><a href="../../index.html">Tabla de contenido</a></h3>
    <ul>
<li><a class="reference internal" href="#">2.2.2. Archivos y directorios</a><ul>
<li><a class="reference internal" href="#bicheando">2.2.2.1. Bicheando</a><ul>
<li><a class="reference internal" href="#dentro-de-directorios">2.2.2.1.1. … dentro de directorios</a></li>
<li><a class="reference internal" href="#y-dentro-de-archivos">2.2.2.1.2. … y dentro de archivos</a></li>
</ul>
</li>
<li><a class="reference internal" href="#creando-contenidos">2.2.2.2. Creando contenidos</a></li>
<li><a class="reference internal" href="#ejercicios-sobre-manipulacion-de-archivos">2.2.2.3. Ejercicios sobre manipulación de archivos</a></li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>Tema anterior</h4>
    <p class="topless"><a href="01.filesystem.html"
                          title="capítulo anterior"><span class="section-number">2.2.1. </span>El sistema de archivos</a></p>
  </div>
  <div>
    <h4>Próximo tema</h4>
    <p class="topless"><a href="04.devices.html"
                          title="próximo capítulo"><span class="section-number">2.2.3. </span>Dispositivos</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>Esta página</h3>
    <ul class="this-page-menu">
      <li><a href="../../_sources/02.conbas/02.informacion/03.ficheros.rst.txt"
            rel="nofollow">Mostrar el código</a></li>
    </ul>
   </div>
<search id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Búsqueda rápida</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Ir a" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="Related">
      <h3>Navegación</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="Índice General"
             >índice</a></li>
        <li class="right" >
          <a href="04.devices.html" title="2.2.3. Dispositivos"
             >siguiente</a> |</li>
        <li class="right" >
          <a href="01.filesystem.html" title="2.2.1. El sistema de archivos"
             >anterior</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">documentación de Linuxnomicón - rolling</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" ><span class="section-number">2. </span>Conceptos básicos</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="index.html" ><span class="section-number">2.2. </span>Acceso a la información</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href=""><span class="section-number">2.2.2. </span>Archivos y directorios</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
    &#169; Copyright CC BY 4.0, 2016-2025, José Miguel Sánchez Alés.
      Creado usando <a href="https://www.sphinx-doc.org/">Sphinx</a> 8.2.3.
    </div>
  </body>
</html>