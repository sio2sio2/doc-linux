

<!DOCTYPE html>

<html lang="es" data-content_root="../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>3.3. Estructuras de control &#8212; documentación de Linuxnomicón - rolling</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=03e43079" />
    <link rel="stylesheet" type="text/css" href="../_static/classic.css?v=2bf1fcf8" />
    <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
    
    <script src="../_static/documentation_options.js?v=a621b78a"></script>
    <script src="../_static/doctools.js?v=9bcbadda"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../_static/translations.js?v=f85f4cfb"></script>
    
    <link rel="index" title="Índice" href="../genindex.html" />
    <link rel="search" title="Búsqueda" href="../search.html" />
    <link rel="next" title="3.4. Datos complejos" href="04.datos.html" />
    <link rel="prev" title="3.2. Entrada/Salida" href="02.io.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="Related">
      <h3>Navegación</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="Índice General"
             accesskey="I">índice</a></li>
        <li class="right" >
          <a href="04.datos.html" title="3.4. Datos complejos"
             accesskey="N">siguiente</a> |</li>
        <li class="right" >
          <a href="02.io.html" title="3.2. Entrada/Salida"
             accesskey="P">anterior</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">documentación de Linuxnomicón - rolling</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="index.html" accesskey="U"><span class="section-number">3. </span>Programación de <em>scripts</em></a> &#187;</li>
        <li class="nav-item nav-item-this"><a href=""><span class="section-number">3.3. </span>Estructuras de control</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="estructuras-de-control">
<h1><span class="section-number">3.3. </span>Estructuras de control<a class="headerlink" href="#estructuras-de-control" title="Link to this heading">¶</a></h1>
<p>El epígrafe está dedicado a las <em>estructuras de control</em> disponibles es linux,
excepto las funciones, que se verán <a class="reference internal" href="05.funciones.html#sh-func"><span class="std std-ref">mas adelante</span></a>.</p>
<section id="if">
<span id="sh-if"></span><h2><span class="section-number">3.3.1. </span><code class="docutils literal notranslate"><span class="pre">if</span></code><a class="headerlink" href="#if" title="Link to this heading">¶</a></h2>
<p>La sentencia condicional tiene la siguiente forma:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="k">if</span><span class="w"> </span>ORDEN<span class="p">;</span><span class="w"> </span><span class="k">then</span>
<span class="w">   </span>ORDENES
<span class="k">else</span>
<span class="w">   </span>ORDENES
<span class="k">fi</span>
</pre></div>
</div>
<p>y, si quiere encadenarse varios:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="k">if</span><span class="w"> </span>ORDEN<span class="p">;</span><span class="w"> </span><span class="k">then</span>
<span class="w">   </span>ORDENES
<span class="k">elif</span><span class="w"> </span>ORDEN<span class="p">;</span><span class="w"> </span><span class="k">then</span>
<span class="w">   </span>ORDENES
<span class="k">else</span>
<span class="w">   </span>ORDENES
<span class="k">fi</span>
</pre></div>
</div>
<p>La orden<a class="footnote-reference brackets" href="#id10" id="id1" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a> que acompaña al <code class="docutils literal notranslate"><span class="pre">if</span></code> actúa como expresión evaluadora, de manera
que si devuelve <strong>0</strong> (éxito) se evalúa el bloque del <code class="docutils literal notranslate"><span class="pre">if</span></code>; y, en caso
contrario, el bloque del <code class="docutils literal notranslate"><span class="pre">else</span></code>. Por ejemplo:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="k">if</span><span class="w"> </span>grep<span class="w"> </span>-q<span class="w"> </span><span class="s1">&#39;^V&#39;</span><span class="w"> </span>&lt;<span class="w"> </span>fichero.txt<span class="p">;</span><span class="w"> </span><span class="k">then</span>
<span class="w">   </span><span class="nb">echo</span><span class="w"> </span><span class="s2">&quot;Al menos una línea empieza por V&quot;</span>
<span class="k">else</span>
<span class="w">   </span><span class="nb">echo</span><span class="w"> </span><span class="s2">&quot;Ninguna línea empieza por V&quot;</span>
<span class="k">fi</span>
</pre></div>
</div>
<p id="index-0"><span id="test"></span>Una de las órdenes que más se usa para construir expresiones evaluadoras es
<strong class="command">test</strong>, que permite inquirir sobre el valor de las variables y la
existencia o inexistencia de ficheros, y es tanto una orden interna
proporcionada por la propia <em>shell</em> como un comando independiente.  Por
ejemplo:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="k">if</span><span class="w"> </span><span class="nb">test</span><span class="w"> </span><span class="s2">&quot;</span><span class="nv">$USER</span><span class="s2">&quot;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">&quot;root&quot;</span><span class="p">;</span><span class="w"> </span><span class="k">then</span>
<span class="w">   </span><span class="nb">echo</span><span class="w"> </span><span class="s2">&quot;Es usted el administrador&quot;</span>
<span class="k">fi</span>
</pre></div>
</div>
<p>o también:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="k">if</span><span class="w"> </span><span class="nb">test</span><span class="w"> </span>-d<span class="w"> </span><span class="s2">&quot;</span><span class="nv">$HOME</span><span class="s2">&quot;</span><span class="p">;</span><span class="w"> </span><span class="k">then</span>
<span class="w">   </span><span class="nb">echo</span><span class="w"> </span><span class="s2">&quot;¡Felicidades, </span><span class="nv">$USER</span><span class="s2">! Su directorio personal existe&quot;</span>
<span class="k">fi</span>
</pre></div>
</div>
<p>Para conocer todas las posibilidades que brinda <strong class="command">test</strong>, consulte la
ayuda interna o la página de manual del comando correspondiente:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$<span class="w"> </span><span class="nb">help</span><span class="w"> </span><span class="nb">test</span>
$<span class="w"> </span>man<span class="w"> </span><span class="nb">test</span>
</pre></div>
</div>
<p>No obstante lo anterior, existe una variante de la orden anterior llamada
<strong class="command">[</strong> (sí, un corchete, así como se escribe), que funciona de la misma
forma excepto por el hecho de que obliga siempre a que su argumento final sea
<code class="docutils literal notranslate"><span class="pre">]</span></code>. Por ese motivo, las condicionales arriba escritas se escriben más
comunmente así:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="k">if</span><span class="w"> </span><span class="o">[</span><span class="w"> </span><span class="s2">&quot;</span><span class="nv">$USER</span><span class="s2">&quot;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">&quot;root&quot;</span><span class="w"> </span><span class="o">]</span><span class="p">;</span><span class="w"> </span><span class="k">then</span>
<span class="w">   </span><span class="nb">echo</span><span class="w"> </span><span class="s2">&quot;Es usted el administrador&quot;</span>
<span class="k">fi</span>

<span class="k">if</span><span class="w"> </span><span class="o">[</span><span class="w"> </span>-d<span class="w"> </span><span class="s2">&quot;</span><span class="nv">$HOME</span><span class="s2">&quot;</span><span class="w"> </span><span class="o">]</span><span class="p">;</span><span class="w"> </span><span class="k">then</span>
<span class="w">   </span><span class="nb">echo</span><span class="w"> </span><span class="s2">&quot;¡Felicidades, </span><span class="nv">$USER</span><span class="s2">! Su directorio personal existe&quot;</span>
<span class="k">fi</span>
</pre></div>
</div>
<div class="admonition warning">
<p class="admonition-title">Advertencia</p>
<p>Recuerde que <strong class="command">[</strong> es una orden y <code class="docutils literal notranslate"><span class="pre">]</span></code>, su último
argumento. En consecuencia, siempre debe existir un espacio de separación entre
entre ellos y el contenido (que son argumentos). De la misma forma, que no
tiene sentido <code class="code docutils literal notranslate"><span class="pre">test-d</span> <span class="pre">&quot;$HOME&quot;</span></code>, no tiene sentido <code class="code docutils literal notranslate"><span class="pre">[-d</span> <span class="pre">&quot;$HOME&quot;]</span></code>.</p>
</div>
<p>Para construir una condición compuesta, basta con concatenar varias órdenes
<strong class="command">test</strong>, tal como se explicó con la <a class="reference internal" href="../02.conbas/07.avanzada/07.concatenacion.html#sh-concat"><span class="std std-ref">concatenación de órdenes</span></a>:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="k">if</span><span class="w"> </span><span class="o">[</span><span class="w"> </span>-d<span class="w"> </span><span class="s2">&quot;</span><span class="nv">$HOME</span><span class="s2">&quot;</span><span class="w"> </span><span class="o">]</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="o">[</span><span class="w"> </span>-z<span class="w"> </span><span class="s2">&quot;</span><span class="nv">$HOME</span><span class="s2">&quot;</span><span class="w"> </span><span class="o">]</span><span class="p">;</span><span class="w"> </span>fhen
<span class="w">   </span><span class="c1"># Bla, bla, bla...</span>
<span class="k">fi</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>La orden <strong class="command">test</strong> <a class="reference external" href="http://pubs.opengroup.org/onlinepubs/009695399/utilities/test.html">según el estándar POSIX</a>
dispone de las opciones <kbd class="kbd docutils literal notranslate">-a</kbd> y <kbd class="kbd docutils literal notranslate">-o</kbd>, pero como extensiones
<em>XSI</em> que no son obligatorias, por lo que por portabilidad es
preferible usar varias órdenes <strong class="command">test</strong>.</p>
</div>
<div class="admonition warning">
<p class="admonition-title">Advertencia</p>
<p>Recuerde que en la <em>shell</em> el operador lógico <kbd class="kbd docutils literal notranslate">&amp;&amp;</kbd> tiene la
misma precedencia que <kbd class="kbd docutils literal notranslate">||</kbd>.</p>
</div>
<p id="sh-regex"><strong class="command">bash</strong> dispone, además, de la orden interna <strong class="command">[[</strong> que introduce
<a class="reference external" href="http://mywiki.wooledge.org/BashFAQ/031">algunas mejoras al test estándar</a>.
Una de sus ventajas es que permite el uso de <a class="reference internal" href="../02.conbas/10.texto/01.regex.html#regex"><span class="std std-ref">expresiones regulares</span></a><a class="footnote-reference brackets" href="#id11" id="id2" role="doc-noteref"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></a>,
lo cual nos puede evitar el uso de <a class="reference internal" href="../02.conbas/10.texto/02.busqueda.html#grep"><span class="std std-ref">grep</span></a>, cuando lo que hacemos es
comprobar valores de variables. Por ejemplo, esta evaluación:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="k">if</span><span class="w"> </span><span class="nb">echo</span><span class="w"> </span><span class="s2">&quot;</span><span class="nv">$HOME</span><span class="s2">&quot;</span><span class="w"> </span><span class="p">|</span><span class="w"> </span>grep<span class="w"> </span>-qw<span class="w"> </span><span class="s2">&quot;</span><span class="nv">$USER</span><span class="s2">&quot;</span><span class="p">;</span><span class="w"> </span><span class="k">then</span>
<span class="w">   </span><span class="nb">echo</span><span class="w"> </span><span class="s2">&quot;El directorio personal contiene el nombre de usuario&quot;</span>
<span class="k">fi</span>
</pre></div>
</div>
<p>es equivalente a esta otra<a class="footnote-reference brackets" href="#id12" id="id3" role="doc-noteref"><span class="fn-bracket">[</span>3<span class="fn-bracket">]</span></a>:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="k">if</span><span class="w"> </span><span class="o">[[</span><span class="w"> </span><span class="nv">$HOME</span><span class="w"> </span><span class="o">=</span>~<span class="w"> </span><span class="nv">$USER</span><span class="w"> </span><span class="o">]]</span><span class="p">;</span><span class="w"> </span><span class="k">then</span>
<span class="w">   </span><span class="nb">echo</span><span class="w"> </span><span class="s2">&quot;El directorio personal contiene el nombre de usuario&quot;</span>
<span class="k">fi</span>
</pre></div>
</div>
<p>También permite el uso de expansiones con las operaciones de igualdad y
desigualdad (tal como hace <code class="docutils literal notranslate"><span class="pre">case</span></code> como veremos a continuación). Por ejemplo:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$<span class="w"> </span><span class="nv">var</span><span class="o">=</span><span class="s2">&quot;HOLA&quot;</span>
$<span class="w"> </span><span class="o">[</span><span class="w"> </span><span class="nv">$var</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>H*<span class="w"> </span><span class="o">]</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="nb">echo</span><span class="w"> </span><span class="s2">&quot;Éxito&quot;</span>
$<span class="w"> </span><span class="o">[[</span><span class="w"> </span><span class="nv">$var</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>H*<span class="w"> </span><span class="o">]]</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="nb">echo</span><span class="w"> </span><span class="s2">&quot;Éxito&quot;</span>
Éxito
</pre></div>
</div>
</section>
<section id="case">
<span id="sh-case"></span><h2><span class="section-number">3.3.2. </span><code class="docutils literal notranslate"><span class="pre">case</span></code><a class="headerlink" href="#case" title="Link to this heading">¶</a></h2>
<p>Esta estructura se usa para expresar la sentencia condicional múltiple. Tiene
esta forma:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="k">case</span><span class="w"> </span><span class="nv">$VARIABLE</span><span class="w"> </span><span class="k">in</span>
<span class="w">   </span>v1<span class="o">)</span>
<span class="w">      </span><span class="c1"># Bloque de instrucciones para el primer valor</span>
<span class="w">      </span><span class="p">;;</span>
<span class="w">   </span>v2<span class="o">)</span>
<span class="w">      </span><span class="c1"># Bloque de instrucciones para el segundo valor</span>
<span class="w">      </span><span class="p">;;</span>
<span class="w">      </span>.
<span class="w">      </span>.
<span class="w">      </span>.
<span class="w">   </span>vn<span class="o">)</span>
<span class="w">      </span><span class="c1"># Bloque de instrucciones para el enésimo valor</span>
<span class="w">      </span><span class="p">;;</span>
<span class="k">esac</span>
</pre></div>
</div>
<p>donde <em>v1</em>, <em>v2</em>, …, <em>vn</em> son los distintos valores que puede tomar la
variable <code class="docutils literal notranslate"><span class="pre">VARIABLE</span></code> cuyo valor se prueba al principio de la sentencia. El
intérprete comprueba en orden si el valor de la variable coincide con los
expresados y ejecutará el bloque del primero con el que coincida. Los bloques
siempre deben acabar con dos puntos y coma. La potencia de esta estructura es
que el intérprete expande los valores <em>v1</em>, <em>v2</em>, etc:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="ch">#!/bin/sh</span>

<span class="nb">read</span><span class="w"> </span>-p<span class="w"> </span><span class="s2">&quot;Escriba un carácter: &quot;</span><span class="w"> </span>CHAR
<span class="nb">echo</span>

<span class="k">case</span><span class="w"> </span><span class="nv">$CHAR</span><span class="w"> </span><span class="k">in</span>
<span class="w">   </span><span class="o">[</span><span class="m">0</span>-9<span class="o">])</span>
<span class="w">      </span><span class="nb">echo</span><span class="w"> </span><span class="s2">&quot;Ha introducido un número&quot;</span>
<span class="w">      </span><span class="p">;;</span>
<span class="w">   </span><span class="o">[</span>a-zA-Z<span class="o">])</span>
<span class="w">      </span><span class="nb">echo</span><span class="w"> </span><span class="s2">&quot;Ha introducido una letra&quot;</span>
<span class="w">      </span><span class="p">;;</span>
<span class="w">   </span>*<span class="o">)</span>
<span class="w">      </span><span class="nb">echo</span><span class="w"> </span><span class="s2">&quot;No tengo ni idea de lo que ha introducido&quot;</span>
<span class="w">      </span><span class="p">;;</span>
<span class="k">esac</span>
</pre></div>
</div>
<p>También es posible usar el carácter <code class="docutils literal notranslate"><span class="pre">|</span></code> para permitir la coincidencia múltiple
con un bloque:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="k">case</span><span class="w"> </span>nombre<span class="w"> </span><span class="k">in</span>
<span class="w">   </span>Luis<span class="p">|</span>Manolo<span class="p">|</span>Pablo<span class="o">)</span>
<span class="w">      </span><span class="nb">echo</span><span class="w"> </span><span class="s2">&quot;</span><span class="nv">$nombre</span><span class="s2"> es mi amigo.&quot;</span>
<span class="w">      </span><span class="p">;;</span>
<span class="w">   </span>*<span class="o">)</span>
<span class="w">      </span><span class="nb">echo</span><span class="w"> </span><span class="s2">&quot;No tengo el gusto de conocer a </span><span class="nv">$nombre</span><span class="s2">&quot;</span>
<span class="w">      </span><span class="p">;;</span>
<span class="k">esac</span>
</pre></div>
</div>
</section>
<section id="while-until">
<span id="sh-while"></span><h2><span class="section-number">3.3.3. </span><code class="docutils literal notranslate"><span class="pre">while</span></code>/<code class="docutils literal notranslate"><span class="pre">until</span></code><a class="headerlink" href="#while-until" title="Link to this heading">¶</a></h2>
<p>Son los ordenes que permiten repetir un bucle mientras se cumpla (<code class="docutils literal notranslate"><span class="pre">while</span></code>) o no
(<code class="docutils literal notranslate"><span class="pre">until</span></code>) una condición:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="k">while</span><span class="w"> </span>ORDEN<span class="p">;</span><span class="w"> </span><span class="k">do</span>
<span class="w">   </span><span class="c1"># Órdenes del bucle</span>
<span class="k">done</span>
</pre></div>
</div>
<p>y para <code class="docutils literal notranslate"><span class="pre">until</span></code> se tiene la misma estructura:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="k">until</span><span class="w"> </span>ORDEN<span class="p">;</span><span class="w"> </span><span class="k">do</span>
<span class="w">   </span><span class="c1"># Órdenes del bucle</span>
<span class="k">done</span>
</pre></div>
</div>
<p>La orden que expresa la condición se evalúa exactamente de la misma forma que en
el caso de <code class="docutils literal notranslate"><span class="pre">if</span></code>. Por ejemplo:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="ch">#!/biun/sh</span>

<span class="nv">RANDOM</span><span class="o">=</span><span class="m">5</span>

<span class="nb">echo</span><span class="w"> </span><span class="s2">&quot;Acabo de pensar un número entre 1 y 10.&quot;</span>

<span class="k">while</span><span class="w"> </span><span class="o">[</span><span class="w"> </span><span class="s2">&quot;</span><span class="nv">$num</span><span class="s2">&quot;</span><span class="w"> </span>!<span class="o">=</span><span class="w"> </span><span class="s2">&quot;</span><span class="nv">$RANDOM</span><span class="s2">&quot;</span><span class="w"> </span><span class="o">]</span><span class="p">;</span><span class="w"> </span><span class="k">do</span>
<span class="w">   </span><span class="nb">read</span><span class="w"> </span>-p<span class="w"> </span><span class="s2">&quot;Intente averiguarlo: &quot;</span><span class="w"> </span>num
<span class="k">done</span>

<span class="nb">echo</span><span class="w"> </span><span class="s2">&quot;¡¡¡Correcto!!!&quot;</span>
</pre></div>
</div>
<p>Sí, es cierto: el programa sólo sirve para jugar una vez, porque el número
oculto siempre es el mismo. La idea es sólo mostrar cómo usar el bucle, pero
podemos complicar el programa para que el número se obtenga al azar<a class="footnote-reference brackets" href="#id13" id="id4" role="doc-noteref"><span class="fn-bracket">[</span>4<span class="fn-bracket">]</span></a>:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="ch">#!/bin/sh</span>

<span class="c1">#</span>
<span class="c1"># Convierte código hexadecimal en binario</span>
<span class="c1"># (requiere bc, que puede no estar instalado)</span>
<span class="c1"># $1: El número en hexadecimal</span>
<span class="c1">#</span>
hex2dec<span class="o">()</span><span class="w"> </span><span class="o">{</span>
<span class="w">   </span><span class="nb">echo</span><span class="w"> </span><span class="s2">&quot;ibase=16;</span><span class="nv">$1</span><span class="s2">&quot;</span><span class="w"> </span><span class="p">|</span><span class="w"> </span>bc
<span class="o">}</span>


<span class="c1">#</span>
<span class="c1"># Obtiene n bytes al azar expresados en hexadecimal</span>
<span class="c1"># $1: Número de bytes. 1, si no se especifica.</span>
<span class="c1">#</span>
random_x<span class="o">()</span><span class="w"> </span><span class="o">{</span>
<span class="w">   </span><span class="c1"># hexdump -n${1:-1} -ve &#39;&quot;%02X&quot;&#39; /dev/urandom</span>
<span class="w">   </span><span class="c1"># od debería ser más portable que hexdump,</span>
<span class="w">   </span><span class="c1"># aunque debemos eliminar espacios y pasar a mayúsculas.</span>
<span class="w">   </span>od<span class="w"> </span>-v<span class="w"> </span>-An<span class="w"> </span>-tx1<span class="w"> </span>-N<span class="si">${</span><span class="nv">1</span><span class="k">:-</span><span class="nv">1</span><span class="si">}</span><span class="w"> </span>/dev/urandom<span class="w"> </span><span class="p">|</span><span class="w"> </span>tr<span class="w"> </span>-d<span class="w"> </span><span class="s1">&#39;\n &#39;</span><span class="w"> </span><span class="p">|</span><span class="w"> </span>tr<span class="w"> </span><span class="s1">&#39;[:lower:]&#39;</span><span class="w"> </span><span class="s1">&#39;[:upper:]&#39;</span>
<span class="o">}</span>


<span class="c1">#</span>
<span class="c1"># Obtiene un número decimal aleatorio entre 0 y 2**n-1.</span>
<span class="c1"># $1: El valor de n.</span>
<span class="c1">#</span>
random<span class="o">()</span><span class="w"> </span><span class="o">{</span>
<span class="w">   </span>hex2dec<span class="w"> </span><span class="k">$(</span>random_x<span class="w"> </span><span class="s2">&quot;</span><span class="nv">$1</span><span class="s2">&quot;</span><span class="k">)</span>
<span class="o">}</span>


<span class="nv">RANDOM</span><span class="o">=</span><span class="k">$((</span><span class="sb">`</span>random<span class="sb">`</span><span class="o">%</span><span class="m">10</span><span class="o">+</span><span class="m">1</span><span class="k">))</span><span class="w">     </span><span class="c1"># Número entre 1 y 10 (sí, no son equiprobables)</span>

<span class="nb">echo</span><span class="w"> </span><span class="s2">&quot;Acabo de pensar un número entre 1 y 10.&quot;</span>

<span class="k">while</span><span class="w"> </span><span class="o">[</span><span class="w"> </span><span class="s2">&quot;</span><span class="nv">$num</span><span class="s2">&quot;</span><span class="w"> </span>!<span class="o">=</span><span class="w"> </span><span class="s2">&quot;</span><span class="nv">$RANDOM</span><span class="s2">&quot;</span><span class="w"> </span><span class="o">]</span><span class="p">;</span><span class="w"> </span><span class="k">do</span>
<span class="w">   </span><span class="nb">read</span><span class="w"> </span>-p<span class="w"> </span><span class="s2">&quot;Intente averiguarlo: &quot;</span><span class="w"> </span>num
<span class="k">done</span>

<span class="nb">echo</span><span class="w"> </span><span class="s2">&quot;¡¡¡Correcto!!!&quot;</span>
</pre></div>
</div>
<p>Como en otros lenguajes de programación, se dispone (y también en el próximo
tipo de bucle) de <code class="docutils literal notranslate"><span class="pre">break</span></code> (romper el bucle) y <code class="docutils literal notranslate"><span class="pre">continue</span></code> (volver a comenzar
el bucle sin completar la iteración actual).</p>
<p id="while-read">Es bastante común usar el bucle <code class="docutils literal notranslate"><span class="pre">while</span></code> junto a la orden <a class="reference internal" href="../02.conbas/08.redirecciones/02avanzada.html#read"><span class="std std-ref">read</span></a>
para leer línea a línea el contenido de un fichero, aprovechando que ésta orden
tienen éxito si lee algo y fracasa si no queda nada que leer o, visto de otro
modo, si lee el carácter <abbr title="End Of File">EOF</abbr>:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="k">while</span><span class="w"> </span><span class="nb">read</span><span class="w"> </span>linea<span class="p">;</span><span class="w"> </span><span class="k">do</span>
<span class="w">   </span><span class="nb">echo</span><span class="w"> </span><span class="nv">$linea</span>
<span class="k">done</span><span class="w"> </span>&lt;<span class="w"> </span>fichero.txt
</pre></div>
</div>
<p>Si las líneas que deseamos leer se encuentran en una variable, también podemos
utilizar esta construcción, bien con la redirección <cite>&lt;&lt;&lt;</cite> (exclusiva de
<strong class="program">bash</strong>), o bien usando una tubería:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="nb">echo</span><span class="w"> </span><span class="s2">&quot;</span><span class="nv">$contenido</span><span class="s2">&quot;</span><span class="w"> </span><span class="p">|</span><span class="w"> </span><span class="k">while</span><span class="w"> </span><span class="nb">read</span><span class="w"> </span>linea<span class="p">;</span><span class="w"> </span><span class="k">do</span>
<span class="w">   </span><span class="nb">echo</span><span class="w"> </span><span class="nv">$linea</span>
<span class="k">done</span>
</pre></div>
</div>
<div class="admonition warning">
<p class="admonition-title">Advertencia</p>
<p>La tubería provoca que el bucle se ejecute en una subshell y, en
consecuencia, que toda definición o redefinición de variable que se haga
dentro de él no exista fuera:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$<span class="w"> </span><span class="nb">echo</span><span class="w"> </span><span class="s2">&quot;AAA&quot;</span><span class="w"> </span><span class="p">|</span><span class="w"> </span><span class="k">while</span><span class="w"> </span><span class="nb">read</span><span class="w"> </span>linea<span class="p">;</span><span class="w"> </span><span class="k">do</span><span class="w"> </span><span class="nv">var</span><span class="o">=</span><span class="s2">&quot;</span><span class="nv">$linea</span><span class="s2">&quot;</span><span class="p">;</span><span class="w"> </span><span class="k">done</span>
$<span class="w"> </span><span class="nb">echo</span><span class="w"> </span><span class="s2">&quot;El valor de var es: </span><span class="nv">$var</span><span class="s2">&quot;</span>
El<span class="w"> </span>valor<span class="w"> </span>de<span class="w"> </span>var<span class="w"> </span>es:
</pre></div>
</div>
<p>A pesar de lo que podríamos esperar la variable <em>var</em> no vale «AAA», puesto
que la asignación se hizo dentro del bucle y este se ejecuta en una
<em>subshell</em>. Este es un error muy común, incluso entre programadores
experimentados.</p>
<p>Soslayar este problema supone o cambiar la estructura (p.e. usando el
<strong class="command">for</strong> que se verá a continuación) o eliminar la tubería utilizando
un <a class="reference internal" href="../02.conbas/08.redirecciones/01basica.html#sh-here-document"><span class="std std-ref">Here Document</span></a> (si programamos en
<strong class="program">bash</strong> podemos usar un <a class="reference internal" href="../02.conbas/08.redirecciones/01basica.html#bash-here-string"><span class="std std-ref">Here String</span></a>):</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$<span class="w"> </span><span class="k">while</span><span class="w"> </span><span class="nb">read</span><span class="w"> </span>linea<span class="p">;</span><span class="w"> </span><span class="k">do</span><span class="w"> </span><span class="nv">var</span><span class="o">=</span><span class="s2">&quot;</span><span class="nv">$linea</span><span class="s2">&quot;</span><span class="p">;</span><span class="w"> </span><span class="k">done</span><span class="w"> </span><span class="s">&lt;&lt;EOF</span>
<span class="s">&gt; AAA</span>
<span class="s">EOF</span>
$<span class="w"> </span><span class="nb">echo</span><span class="w"> </span><span class="s2">&quot;El valor de var es: </span><span class="nv">$var</span><span class="s2">&quot;</span>
El<span class="w"> </span>valor<span class="w"> </span>de<span class="w"> </span>var<span class="w"> </span>es:<span class="w"> </span>AAA
</pre></div>
</div>
</div>
</section>
<section id="for">
<span id="sh-for"></span><h2><span class="section-number">3.3.4. </span><code class="docutils literal notranslate"><span class="pre">for</span></code><a class="headerlink" href="#for" title="Link to this heading">¶</a></h2>
<p>La <em>shell</em> dispone tambien de un bucle de tipo <code class="docutils literal notranslate"><span class="pre">for</span></code>, que está asociado a una
variable que va tomando distintos valores<a class="footnote-reference brackets" href="#id14" id="id5" role="doc-noteref"><span class="fn-bracket">[</span>5<span class="fn-bracket">]</span></a>:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="k">for</span><span class="w"> </span>var<span class="w"> </span><span class="k">in</span><span class="w"> </span>a<span class="w"> </span>b<span class="w"> </span>c<span class="p">;</span><span class="w"> </span><span class="k">do</span>
<span class="w">   </span><span class="nb">echo</span><span class="w"> </span><span class="nv">$var</span>
<span class="k">done</span>
</pre></div>
</div>
<p>En este caso, se imprimirán tres líneas con los valores <em>a</em>, <em>b</em> y <em>c</em>,
respectivamente.</p>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>Aunque los caracteres separadores de campos vienen dado por el valor
de la variable <a class="reference internal" href="../02.conbas/07.avanzada/08.interpretaciones.html#sh-ifs"><span class="std std-ref">IFS</span></a>, las expansiones de la <em>shell</em> se
comportan de modo que cada campo es cada uno de los resultados individuales
de la expansión. Por ejemplo, supongamos estos dos ficheros:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$<span class="w"> </span>ls<span class="w"> </span>*.mp3
cancion1.mp3
cancion<span class="w"> </span><span class="m">2</span>.mp3
</pre></div>
</div>
<p>Le expansión genera dos elementos, no tres, aunque el segundo nombre contenga
un espacio:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$<span class="w"> </span><span class="k">for</span><span class="w"> </span>f<span class="w"> </span><span class="k">in</span><span class="w"> </span>*.mp3<span class="p">;</span><span class="w"> </span><span class="k">do</span>
&gt;<span class="w">    </span><span class="nb">echo</span><span class="w"> </span><span class="s2">&quot;</span><span class="nv">$f</span><span class="s2">&quot;</span>
&gt;<span class="w"> </span><span class="k">done</span>
cancion1.mp3
cancion<span class="w"> </span><span class="m">2</span>.mp3
</pre></div>
</div>
<p>Esto no es una característica exclusiva de <em>for</em>, sino que es aplicable a
cualquier ocasión en que haya que interpretar distintos campos (p.e. cuando
se pasan argumentos a una función).</p>
</div>
<p><strong class="command">bash</strong>, además, dispone de un <code class="docutils literal notranslate"><span class="pre">for</span></code> con la sintaxis de <em>C</em><a class="footnote-reference brackets" href="#id15" id="id6" role="doc-noteref"><span class="fn-bracket">[</span>6<span class="fn-bracket">]</span></a>:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="k">for</span><span class="o">((</span><span class="nv">i</span><span class="o">=</span><span class="m">0</span><span class="p">;</span><span class="w"> </span>i&lt;<span class="m">10</span><span class="p">;</span><span class="w"> </span>i++<span class="o">))</span><span class="p">;</span><span class="w"> </span><span class="k">do</span>
<span class="w">   </span><span class="nb">echo</span><span class="w"> </span><span class="nv">$i</span>
<span class="k">done</span>
</pre></div>
</div>
</section>
<section id="bloque">
<h2><span class="section-number">3.3.5. </span>Bloque<a class="headerlink" href="#bloque" title="Link to this heading">¶</a></h2>
<p>Un <em class="dfn">bloque</em> no es propiamente una estructura de control de flujo, sino
simplemente un modo de agrupar lógicamente varias instrucciones:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="o">{</span><span class="w">  </span><span class="c1"># Bloque: encerrado entre llaves.</span>
<span class="w">   </span>orden1
<span class="w">   </span>orden2
<span class="w">   </span>orden3
<span class="o">}</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>Si queremos llevar la llave de cierre a la misma línea que la última
orden, hay que separarla de esta con un «;» (punto y coma):</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="o">{</span><span class="w"> </span>orden1<span class="p">;</span><span class="w"> </span>orden2<span class="p">;</span><span class="w"> </span>orden3<span class="p">;</span><span class="w"> </span><span class="o">}</span>
</pre></div>
</div>
</div>
<p>En principio, no hay diferencia alguna entre crear o no el bloque, esto es,
encerrar las instrucciones entre llaves, si no es la de organizar con más
claridad el código. Tiene, sin embargo, utilidad cuando se combina con
redirecciones, puesto que permite redirigir la entrada o la salida de todas las
instrucciones hacia el mismo sitio. Por ejemplo:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="o">{</span>
<span class="w">   </span><span class="nb">read</span><span class="w"> </span>_<span class="w">  </span><span class="c1"># Este read lee la primera línea.</span>
<span class="w">   </span><span class="k">while</span><span class="w"> </span><span class="nb">read</span><span class="w"> </span>-r<span class="w"> </span>linea<span class="p">;</span><span class="w"> </span><span class="k">do</span>
<span class="w">      </span><span class="c1"># Manipulamos la línea</span>
<span class="w">   </span><span class="k">done</span>
<span class="o">}</span><span class="w"> </span>&lt;<span class="w"> </span>entrada.txt
</pre></div>
</div>
<p>El efecto del código anterior es desechar la primera línea del fichero, ya que
no la tratamos. Con la redirección de salida podemos obrar igual:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="o">{</span><span class="w"> </span><span class="nb">echo</span><span class="w"> </span><span class="s2">&quot;Hola&quot;</span><span class="p">;</span><span class="w"> </span><span class="nb">echo</span><span class="w"> </span><span class="s2">&quot;Adios&quot;</span><span class="p">;</span><span class="w"> </span><span class="o">}</span><span class="w"> </span>&gt;<span class="w"> </span>salida.txt
</pre></div>
</div>
<p>O con la tubería:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span><span class="nb">echo</span><span class="w"> </span><span class="s2">&quot;Hola&quot;</span><span class="p">;</span><span class="w"> </span><span class="nb">echo</span><span class="w"> </span><span class="s2">&quot;Adios&quot;</span><span class="w"> </span><span class="p">|</span><span class="w"> </span>tr<span class="w"> </span><span class="s1">&#39;[:lower:]&#39;</span><span class="w"> </span><span class="s1">&#39;[:upper:]&#39;</span>
<span class="go">Hola</span>
<span class="go">ADIOS</span>
<span class="gp">$ </span><span class="o">{</span><span class="w"> </span><span class="nb">echo</span><span class="w"> </span><span class="s2">&quot;Hola&quot;</span><span class="p">;</span><span class="w"> </span><span class="nb">echo</span><span class="w"> </span><span class="s2">&quot;Adios&quot;</span><span class="p">;</span><span class="w"> </span><span class="o">}</span><span class="w"> </span><span class="p">|</span><span class="w"> </span>tr<span class="w"> </span><span class="s1">&#39;[:lower:]&#39;</span><span class="w"> </span><span class="s1">&#39;[:upper:]&#39;</span>
<span class="go">HOLA</span>
<span class="go">ADIOS</span>
</pre></div>
</div>
<div class="admonition warning">
<p class="admonition-title">Advertencia</p>
<p>Usar parentesis tiene el efecto aparente de agrupar, pero en
realidad, lo que hace es crear una <em>subshell</em> y que todas las órdenes
encerradas en él, se ejecuten en la <em>subshell</em>.</p>
</div>
</section>
<section id="bonus-track-xargs">
<span id="index-1"></span><span id="xargs"></span><h2><span class="section-number">3.3.6. </span><em>Bonus track</em>: <strong class="command">xargs</strong><a class="headerlink" href="#bonus-track-xargs" title="Link to this heading">¶</a></h2>
<p><strong class="command">xargs</strong> no es propiamente un bucle, sino una orden externa que nos
permite emular el comportamiento de un bucle<a class="footnote-reference brackets" href="#id16" id="id7" role="doc-noteref"><span class="fn-bracket">[</span>7<span class="fn-bracket">]</span></a> y, bajo ciertas circunstancias,
tomar ventaja sobre el uso de <strong class="command">while</strong> o <strong class="command">for</strong>. Básicamente es
una orden que se alimenta de la entrada estándar y pasa los datos que recibe a
la orden que se haya escrito como argumento suyo. Por ejemplo:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$<span class="w"> </span>seq<span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="m">5</span><span class="w"> </span><span class="p">|</span><span class="w"> </span>xargs<span class="w"> </span><span class="nb">printf</span><span class="w"> </span><span class="s2">&quot;%05d\n&quot;</span>
<span class="m">00001</span>
<span class="m">00002</span>
<span class="m">00003</span>
<span class="m">00004</span>
<span class="m">00005</span>
</pre></div>
</div>
<p>que equivale a<a class="footnote-reference brackets" href="#id17" id="id8" role="doc-noteref"><span class="fn-bracket">[</span>8<span class="fn-bracket">]</span></a>:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="k">for</span><span class="w"> </span>x<span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="k">$(</span>seq<span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="m">5</span><span class="k">)</span><span class="p">;</span><span class="w"> </span><span class="k">do</span>
<span class="w">   </span><span class="nb">printf</span><span class="w"> </span><span class="s2">&quot;%05d\n&quot;</span><span class="w"> </span><span class="nv">$x</span>
<span class="k">done</span>
</pre></div>
</div>
<p>Hay que tener presente, no obstante, varias particularidades:</p>
<ol class="arabic">
<li><p><strong class="program">xargs</strong> considera separadores de argumentos el espacio, la
tabulación y el cambio de línea. Esta consideración es independiente del
valor de la <a class="reference internal" href="../02.conbas/07.avanzada/08.interpretaciones.html#sh-ifs"><span class="std std-ref">variable de ambiente IFS</span></a>.</p>
<p>Ahora bien, como en la <em>shell</em>, el escapado o las comillas simples o dobles
permiten construir argumentos que contienen estos caracteres separadores.
Por ejemplo:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$<span class="w"> </span><span class="nb">echo</span><span class="w"> </span><span class="s2">&quot;1 &#39;2 3&#39;&quot;</span><span class="w"> </span><span class="p">|</span><span class="w"> </span>xargs<span class="w"> </span><span class="nb">printf</span><span class="w"> </span><span class="s2">&quot;%05d\n&quot;</span>
<span class="m">00001</span>
printf:<span class="w"> </span>«2<span class="w"> </span><span class="m">3</span>»:<span class="w"> </span>valor<span class="w"> </span>no<span class="w"> </span>completamente<span class="w"> </span>convertido
<span class="m">00002</span>
</pre></div>
</div>
<p>que funciona mal, porque el segundo argumento que se pasa es el conjunto «<em>2
3</em>» y eso no es un número. Sin las comillas, <em>2</em> y <em>3</em> serían dos argumentos
distintos y así es como <strong class="program">xargs</strong> los habria pasado a
<a class="reference internal" href="02.io.html#printf"><span class="std std-ref">printf</span></a>.</p>
</li>
<li><p>En principio, no pasa todos los argumentos uno a uno, sino todos de golpe<a class="footnote-reference brackets" href="#id18" id="id9" role="doc-noteref"><span class="fn-bracket">[</span>9<span class="fn-bracket">]</span></a>.  En consecuencia, la orden del primer ejemplo es, en realidad,
equivalente a:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$<span class="w"> </span><span class="nb">printf</span><span class="w"> </span><span class="s2">&quot;%05d\n&quot;</span><span class="w"> </span><span class="k">$(</span>seq<span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="m">5</span><span class="k">)</span>
</pre></div>
</div>
<p>pero como tenemos la suerte de que <strong class="program">printf</strong> interpreta que debe
aplicar el mismo formato (<em>%05d\n</em>) a los cinco argumentos, el resultado de
la orden es el mismo que si se hubiera ejecutado cinco veces repetidamente lo
que nos ha permitido antes mentir al respecto. Para llegar a ver cómo puede
comportarse <strong class="command">xargs</strong> como un bucle, debemos avanzar un poco más.</p>
</li>
<li><p>En ausencia de indicación alguna (como es el caso) añade los datos recibidos
al final de la orden que se da como argumento.</p></li>
<li><p>Cuando <strong class="program">xargs</strong> propicia que la orden de la que se acompaña se ejecute
varias veces, se ejecuta secuencialmente (no en paralelo), que es
precisamente la forma en que se ejecutan las iteraciones de un bucle.</p></li>
</ol>
<p>Para alterar el <em>primer aspecto</em> existe la opción:</p>
<dl>
<dt><kbd class="kbd docutils literal notranslate">-0</kbd></dt><dd><p>que provoca que sólo se considere como carácter separador de argumentos el
caracter nulo. Por tanto:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$<span class="w"> </span><span class="nb">printf</span><span class="w"> </span><span class="s2">&quot;1\00002&quot;</span><span class="w"> </span><span class="p">|</span><span class="w"> </span>xargs<span class="w"> </span>-0<span class="w"> </span><span class="nb">printf</span><span class="w"> </span><span class="s2">&quot;%4.2f\n&quot;</span>
<span class="m">1</span>,00
<span class="m">2</span>,00
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p><a class="reference internal" href="../02.conbas/02.informacion/03.ficheros.html#find"><span class="std std-ref">find</span></a> tiene un argumento <cite>-print0</cite> para hacer que los
ficheros que encuentre se separen con un carácter nulo, en vez de con un
cambio de línea, lo cual lo hace muy apto para usarlo en conjunción con
<strong class="command">xargs</strong>.</p>
</div>
</dd>
</dl>
<p>El <em>segundo aspecto</em> lo podemos alterar con algunas opciones:</p>
<dl>
<dt><kbd class="kbd docutils literal notranslate">-L</kbd></dt><dd><p>Permite indicar cada cuántas líneas queremos que <strong class="command">xargs</strong> pare de
pasar de un tirón argumentos y continúe pasando los siguientes en una nueva
orden. Por ejemplo:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$<span class="w"> </span><span class="nb">echo</span><span class="w"> </span>-e<span class="w"> </span><span class="s2">&quot;1 2\n3 4&quot;</span><span class="w"> </span><span class="p">|</span><span class="w"> </span>xargs<span class="w"> </span><span class="nb">echo</span>
<span class="m">1</span><span class="w"> </span><span class="m">2</span><span class="w"> </span><span class="m">3</span><span class="w"> </span><span class="m">4</span>
</pre></div>
</div>
<p>hace que <strong class="command">xargs</strong> pasa los cuatro números a <strong class="command">echo</strong> por lo que
todos se escribirán en una misma línea. En cambio:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$<span class="w"> </span><span class="nb">echo</span><span class="w"> </span>-e<span class="w"> </span><span class="s2">&quot;1 2\n3 4&quot;</span><span class="w"> </span><span class="p">|</span><span class="w"> </span>xargs<span class="w"> </span>-L1<span class="w"> </span><span class="nb">echo</span>
<span class="m">1</span><span class="w"> </span><span class="m">2</span>
<span class="m">3</span><span class="w"> </span><span class="m">4</span>
</pre></div>
</div>
<p>pasa los dos primeros argumentos (números) a un primer <strong class="command">echo</strong>,
mientras que los dos segundos se los pasa a un <strong class="command">echo</strong> distinto. En
consecuencia, aparecen en dos líneas distintas.</p>
</dd>
<dt><kbd class="kbd docutils literal notranslate">-n</kbd></dt><dd><p>Permite indicar cuántos argumentos como máximo pasa <strong class="command">xargs</strong> a la
orden expresada en su argumento. En consecuencia:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$<span class="w"> </span><span class="nb">echo</span><span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="m">2</span><span class="w"> </span><span class="m">3</span><span class="w"> </span><span class="m">4</span><span class="w"> </span><span class="p">|</span><span class="w"> </span>xargs<span class="w"> </span>-n1<span class="w"> </span><span class="nb">echo</span>
<span class="m">1</span>
<span class="m">2</span>
<span class="m">3</span>
<span class="m">4</span>
</pre></div>
</div>
<p>escribe los dos argumentos en líneas distintas, ya que son imprimidos por
distinto <strong class="command">echo</strong>.</p>
</dd>
<dt><kbd class="kbd docutils literal notranslate">-r</kbd></dt><dd><p>No ejecuta la orden si no tiene nada que pasar. Un ejemplo bastante
estúpido es éste:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$<span class="w"> </span><span class="nb">echo</span><span class="w"> </span><span class="s2">&quot;&quot;</span><span class="w"> </span><span class="p">|</span><span class="w"> </span>xargs<span class="w"> </span><span class="nb">echo</span>

$<span class="w"> </span><span class="nb">echo</span><span class="w"> </span><span class="s2">&quot;&quot;</span><span class="w"> </span><span class="p">|</span><span class="w"> </span>xargs<span class="w"> </span>-r<span class="w"> </span><span class="nb">echo</span>
</pre></div>
</div>
<p>En el primer caso se imprime una línea en blanco, pues ejecuta el
<strong class="command">echo</strong> sin argumentos. En el segundo caso, al añadir la opción
<kbd class="kbd docutils literal notranslate">-r</kbd> jamás se llega a ejecutar el <strong class="command">echo</strong> derecho. Es bastamte
útil, por ejemplo, cuando pasamos líneas completas, pero queremos saltar las
líneas en blanco.</p>
</dd>
</dl>
<p>Para el <em>tercer aspecto</em> existe la opción:</p>
<dl>
<dt><kbd class="kbd docutils literal notranslate">-I</kbd></dt><dd><p>que permite indicar una cadena que se usará para indicar en qué punto de la
orden deben incluirse los datos suministrados. Por ejemplo:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$<span class="w"> </span><span class="nb">echo</span><span class="w"> </span><span class="s2">&quot;eth0 eth1&quot;</span><span class="w"> </span><span class="p">|</span><span class="w"> </span>xargs<span class="w"> </span>-n1<span class="w"> </span>-I<span class="w"> </span><span class="o">{}</span><span class="w"> </span>arp-scan<span class="w"> </span>--interface<span class="w"> </span><span class="o">{}</span><span class="w"> </span>--localnet
</pre></div>
</div>
<p>hará que el nombre de la interfaz aparezca como argumento de la opción
<kbd class="kbd docutils literal notranslate">-</kbd>-<kbd class="kbd docutils literal notranslate">interface</kbd> de <a class="reference external" href="https://linux.die.net/man/1/arp-scan">arp-scan</a>.</p>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>Tal como prescribe su página de manual, usar esta opción implica
<code class="docutils literal notranslate"><span class="pre">-L</span> <span class="pre">1</span></code></p>
</div>
</dd>
</dl>
<p>El <em>cuarto aspecto</em> también se puede modificar, de manera que las órdenes se
procesen en paralelo. De hecho, puede ser interesante si nos es indiferente el
orden de procesamiento y, además, cada una se demora un tiempo. Para ello existe
la opción:</p>
<dl>
<dt><kbd class="kbd docutils literal notranslate">-P</kbd></dt><dd><p>que permite indicar el número de órdenes que admitimos que se ejecuten en
paralelo (<strong>0</strong>, si queremos que se ejecuten todas en paralelo). En este
caso:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$<span class="w"> </span><span class="nb">echo</span><span class="w"> </span><span class="m">192</span>.168.1.<span class="o">{</span><span class="m">1</span>..254<span class="o">}</span><span class="w"> </span><span class="p">|</span><span class="w"> </span>xargs<span class="w"> </span>-n1<span class="w"> </span>-P20<span class="w"> </span>ping<span class="w"> </span>-q<span class="w"> </span>-W2<span class="w"> </span>-c1
</pre></div>
</div>
<p>Hacemos <strong class="command">ping</strong> a los 254 posibles dispositivos de la red, pero de 20
en 20, para ahorrar tiempo.</p>
</dd>
</dl>
<p>En conclusión, podemos usar <strong class="command">xargs</strong> para emular bucles pero teniendo en
cuenta lo siguiente:</p>
<ul class="simple">
<li><p>Sólo vale para ejecución de una orden, que, además, no puede ser una función
de la <em>shell</em>, ya que <strong class="command">xargs</strong> es un programa externo.</p></li>
<li><p>Usarlo implica la ejecución en <em>subshells</em> y la ejecución de <strong class="program">xargs</strong>
como intermediario.</p></li>
<li><p>En compensación, es una sintaxis más compacta y permite hacer fácilmente
ejecuciones en paralelo.</p></li>
</ul>
<p class="rubric">Notas al pie</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id10" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id1">1</a><span class="fn-bracket">]</span></span>
<p>En realidad, pueden escribirse varias ordenes, de manera que el resultado
evaluable será el que devuelva la última.</p>
</aside>
<aside class="footnote brackets" id="id11" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id2">2</a><span class="fn-bracket">]</span></span>
<p><strong class="program">bash</strong> tiene soporte limitado para
<abbr title="Extended Regular Expressions">ERE</abbr>.</p>
</aside>
<aside class="footnote brackets" id="id12" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id3">3</a><span class="fn-bracket">]</span></span>
<p>En honor a la verdad no son equivalentes. Para que lo fueran el patrón
debería ser <code class="code docutils literal notranslate"><span class="pre">b$USERb</span></code>. Sin embargo, usar estos caracteres dentro del
corchete da problemas en <strong class="command">bash</strong> por lo que nos veríamos obligados a
usar una variable intermedia:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="nv">pattern</span><span class="o">=</span><span class="se">\\</span>b<span class="nv">$USER</span><span class="se">\\</span>b
<span class="k">if</span><span class="w"> </span><span class="o">[[</span><span class="w"> </span><span class="nv">$HOME</span><span class="w"> </span><span class="o">=</span>~<span class="w"> </span><span class="nv">$pattern</span><span class="w"> </span><span class="o">]]</span><span class="p">;</span><span class="w"> </span><span class="k">then</span>
<span class="w">   </span><span class="nb">echo</span><span class="w"> </span><span class="s2">&quot;El directorio personal contiene el nombre de usuario&quot;</span>
<span class="k">fi</span>
</pre></div>
</div>
</aside>
<aside class="footnote brackets" id="id13" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id4">4</a><span class="fn-bracket">]</span></span>
<p><strong class="command">bash</strong> dispone de una variable para generar número aleatorios
entre 0 y 32767:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$<span class="w"> </span><span class="nb">echo</span><span class="w"> </span><span class="nv">$RANDOM</span>
<span class="m">28396</span>
$<span class="w"> </span><span class="nb">echo</span><span class="w"> </span><span class="nv">$RANDOM</span>
<span class="m">1919</span>
</pre></div>
</div>
<p>pero no existe en otras <em>shell</em> lo que hace la solución no portable. Para
evitarlo, hemos accedido al dispositivo de bytes pseudo-aleatorios
<code class="file docutils literal notranslate"><span class="pre">/dev/urandom</span></code>.</p>
</aside>
<aside class="footnote brackets" id="id14" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id5">5</a><span class="fn-bracket">]</span></span>
<p>Es decir, que el bucle es más bien del tipo <em>foreach</em>.</p>
</aside>
<aside class="footnote brackets" id="id15" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id6">6</a><span class="fn-bracket">]</span></span>
<p>Podríamos escribir este bucle coon la sintaxis anterior usando las
expansiones:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="k">for</span><span class="w"> </span>i<span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="o">{</span><span class="m">0</span>..9<span class="o">}</span><span class="p">;</span><span class="w"> </span><span class="k">do</span>
<span class="w">   </span><span class="nb">echo</span><span class="w"> </span><span class="nv">$i</span>
<span class="k">done</span>
</pre></div>
</div>
<p id="index-2"><span id="seq"></span>pero, de nuevo, esta forma sólo es compatible con <strong class="command">bash</strong>, porque
en el estándar no existe la expansión de llaves. Preservando la
compatibilidad, podría llevarse a cabo la acción, recurriendo a la orden
<strong class="command">seq</strong>:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="k">for</span><span class="w"> </span>i<span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="k">$(</span>seq<span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="m">10</span><span class="k">)</span><span class="p">;</span><span class="w"> </span><span class="k">do</span>
<span class="w">   </span><span class="nb">echo</span><span class="w"> </span><span class="nv">$i</span>
<span class="k">done</span>
</pre></div>
</div>
</aside>
<aside class="footnote brackets" id="id16" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id7">7</a><span class="fn-bracket">]</span></span>
<p>Para el programador familiarizado medianamente con la <a class="reference external" href="https://es.wikipedia.org/wiki/Programaci%C3%B3n_funcional">programación
funcional</a>,
podríamos considerar <strong class="command">xargs</strong> una suerte de función <a class="reference external" href="https://en.wikipedia.org/wiki/Map_(higher-order_function)">map</a>. Claro que,
siendo tan laxos, también podríamos considerar <a class="reference internal" href="../02.conbas/10.texto/02.busqueda.html#grep"><span class="std std-ref">grep</span></a> el
sucedáneo de la función <a class="reference external" href="https://en.wikipedia.org/wiki/Filter_(higher-order_function)">filter</a>.</p>
</aside>
<aside class="footnote brackets" id="id17" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id8">8</a><span class="fn-bracket">]</span></span>
<p>Mentira, no equivale a tal bucle, sino a lo que se explicará a
continuación, pero con el argumento apropiado sí podríamos hacer que
equivaliera a ese bucle de cinco iteraciones. Tras la explicación quedará
todo claro.</p>
</aside>
<aside class="footnote brackets" id="id18" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id9">9</a><span class="fn-bracket">]</span></span>
<p>Esta afirmación no es complemente exacta: hay un tamaño máximo, superado
el cual los restantes argumentos se reservan para una segunda ejecución de la
orden. Esta cantidad máxima de caracteres que se pueden pasar como argumentos
dependen del sistema. Para más información puede consultarse lo que se dice
de la opción <kbd class="kbd docutils literal notranslate">-s</kbd> en su página de manual.</p>
</aside>
</aside>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
  <div>
    <h3><a href="../index.html">Tabla de contenido</a></h3>
    <ul>
<li><a class="reference internal" href="#">3.3. Estructuras de control</a><ul>
<li><a class="reference internal" href="#if">3.3.1. <code class="docutils literal notranslate"><span class="pre">if</span></code></a></li>
<li><a class="reference internal" href="#case">3.3.2. <code class="docutils literal notranslate"><span class="pre">case</span></code></a></li>
<li><a class="reference internal" href="#while-until">3.3.3. <code class="docutils literal notranslate"><span class="pre">while</span></code>/<code class="docutils literal notranslate"><span class="pre">until</span></code></a></li>
<li><a class="reference internal" href="#for">3.3.4. <code class="docutils literal notranslate"><span class="pre">for</span></code></a></li>
<li><a class="reference internal" href="#bloque">3.3.5. Bloque</a></li>
<li><a class="reference internal" href="#bonus-track-xargs">3.3.6. <em>Bonus track</em>: <strong class="command">xargs</strong></a></li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>Tema anterior</h4>
    <p class="topless"><a href="02.io.html"
                          title="capítulo anterior"><span class="section-number">3.2. </span>Entrada/Salida</a></p>
  </div>
  <div>
    <h4>Próximo tema</h4>
    <p class="topless"><a href="04.datos.html"
                          title="próximo capítulo"><span class="section-number">3.4. </span>Datos complejos</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>Esta página</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/03.scripts/03.control.rst.txt"
            rel="nofollow">Mostrar el código</a></li>
    </ul>
   </div>
<search id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Búsqueda rápida</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Ir a" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="Related">
      <h3>Navegación</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="Índice General"
             >índice</a></li>
        <li class="right" >
          <a href="04.datos.html" title="3.4. Datos complejos"
             >siguiente</a> |</li>
        <li class="right" >
          <a href="02.io.html" title="3.2. Entrada/Salida"
             >anterior</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">documentación de Linuxnomicón - rolling</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="index.html" ><span class="section-number">3. </span>Programación de <em>scripts</em></a> &#187;</li>
        <li class="nav-item nav-item-this"><a href=""><span class="section-number">3.3. </span>Estructuras de control</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
    &#169; Copyright CC BY 4.0, 2016-2025, José Miguel Sánchez Alés.
      Creado usando <a href="https://www.sphinx-doc.org/">Sphinx</a> 8.2.3.
    </div>
  </body>
</html>