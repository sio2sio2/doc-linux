


<!DOCTYPE html>

<html lang="es">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>4.5.4. Autenticación de clave pública &#8212; documentación de Linuxnomicón - rolling</title>
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
    
    <script id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/translations.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <link rel="index" title="Índice" href="../../genindex.html" />
    <link rel="search" title="Búsqueda" href="../../search.html" />
    <link rel="next" title="4.5.5. Túneles" href="03.tuneles.html" />
    <link rel="prev" title="4.5.1. Instalación" href="01.basico.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navegación</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="Índice General"
             accesskey="I">índice</a></li>
        <li class="right" >
          <a href="03.tuneles.html" title="4.5.5. Túneles"
             accesskey="N">siguiente</a> |</li>
        <li class="right" >
          <a href="01.basico.html" title="4.5.1. Instalación"
             accesskey="P">anterior</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">documentación de Linuxnomicón - rolling</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" ><span class="section-number">4. </span>Gestión del servidor</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="index.html" accesskey="U"><span class="section-number">4.5. </span>Administración remota</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href=""><span class="section-number">4.5.4. </span>Autenticación de clave pública</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="autenticacion-de-clave-publica">
<span id="ssh-cert"></span><h1><span class="section-number">4.5.4. </span>Autenticación de clave pública<a class="headerlink" href="#autenticacion-de-clave-publica" title="Enlazar permanentemente con este título">¶</a></h1>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>Una perfecta compresión de este apartado exige tener unos
conocimineots mínimos sobre <a class="reference internal" href="../../09.apendice/01.cryto/index.html#crypto"><span class="std std-ref">Criptografía</span></a>.</p>
</div>
<p>Las técnicas de <a class="reference internal" href="../../09.apendice/01.cryto/02.algo.html#asimetrico"><span class="std std-ref">cifrado asimétrico</span></a> se usan en el protocolo
<abbr title="Security SHell">SSH</abbr> para la autenticación tanto de servidor como de cliente. En el caso del
segundo, también es posible la autenticación con contraseña, que es justamente
la que hemos visto hasta ahora.</p>
<p>Cuando se usa autenticación con clave pública hay dos posibilidades:</p>
<ul class="simple">
<li><p>Una solución basada exclusivamente en el uso de claves asimétricas</p></li>
<li><p>Otra que, sobre la base de la anterior, genera <a class="reference internal" href="../../09.apendice/01.cryto/03.aplicaciones/01.certdig.html#cert-digital"><span class="std std-ref">certificados digitales</span></a> a partir de las claves públicas utilizando una
<a class="reference internal" href="../../09.apendice/01.cryto/03.aplicaciones/01.certdig.html#pki"><span class="std std-ref">infraestructura PKI</span></a>.</p></li>
</ul>
<p>Como para analizar la segunda solución es conveniente conocer la primera,
analizaremos la primera y, sobre ella, expondremos la segunda.</p>
<div class="section" id="claves">
<span id="ssh-auth-keys"></span><h2><span class="section-number">4.5.4.1. </span>Claves<a class="headerlink" href="#claves" title="Enlazar permanentemente con este título">¶</a></h2>
<p>Analicemos por separado cómo se identifica el servidor ante el cliente y cómo lo
hace el cliente ante el servidor.</p>
<div class="section" id="identificacion-del-servidor">
<h3><span class="section-number">4.5.4.1.1. </span>Identificación del servidor<a class="headerlink" href="#identificacion-del-servidor" title="Enlazar permanentemente con este título">¶</a></h3>
<p>Ya se ha mencionado anteriormente que para evitar ataques <em>man-in-the-middle</em>
mediante la suplantación de la identidad del servidor, éste envía al cliente su
clave pública. En la primera conexión aceptar la clave pública de un servidor es
un acto de fe, a menos que se haya obtenido esa clave pública de algún modo
seguro. Sea como sea, el cliente, por su parte, puede almacenar las claves
públicas de todos los servidores a los que se conecta, de modo que si se produce
una segunda conexión compara la clave pública que le vuelve a enviar el servidor
con la que previamente tiene almacenada. En realidad lo que compara es el
<em>fingerprint</em> o huella dactilar de la clave pública, una sucesión de pares de
números hexadecimales que se obtiene a partir de ella: si coinciden, el cliente
se fiará de que el servidor es quien dice ser; si no coinciden, entonces
sospechará que hay una suplantación y, o bien avisará (caso de
<strong class="program">putty</strong>), o bien, se negará en rotundo a conectar hasta que no se
elimine del cliente la clave pública antigua (caso del cliente de <em>openssh</em>).</p>
<p>Del párrafo anterior, hay dos ideas que es necesario remarcar y que se
desglosarán bajo los siguientes epígrafes:</p>
<ol class="arabic simple">
<li><p>El servidor tiene una pareja de claves pública/privada que le sirven para
identificarse ante el cliente (también sirven para cifrar la clave simétrica,
pero esto importa poco a los efectos de esta discusión).</p></li>
<li><p>El cliente almacena las claves públicas de los servidores para comprobar las
identidades de éstos cuando intenta una conexión.</p></li>
</ol>
<div class="section" id="claves-en-el-servidor">
<span id="ssh-server-keys"></span><h4><span class="section-number">4.5.4.1.1.1. </span>Claves en el servidor<a class="headerlink" href="#claves-en-el-servidor" title="Enlazar permanentemente con este título">¶</a></h4>
<p>Se ha afirmado que el servidor tiene una pareja de claves. Esto no es del todo
cierto, en realidad, las versiones modernas del servidor <em>openssh</em> tiene varias
parejas de claves, cada una de cuales usa un algoritmo diferente de cifrado<a class="footnote-reference brackets" href="#id14" id="id1">1</a>. Estas claves está almacenadas en el directorio <code class="file docutils literal notranslate"><span class="pre">/etc/ssh</span></code>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> ls -1 /etc/ssh/ssh_host_*
<span class="go">/etc/ssh/ssh_host_ecdsa_key</span>
<span class="go">/etc/ssh/ssh_host_ecdsa_key.pub</span>
<span class="go">/etc/ssh/ssh_host_ed25519_key</span>
<span class="go">/etc/ssh/ssh_host_ed25519_key.pub</span>
<span class="go">/etc/ssh/ssh_host_rsa_key</span>
<span class="go">/etc/ssh/ssh_host_rsa_key.pub</span>
</pre></div>
</div>
<p>Los ficheros de extensión <em>.pub</em> son los que almacenan las claves públicas.
Paralelamente, en el fichero de configuración debe indicarse que estas serán las
claves de identificación<a class="footnote-reference brackets" href="#id15" id="id2">2</a>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> grep -w HostKey /etc/ssh/sshd_config
<span class="gp">#</span>HostKey /etc/ssh/ssh_host_rsa_key
<span class="gp">#</span>HostKey /etc/ssh/ssh_host_ecdsa_key
<span class="gp">#</span>HostKey /etc/ssh/ssh_host_ed25519_key
</pre></div>
</div>
<p>Cuál de estas parejas se use para la validación depende del cliente: él le
indicará al servidor por orden que algoritmos prefiere y el servidor usará el
primero que tenga disponible. Se ha dicho también que en realidad lo que se
compara es el fingerkey obtenido a partir de la clave pública. De hecho, la
primera vez que se conecta el cliente al servidor, se encontrará con esto:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">pepe@cliente$</span> ssh usuario@servidor
<span class="go">The authenticity of host &#39;servidor (192.168.1.11)&#39; can&#39;t be established.</span>
<span class="go">ECDSA key fingerprint is SHA256:vOef4Mo/0obxdDeS9iNIZ5+kQpMB+krMf9XTedRMUbE.</span>
<span class="go">Are you sure you want to continue connecting (yes/no)</span>
</pre></div>
</div>
<span class="target" id="ssh-keygen"></span><p id="index-0">Aceptarlo implicará almacenar en el cliente tal <em>fingerprint</em>. Tal huella
digital es posible obtenerla manualmente gracias a <strong class="command">ssh-keygen</strong>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> ssh-keygen -l -f /etc/ssh/ssh_host_ecdsa_key.pub
<span class="go">256 SHA256:vOef4Mo/0obxdDeS9iNIZ5+kQpMB+krMf9XTedRMUbE root@servidor (ECDSA)</span>
</pre></div>
</div>
<p>que obviamente coincide con el <em>fingerprint</em> que observó <em>pepe</em> desde el
cliente. El primer número (<strong>256</strong>) indica la longitud de la clave.</p>
<div class="admonition warning">
<p class="admonition-title">Advertencia</p>
<p>Las claves identifican al servidor, así que es mejor no cambiarlas
a menos que las sospechemos comprometidas. Si es absolutamente necesario,
pueden redefinirse así:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> ssh-keygen -t ecdsa -f /etc/ssh/ssh_host_ecdsa_key -N <span class="s2">&quot;&quot;</span>
</pre></div>
</div>
<p>que crea una clave <abbr title="Elliptic Curve Digital Signature Algorithm">ECDSA</abbr> en el fichero apropiado sin contraseña (esto
último necesario, porque el servidor debe ser capaz de usarlas sin pedir
la contraseña a nadie). La orden debería repetirse para todos los algoritmos,
así que podríamos hacer:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> <span class="k">for</span> algo in rsa ecdsa ed25519<span class="p">;</span> <span class="k">do</span> ssh-keygen -t <span class="nv">$algo</span> -f /etc/ssh/ssh_host_<span class="si">${</span><span class="nv">algo</span><span class="si">}</span>_key -N <span class="s2">&quot;&quot;</span><span class="p">;</span> <span class="k">done</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="claves-en-el-cliente">
<h4><span class="section-number">4.5.4.1.1.2. </span>Claves en el cliente<a class="headerlink" href="#claves-en-el-cliente" title="Enlazar permanentemente con este título">¶</a></h4>
<p>Como se ha adelantado, los clientes almacenan los <em>fingerprints</em> de las claves
públicas de los servidores a los que se han conectado previamente dentro del
fichero <code class="file docutils literal notranslate"><span class="pre">~/.ssh/known_hosts</span></code>. Ahora bien:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">pepe@cliente$</span> ssh-keygen -l -f ~/.ssh/known_hosts
<span class="go">256 SHA256:vOef4Mo/0obxdDeS9iNIZ5+kQpMB+krMf9XTedRMUbE |1|4WnmUKMOBGnrOtOHytjLzB8cKFE=|q7chrsGIIRUBS2S1GlpzA0vDbjo= (ECDSA)</span>
<span class="go">256 SHA256:vOef4Mo/0obxdDeS9iNIZ5+kQpMB+krMf9XTedRMUbE |1|l4/bYn6a2ImKN27oCuwD3wb9M8o=|b5i6kcIRct1K1U9EBVH4PgfoJJU= (ECDSA)</span>
</pre></div>
</div>
<p>si comprobamos los <em>fingerprints</em> almacenados no seremos capaces de saber a qué
servidor corresponde tal <em>fingerprint</em>. Esto se hace así por privacidad, esto
es, por evitar que otros usuarios sean capaces de conocer a qué servidores nos
conectamos<a class="footnote-reference brackets" href="#id16" id="id3">3</a>. El comportamiento puede modificarse cambiando el valor de la
directiva <em>HashKnownHosts</em> en la configuración del cliente. Por tanto, si
añadimos como directiva global a <code class="file docutils literal notranslate"><span class="pre">~/.ssh/config</span></code>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">HashKnownHosts no</span>
</pre></div>
</div>
<p>se almacenarán las direcciones en claro:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">pepe@cliente$</span> rm -f ~/.ssh/known_hosts
<span class="gp">pepe@cliente$</span> ssh usuario@servidor

<span class="go">[...]</span>

<span class="gp">pepe@cliente$</span> ssh-keygen -l -f ~/.ssh/known_hosts
<span class="go">256 SHA256:vOef4Mo/0obxdDeS9iNIZ5+kQpMB+krMf9XTedRMUbE servidor,192.168.1.11 (ECDSA)</span>
</pre></div>
</div>
<p>En cualquier caso, aunque estén ofuscados los nombres, puede buscarse si hay ya alguna entrada para un servidor:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> ssh-keygen -F servdior
</pre></div>
</div>
<p>A partir de ahora, cada ve que se conecte a <em>servidor</em>, se confirmará que el
<em>firgenprint</em> de la clave proporcionada por este coincide con la almacenada. Si
no es así, ocurrirá esto:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">pepe@cliente$</span> ssh usuario@servidor
<span class="go">@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@</span>
<span class="go">@    WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!     @</span>
<span class="go">@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@</span>
<span class="go">IT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!</span>
<span class="go">Someone could be eavesdropping on you right now (man-in-the-middle attack)!</span>
<span class="go">It is also possible that a host key has just been changed.</span>
<span class="go">The fingerprint for the ECDSA key sent by the remote host is</span>
<span class="go">SHA256:IWvZBm4stPCufdUlUdUtKGkk7P/nNhDsf1R5XDUANtM.</span>
<span class="go">Please contact your system administrator.</span>
<span class="go">Add correct host key in /home/josem/.ssh/known_hosts to get rid of this message.</span>
<span class="go">Offending ECDSA key in /home/josem/.ssh/known_hosts:1</span>
<span class="go">  remove with:</span>
<span class="go">  ssh-keygen -f &quot;/home/josem/.ssh/known_hosts&quot; -R &quot;servidor&quot;</span>
<span class="go">ECDSA host key for servidor has changed and you have requested strict checking.</span>
<span class="go">Host key verification failed.</span>
</pre></div>
</div>
<p>Que no coincidan las claves puede suponer una suplantación de identidad… o que
las claves cambiaron en el servidor por alguna razón. Si la razón es esta
segunda, la solución está incluida en el mensaje de advertenca, y es borrar el
<em>fingerprint</em> asociado al servidor:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">pepe@cliente$</span> ssh-keygen -R servidor
<span class="gp">#</span> Host servidor found: line <span class="m">1</span>
<span class="go">/home/josem/.ssh/known_hosts updated.</span>
<span class="go">Original contents retained as /home/josem/.ssh/known_hosts.old</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p><strong class="program">Putty</strong> también almacena el <em>fingerprint</em> del servidor, pero
a diferencia de éste, no rechaza la conexión cuando detecta un cambio en la
clave, sino que advierte del peligro de seguridad y permite aceptar (o no) la
nueva clave.</p>
</div>
</div>
</div>
<div class="section" id="ssh-auth-claves">
<span id="identificacion-del-cliente"></span><h3><span class="section-number">4.5.4.1.2. </span>Identificación del cliente<a class="headerlink" href="#ssh-auth-claves" title="Enlazar permanentemente con este título">¶</a></h3>
<p>Obviamente, nos referimos a su identificación mediante certificado y no
mediante contraseña. Por supuesto, la identificación exige primero la creación
de las claves y que el servidor acepte este tipo de identificación:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> grep -w PubkeyAuthentication /etc/ssh/sshd_config
<span class="gp">#</span>PubkeyAuthentication yes
</pre></div>
</div>
<div class="section" id="cliente-openssh">
<h4><span class="section-number">4.5.4.1.2.1. </span>Cliente <em>openssh</em><a class="headerlink" href="#cliente-openssh" title="Enlazar permanentemente con este título">¶</a></h4>
<p>En este caso, la generación es sencilla. La orden:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> ssh-keygen -t ecdsa -C <span class="s2">&quot;Comentario alusivo a la clave&quot;</span>
</pre></div>
</div>
<p>generará una clave de tipo <abbr title="Elliptic Curve Digital Signature Algorithm">ECDSA</abbr> y, como fichero, se escogerá el
predeterminado para este tipo de clave (<code class="file docutils literal notranslate"><span class="pre">~/.ssh/id_ecdsa</span></code> y
<code class="file docutils literal notranslate"><span class="pre">~/.ssh/id_ecdsa.pub</span></code>, para la clave pública). Si no se altera la
configuración, en el momento en que intentemos conectar a cualquier servidor se
intentará usar esta clave para la autenticación. Tras generar la pareja de
claves se nos pide una <em>clave de paso</em>, que no es más que una contraseña
necesaria para poder usar la clave privada. Fijarla obliga a escribir tal
contraseña antes de usarla y nos asegura ante un hurto de las claves.</p>
<span class="target" id="ssh-copy-id"></span><p id="index-1">Es obvio, que no basta con generar la clave en el cliente: en el servidor debe
alojarse la clave pública para que, cuando se produzca la comunicación, pueda
asegurarse que quien se conecta desde el cliente es el propietario de la clave
privada correspondiente. Para ello, puede hacerse:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> ssh-copy-id usuario@servidor
</pre></div>
</div>
<p>que subirá la clave<a class="footnote-reference brackets" href="#id17" id="id4">4</a> al fichero del servidor que almacena las claves
públicas (<code class="file docutils literal notranslate"><span class="pre">~./ssh/authorized_keys</span></code>)<a class="footnote-reference brackets" href="#id18" id="id5">5</a>. A partir de ahora, al intentar
ingresar en el servidor, se usará en primer término la identificación mediante
el certificado y se nos pedirá la clave de paso (ya que hay que usar la clave
privada) o nada, si no se introdujo contraseña al generar las claves.</p>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>No obstante, lo anterior, es posible usar claves almacenadas en otros
ficheros. Por ejemplo:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> ssh-keygen -t ecdsa -f .ssh/id_servidor -C <span class="s2">&quot;Clave para &#39;servidor&#39;&quot;</span>
<span class="gp">$</span> ssh-copy-id -i .ssh/id_servidor usuario@servidor
<span class="gp">$</span> ssh -i .ssh/id_servidor usuario@servidor
</pre></div>
</div>
<p>e incluso indicar cuál es el nombre de la clave en la configuración:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">Host svm</span>
<span class="go">   Hostname       servidor</span>
<span class="go">   User           usuario</span>
<span class="go">   IdentityFile   ~/.ssh/id_%h</span>
</pre></div>
</div>
<p>de manera que cuando conectemos a <em>servidor</em> siempre usemos
<code class="file docutils literal notranslate"><span class="pre">~/.ssh/id_servidor</span></code><a class="footnote-reference brackets" href="#id19" id="id6">6</a>.</p>
</div>
</div>
<div class="section" id="cliente-putty">
<h4><span class="section-number">4.5.4.1.2.2. </span>Cliente <strong class="program">putty</strong><a class="headerlink" href="#cliente-putty" title="Enlazar permanentemente con este título">¶</a></h4>
<p>Debemos efectuar las mismas acciones que en el caso anterior. El equivalente a
<strong class="command">ssh-keygen</strong> en la suite de <strong class="program">putty</strong> es <strong class="program">puttygen</strong>:</p>
<img alt="Captura de puttygen" src="04.servidor/10.ssh/files/putty_gen.jpg" />
<div class="admonition-todo admonition" id="id7">
<p class="admonition-title">Por hacer</p>
<p>HACER la captura…</p>
</div>
<p>Al generar el par de claves (<code class="docutils literal notranslate"><span class="pre">Generate</span></code>) el programa quedará esperando que
movamos aletariamente el ratón por encima de la superficie vacía a fin de lograr
mayor aletoriedad. Al acabar la generación, se podrá escribir un comentario y la
clave de paso o contraseña de la propia clave. Podemos entonces guardar la clave
privada (<code class="docutils literal notranslate"><span class="pre">Save</span> <span class="pre">private</span> <span class="pre">key</span></code>), pero la clave pública no es de poca ayuda, puesto
que no tiene el mismo formato que las claves que genera <em>openssh</em>. Sin embargo,
la clave pública, tal y como la exige <em>openssh</em>, se muestra en la propia
pantalla con lo que se puede copiar y pegar en un fichero.</p>
<p>Dado que ahora no disponemos de <strong class="command">ssh-id-copy</strong>, hay que subir manualmente
la clave pública al servidor para incluirla en en <code class="file docutils literal notranslate"><span class="pre">~/.ssh/authorized_keys</span></code>.
Quizás lo más sencillo es abrir una sesión de <strong class="program">putty</strong> y copiar
contenido de la clave pública directamente sobre el fichero anterior, en vez de
en un fichero cualquiera del cliente <em>windows</em>.</p>
</div>
</div>
</div>
<div class="section" id="certificados">
<span id="ssh-auth-certs"></span><h2><span class="section-number">4.5.4.2. </span>Certificados<a class="headerlink" href="#certificados" title="Enlazar permanentemente con este título">¶</a></h2>
<p>Autenticar con <a class="reference internal" href="../../09.apendice/01.cryto/03.aplicaciones/01.certdig.html#cert-digital"><span class="std std-ref">certificados digitales</span></a> en vez de con
simples claves presenta algunas ventajas<a class="footnote-reference brackets" href="#id20" id="id8">7</a>:</p>
<ul class="simple">
<li><p>Un cambio de claves en el servidor, si la identificación de este ante el
cliente es con meras claves, provoca un aviso de suplantación, por cuanto el
cliente había almacenado ya su anterior clave. Es tan frecuente que de forma
legítima se presente el aviso que se corre el riesgo de que el cliente no
le dé ninguna importancia de seguridad. Un certificado de servidor lo evita.</p></li>
<li><p>En la autenticación de clientes, un mismo cliente tendrá que subir a todos los
servidores la clave pública con la que pretende identificarse.</p></li>
<li><p>Los certificados pueden expedirse con un periodo de tiempo limitado.</p></li>
<li><p>Los certificados pueden especificar qué extras se le permiten o ventan al
propietario (p.e. podríamos estar interesados en que el cliente pudiera
acceder al servidor, pero que en ningún caso pudiera usarlo para tunelizar<a class="footnote-reference brackets" href="#id21" id="id9">8</a>).</p></li>
</ul>
<p>Para crear <a class="reference internal" href="../../09.apendice/01.cryto/03.aplicaciones/01.certdig.html#cert-digital"><span class="std std-ref">certificados</span></a> podemos partir de las claves
públicas que hemos visto en el epígrafe anterior. Estos certificados <abbr title="Security SHell">SSH</abbr> no
son <a class="reference internal" href="../../09.apendice/01.cryto/03.aplicaciones/01.certdig.html#x-509"><span class="std std-ref">certificados X.509</span></a>, como los usados en <abbr title="Secure Sockets Layer">SSL</abbr>, sino propios
de <abbr title="Security SHell">SSH</abbr>, y se generan utilizando nuestro ya conocido <a class="reference internal" href="#ssh-keygen"><span class="std std-ref">ssh-keygen</span></a>.</p>
<p>La idea es crear una <abbr title="Certification Authority">CA</abbr> que firme las claves públicas de clientes y servidores
con objeto de crear los certificados:</p>
<img alt="../../_images/CA-SSH.png" src="../../_images/CA-SSH.png" />
<p>Tal como se señala en el esquema se pueden tener dos parejas de claves:
<em>CA_host</em> para firmar certificados de servidor y <em>CA_user</em> para firmar
certificados de cliente:</p>
<ul class="simple">
<li><p>Cualquier servidor remitirá su clave pública a la <abbr title="Certification Authority">CA</abbr> para obtener el
certificado correspondiente (resultado de firmar la clave con <em>CA_host</em>) y,
además, necesitará una copia de la clave pública <em>CA_user</em>, si quiere poder
autenticar clientes mediante certificado.</p></li>
<li><p>Cualquier cluiente remitirá su clave pública a la <abbr title="Certification Authority">CA</abbr> para obtener el
certificado correspondiente (resultado de firmar la clave con <em>CA_user</em>) y,
además, necesitará una copia de la clave pública <em>CA_host</em>, si quiere poder
identificar clientes mediante certificado.</p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>Por supuesto, las dos parejas de claves pueden ser la misma.</p>
</div>
<p>A partir de ahora trabajaremos sobre tres máquinas:</p>
<ul class="simple">
<li><p>La que hace de <abbr title="Certification Authority">CA</abbr> que es aquella que contiene las claves de <abbr title="Certification Authority">CA</abbr> y que
se encarga de firmar los certificados de las demás</p></li>
<li><p>Una máquina que hace el papel de servidor <abbr title="Security SHell">SSH</abbr>.</p></li>
<li><p>Una máquina que hace el papel de cliente <abbr title="Security SHell">SSH</abbr>.</p></li>
</ul>
<p>Para indicar en qué máquina estamos actuando al ejecutar una orden, utilizaremos
el <em>prompt</em>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">root@ca:~#</span>
<span class="gp">root@servidor:~#</span>
<span class="gp">pepe@cliente:~$</span>
</pre></div>
</div>
<div class="section" id="id10">
<h3><span class="section-number">4.5.4.2.1. </span>Identificación del servidor<a class="headerlink" href="#id10" title="Enlazar permanentemente con este título">¶</a></h3>
<p>Partimos de <a class="reference internal" href="#ssh-server-keys"><span class="std std-ref">tener ya las claves del servidor</span></a> y nuestra
intención es que los clientes sean capaces de identificar al servidor mediante
certificado. Debemos antes de nada generar las claves para firmar certificados
de servidor:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">root@ca:~#</span> ssh-keygen -t ecdsa -f /etc/ssh/ca_host -C <span class="s2">&quot;Clave de CA para servidores&quot;</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>Usamos claves de tipo ecdsa para evitar problemas con versiones de
Open<abbr title="Security SHell">SSH</abbr> por encima de la 8.1. Para más información, consulte <a class="reference external" href="https://ibug.io/blog/2020/04/ssh-8.2-rsa-ca/">esta
entrada de iBug</a>.</p>
</div>
<p>Con esta pareja de claves operativas, debemos pasar las claves públicas del
servidor a la máquina <em>ca</em> para que puedan ser firmadas (esto es, generado el
certificado):</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">root@servidor:~$</span> scp /etc/ssh/ssh_host_*key.pub ca:/tmp
</pre></div>
</div>
<p>y una vez en ella, firmarlas para crear el certificado:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">root@ca:~#</span> ssh-keygen -h -s /etc/ssh/ca_host -I s_hostID -n example.net,www.example.net /tmp/ssh_host_*key.pub
<span class="gp">root@ca:~#</span> scp /tmp/ssh_host_*-cert.pub servidor:/etc/ssh
</pre></div>
</div>
<p>La orden genera certificados de servidor (gracias a <kbd class="kbd docutils literal notranslate"><kbd class="kbd docutils literal notranslate"></kbd>-<kbd class="kbd docutils literal notranslate">h</kbd></kbd>), firmados
(<kbd class="kbd docutils literal notranslate"><kbd class="kbd docutils literal notranslate"></kbd>-<kbd class="kbd docutils literal notranslate">s</kbd></kbd>) con <code class="file docutils literal notranslate"><span class="pre">ca_host</span></code>, con un determinado identificador (<kbd class="kbd docutils literal notranslate"><kbd class="kbd docutils literal notranslate"></kbd>-<kbd class="kbd docutils literal notranslate">I</kbd></kbd>) y
que son válidos para una máquina llamada <em>example.net</em> o <em>www.example.net</em>.
Podríamos haber definido una validez determinada con <kbd class="kbd docutils literal notranslate"><kbd class="kbd docutils literal notranslate"></kbd>-<kbd class="kbd docutils literal notranslate">V</kbd></kbd>, pero por ser
estos certificados de servidor los haremos eternos.</p>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>Los comodines no funcionan para definir nombres de servidor válidos.
Por tanto, algo como <kbd class="kbd docutils literal notranslate"><kbd class="kbd docutils literal notranslate"></kbd>-<kbd class="kbd docutils literal notranslate">n</kbd> <kbd class="kbd docutils literal notranslate">&quot;*.example,example.net&quot;</kbd></kbd> no valdrá para que
el certificado sea aplicable a la máquina <em>www.example.net</em>.</p>
</div>
<p>Una vez que los certificados se remiten al servidor y se almacenan en
<kbd class="kbd docutils literal notranslate">/etc/ssh</kbd> debemos modificar la configuración del servidor para que los
use:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">root@servidor:~#</span> <span class="nb">printf</span> <span class="s2">&quot;HostCertificate %s\n&quot;</span> /etc/ssh/ssh_host_*-cert.pub &gt;&gt; /etc/ssh/sshd_config
<span class="gp">root@servidor:~#</span> invoke-rc.d ssh reload
</pre></div>
</div>
<p>Y con esto, hemos completado la configuración en él. Ahora debemos lograr que
los clientes confien en cualquier certificado firmado por nuestra <abbr title="Certification Authority">CA</abbr>. Para ello debemos copiar la clave pública de la <abbr title="Certification Authority">CA</abbr> en el cliente:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">root@ca:~#</span> scp /etc/ssh/CA_host.pub cliente:/tmp
</pre></div>
</div>
<p>con objeto de añadirla a <code class="file docutils literal notranslate"><span class="pre">~/.ssh/known_hosts</span></code> (o <code class="file docutils literal notranslate"><span class="pre">/etc/ssh/ssh_known_hosts</span></code> si se quiere que afecte a todos los usuarios):</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">cliente# echo &quot;@cert-authority *.example.net,example.net,*.example.com,example.com $(cat /tmp/CA_host.pub)&quot; &gt;&gt; /etc/ssh/ssh_known_hosts</span>
</pre></div>
</div>
<p>Obsérvese que es necesario indicar <kbd class="kbd docutils literal notranslate"><kbd class="kbd docutils literal notranslate">&#64;cert</kbd>-<kbd class="kbd docutils literal notranslate">authority</kbd></kbd> para expresar que la clave es una clave de <abbr title="Certification Authority">CA</abbr> que tiene validez para todas las máquinas cuyo nombre se especifica a continuación (pueden añadirse también direcciones <abbr title="Internet Protocol">IP</abbr>). Hecho esto, se aceptará la conexión con el servidor, aunque nunca antes la hubiéramos hecho, y no registrará la clave pública del servidor en el archivo <code class="file docutils literal notranslate"><span class="pre">~/.ssh/known_hosts</span></code>.</p>
</div>
<div class="section" id="id11">
<h3><span class="section-number">4.5.4.2.2. </span>Identificación del cliente<a class="headerlink" href="#id11" title="Enlazar permanentemente con este título">¶</a></h3>
<p>Para que el cliente pueda autenticarse en el servidor, también pueden utilizarse certificados. Generemos primero unas claves de <abbr title="Certification Authority">CA</abbr> para firmar certificados de cliente:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">root@ca:~#</span> ssh-keygen -t ecdsa -f /etc/ssh/ca_user -C <span class="s2">&quot;Clave de CA para clientes&quot;</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>Podríamos reaprovechar la pareja de claves anteriores, pero por pulcritud usaremos dos claves distintas.</p>
</div>
<p>Debemos pasar la clave al servidor para que este acepte clientes que tengan su certificado firmado con ella. Esto se logra añadiendo una línea a la configuración:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">root@servidor:~#</span> scp ca:/etc/ssh/ca_user.pub /etc/ssh
<span class="gp">root@servidor:~#</span> <span class="nb">echo</span> <span class="s2">&quot;TrustedUserCAKeys /etc/ssh/ca_user.pub&quot;</span> &gt;&gt; /etc/ssh/sshd_config
<span class="gp">root@servidor:~#</span> invoke-rc.d ssh reload
</pre></div>
</div>
<p>Y ahora, un usuario que desee autenticarse en tal servidor, deberá generar un par de claves para sí y pasarla a la <abbr title="Certification Authority">CA</abbr> para que se las firme:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">pepe@cliente:~$</span> ssh-keygen -C <span class="s2">&quot;Clave de pepe&quot;</span>
<span class="gp">pepe@cliente:~#</span> scp ~/.ssh/id_rsa.pub ca:/tmp
</pre></div>
</div>
<p>La <abbr title="Certification Authority">CA</abbr> firmará esas claves:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">root@ca:~#</span> ssh-keygen -s /etc/ssh/ca_user -I u_pepeID -n pepe,root -V +32w /tmp/id_rsa.pub
</pre></div>
</div>
<p>sin indicar la opción <kbd class="kbd docutils literal notranslate"><kbd class="kbd docutils literal notranslate"></kbd>-<kbd class="kbd docutils literal notranslate">h</kbd></kbd>, porque esta es una clave de cliente, indicando con <kbd class="kbd docutils literal notranslate"><kbd class="kbd docutils literal notranslate"></kbd>-<kbd class="kbd docutils literal notranslate">n</kbd></kbd> que la clave es válida para el usuario del servidor «pepe» y el administrador del mismo, y que el certificado tiene una validez de 32 semanas a partir del momento en el que se firma:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">root@ca:~#</span> ssh-keygen -Lf /tmp/id_rsa.pub
<span class="go">id_rsa-cert.pub:</span>
<span class="go">        Type: ssh-rsa-cert-v01@openssh.com user certificate</span>
<span class="go">        Public key: RSA-CERT SHA256:eFEoGIJgDNFgiQycGvKXWc1FbJQOQljc90gjzRgI4uA</span>
<span class="go">        Signing CA: ECDSA SHA256:ibktBc6yzycepNgHWYpWWo4V7l0QmKn+q73nf8/9vXM</span>
<span class="go">        Key ID: &quot;u_pepeID&quot;</span>
<span class="go">        Serial: 0</span>
<span class="go">        Valid: from 2021-04-08T08:43:00 to 2021-11-18T08:44:34</span>
<span class="go">        Principals:</span>
<span class="go">                pepe</span>
<span class="go">                root</span>
<span class="go">        Critical Options: (none)</span>
<span class="go">        Extensions:</span>
<span class="go">                permit-X11-forwarding</span>
<span class="go">                permit-agent-forwarding</span>
<span class="go">                permit-port-forwarding</span>
<span class="go">                permit-pty</span>
<span class="go">                permit-user-rc</span>
</pre></div>
</div>
<p>Obsérvese que el certificado, además de limitar los usuarios con los que puede
autenticarse el propietario, también permite definir de qué <em>extras</em> puede
hacer uso (sección <kbd class="kbd docutils literal notranslate">Extensions</kbd>). Los que apareen listados son los
habilitados por defecto. Sin embargo, podemos modificarlos mediante la opción
<kbd class="kbd docutils literal notranslate"><kbd class="kbd docutils literal notranslate"></kbd>-<kbd class="kbd docutils literal notranslate">O</kbd></kbd>. Por ejemplo, <code class="code docutils literal notranslate"><span class="pre">-O</span> <span class="pre">no-X11-forwarding</span> <span class="pre">-O</span> <span class="pre">mo-port-forwarding</span></code>
impediría al usuario identificado con el certificado mostrar en el escritorio
local la ejecución aplicaciones gráficas en el servidor y <a class="reference internal" href="03.tuneles.html#tunel-ssh"><span class="std std-ref">hacer túneles</span></a>.</p>
<p>Por último, el usuario en el cliente deberá obtener el certificado y guardarlo dentro de <code class="file docutils literal notranslate"><span class="pre">~/.ssh</span></code>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">cliente# scp ca:/tmp/id_rsa-cert.pub ~/.ssh</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="openssh-y-openssl">
<span id="openssh-openssl"></span><h2><span class="section-number">4.5.4.3. </span>Open<abbr title="Security SHell">SSH</abbr> y Open<abbr title="Secure Sockets Layer">SSL</abbr><a class="headerlink" href="#openssh-y-openssl" title="Enlazar permanentemente con este título">¶</a></h2>
<p>Dado que ambas aplicaciones usan <a class="reference internal" href="../../09.apendice/01.cryto/02.algo.html#asimetrico"><span class="std std-ref">cifrado asimétrico</span></a> y
algoritmos comunes, es posible hacer conversiones entre las claves generadas con
ellas. En principio:</p>
<ul>
<li><p>Pueden hacerse conversiones para claves <abbr title="Rivest, Shamir y Adleman">RSA</abbr> y <abbr title="Elliptic Curve Digital Signature Algorithm">ECDSA</abbr>. Las claves <abbr title="EDwards-curve Curve Digital Signature Algorithm">EdDSA</abbr> no
tienen soporte en <a class="reference internal" href="../../09.apendice/01.cryto/02.algo.html#openssl"><span class="std std-ref">OpenSSL</span></a>.</p></li>
<li><p>El formato para las claves públicas es distinto e incompatible, pero
<a class="reference internal" href="#ssh-keygen"><span class="std std-ref">ssh-keyget</span></a> es capaz de hacer conversiones entre ambos formatos.
Para obtener la clave pública en formato reconocible por Open<abbr title="Secure Sockets Layer">SSL</abbr>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> ssh-keygen -e -f miclave.pub -m pkcs8 &gt; miclave.pem
</pre></div>
</div>
<p>Y para el proceso inverso:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> ssh-keygen -i -f miclave.pem -m pkcs8 &gt; miclave.pub
</pre></div>
</div>
</li>
<li><p>El formato para las claves privadas era el mismo hasta no hace demasiado, pero
las últimas versiones de Open<abbr title="Security SHell">SSH</abbr> utilizan por defecto un formato
incompatible. En cualquier caso, el formato de Open<abbr title="Security SHell">SSH</abbr> sigue soportado
por Open<abbr title="Security SHell">SSH</abbr>:. Así, si se tiene una clave privada en el formato de Open<abbr title="Security SHell">SSH</abbr>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> cp miclave miclave.key
<span class="gp">$</span> ssh-keygen -p -f miclave.key -m pem
</pre></div>
</div>
<p>Y si se tiene una clave generada con Open<abbr title="Secure Sockets Layer">SSL</abbr>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> cp miclave.key miclave
<span class="gp">$</span> ssh-keygen -p -f miclave
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>En estos casos <a class="reference internal" href="#ssh-keygen"><span class="std std-ref">ssh-keygen</span></a> genera el nuevo
formato sobrescribiendo el archivo, por lo que se hace necesaria la copia
previa.</p>
</div>
</li>
<li><p>Los formatos de <a class="reference internal" href="../../09.apendice/01.cryto/03.aplicaciones/01.certdig.html#cert-digital"><span class="std std-ref">certificado digital</span></a> son absolutamente
incompatibles y no hay conversión entre ellos, pero sí podemos tener sendos
certificados generados con el mismo par de claves.</p></li>
</ul>
<div class="admonition seealso">
<p class="admonition-title">Ver también</p>
<p>Puede echar una lectura a <a class="reference external" href="https://coolaj86.com/articles/openssh-vs-openssl-key-formats/">este artículo sobre formatos de claves
en ambas aplicaciones</a>.</p>
</div>
<div class="section" id="partiendo-de-openssh">
<h3><span class="section-number">4.5.4.3.1. </span>Partiendo de Open<abbr title="Security SHell">SSH</abbr><a class="headerlink" href="#partiendo-de-openssh" title="Enlazar permanentemente con este título">¶</a></h3>
<p>Si tenemos un par de claves, las habremos generado así (para que sean <abbr title="Elliptic Curve Digital Signature Algorithm">ECDSA</abbr>
habrá que añadir <kbd class="kbd docutils literal notranslate"><kbd class="kbd docutils literal notranslate"></kbd>-<kbd class="kbd docutils literal notranslate">t</kbd> <kbd class="kbd docutils literal notranslate">ecdsa</kbd></kbd>):</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> ssh-keygen -f miclave
</pre></div>
</div>
<p>lo cual creará los archivos de clave <code class="file docutils literal notranslate"><span class="pre">miclave</span></code> y <code class="file docutils literal notranslate"><span class="pre">miclave.pub</span></code>, ambas
en formato incomprensible para Open<abbr title="Secure Sockets Layer">SSL</abbr>. Para convertir podremos hacer:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> cp miclave miclave.key
<span class="gp">$</span> ssh-keygen -p -f miclave.key -m pem
</pre></div>
</div>
<p>Y la clave pública la podremoe obtener a partir de la clave privada usando Open<abbr title="Secure Sockets Layer">SSL</abbr>, La orden exacta dependerá de si la clave es <abbr title="Rivest, Shamir y Adleman">RSA</abbr> o <abbr title="Elliptic Curve Digital Signature Algorithm">ECDSA</abbr>. Podemos
también usar <strong class="command">ssh-keygen</strong> para obtener la clave pública<a class="footnote-reference brackets" href="#id22" id="id12">9</a>, que no
presenta diferencias sea una u otra la clave:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> ssh-keygen -e -f miclave.pub -m pkcs8
</pre></div>
</div>
</div>
<div class="section" id="partiendo-de-openssl">
<h3><span class="section-number">4.5.4.3.2. </span>Partiendo de Open<abbr title="Secure Sockets Layer">SSL</abbr><a class="headerlink" href="#partiendo-de-openssl" title="Enlazar permanentemente con este título">¶</a></h3>
<p>Podemos haber generado unas claves <abbr title="Rivest, Shamir y Adleman">RSA</abbr>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> openssl genrsa -aes128 -out miclave.key
<span class="gp">$</span> openssl rsa -in miclave.key -pubout -out miclave.pem
</pre></div>
</div>
<p>o bien unas claves <abbr title="Elliptic Curve Digital Signature Algorithm">ECDSA</abbr><a class="footnote-reference brackets" href="#id23" id="id13">10</a>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> openssl ecparam -name prime256v1 -genkey -noout -out miclave.key
<span class="gp">$</span> openssl ec -in miclave.key -pubout -out miclave.pem
</pre></div>
</div>
<p>Sea como sea, el proceso de obtención de claves válidas para Open<abbr title="Security SHell">SSH</abbr> es el
mismo:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> ln -s miclave.key miclave
<span class="gp">$</span> ssh-keygen -y -f miclave &gt; miclave.pub
</pre></div>
</div>
<p>donde no hemos cambiado de formato la clave privada, porque Open<abbr title="Security SHell">SSH</abbr> soporta
el formato de Open<abbr title="Secure Sockets Layer">SSL</abbr> y hemos obtenido la clave pública a partir de la
privada (otra opción habría sido convertir desde la clave pública en el formato
de Open<abbr title="Secure Sockets Layer">SSL</abbr> <code class="file docutils literal notranslate"><span class="pre">miclave.pem</span></code>).</p>
<p class="rubric">Notas al pie</p>
<dl class="footnote brackets">
<dt class="label" id="id14"><span class="brackets"><a class="fn-backref" href="#id1">1</a></span></dt>
<dd><p>Hasta la versión <em>7.0</em>, también existía una versión <a class="reference external" href="https://es.wikipedia.org/wiki/DSA">DSA</a>, pero acabó por deshabilitarse su uso al
considerarla débil (véase <a class="reference external" href="http://www.openssh.com/legacy.html">la información relativa</a> par más información).</p>
</dd>
<dt class="label" id="id15"><span class="brackets"><a class="fn-backref" href="#id2">2</a></span></dt>
<dd><p>Las líneas aparecen comentadas, pero recordemos que en este fichero las
directivas comentadas muestran el valor predeterminado.</p>
</dd>
<dt class="label" id="id16"><span class="brackets"><a class="fn-backref" href="#id3">3</a></span></dt>
<dd><p>Este comportamiento se deriva de la configuración predeterminada de las
últimas versiones de debian:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> grep -w HashKnownHosts /etc/ssh/ssh_config
<span class="go">    HashKnownHosts yes</span>
</pre></div>
</div>
</dd>
<dt class="label" id="id17"><span class="brackets"><a class="fn-backref" href="#id4">4</a></span></dt>
<dd><p>No especificamos dónde está la clave (opción <code class="docutils literal notranslate"><span class="pre">-i</span></code>), pero carece de
relevancia puesto que estamos usando los nombres predeterminados.</p>
</dd>
<dt class="label" id="id18"><span class="brackets"><a class="fn-backref" href="#id5">5</a></span></dt>
<dd><p>Tal es así, que podríamos haber hecho la subida de forma artesanal:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> ssh usuario@servidor <span class="s2">&quot;mkdir -p ~/.ssh; cat &gt;&gt; ~/.ssh/authorized_keys&quot;</span> &lt; ~/.ssh/id_ecdsa.pub
</pre></div>
</div>
</dd>
<dt class="label" id="id19"><span class="brackets"><a class="fn-backref" href="#id6">6</a></span></dt>
<dd><p>Consúltese el apartado <strong>TOKENS</strong> de la página de manual de <em>ssh_config</em>
para entender por qué <code class="docutils literal notranslate"><span class="pre">%h</span></code> se convierte en el nombre de la máquina remota
(<em>servidor</em>).</p>
</dd>
<dt class="label" id="id20"><span class="brackets"><a class="fn-backref" href="#id8">7</a></span></dt>
<dd><p>Para leer una larga disscusión sobre los inconvenientes, puede echar un
ojo a <a class="reference external" href="https://smallstep.com/blog/use-ssh-certificates/">ester artículo de smallsetp</a>.</p>
</dd>
<dt class="label" id="id21"><span class="brackets"><a class="fn-backref" href="#id9">8</a></span></dt>
<dd><p>Es cierto que podemos utilizar la <a class="reference internal" href="01.basico.html#ssh-match"><span class="std std-ref">directiva Match</span></a> en
la configuración pero lograr un efecto semejante, pero utilizar certificados
para este fin es mucho más cómodo y evita la obligación de modificar la
configuración.</p>
</dd>
<dt class="label" id="id22"><span class="brackets"><a class="fn-backref" href="#id12">9</a></span></dt>
<dd><p>La orden de exportación puede hacerse utilizando como argumento de la
opción <kbd class="kbd docutils literal notranslate"><kbd class="kbd docutils literal notranslate"></kbd>-<kbd class="kbd docutils literal notranslate">f</kbd></kbd> tanto la clave pública como la clave privada. Con la privada
se requerirá introducir la contraseña de cifrado.</p>
</dd>
<dt class="label" id="id23"><span class="brackets"><a class="fn-backref" href="#id13">10</a></span></dt>
<dd><p>La clave privada no tendrá contraseña que la proteja. Si se quiere
proteger con una, habrá que añadir una orden más:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> openssl ec -in miclave.key -aes256 -out miclave.crypt.key
</pre></div>
</div>
<p>Una alternativa es cambiar la clave al formato <abbr title="Public-Key Cryptography Standards">PKCS</abbr>#8:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> openssl pkcs8 -topk8 -in miclave.key -out miclave.crypt.key
</pre></div>
</div>
</dd>
</dl>
</div>
</div>
</div>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../../index.html">Tabla de contenido</a></h3>
  <ul>
<li><a class="reference internal" href="#">4.5.4. Autenticación de clave pública</a><ul>
<li><a class="reference internal" href="#claves">4.5.4.1. Claves</a><ul>
<li><a class="reference internal" href="#identificacion-del-servidor">4.5.4.1.1. Identificación del servidor</a><ul>
<li><a class="reference internal" href="#claves-en-el-servidor">4.5.4.1.1.1. Claves en el servidor</a></li>
<li><a class="reference internal" href="#claves-en-el-cliente">4.5.4.1.1.2. Claves en el cliente</a></li>
</ul>
</li>
<li><a class="reference internal" href="#ssh-auth-claves">4.5.4.1.2. Identificación del cliente</a><ul>
<li><a class="reference internal" href="#cliente-openssh">4.5.4.1.2.1. Cliente <em>openssh</em></a></li>
<li><a class="reference internal" href="#cliente-putty">4.5.4.1.2.2. Cliente <strong class="program">putty</strong></a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#certificados">4.5.4.2. Certificados</a><ul>
<li><a class="reference internal" href="#id10">4.5.4.2.1. Identificación del servidor</a></li>
<li><a class="reference internal" href="#id11">4.5.4.2.2. Identificación del cliente</a></li>
</ul>
</li>
<li><a class="reference internal" href="#openssh-y-openssl">4.5.4.3. Open<abbr title="Security SHell">SSH</abbr> y Open<abbr title="Secure Sockets Layer">SSL</abbr></a><ul>
<li><a class="reference internal" href="#partiendo-de-openssh">4.5.4.3.1. Partiendo de Open<abbr title="Security SHell">SSH</abbr></a></li>
<li><a class="reference internal" href="#partiendo-de-openssl">4.5.4.3.2. Partiendo de Open<abbr title="Secure Sockets Layer">SSL</abbr></a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>Tema anterior</h4>
  <p class="topless"><a href="01.basico.html"
                        title="capítulo anterior"><span class="section-number">4.5.1. </span>Instalación</a></p>
  <h4>Próximo tema</h4>
  <p class="topless"><a href="03.tuneles.html"
                        title="próximo capítulo"><span class="section-number">4.5.5. </span>Túneles</a></p>
  <div role="note" aria-label="source link">
    <h3>Esta página</h3>
    <ul class="this-page-menu">
      <li><a href="../../_sources/04.servidor/10.ssh/02.certificados.rst.txt"
            rel="nofollow">Mostrar el código</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Búsqueda rápida</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Ir a" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navegación</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="Índice General"
             >índice</a></li>
        <li class="right" >
          <a href="03.tuneles.html" title="4.5.5. Túneles"
             >siguiente</a> |</li>
        <li class="right" >
          <a href="01.basico.html" title="4.5.1. Instalación"
             >anterior</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">documentación de Linuxnomicón - rolling</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" ><span class="section-number">4. </span>Gestión del servidor</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="index.html" ><span class="section-number">4.5. </span>Administración remota</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href=""><span class="section-number">4.5.4. </span>Autenticación de clave pública</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Derechos de autor CC BY 4.0, 2016-2021, José Miguel Sánchez Alés.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 3.4.3.
    </div>
  </body>
</html>