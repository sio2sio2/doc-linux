


<!DOCTYPE html>

<html lang="es">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>4.5.4. Certificados de autenticación &#8212; documentación de Linuxnomicón - rolling</title>
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
    
    <script id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/language_data.js"></script>
    <script src="../../_static/translations.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <link rel="index" title="Índice" href="../../genindex.html" />
    <link rel="search" title="Búsqueda" href="../../search.html" />
    <link rel="next" title="4.5.5. Túneles" href="03.tuneles.html" />
    <link rel="prev" title="4.5.1. Instalación" href="01.basico.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navegación</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="Índice General"
             accesskey="I">índice</a></li>
        <li class="right" >
          <a href="03.tuneles.html" title="4.5.5. Túneles"
             accesskey="N">siguiente</a> |</li>
        <li class="right" >
          <a href="01.basico.html" title="4.5.1. Instalación"
             accesskey="P">anterior</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">documentación de Linuxnomicón - rolling</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" ><span class="section-number">4. </span>Gestión del servidor</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="index.html" accesskey="U"><span class="section-number">4.5. </span>Administración remota</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href=""><span class="section-number">4.5.4. </span>Certificados de autenticación</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="certificados-de-autenticacion">
<span id="ssh-cert"></span><h1><span class="section-number">4.5.4. </span>Certificados de autenticación<a class="headerlink" href="#certificados-de-autenticacion" title="Enlazar permanentemente con este título">¶</a></h1>
<p>Los certificados digitales permiten tanto identificar al servidor frente al
cliente, como al revés. En el primer caso, se usan siempre, ya que es la única
forma que tiene el cliente de identificar al servidor; en el segundo, en cambio,
el uso es opcional, ya que el cliente puede optar por usar una identificación
basada en usuario y contraseña. Analicemos por separado ambos casos.</p>
<div class="section" id="identificacion-del-servidor">
<h2><span class="section-number">4.5.4.1. </span>Identificación del servidor<a class="headerlink" href="#identificacion-del-servidor" title="Enlazar permanentemente con este título">¶</a></h2>
<p>Ya se ha mencionado al anteriormente que para evitar ataques <em>man-in-the-middle</em>
mediante la suplantación de la identidad del servidor, éste envía al cliente su
clave pública. En la primera conexión aceptar la clave pública de un servidor es
un acto de fe, a menos que se haya obtenido esa clave pública de algún modo
seguro. Sea como sea, el cliente, por su parte, almacena las claves públicas de
todos los servidores a los que se conecta, de modo que si se produce una segunda
conexión compara la clave pública que le vuelve a enviar el servidor con la que
previamente tiene almacenada. En realidad lo que compara es el <em>fingerprint</em> o
huella dactilar de la clave pública, una sucesión de pares de números
hexadecimales que se obtiene a partir de dicha: si coinciden, el cliente se
fiará de que el servidor es quien dice ser; si no coinciden, entonces sospechará
que hay una suplantación y, o bien avisará (caso de <strong class="program">putty</strong>), o bien,
se negará en rotundo a conectar hasta que no se elimine del cliente la clave
pública antigua (caso del cliente de <em>openssh</em>).</p>
<p>Del párrafo anterior, hay dos ideas que es necesario remarcar y que se
desglosarán bajo los siguientes epígrafes:</p>
<ol class="arabic simple">
<li><p>El servidor tiene una pareja de claves pública/privada que le sirven para
identificarse ante el cliente (también sirven para cifrar la clave simétrica,
pero esto importa poco a los efectos de esta discusión).</p></li>
<li><p>El cliente almacena las claves públicas de los servidores para comprobar las
identidades de éstos cuando intenta una conexión.</p></li>
</ol>
<div class="section" id="claves-en-el-servidor">
<h3><span class="section-number">4.5.4.1.1. </span>Claves en el servidor<a class="headerlink" href="#claves-en-el-servidor" title="Enlazar permanentemente con este título">¶</a></h3>
<p>Se ha afirmado que el servidor tiene una pareja de claves. Esto no es del todo
cierto, en realidad, las versiones modernas del servidor <em>openssh</em> tiene varias
parejas de claves, cada una de cuales usa un algoritmo diferente de cifrado<a class="footnote-reference brackets" href="#id8" id="id1">1</a>. Estas claves está almacenadas en el directorio <code class="file docutils literal notranslate"><span class="pre">/etc/ssh</span></code>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> ls -1 /etc/ssh/ssh_host_*
<span class="go">/etc/ssh/ssh_host_ecdsa_key</span>
<span class="go">/etc/ssh/ssh_host_ecdsa_key.pub</span>
<span class="go">/etc/ssh/ssh_host_ed25519_key</span>
<span class="go">/etc/ssh/ssh_host_ed25519_key.pub</span>
<span class="go">/etc/ssh/ssh_host_rsa_key</span>
<span class="go">/etc/ssh/ssh_host_rsa_key.pub</span>
</pre></div>
</div>
<p>Los ficheros de extensión <em>.pub</em> son los que almacenan las claves públicas.
Paralelamente, en el fichero de configuración debe indicarse que estas serán las
claves de identificación<a class="footnote-reference brackets" href="#id9" id="id2">2</a>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> grep -w HostKey /etc/ssh/sshd_config
<span class="gp">#</span>HostKey /etc/ssh/ssh_host_rsa_key
<span class="gp">#</span>HostKey /etc/ssh/ssh_host_ecdsa_key
<span class="gp">#</span>HostKey /etc/ssh/ssh_host_ed25519_key
</pre></div>
</div>
<p>Cuál de estas parejas se use para la validación depende del cliente: él le
indicará al servidor por orden que algoritmos prefiere y el servidor usará el
primero que tenga disponible. Se ha dicho también que en realidad lo que se
compara es el fingerkey obtenido a partir de la clave pública. De hecho, la
primera vez que se conecta el cliente al servidor, se encontrará con esto:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">pepe@cliente$</span> ssh usuario@servidor
<span class="go">The authenticity of host &#39;servidor (192.168.1.11)&#39; can&#39;t be established.</span>
<span class="go">ECDSA key fingerprint is SHA256:vOef4Mo/0obxdDeS9iNIZ5+kQpMB+krMf9XTedRMUbE.</span>
<span class="go">Are you sure you want to continue connecting (yes/no)</span>
</pre></div>
</div>
<span class="target" id="ssh-keygen"></span><p id="index-0">Aceptarlo implicará almacenar en el cliente tal <em>fingerprint</em>. Tal huella
digital es posible obtenerla manualmente gracias a <strong class="command">ssh-keygen</strong>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> ssh-keygen -l -f /etc/ssh/ssh_host_ecdsa_key.pub
<span class="go">256 SHA256:vOef4Mo/0obxdDeS9iNIZ5+kQpMB+krMf9XTedRMUbE root@servidor (ECDSA)</span>
</pre></div>
</div>
<p>que obviamente coincide con el <em>fingerprint</em> que observó <em>pepe</em> desde el
cliente. El primer número (<strong>256</strong>) indica la longitud de la clave.</p>
<div class="admonition warning">
<p class="admonition-title">Advertencia</p>
<p>Las claves identifican al servidor, así que es mejor no cambiarlas a
menos que las sospechemos comprometidas. Si es absolutamente necesario,
pueden redefinirse así:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> ssh-keygen -t ecdsa -f /etc/ssh/ssh_host_ecdsa_key -N <span class="s2">&quot;&quot;</span>
</pre></div>
</div>
<p>que crea una clave <em>ECDSA</em> en el fichero apropiado sin contraseña (esto
último necesario, porque el servidor debe ser capaz de usarlas sin pedir
la contraseña a nadie). La orden debería repetirse para todos los algoritmos,
así que podríamos hacer:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> <span class="k">for</span> algo in rsa ecdsa ed25519<span class="p">;</span> <span class="k">do</span> ssh-keygen -t <span class="nv">$algo</span> -f /etc/ssh/ssh_host_<span class="si">${</span><span class="nv">algo</span><span class="si">}</span>_key -N <span class="s2">&quot;&quot;</span><span class="p">;</span> <span class="k">done</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="claves-en-el-cliente">
<h3><span class="section-number">4.5.4.1.2. </span>Claves en el cliente<a class="headerlink" href="#claves-en-el-cliente" title="Enlazar permanentemente con este título">¶</a></h3>
<p>Como se ha adelantado, los clientes almacenan los <em>fingerprints</em> de las claves
públicas de los servidores a los que se han conectado previamente dentro del
fichero <code class="file docutils literal notranslate"><span class="pre">~/.ssh/known_hosts</span></code>. Ahora bien:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">pepe@cliente$</span> ssh-keygen -l -f ~/.ssh/known_hosts
<span class="go">256 SHA256:vOef4Mo/0obxdDeS9iNIZ5+kQpMB+krMf9XTedRMUbE |1|4WnmUKMOBGnrOtOHytjLzB8cKFE=|q7chrsGIIRUBS2S1GlpzA0vDbjo= (ECDSA)</span>
<span class="go">256 SHA256:vOef4Mo/0obxdDeS9iNIZ5+kQpMB+krMf9XTedRMUbE |1|l4/bYn6a2ImKN27oCuwD3wb9M8o=|b5i6kcIRct1K1U9EBVH4PgfoJJU= (ECDSA)</span>
</pre></div>
</div>
<p>si comprobamos los <em>fingerprints</em> almacenados no seremos capaces de saber a qué
servidor corresponde tal <em>fingerprint</em>. Esto se hace así, por privacidad, esto
es, por evitar que otros usuarios sean capaces de conocer a qué servidores nos
conectamos<a class="footnote-reference brackets" href="#id10" id="id3">3</a>. El comportamiento puede modificarse cambiando el valor de la
directiva <em>HashKnownHosts</em> en la configuración del cliente. Por tanto, si
añadimos como directiva global a <code class="file docutils literal notranslate"><span class="pre">~/.ssh/config</span></code>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">HashKnownHosts no</span>
</pre></div>
</div>
<p>se almacenarán las direcciones en claro:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">pepe@cliente$</span> rm -f ~/.ssh/known_hosts
<span class="gp">pepe@cliente$</span> ssh usuario@servidor

<span class="go">[...]</span>

<span class="gp">pepe@cliente$</span> ssh-keygen -l -f ~/.ssh/known_hosts
<span class="go">256 SHA256:vOef4Mo/0obxdDeS9iNIZ5+kQpMB+krMf9XTedRMUbE servidor,192.168.1.11 (ECDSA)</span>
</pre></div>
</div>
<p>A partir de ahora, cada ve que se conecte a <em>servidor</em>, se confirmará que el
<em>firgenprint</em> de la clave proporcionada por este coincide con la almacena. Si no
es así, ocurrirá esto:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">pepe@cliente$</span> ssh usuario@servidor
<span class="go">@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@</span>
<span class="go">@    WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!     @</span>
<span class="go">@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@</span>
<span class="go">IT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!</span>
<span class="go">Someone could be eavesdropping on you right now (man-in-the-middle attack)!</span>
<span class="go">It is also possible that a host key has just been changed.</span>
<span class="go">The fingerprint for the ECDSA key sent by the remote host is</span>
<span class="go">SHA256:IWvZBm4stPCufdUlUdUtKGkk7P/nNhDsf1R5XDUANtM.</span>
<span class="go">Please contact your system administrator.</span>
<span class="go">Add correct host key in /home/josem/.ssh/known_hosts to get rid of this message.</span>
<span class="go">Offending ECDSA key in /home/josem/.ssh/known_hosts:1</span>
<span class="go">  remove with:</span>
<span class="go">  ssh-keygen -f &quot;/home/josem/.ssh/known_hosts&quot; -R &quot;servidor&quot;</span>
<span class="go">ECDSA host key for servidor has changed and you have requested strict checking.</span>
<span class="go">Host key verification failed.</span>
</pre></div>
</div>
<p>Que no coincidan las claves puede suponer una suplantación de identidad… o que
las claves cambiaron en el servidor por alguna razón. Si la razón es esta
segunda, la solución está incluida en el mensaje de advertenca, y es borrar el
<em>fingerprint</em> asociado al servidor:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">pepe@cliente$</span> ssh-keygen -R servidor
<span class="gp">#</span> Host servidor found: line <span class="m">1</span>
<span class="go">/home/josem/.ssh/known_hosts updated.</span>
<span class="go">Original contents retained as /home/josem/.ssh/known_hosts.old</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p><strong class="program">Putty</strong> también almacena el <em>fingerprint</em> del servidor, pero
a diferencia de éste, no rechaza la conexión cuando detecta un cambio en la
clave, sino que advierte del peligro de seguridad y permite aceptar (o no) la
nueva clave.</p>
</div>
</div>
</div>
<div class="section" id="ssh-auth-claves">
<span id="identificacion-del-cliente"></span><h2><span class="section-number">4.5.4.2. </span>Identificación del cliente<a class="headerlink" href="#ssh-auth-claves" title="Enlazar permanentemente con este título">¶</a></h2>
<p>Obviamente, nos referimos a su identificación mediante certificado y no
mediante contraseña. Por supuesto, la identificación exige primero la creación
de las claves y que el servidor acepte este tipo de identificación:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> grep -w PubkeyAuthentication /etc/ssh/sshd_config
<span class="gp">#</span>PubkeyAuthentication yes
</pre></div>
</div>
<div class="section" id="cliente-openssh">
<h3><span class="section-number">4.5.4.2.1. </span>Cliente <em>openssh</em><a class="headerlink" href="#cliente-openssh" title="Enlazar permanentemente con este título">¶</a></h3>
<p>En este caso, laa generación es sencilla. La orden:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> ssh-keygen -t ecdsa -C <span class="s2">&quot;Comentario alusivo a la clave&quot;</span>
</pre></div>
</div>
<p>generará una clave de tipo <em>ECDSA</em> y, como fichero, se escogerá el
predeterminado para este tipo de clave (<code class="file docutils literal notranslate"><span class="pre">~/.ssh/id_ecdsa</span></code> y
<code class="file docutils literal notranslate"><span class="pre">~/.ssh/id_ecdsa.pub</span></code>, para la clave pública). Si no se altera la
configuración, en el momento en que intentemos conectar a cualquier servidor se
intentará usar esta clave para la autenticación. Tras generar la pareja de
claves se nos pide una <em>clave de paso</em>, que no es más que una contraseña
necesaria para poder usar la clave privada. Fijarla obliga a escribir tal
contraseña antes de usarla y nos asegura ante un hurto de las claves.</p>
<span class="target" id="ssh-copy-id"></span><p id="index-1">Es obvio, que no basta con generar la clave en el cliente: en el servidor debe
alojarse la clave pública para que, cuando se produzca la comunicación, pueda
asegurarse que quien se conecta desde el cliente es el propietario de la clave
privada correspondiente. Para ello, puede hacerse:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> ssh-copy-id usuario@servidor
</pre></div>
</div>
<p>que subirá la clave<a class="footnote-reference brackets" href="#id11" id="id4">4</a> al fichero del servidor que almacena las claves
públicas (<code class="file docutils literal notranslate"><span class="pre">~./ssh/authorized_keys</span></code>)<a class="footnote-reference brackets" href="#id12" id="id5">5</a>. A partir de ahora, al intentar
ingresar en el servidor, se usará en primer término la identificación mediante
el certificado y se nos pedirá la clave de paso (ya que hay que usar la clave
privada) o nada, si no se introdujo contraseña al generar las claves.</p>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>No obstante, lo anterior, es posible usar claves almacenadas en otros
ficheros. Por ejemplo:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> ssh-keygen -t edcsa -f .ssh/id_servidor -C <span class="s2">&quot;Clave para &#39;servidor&#39;&quot;</span>
<span class="gp">$</span> ssh-copy-id -i .ssh/id_servidor usuario@servidor
<span class="gp">$</span> ssh -i .ssh/id_servidor usuario@servidor
</pre></div>
</div>
<p>e incluso indicar cuál es el nombre de la clave en la configuración:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">Host svm</span>
<span class="go">   Hostname       servidor</span>
<span class="go">   User           usuario</span>
<span class="go">   IdentityFile   ~/.ssh/id_%h</span>
</pre></div>
</div>
<p>de manera que cuando conectemos a <em>servidor</em> siempre usemos
<code class="file docutils literal notranslate"><span class="pre">~/.ssh/id_servidor</span></code><a class="footnote-reference brackets" href="#id13" id="id6">6</a>.</p>
</div>
</div>
<div class="section" id="cliente-putty">
<h3><span class="section-number">4.5.4.2.2. </span>Cliente <strong class="program">putty</strong><a class="headerlink" href="#cliente-putty" title="Enlazar permanentemente con este título">¶</a></h3>
<p>Debemos efectuar las mismas acciones que en el caso anterior. El equivalente a
<strong class="command">ssh-keygen</strong> en la suite de <strong class="program">putty</strong> es <strong class="program">puttygen</strong>:</p>
<img alt="Captura de puttygen" src="04.servidor/10.ssh/files/putty_gen.jpg" />
<div class="admonition-todo admonition" id="id7">
<p class="admonition-title">Por hacer</p>
<p>HACER la captura…</p>
</div>
<p>Al generar el par de claves (<code class="docutils literal notranslate"><span class="pre">Generate</span></code>) el programa quedará esperando que
movamos aletariamente el ratón por encima de la superficie vacía a fin de lograr
mayor aletoriedad. Al acabar la generación, se podrá escribir un comentario y la
clave de paso o contraseña de la propia clave. Podemos entonces guardar la clave
privada (<code class="docutils literal notranslate"><span class="pre">Save</span> <span class="pre">private</span> <span class="pre">key</span></code>), pero la clave pública no es de poca ayuda, puesto
que no tiene el mismo formato que las claves que genera <em>openssh</em>. Sin embargo,
la clave pública, tal y como la exige <em>openssh</em>, se muestra en la propia
pantalla con lo que se puede copiar y pegar en un fichero.</p>
<p>Dado que ahora no disponemos de <strong class="command">ssh-id-copy</strong>, hay que subir manualmente
la clave pública al servidor para incluirla en en <code class="file docutils literal notranslate"><span class="pre">~/.ssh/authorized_keys</span></code>.
Quizás lo más sencillo es abrir una sesión de <strong class="program">putty</strong> y copiar
contenido de la clave pública directamente sobre el fichero anterior, en vez de
en un fichero cualquiera del cliente <em>windows</em>.</p>
<p class="rubric">Notas al pie</p>
<dl class="footnote brackets">
<dt class="label" id="id8"><span class="brackets"><a class="fn-backref" href="#id1">1</a></span></dt>
<dd><p>Hasta la versión <em>7.0</em>, también existía una versión <a class="reference external" href="https://es.wikipedia.org/wiki/DSA">DSA</a>, pero acabó por deshabilitarse su uso al
considerarla débil (véase <a class="reference external" href="http://www.openssh.com/legacy.html">la información relativa</a> par más información).</p>
</dd>
<dt class="label" id="id9"><span class="brackets"><a class="fn-backref" href="#id2">2</a></span></dt>
<dd><p>Las líneas aparecen comentadas, pero recordemos que en este fichero las
directivas comentadas muestran el valor predeterminado.</p>
</dd>
<dt class="label" id="id10"><span class="brackets"><a class="fn-backref" href="#id3">3</a></span></dt>
<dd><p>Este comportamiento se deriva de la configuración predeterminada de las
últimas versiones de debian:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> grep -w HashKnownHosts /etc/ssh/ssh_config
<span class="go">    HashKnownHosts yes</span>
</pre></div>
</div>
</dd>
<dt class="label" id="id11"><span class="brackets"><a class="fn-backref" href="#id4">4</a></span></dt>
<dd><p>No especificamos dónde está la clave (opción <code class="docutils literal notranslate"><span class="pre">-i</span></code>), pero carece de
relevancia puesto que estamos usando los nombres predeterminados.</p>
</dd>
<dt class="label" id="id12"><span class="brackets"><a class="fn-backref" href="#id5">5</a></span></dt>
<dd><p>Tal es así, que podríamos haber hecho la subida de forma artesanal:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> ssh usuario@servidor <span class="s2">&quot;mkdir -p ~/.ssh; cat &gt;&gt; ~/.ssh/authorized_keys&quot;</span> &lt; ~/.ssh/id_ecdsa.pub
</pre></div>
</div>
</dd>
<dt class="label" id="id13"><span class="brackets"><a class="fn-backref" href="#id6">6</a></span></dt>
<dd><p>Consúltese el apartado <strong>TOKENS</strong> de la página de manual de <em>ssh_config</em>
para entender por qué <code class="docutils literal notranslate"><span class="pre">%h</span></code> se convierte en el nombre de la máquina remota
(<em>servidor</em>).</p>
</dd>
</dl>
</div>
</div>
</div>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../../index.html">Tabla de contenido</a></h3>
  <ul>
<li><a class="reference internal" href="#">4.5.4. Certificados de autenticación</a><ul>
<li><a class="reference internal" href="#identificacion-del-servidor">4.5.4.1. Identificación del servidor</a><ul>
<li><a class="reference internal" href="#claves-en-el-servidor">4.5.4.1.1. Claves en el servidor</a></li>
<li><a class="reference internal" href="#claves-en-el-cliente">4.5.4.1.2. Claves en el cliente</a></li>
</ul>
</li>
<li><a class="reference internal" href="#ssh-auth-claves">4.5.4.2. Identificación del cliente</a><ul>
<li><a class="reference internal" href="#cliente-openssh">4.5.4.2.1. Cliente <em>openssh</em></a></li>
<li><a class="reference internal" href="#cliente-putty">4.5.4.2.2. Cliente <strong class="program">putty</strong></a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>Tema anterior</h4>
  <p class="topless"><a href="01.basico.html"
                        title="capítulo anterior"><span class="section-number">4.5.1. </span>Instalación</a></p>
  <h4>Próximo tema</h4>
  <p class="topless"><a href="03.tuneles.html"
                        title="próximo capítulo"><span class="section-number">4.5.5. </span>Túneles</a></p>
  <div role="note" aria-label="source link">
    <h3>Esta página</h3>
    <ul class="this-page-menu">
      <li><a href="../../_sources/04.servidor/10.ssh/02.certificados.rst.txt"
            rel="nofollow">Mostrar el código</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Búsqueda rápida</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Ir a" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navegación</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="Índice General"
             >índice</a></li>
        <li class="right" >
          <a href="03.tuneles.html" title="4.5.5. Túneles"
             >siguiente</a> |</li>
        <li class="right" >
          <a href="01.basico.html" title="4.5.1. Instalación"
             >anterior</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">documentación de Linuxnomicón - rolling</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" ><span class="section-number">4. </span>Gestión del servidor</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="index.html" ><span class="section-number">4.5. </span>Administración remota</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href=""><span class="section-number">4.5.4. </span>Certificados de autenticación</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Derechos de autor CC BY 4.0, 2016-2020, José Miguel Sánchez Alés.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 3.3.1.
    </div>
  </body>
</html>