

<!DOCTYPE html>

<html lang="es" data-content_root="../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>4.5.4. Autenticación de clave pública &#8212; documentación de Linuxnomicón - rolling</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="../../_static/classic.css?v=2bf1fcf8" />
    <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
    
    <script src="../../_static/documentation_options.js?v=a621b78a"></script>
    <script src="../../_static/doctools.js?v=9bcbadda"></script>
    <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../_static/translations.js?v=f85f4cfb"></script>
    
    <link rel="index" title="Índice" href="../../genindex.html" />
    <link rel="search" title="Búsqueda" href="../../search.html" />
    <link rel="next" title="4.5.5. Túneles" href="03.tuneles.html" />
    <link rel="prev" title="4.5.1. Instalación" href="01.basico.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="Related">
      <h3>Navegación</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="Índice General"
             accesskey="I">índice</a></li>
        <li class="right" >
          <a href="03.tuneles.html" title="4.5.5. Túneles"
             accesskey="N">siguiente</a> |</li>
        <li class="right" >
          <a href="01.basico.html" title="4.5.1. Instalación"
             accesskey="P">anterior</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">documentación de Linuxnomicón - rolling</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" ><span class="section-number">4. </span>Gestión del servidor</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="index.html" accesskey="U"><span class="section-number">4.5. </span>Administración remota</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href=""><span class="section-number">4.5.4. </span>Autenticación de clave pública</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="autenticacion-de-clave-publica">
<span id="ssh-cert"></span><h1><span class="section-number">4.5.4. </span>Autenticación de clave pública<a class="headerlink" href="#autenticacion-de-clave-publica" title="Link to this heading">¶</a></h1>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>Una perfecta compresión de este apartado exige tener unos
conocimineots mínimos sobre <a class="reference internal" href="../../98.apendice/01.cryto/index.html#crypto"><span class="std std-ref">Criptografía</span></a>.</p>
</div>
<p>Las técnicas de <a class="reference internal" href="../../98.apendice/01.cryto/02.algo.html#asimetrico"><span class="std std-ref">cifrado asimétrico</span></a> se usan en el protocolo
<abbr title="Security SHell">SSH</abbr> para la autenticación tanto de servidor como de cliente. En el caso del
segundo, también es posible la autenticación con contraseña, que es justamente
la que hemos visto hasta ahora.</p>
<p>Cuando se usa autenticación con clave pública hay dos posibilidades:</p>
<ul class="simple">
<li><p>Una solución basada exclusivamente en el uso de claves asimétricas</p></li>
<li><p>Otra que, sobre la base de la anterior, genera <a class="reference internal" href="../../98.apendice/01.cryto/03.aplicaciones/01.certdig.html#cert-digital"><span class="std std-ref">certificados digitales</span></a> a partir de las claves públicas utilizando una
<a class="reference internal" href="../../98.apendice/01.cryto/03.aplicaciones/01.certdig.html#pki"><span class="std std-ref">infraestructura PKI</span></a>.</p></li>
</ul>
<p>Como para analizar la segunda solución es conveniente conocer la primera,
analizaremos la primera y, sobre ella, expondremos la segunda.</p>
<section id="claves">
<span id="ssh-auth-keys"></span><h2><span class="section-number">4.5.4.1. </span>Claves<a class="headerlink" href="#claves" title="Link to this heading">¶</a></h2>
<p>Analicemos por separado cómo se identifica el servidor ante el cliente y cómo lo
hace el cliente ante el servidor.</p>
<section id="identificacion-del-servidor">
<h3><span class="section-number">4.5.4.1.1. </span>Identificación del servidor<a class="headerlink" href="#identificacion-del-servidor" title="Link to this heading">¶</a></h3>
<p>Ya se ha mencionado anteriormente que para evitar ataques <em>man-in-the-middle</em>
mediante la suplantación de la identidad del servidor, éste envía al cliente su
clave pública. En la primera conexión aceptar la clave pública de un servidor es
un acto de fe, a menos que se haya obtenido esa clave pública de algún modo
seguro. Sea como sea, el cliente, por su parte, puede almacenar las claves
públicas de todos los servidores a los que se conecta, de modo que si se produce
una segunda conexión compara la clave pública que le vuelve a enviar el servidor
con la que previamente tiene almacenada. En realidad lo que compara es el
<em>fingerprint</em> o huella dactilar de la clave pública, una sucesión de pares de
números hexadecimales que se obtiene a partir de ella: si coinciden, el cliente
se fiará de que el servidor es quien dice ser; si no coinciden, entonces
sospechará que hay una suplantación y, o bien avisará (caso de
<strong class="program">putty</strong>), o bien, se negará en rotundo a conectar hasta que no se
elimine del cliente la clave pública antigua (caso del cliente de <em>openssh</em>).</p>
<p>Del párrafo anterior, hay dos ideas que es necesario remarcar y que se
desglosarán bajo los siguientes epígrafes:</p>
<ol class="arabic simple">
<li><p>El servidor tiene una pareja de claves pública/privada que le sirven para
identificarse ante el cliente (también sirven para cifrar la clave simétrica,
pero esto importa poco a los efectos de esta discusión).</p></li>
<li><p>El cliente almacena las claves públicas de los servidores para comprobar las
identidades de éstos cuando intenta una conexión.</p></li>
</ol>
<section id="claves-en-el-servidor">
<span id="ssh-server-keys"></span><h4><span class="section-number">4.5.4.1.1.1. </span>Claves en el servidor<a class="headerlink" href="#claves-en-el-servidor" title="Link to this heading">¶</a></h4>
<p>Se ha afirmado que el servidor tiene una pareja de claves. Esto no es del todo
cierto, en realidad, las versiones modernas del servidor <em>openssh</em> tiene varias
parejas de claves, cada una de cuales usa un algoritmo diferente de cifrado<a class="footnote-reference brackets" href="#id14" id="id1" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a>. Estas claves está almacenadas en el directorio <code class="file docutils literal notranslate"><span class="pre">/etc/ssh</span></code>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>ls<span class="w"> </span>-1<span class="w"> </span>/etc/ssh/ssh_host_*
<span class="go">/etc/ssh/ssh_host_ecdsa_key</span>
<span class="go">/etc/ssh/ssh_host_ecdsa_key.pub</span>
<span class="go">/etc/ssh/ssh_host_ed25519_key</span>
<span class="go">/etc/ssh/ssh_host_ed25519_key.pub</span>
<span class="go">/etc/ssh/ssh_host_rsa_key</span>
<span class="go">/etc/ssh/ssh_host_rsa_key.pub</span>
</pre></div>
</div>
<p>Los ficheros de extensión <em>.pub</em> son los que almacenan las claves públicas.
Paralelamente, en el fichero de configuración debe indicarse que estas serán las
claves de identificación<a class="footnote-reference brackets" href="#id15" id="id2" role="doc-noteref"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></a>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>/usr/sbin/sshd<span class="w"> </span>-T<span class="w"> </span><span class="p">|</span><span class="w"> </span>grep<span class="w"> </span>-i<span class="w"> </span>^HostKey
<span class="go">hostkey /etc/ssh/ssh_host_rsa_key</span>
<span class="go">hostkey /etc/ssh/ssh_host_ecdsa_key</span>
<span class="go">hostkey /etc/ssh/ssh_host_ed25519_key</span>
</pre></div>
</div>
<p>Cuál de estas parejas se use para la validación depende del cliente: él le
indicará al servidor por orden que algoritmos prefiere y el servidor usará el
primero que tenga disponible. Se ha dicho también que en realidad lo que se
compara es el fingerkey obtenido a partir de la clave pública. De hecho, la
primera vez que se conecta el cliente al servidor, se encontrará con esto:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">pepe@cliente$ </span>ssh<span class="w"> </span>usuario@servidor
<span class="go">The authenticity of host &#39;servidor (192.168.1.11)&#39; can&#39;t be established.</span>
<span class="go">ECDSA key fingerprint is SHA256:vOef4Mo/0obxdDeS9iNIZ5+kQpMB+krMf9XTedRMUbE.</span>
<span class="go">Are you sure you want to continue connecting (yes/no)</span>
</pre></div>
</div>
<p id="index-0"><span id="ssh-keygen"></span>Aceptarlo implicará almacenar en el cliente tal <em>fingerprint</em>. Tal huella
digital es posible obtenerla manualmente gracias a <strong class="command">ssh-keygen</strong>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>ssh-keygen<span class="w"> </span>-l<span class="w"> </span>-f<span class="w"> </span>/etc/ssh/ssh_host_ecdsa_key.pub
<span class="go">256 SHA256:vOef4Mo/0obxdDeS9iNIZ5+kQpMB+krMf9XTedRMUbE root@servidor (ECDSA)</span>
</pre></div>
</div>
<p>que obviamente coincide con el <em>fingerprint</em> que observó <em>pepe</em> desde el
cliente. El primer número (<strong>256</strong>) indica la longitud de la clave.</p>
<div class="admonition warning">
<p class="admonition-title">Advertencia</p>
<p>Las claves identifican al servidor, así que es mejor no cambiarlas
a menos que las sospechemos comprometidas. Si es absolutamente necesario,
pueden redefinirse así:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp"># </span>rm<span class="w"> </span>-f<span class="w"> </span>/etc/ssh/ssh_host_*
<span class="gp"># </span>ssh-keygen<span class="w"> </span>-A
</pre></div>
</div>
<p>ya que <kbd class="kbd docutils literal notranslate">-A</kbd> sólo genera las claves de servidor que no encuentra.</p>
</div>
</section>
<section id="claves-en-el-cliente">
<h4><span class="section-number">4.5.4.1.1.2. </span>Claves en el cliente<a class="headerlink" href="#claves-en-el-cliente" title="Link to this heading">¶</a></h4>
<p>Como se ha adelantado, los clientes almacenan los <em>fingerprints</em> de las claves
públicas de los servidores a los que se han conectado previamente dentro del
fichero <code class="file docutils literal notranslate"><span class="pre">~/.ssh/known_hosts</span></code>. Ahora bien:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">pepe@cliente$ </span>ssh-keygen<span class="w"> </span>-l<span class="w"> </span>-f<span class="w"> </span>~/.ssh/known_hosts
<span class="go">256 SHA256:vOef4Mo/0obxdDeS9iNIZ5+kQpMB+krMf9XTedRMUbE |1|4WnmUKMOBGnrOtOHytjLzB8cKFE=|q7chrsGIIRUBS2S1GlpzA0vDbjo= (ECDSA)</span>
<span class="go">256 SHA256:vOef4Mo/0obxdDeS9iNIZ5+kQpMB+krMf9XTedRMUbE |1|l4/bYn6a2ImKN27oCuwD3wb9M8o=|b5i6kcIRct1K1U9EBVH4PgfoJJU= (ECDSA)</span>
</pre></div>
</div>
<p>si comprobamos los <em>fingerprints</em> almacenados no seremos capaces de saber a qué
servidor corresponde tal <em>fingerprint</em>. Esto se hace así por privacidad, esto
es, por evitar que otros usuarios sean capaces de conocer a qué servidores nos
conectamos<a class="footnote-reference brackets" href="#id16" id="id3" role="doc-noteref"><span class="fn-bracket">[</span>3<span class="fn-bracket">]</span></a>. El comportamiento puede modificarse cambiando el valor de la
directiva <em>HashKnownHosts</em> en la configuración del cliente. Por tanto, si
añadimos como directiva global a <code class="file docutils literal notranslate"><span class="pre">~/.ssh/config</span></code>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">HashKnownHosts no</span>
</pre></div>
</div>
<p>se almacenarán las direcciones en claro:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">pepe@cliente$ </span>rm<span class="w"> </span>-f<span class="w"> </span>~/.ssh/known_hosts
<span class="gp">pepe@cliente$ </span>ssh<span class="w"> </span>usuario@servidor

<span class="go">[...]</span>

<span class="gp">pepe@cliente$ </span>ssh-keygen<span class="w"> </span>-l<span class="w"> </span>-f<span class="w"> </span>~/.ssh/known_hosts
<span class="go">256 SHA256:vOef4Mo/0obxdDeS9iNIZ5+kQpMB+krMf9XTedRMUbE servidor,192.168.1.11 (ECDSA)</span>
</pre></div>
</div>
<p>En cualquier caso, aunque estén ofuscados los nombres, puede buscarse si hay ya alguna entrada para un servidor:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>ssh-keygen<span class="w"> </span>-F<span class="w"> </span>servidor
</pre></div>
</div>
<p>A partir de ahora, cada vez que se conecte a <em>servidor</em>, se confirmará que el
<em>firgenprint</em> de la clave proporcionada por este coincide con la almacenada. Si
no es así, ocurrirá esto:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">pepe@cliente$ </span>ssh<span class="w"> </span>usuario@servidor
<span class="go">@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@</span>
<span class="go">@    WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!     @</span>
<span class="go">@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@</span>
<span class="go">IT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!</span>
<span class="go">Someone could be eavesdropping on you right now (man-in-the-middle attack)!</span>
<span class="go">It is also possible that a host key has just been changed.</span>
<span class="go">The fingerprint for the ECDSA key sent by the remote host is</span>
<span class="go">SHA256:IWvZBm4stPCufdUlUdUtKGkk7P/nNhDsf1R5XDUANtM.</span>
<span class="go">Please contact your system administrator.</span>
<span class="go">Add correct host key in /home/josem/.ssh/known_hosts to get rid of this message.</span>
<span class="go">Offending ECDSA key in /home/josem/.ssh/known_hosts:1</span>
<span class="go">  remove with:</span>
<span class="go">  ssh-keygen -f &quot;/home/josem/.ssh/known_hosts&quot; -R &quot;servidor&quot;</span>
<span class="go">ECDSA host key for servidor has changed and you have requested strict checking.</span>
<span class="go">Host key verification failed.</span>
</pre></div>
</div>
<p>Que no coincidan las claves puede suponer una suplantación de identidad… o que
las claves cambiaron en el servidor por alguna razón. Si la razón es esta
segunda, la solución está incluida en el mensaje de advertenca, y es borrar el
<em>fingerprint</em> asociado al servidor:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">pepe@cliente$ </span>ssh-keygen<span class="w"> </span>-R<span class="w"> </span>servidor
<span class="gp"># </span>Host<span class="w"> </span>servidor<span class="w"> </span>found:<span class="w"> </span>line<span class="w"> </span><span class="m">1</span>
<span class="go">/home/josem/.ssh/known_hosts updated.</span>
<span class="go">Original contents retained as /home/josem/.ssh/known_hosts.old</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p><strong class="program">Putty</strong> también almacena el <em>fingerprint</em> del servidor, pero
a diferencia de éste, no rechaza la conexión cuando detecta un cambio en la
clave, sino que advierte del peligro de seguridad y permite aceptar (o no) la
nueva clave.</p>
</div>
</section>
</section>
<section id="ssh-auth-claves">
<span id="identificacion-del-cliente"></span><h3><span class="section-number">4.5.4.1.2. </span>Identificación del cliente<a class="headerlink" href="#ssh-auth-claves" title="Link to this heading">¶</a></h3>
<p>Obviamente, nos referimos a su identificación mediante clave y no mediante
contraseña. Por supuesto, la identificación exige primero la creación de las
claves y que el servidor acepte este tipo de identificación:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>/usr/sbin/sshd<span class="w"> </span>-T<span class="w"> </span><span class="p">|</span><span class="w"> </span>grep<span class="w"> </span>-i<span class="w"> </span>^Pubkey
<span class="go">pubkeyauthentication yes</span>
</pre></div>
</div>
<section id="cliente-openssh">
<h4><span class="section-number">4.5.4.1.2.1. </span>Cliente <em>openssh</em><a class="headerlink" href="#cliente-openssh" title="Link to this heading">¶</a></h4>
<p>En este caso, la generación es sencilla. La orden:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>ssh-keygen<span class="w"> </span>-t<span class="w"> </span>ecdsa<span class="w"> </span>-C<span class="w"> </span><span class="s2">&quot;Comentario alusivo a la clave&quot;</span>
</pre></div>
</div>
<p>generará una clave de tipo <abbr title="Elliptic Curve Digital Signature Algorithm">ECDSA</abbr> y, como fichero, se escogerá el
predeterminado para este tipo de clave (<code class="file docutils literal notranslate"><span class="pre">~/.ssh/id_ecdsa</span></code> y
<code class="file docutils literal notranslate"><span class="pre">~/.ssh/id_ecdsa.pub</span></code>, para la clave pública). Si no se altera la
configuración, en el momento en que intentemos conectar a cualquier servidor se
intentará usar esta clave para la autenticación. Tras generar la pareja de
claves se nos pide una <em>clave de paso</em>, que no es más que una contraseña con la
que cifrar la clave privada. Fijarla obliga a escribir tal contraseña antes de
usarla y nos asegura ante un hurto de las claves.</p>
<p id="index-1"><span id="ssh-copy-id"></span>Es obvio, que no basta con generar la clave en el cliente: en el servidor debe
alojarse la clave pública para que, cuando se produzca la comunicación, pueda
asegurarse que quien se conecta desde el cliente es el propietario de la clave
privada correspondiente. Para ello, puede hacerse:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>ssh-copy-id<span class="w"> </span>usuario@servidor
</pre></div>
</div>
<p>que subirá la clave<a class="footnote-reference brackets" href="#id17" id="id4" role="doc-noteref"><span class="fn-bracket">[</span>4<span class="fn-bracket">]</span></a> al fichero del servidor que almacena las claves
públicas (<code class="file docutils literal notranslate"><span class="pre">~./ssh/authorized_keys</span></code>)<a class="footnote-reference brackets" href="#id18" id="id5" role="doc-noteref"><span class="fn-bracket">[</span>5<span class="fn-bracket">]</span></a>. A partir de ahora, al intentar
ingresar en el servidor, se usará en primer término la identificación mediante
el certificado y se nos pedirá la clave de paso (ya que hay que usar la clave
privada) o nada, si no se introdujo contraseña al generar las claves.</p>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>No obstante, lo anterior, es posible usar claves almacenadas en otros
ficheros. Por ejemplo:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>ssh-keygen<span class="w"> </span>-t<span class="w"> </span>ecdsa<span class="w"> </span>-f<span class="w"> </span>.ssh/id_servidor<span class="w"> </span>-C<span class="w"> </span><span class="s2">&quot;Clave para &#39;servidor&#39;&quot;</span>
<span class="gp">$ </span>ssh-copy-id<span class="w"> </span>-i<span class="w"> </span>.ssh/id_servidor<span class="w"> </span>usuario@servidor
<span class="gp">$ </span>ssh<span class="w"> </span>-i<span class="w"> </span>.ssh/id_servidor<span class="w"> </span>usuario@servidor
</pre></div>
</div>
<p>e incluso indicar cuál es el nombre de la clave en la configuración:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">Host svm</span>
<span class="go">   Hostname       servidor</span>
<span class="go">   User           usuario</span>
<span class="go">   IdentityFile   ~/.ssh/id_%h</span>
</pre></div>
</div>
<p>de manera que cuando conectemos a <em>servidor</em> siempre usemos
<code class="file docutils literal notranslate"><span class="pre">~/.ssh/id_servidor</span></code><a class="footnote-reference brackets" href="#id19" id="id6" role="doc-noteref"><span class="fn-bracket">[</span>6<span class="fn-bracket">]</span></a>.</p>
</div>
</section>
<section id="cliente-putty">
<h4><span class="section-number">4.5.4.1.2.2. </span>Cliente <strong class="program">putty</strong><a class="headerlink" href="#cliente-putty" title="Link to this heading">¶</a></h4>
<p>Debemos efectuar las mismas acciones que en el caso anterior. El equivalente a
<strong class="command">ssh-keygen</strong> en la suite de <strong class="program">putty</strong> es <strong class="program">puttygen</strong>.
Al generar el par de claves (<code class="docutils literal notranslate"><span class="pre">Generate</span></code>) el programa quedará esperando que
movamos aletariamente el ratón por encima de la superficie vacía a fin de lograr
mayor aletoriedad:</p>
<img alt="Captura de puttygen" src="../../_images/puttygen.png" />
<p>Al acabar la generación, se podrá escribir un comentario y la clave de paso o
contraseña de la propia clave. Podemos entonces guardar la clave privada (<code class="docutils literal notranslate"><span class="pre">Save</span>
<span class="pre">private</span> <span class="pre">key</span></code>), pero la clave pública no es de poca ayuda, puesto que no tiene
el mismo formato que las claves que genera Open<abbr title="Security SHell">SSH</abbr>. Sin embargo, la clave
pública, tal y como la exige Open<abbr title="Security SHell">SSH</abbr>, se muestra en la propia pantalla con
lo que se puede copiar y pegar en un fichero:</p>
<img alt="Captura de puttygen" src="../../_images/puttygen2.png" />
<p>Dado que ahora no disponemos de <strong class="command">ssh-id-copy</strong>, hay que subir manualmente
la clave pública al servidor para incluirla en en <code class="file docutils literal notranslate"><span class="pre">~/.ssh/authorized_keys</span></code>.
Quizás lo más sencillo es abrir una sesión de <strong class="program">putty</strong> y copiar
contenido de la clave pública directamente sobre el fichero anterior, en vez de
en un fichero cualquiera del cliente <em>windows</em>.</p>
</section>
</section>
</section>
<section id="certificados">
<span id="ssh-auth-certs"></span><h2><span class="section-number">4.5.4.2. </span>Certificados<a class="headerlink" href="#certificados" title="Link to this heading">¶</a></h2>
<p>Autenticar con <a class="reference internal" href="../../98.apendice/01.cryto/03.aplicaciones/01.certdig.html#cert-digital"><span class="std std-ref">certificados digitales</span></a> en vez de con
simples claves presenta algunas ventajas<a class="footnote-reference brackets" href="#id20" id="id7" role="doc-noteref"><span class="fn-bracket">[</span>7<span class="fn-bracket">]</span></a>:</p>
<ul class="simple">
<li><p>Un cambio de claves en el servidor, si la identificación de este ante el
cliente es con meras claves, provoca un aviso de suplantación, por cuanto el
cliente había almacenado ya su anterior clave. Es tan frecuente que de forma
legítima se presente el aviso que se corre el riesgo de que el cliente no
le dé ninguna importancia de seguridad. Un certificado de servidor lo evita.</p></li>
<li><p>En la autenticación de clientes, un mismo cliente tendrá que subir a todos los
servidores la clave pública con la que pretende identificarse.</p></li>
<li><p>Los certificados pueden expedirse con un periodo de tiempo limitado.</p></li>
<li><p>Los certificados pueden especificar qué extras se le permiten o vetan al
propietario (p.e. podríamos estar interesados en que el cliente pudiera
acceder al servidor, pero que en ningún caso pudiera usarlo para tunelizar<a class="footnote-reference brackets" href="#id21" id="id8" role="doc-noteref"><span class="fn-bracket">[</span>8<span class="fn-bracket">]</span></a>).</p></li>
</ul>
<p>Para crear <a class="reference internal" href="../../98.apendice/01.cryto/03.aplicaciones/01.certdig.html#cert-digital"><span class="std std-ref">certificados</span></a> podemos partir de las claves
públicas que hemos visto en el epígrafe anterior. Estos certificados <abbr title="Security SHell">SSH</abbr> no
son <a class="reference internal" href="../../98.apendice/01.cryto/03.aplicaciones/01.certdig.html#x-509"><span class="std std-ref">certificados X.509</span></a>, como los usados en <abbr title="Secure Sockets Layer">SSL</abbr>, sino propios
de <abbr title="Security SHell">SSH</abbr>, y se generan utilizando nuestro ya conocido <a class="reference internal" href="#ssh-keygen"><span class="std std-ref">ssh-keygen</span></a>.</p>
<p>La idea es crear una <abbr title="Certification Authority">CA</abbr> que firme las claves públicas de clientes y servidores
con objeto de crear los certificados:</p>
<img alt="../../_images/CA-SSH.png" src="../../_images/CA-SSH.png" />
<p>Tal como se señala en el esquema se pueden tener dos parejas de claves:
<em>CA_host</em> para firmar certificados de servidor y <em>CA_user</em> para firmar
certificados de cliente:</p>
<ul class="simple">
<li><p>Cualquier servidor remitirá su clave pública a la <abbr title="Certification Authority">CA</abbr> para obtener el
certificado correspondiente (resultado de firmar la clave con <em>CA_host</em>) y,
además, necesitará una copia de la clave pública <em>CA_user</em>, si quiere poder
autenticar clientes mediante certificado.</p></li>
<li><p>Cualquier cliente remitirá su clave pública a la <abbr title="Certification Authority">CA</abbr> para obtener el
certificado correspondiente (resultado de firmar la clave con <em>CA_user</em>) y,
además, necesitará una copia de la clave pública <em>CA_host</em>, si quiere poder
identificar clientes mediante certificado.</p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>Por supuesto, las dos parejas de claves pueden ser la misma.</p>
</div>
<p>A partir de ahora trabajaremos sobre tres máquinas:</p>
<ul class="simple">
<li><p>La que hace de <abbr title="Certification Authority">CA</abbr> que es aquella que contiene las claves de <abbr title="Certification Authority">CA</abbr> y que
se encarga de firmar los certificados de las demás</p></li>
<li><p>Una máquina que hace el papel de servidor <abbr title="Security SHell">SSH</abbr>.</p></li>
<li><p>Una máquina que hace el papel de cliente <abbr title="Security SHell">SSH</abbr>.</p></li>
</ul>
<p>Para indicar en qué máquina estamos actuando al ejecutar una orden, utilizaremos
el <em>prompt</em>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">root@ca:~#</span>
<span class="gp">root@servidor:~#</span>
<span class="gp">pepe@cliente:~$</span>
</pre></div>
</div>
<section id="id9">
<h3><span class="section-number">4.5.4.2.1. </span>Identificación del servidor<a class="headerlink" href="#id9" title="Link to this heading">¶</a></h3>
<p>Partimos de <a class="reference internal" href="#ssh-server-keys"><span class="std std-ref">tener ya las claves del servidor</span></a> y nuestra
intención es que los clientes sean capaces de identificar al servidor mediante
certificado. Debemos antes de nada generar las claves para firmar certificados
de servidor:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">root@ca:~# </span>ssh-keygen<span class="w"> </span>-t<span class="w"> </span>ecdsa<span class="w"> </span>-f<span class="w"> </span>/etc/ssh/ca_host<span class="w"> </span>-C<span class="w"> </span><span class="s2">&quot;Clave de CA para servidores&quot;</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>Usamos claves de tipo ecdsa para evitar problemas con versiones de
Open<abbr title="Security SHell">SSH</abbr> por encima de la 8.1. Para más información, consulte <a class="reference external" href="https://ibug.io/blog/2020/04/ssh-8.2-rsa-ca/">esta
entrada de iBug</a>.</p>
</div>
<p>Con esta pareja de claves operativas, debemos pasar las claves públicas del
servidor a la máquina <em>ca</em> para que puedan ser firmadas (esto es, generado el
certificado):</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">root@servidor:~$ </span>scp<span class="w"> </span>/etc/ssh/ssh_host_*key.pub<span class="w"> </span>ca:/tmp
</pre></div>
</div>
<p>y una vez en ella, firmarlas para crear el certificado:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">root@ca:~# </span>ssh-keygen<span class="w"> </span>-h<span class="w"> </span>-s<span class="w"> </span>/etc/ssh/ca_host<span class="w"> </span>-I<span class="w"> </span>s_hostID<span class="w"> </span>-n<span class="w"> </span>example.net,www.example.net<span class="w"> </span>-z1<span class="w"> </span>/tmp/ssh_host_*key.pub
<span class="gp">root@ca:~# </span>scp<span class="w"> </span>/tmp/ssh_host_*-cert.pub<span class="w"> </span>servidor:/etc/ssh
</pre></div>
</div>
<div class="admonition warning">
<p class="admonition-title">Advertencia</p>
<p>Se ha supuesto que la clave de la <abbr title="Certification Authority">CA</abbr> es <abbr title="Elliptic Curve Digital Signature Algorithm">ECDSA</abbr> como se recomendo
poco más arriba. Si la clave, no obstante, es <abbr title="Rivest, Shamir y Adleman">RSA</abbr>, aun podremos firmar,
pero deberemos asegurarmos de que el algoritmo de <em>Hash</em> no es <abbr title="Secure Hash Algorithm">SHA</abbr>1
(<em>ssh-rsa</em>) añadiendo a la orden expresamente que se usa <abbr title="Secure Hash Algorithm">SHA</abbr>2 con
<code class="code docutils literal notranslate"><span class="pre">-t</span> <span class="pre">rsa-sha2-512</span></code>. Sólo así evitaremos problemas con versiones a partir
de la <em>8.2</em>. Este misma advertencia es aplicable a la firma de certificados
para clientes.</p>
</div>
<p>La orden genera certificados de servidor (gracias a <kbd class="kbd docutils literal notranslate">-h</kbd>), firmados
(<kbd class="kbd docutils literal notranslate">-s</kbd>) con <code class="file docutils literal notranslate"><span class="pre">ca_host</span></code>, con un determinado identificador (<kbd class="kbd docutils literal notranslate">-I</kbd>), un número de serie (<kbd class="kbd docutils literal notranslate">-z</kbd>) que debería ser único, y
que son válidos para una máquina llamada <em>example.net</em> o <em>www.example.net</em>.
Podríamos haber definido una validez determinada con <kbd class="kbd docutils literal notranslate">-V</kbd>, pero por ser
estos certificados de servidor los haremos eternos.</p>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>Los comodines no funcionan para definir nombres de servidor válidos.
Por tanto, algo como <kbd class="kbd compound docutils literal notranslate"><kbd class="kbd docutils literal notranslate">-n</kbd> <kbd class="kbd docutils literal notranslate">&quot;*.example,example.net&quot;</kbd></kbd> no valdrá para que
el certificado sea aplicable a la máquina <em>www.example.net</em>.</p>
</div>
<p>Una vez que los certificados se remiten al servidor y se almacenan en
<kbd class="kbd docutils literal notranslate">/etc/ssh</kbd> debemos modificar la configuración del servidor para que los
use:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">root@servidor:~# </span><span class="nb">printf</span><span class="w"> </span><span class="s2">&quot;HostCertificate %s\n&quot;</span><span class="w"> </span>/etc/ssh/ssh_host_*-cert.pub<span class="w"> </span>&gt;&gt;<span class="w"> </span>/etc/ssh/sshd_config
<span class="gp">root@servidor:~# </span>invoke-rc.d<span class="w"> </span>ssh<span class="w"> </span>reload
</pre></div>
</div>
<p>Y con esto, hemos completado la configuración en él. Ahora debemos lograr que
los clientes confien en cualquier certificado firmado por nuestra <abbr title="Certification Authority">CA</abbr>. Para ello debemos copiar la clave pública de la <abbr title="Certification Authority">CA</abbr> en el cliente:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">root@ca:~# </span>scp<span class="w"> </span>/etc/ssh/CA_host.pub<span class="w"> </span>cliente:/tmp
</pre></div>
</div>
<p>con objeto de añadirla a <code class="file docutils literal notranslate"><span class="pre">~/.ssh/known_hosts</span></code> (o <code class="file docutils literal notranslate"><span class="pre">/etc/ssh/ssh_known_hosts</span></code> si se quiere que afecte a todos los usuarios):</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">pepe@cliente:~# </span><span class="nb">echo</span><span class="w"> </span><span class="s2">&quot;@cert-authority *.example.net,example.net,*.example.com,example.com </span><span class="k">$(</span>cat<span class="w"> </span>/tmp/CA_host.pub<span class="k">)</span><span class="s2">&quot;</span><span class="w"> </span>&gt;&gt;<span class="w"> </span>/etc/ssh/ssh_known_hosts
</pre></div>
</div>
<p>Obsérvese que es necesario indicar <kbd class="kbd compound docutils literal notranslate"><kbd class="kbd docutils literal notranslate">&#64;cert</kbd>-<kbd class="kbd docutils literal notranslate">authority</kbd></kbd> para expresar que la clave es una clave de <abbr title="Certification Authority">CA</abbr> que tiene validez para todas las máquinas cuyo nombre se especifica a continuación (pueden añadirse también direcciones <abbr title="Internet Protocol">IP</abbr>). Hecho esto, se aceptará la conexión con el servidor, aunque nunca antes la hubiéramos hecho, y no registrará la clave pública del servidor en el archivo <code class="file docutils literal notranslate"><span class="pre">~/.ssh/known_hosts</span></code>.</p>
</section>
<section id="id10">
<h3><span class="section-number">4.5.4.2.2. </span>Identificación del cliente<a class="headerlink" href="#id10" title="Link to this heading">¶</a></h3>
<p>Para que el cliente pueda autenticarse en el servidor, también pueden utilizarse certificados. Generemos primero unas claves de <abbr title="Certification Authority">CA</abbr> para firmar certificados de cliente:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">root@ca:~# </span>ssh-keygen<span class="w"> </span>-t<span class="w"> </span>ecdsa<span class="w"> </span>-f<span class="w"> </span>/etc/ssh/ca_user<span class="w"> </span>-C<span class="w"> </span><span class="s2">&quot;Clave de CA para clientes&quot;</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>Podríamos reaprovechar la pareja de claves anteriores, pero por pulcritud usaremos dos claves distintas.</p>
</div>
<p>Debemos pasar la clave al servidor para que este acepte clientes que tengan su certificado firmado con ella. Esto se logra añadiendo una línea a la configuración:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">root@servidor:~# </span>scp<span class="w"> </span>ca:/etc/ssh/ca_user.pub<span class="w"> </span>/etc/ssh
<span class="gp">root@servidor:~# </span><span class="nb">echo</span><span class="w"> </span><span class="s2">&quot;TrustedUserCAKeys /etc/ssh/ca_user.pub&quot;</span><span class="w"> </span>&gt;&gt;<span class="w"> </span>/etc/ssh/sshd_config
<span class="gp">root@servidor:~# </span>invoke-rc.d<span class="w"> </span>ssh<span class="w"> </span>reload
</pre></div>
</div>
<p class="rubric">Concesión</p>
<p>Y ahora, un usuario que desee autenticarse en tal servidor, deberá generar un par de claves para sí y pasarla a la <abbr title="Certification Authority">CA</abbr> para que se las firme:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">pepe@cliente:~$ </span>ssh-keygen<span class="w"> </span>-C<span class="w"> </span><span class="s2">&quot;Clave de pepe&quot;</span>
<span class="gp">pepe@cliente:~# </span>scp<span class="w"> </span>~/.ssh/id_rsa.pub<span class="w"> </span>ca:/tmp
</pre></div>
</div>
<p>La <abbr title="Certification Authority">CA</abbr> firmará esas claves:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">root@ca:~# </span>ssh-keygen<span class="w"> </span>-s<span class="w"> </span>/etc/ssh/ca_user<span class="w"> </span>-I<span class="w"> </span>u_pepeID<span class="w"> </span>-n<span class="w"> </span>pepe,root<span class="w"> </span>-z1<span class="w"> </span>-V<span class="w"> </span>+32w<span class="w"> </span>/tmp/id_rsa.pub
</pre></div>
</div>
<p>sin indicar la opción <kbd class="kbd docutils literal notranslate">-h</kbd>, porque esta es una clave de cliente, indicando con <kbd class="kbd docutils literal notranslate">-n</kbd> que la clave es válida para el usuario del servidor «pepe»<a class="footnote-reference brackets" href="#id22" id="id11" role="doc-noteref"><span class="fn-bracket">[</span>9<span class="fn-bracket">]</span></a> y el administrador del mismo, y que el certificado tiene una validez de 32 semanas a partir del momento en el que se firma:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">root@ca:~# </span>ssh-keygen<span class="w"> </span>-Lf<span class="w"> </span>/tmp/id_rsa.pub
<span class="go">id_rsa-cert.pub:</span>
<span class="go">        Type: ssh-rsa-cert-v01@openssh.com user certificate</span>
<span class="go">        Public key: RSA-CERT SHA256:eFEoGIJgDNFgiQycGvKXWc1FbJQOQljc90gjzRgI4uA</span>
<span class="go">        Signing CA: ECDSA SHA256:ibktBc6yzycepNgHWYpWWo4V7l0QmKn+q73nf8/9vXM</span>
<span class="go">        Key ID: &quot;u_pepeID&quot;</span>
<span class="go">        Serial: 1</span>
<span class="go">        Valid: from 2021-04-08T08:43:00 to 2021-11-18T08:44:34</span>
<span class="go">        Principals:</span>
<span class="go">                pepe</span>
<span class="go">                root</span>
<span class="go">        Critical Options: (none)</span>
<span class="go">        Extensions:</span>
<span class="go">                permit-X11-forwarding</span>
<span class="go">                permit-agent-forwarding</span>
<span class="go">                permit-port-forwarding</span>
<span class="go">                permit-pty</span>
<span class="go">                permit-user-rc</span>
</pre></div>
</div>
<p>Obsérvese que el certificado, además de limitar los usuarios con los que puede
autenticarse el propietario, también permite definir de qué <em>extras</em> puede
hacer uso (sección <kbd class="kbd docutils literal notranslate">Extensions</kbd>). Los que apareen listados son los
habilitados por defecto. Sin embargo, podemos modificarlos mediante la opción
<kbd class="kbd docutils literal notranslate">-O</kbd>. Por ejemplo, <code class="code docutils literal notranslate"><span class="pre">-O</span> <span class="pre">no-X11-forwarding</span> <span class="pre">-O</span> <span class="pre">mo-port-forwarding</span></code>
impediría al usuario identificado con el certificado mostrar en el escritorio
local la ejecución aplicaciones gráficas en el servidor y <a class="reference internal" href="03.tuneles.html#tunel-ssh"><span class="std std-ref">hacer túneles</span></a>.</p>
<p>Por último, el usuario en el cliente deberá obtener el certificado y guardarlo dentro de <code class="file docutils literal notranslate"><span class="pre">~/.ssh</span></code>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">pepe@cliente:~# </span>scp<span class="w"> </span>ca:/tmp/id_rsa-cert.pub<span class="w"> </span>~/.ssh
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>Obsérvese que con la configuración actual del servidor, un usuario podrá
acceder al servidor tanto mediante una clave pública convertida en
certificado como por una clave pública que no ha acreditado la <abbr title="Certification Authority">CA</abbr>, si la sube
con <a class="reference internal" href="#ssh-copy-id"><span class="std std-ref">ssh-copy-id</span></a>. Esto puede hacer inútil
la intención del administrador de añadir ciertas limitaciones al certificado
(p.e. temporales) en la medida en que, una vez obtenido el certificado, el
usuario puede utilizar <strong class="command">ssh-copy-id</strong> para subir la clave al archivo
<code class="file docutils literal notranslate"><span class="pre">authorized_keys</span></code> de su perfil remoto. Para evitarlo, podemos
deshabilitar la lectura de estos archivos personales añadiendo a
<code class="file docutils literal notranslate"><span class="pre">sshd_config</span></code>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">AuthorizedKeysFile      /dev/null</span>
</pre></div>
</div>
</div>
<p><strong class="program">Putty</strong> <a class="reference external" href="https://www.chiark.greenend.org.uk/~sgtatham/putty/wishlist/ssh2-openssh-certkeys.html">desde agosto de 2022 soporta certificados SSH</a>
tanto para acreditación del servidor como del usuario cliente. A diferencia de
las claves, el certificado no tiene formato propio y, de hecho, no puede
generarse con <strong class="program">Puttygen</strong>:</p>
<img alt="../../_images/putty-cert.png" src="../../_images/putty-cert.png" />
<p>La captura representa la identificación del cliente con clave/certificado: la
clave privada tiene que tener el formato propio de <strong class="program">Putty</strong>, mientras
que el certificado es aquel que se obtiene directamente de <a class="reference internal" href="#ssh-keygen"><span class="std std-ref">ssh-keygen</span></a>.</p>
<p class="rubric">Revocación</p>
<p>Puede darse el caso de que necesitemos revocar certificados antes
de que expiren. Open<abbr title="Security SHell">SSH</abbr> prevee su revocación a través de
archivos <abbr title="Key Revocation List">KRL</abbr> que listan aquellos certificados que se ha
decidido revocar. Lo primero es indicar en
<code class="file docutils literal notranslate"><span class="pre">/etc/ssh/sshd_config</span></code> qué lista consultará el servidor:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">RevokedKeys     /etc/ssh/revoked_keys</span>
</pre></div>
</div>
<p>y tras ello, generar el archivo (en principio, vacío) y recargar
el servidor:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp"># </span>ssh-keygen<span class="w"> </span>-kf<span class="w"> </span>/etc/ssh/revoked_keys
<span class="gp"># </span>invoke-rc.d<span class="w"> </span>ssh<span class="w"> </span>reload
</pre></div>
</div>
<p>A partir de este momento, todo está listo para revocar
certificados cuando sea preciso. Si el administrador conserva el
certificado o la clave pública, puede hacerlo del siguiente
modo:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp"># </span>ssh-keygen<span class="w"> </span>-kuf<span class="w"> </span>/etc/ssh/revoked_keys<span class="w"> </span>-z1<span class="w"> </span>/path/id_rsa.pub
</pre></div>
</div>
<p>donde debe notarse la presencia de la opción <kbd class="kbd docutils literal notranslate">-u</kbd>, porque
permite conservar la lista y añadir un nuevo ítem. Si
prescindimos de ella, el contenido anterior del archivo, se
perdera. Además, <kbd class="kbd docutils literal notranslate">-z</kbd> permite definir la versión de la lista
mediante un entero (<strong>1</strong> en el ejemplo, porque es la primera
revisión). Hemos hecho la revocación, por otro lado, utilizando
la clave pública, pero habría sido igual de efectivo utilizar el
certificado (<code class="file docutils literal notranslate"><span class="pre">id_rsa-cert.pub</span></code>).</p>
<p>Ahora bien, la revocación también puede llevarse a cabo usando el
identificador del certificado (que se introdujo con <kbd class="kbd docutils literal notranslate">-I</kbd> al
crearlo) o su número de serie (introducido en su momento con
<kbd class="kbd docutils literal notranslate">-z)</kbd>. Para esto, sin embargo, se requiere facilitar la
clave privada de la <abbr title="Certification Authority">CA</abbr>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp"># </span>ssh-keygen<span class="w"> </span>-kuf<span class="w"> </span>/etc/ssh/revoked_keys<span class="w"> </span>-z2<span class="w"> </span>-s<span class="w"> </span>/etc/ssh/ca_user<span class="w"> </span>&lt;<span class="o">(</span><span class="nb">echo</span><span class="w"> </span><span class="s2">&quot;id: u_pepeID&quot;</span><span class="o">)</span>
<span class="gp"># </span>ssh-keygen<span class="w"> </span>-kuf<span class="w"> </span>/etc/ssh/revoked_keys<span class="w"> </span>-z3<span class="w"> </span>-s<span class="w"> </span>/etc/ssh/ca_user<span class="w"> </span>&lt;<span class="o">(</span><span class="nb">echo</span><span class="w"> </span><span class="s2">&quot;serial: 5&quot;</span><span class="o">)</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p><strong class="command">ssh-keygen</strong> sólo admite archivos como
argumento, así que, en realidad, «<kbd class="kbd compound docutils literal notranslate"><kbd class="kbd docutils literal notranslate">id:</kbd> <kbd class="kbd docutils literal notranslate">u_pepeID</kbd></kbd>» o
«<kbd class="kbd compound docutils literal notranslate"><kbd class="kbd docutils literal notranslate">serial:</kbd> <kbd class="kbd docutils literal notranslate">5</kbd></kbd>» deberían encontrarse en un archivo. Hemos
usado <a class="reference internal" href="../../02.conbas/08.redirecciones/01basica.html#bash-process-substitution"><span class="std std-ref">process substitution</span></a>
para evitarlo.</p>
<p>Además, para revocar varios certificados a la vez, pueden
incluirse varios archivos en la misma línea de órdenes como
argumento o, en el caso de que revoquemos con identificador o
número de serie, hacer un mismo archivo con varias líneas en
cada una de los cuales indiquemos un certificado distinto:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp"># </span>cat<span class="w"> </span>&gt;<span class="w"> </span>/tmp/revocaciones.txt
<span class="go">id: u_pepeID</span>
<span class="go">serial: 5</span>

<span class="gp"># </span>ssh-keygen<span class="w"> </span>-kuf<span class="w"> </span>/etc/ssh/revoked_keys<span class="w"> </span>-z2<span class="w"> </span>/tmp/revocaciones.txt
</pre></div>
</div>
</div>
<p>Finalmente, podemos consultar cuáles son los certificados
revocado contenidos en el <abbr title="Key Revocation List">KRL</abbr> mediante la orden:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp"># </span>ssh-keygen<span class="w"> </span>-Qlf<span class="w"> </span>/etc/ssh/revoked_keys
</pre></div>
</div>
</section>
</section>
<section id="openssh-y-openssl">
<span id="openssh-openssl"></span><h2><span class="section-number">4.5.4.3. </span>Open<abbr title="Security SHell">SSH</abbr> y Open<abbr title="Secure Sockets Layer">SSL</abbr><a class="headerlink" href="#openssh-y-openssl" title="Link to this heading">¶</a></h2>
<p>Dado que ambas aplicaciones usan <a class="reference internal" href="../../98.apendice/01.cryto/02.algo.html#asimetrico"><span class="std std-ref">cifrado asimétrico</span></a> y
algoritmos comunes, es posible hacer conversiones entre las claves generadas con
ellas. En principio:</p>
<ul>
<li><p>Pueden hacerse conversiones para claves <abbr title="Rivest, Shamir y Adleman">RSA</abbr> y <abbr title="Elliptic Curve Digital Signature Algorithm">ECDSA</abbr>. Las claves <abbr title="EDwards-curve Curve Digital Signature Algorithm">EdDSA</abbr> no
tienen soporte en <a class="reference internal" href="../../98.apendice/01.cryto/02.algo.html#openssl"><span class="std std-ref">OpenSSL</span></a>.</p></li>
<li><p>El formato para las claves públicas es distinto e incompatible, pero
<a class="reference internal" href="#ssh-keygen"><span class="std std-ref">ssh-keygen</span></a> es capaz de hacer conversiones entre ambos formatos.
Para obtener la clave pública en formato reconocible por Open<abbr title="Secure Sockets Layer">SSL</abbr>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp"># </span>ssh-keygen<span class="w"> </span>-e<span class="w"> </span>-f<span class="w"> </span>miclave.pub<span class="w"> </span>-m<span class="w"> </span>pkcs8<span class="w"> </span>&gt;<span class="w"> </span>miclave.pem
</pre></div>
</div>
<p>Y para el proceso inverso:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp"># </span>ssh-keygen<span class="w"> </span>-i<span class="w"> </span>-f<span class="w"> </span>miclave.pem<span class="w"> </span>-m<span class="w"> </span>pkcs8<span class="w"> </span>&gt;<span class="w"> </span>miclave.pub
</pre></div>
</div>
</li>
<li><p>El formato para las claves privadas era el mismo hasta no hace demasiado, pero
las últimas versiones de Open<abbr title="Security SHell">SSH</abbr> utilizan por defecto un formato
incompatible. En cualquier caso, el formato de Open<abbr title="Secure Sockets Layer">SSL</abbr> sigue soportado
por Open<abbr title="Security SHell">SSH</abbr>:. Así, si se tiene una clave privada en el formato de Open<abbr title="Security SHell">SSH</abbr>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>cp<span class="w"> </span>miclave<span class="w"> </span>miclave.key
<span class="gp">$ </span>ssh-keygen<span class="w"> </span>-p<span class="w"> </span>-f<span class="w"> </span>miclave.key<span class="w"> </span>-m<span class="w"> </span>pem
</pre></div>
</div>
<p>Y si se tiene una clave generada con Open<abbr title="Secure Sockets Layer">SSL</abbr>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>cp<span class="w"> </span>miclave.key<span class="w"> </span>miclave
<span class="gp">$ </span>ssh-keygen<span class="w"> </span>-p<span class="w"> </span>-f<span class="w"> </span>miclave
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>En estos casos <a class="reference internal" href="#ssh-keygen"><span class="std std-ref">ssh-keygen</span></a> genera el nuevo
formato sobrescribiendo el archivo, por lo que se hace necesaria la copia
previa.</p>
</div>
</li>
<li><p>Los formatos de <a class="reference internal" href="../../98.apendice/01.cryto/03.aplicaciones/01.certdig.html#cert-digital"><span class="std std-ref">certificado digital</span></a> son absolutamente
incompatibles y no hay conversión entre ellos, pero sí podemos tener sendos
certificados generados con el mismo par de claves.</p></li>
</ul>
<div class="admonition seealso">
<p class="admonition-title">Ver también</p>
<p>Puede echar una lectura a <a class="reference external" href="https://coolaj86.com/articles/openssh-vs-openssl-key-formats/">este artículo sobre formatos de claves
en ambas aplicaciones</a>.</p>
</div>
<section id="partiendo-de-openssh">
<h3><span class="section-number">4.5.4.3.1. </span>Partiendo de Open<abbr title="Security SHell">SSH</abbr><a class="headerlink" href="#partiendo-de-openssh" title="Link to this heading">¶</a></h3>
<p>Si tenemos un par de claves, las habremos generado así (para que sean <abbr title="Elliptic Curve Digital Signature Algorithm">ECDSA</abbr>
habrá que añadir <kbd class="kbd compound docutils literal notranslate"><kbd class="kbd docutils literal notranslate">-t</kbd> <kbd class="kbd docutils literal notranslate">ecdsa</kbd></kbd>):</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>ssh-keygen<span class="w"> </span>-f<span class="w"> </span>miclave
</pre></div>
</div>
<p>lo cual creará los archivos de clave <code class="file docutils literal notranslate"><span class="pre">miclave</span></code> y <code class="file docutils literal notranslate"><span class="pre">miclave.pub</span></code>, ambas
en formato incomprensible para Open<abbr title="Secure Sockets Layer">SSL</abbr>. Para convertir podremos hacer:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>cp<span class="w"> </span>miclave<span class="w"> </span>miclave.key
<span class="gp">$ </span>ssh-keygen<span class="w"> </span>-p<span class="w"> </span>-f<span class="w"> </span>miclave.key<span class="w"> </span>-m<span class="w"> </span>pem
</pre></div>
</div>
<p>Y la clave pública la podremoe obtener a partir de la clave privada usando Open<abbr title="Secure Sockets Layer">SSL</abbr>, La orden exacta dependerá de si la clave es <abbr title="Rivest, Shamir y Adleman">RSA</abbr> o <abbr title="Elliptic Curve Digital Signature Algorithm">ECDSA</abbr>. Podemos
también usar <strong class="command">ssh-keygen</strong> para obtener la clave pública<a class="footnote-reference brackets" href="#id23" id="id12" role="doc-noteref"><span class="fn-bracket">[</span>10<span class="fn-bracket">]</span></a>, que no
presenta diferencias sea una u otra la clave:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>ssh-keygen<span class="w"> </span>-e<span class="w"> </span>-f<span class="w"> </span>miclave.pub<span class="w"> </span>-m<span class="w"> </span>pkcs8
</pre></div>
</div>
</section>
<section id="partiendo-de-openssl">
<h3><span class="section-number">4.5.4.3.2. </span>Partiendo de Open<abbr title="Secure Sockets Layer">SSL</abbr><a class="headerlink" href="#partiendo-de-openssl" title="Link to this heading">¶</a></h3>
<p>Podemos haber generado unas claves <abbr title="Rivest, Shamir y Adleman">RSA</abbr>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>openssl<span class="w"> </span>genrsa<span class="w"> </span>-aes128<span class="w"> </span>-out<span class="w"> </span>miclave.key<span class="w"> </span><span class="m">4096</span>
<span class="gp">$ </span>openssl<span class="w"> </span>rsa<span class="w"> </span>-in<span class="w"> </span>miclave.key<span class="w"> </span>-pubout<span class="w"> </span>-out<span class="w"> </span>miclave.pem
</pre></div>
</div>
<p>o bien unas claves <abbr title="Elliptic Curve Digital Signature Algorithm">ECDSA</abbr><a class="footnote-reference brackets" href="#id24" id="id13" role="doc-noteref"><span class="fn-bracket">[</span>11<span class="fn-bracket">]</span></a>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>openssl<span class="w"> </span>ecparam<span class="w"> </span>-name<span class="w"> </span>prime256v1<span class="w"> </span>-genkey<span class="w"> </span>-noout<span class="w"> </span>-out<span class="w"> </span>miclave.key
<span class="gp">$ </span>openssl<span class="w"> </span>ec<span class="w"> </span>-in<span class="w"> </span>miclave.key<span class="w"> </span>-pubout<span class="w"> </span>-out<span class="w"> </span>miclave.pem
</pre></div>
</div>
<p>Sea como sea, el proceso de obtención de claves válidas para Open<abbr title="Security SHell">SSH</abbr> es el
mismo:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>ln<span class="w"> </span>-s<span class="w"> </span>miclave.key<span class="w"> </span>miclave
<span class="gp">$ </span>ssh-keygen<span class="w"> </span>-y<span class="w"> </span>-f<span class="w"> </span>miclave<span class="w"> </span>&gt;<span class="w"> </span>miclave.pub
<span class="gp">$ </span>sed<span class="w"> </span>-ri<span class="w"> </span><span class="s1">&#39;$s:$: Comentario para la clave&#39;</span><span class="w"> </span>miclave.pub
</pre></div>
</div>
<p>donde no hemos cambiado de formato la clave privada, porque Open<abbr title="Security SHell">SSH</abbr> soporta
el formato de Open<abbr title="Secure Sockets Layer">SSL</abbr> y hemos obtenido la clave pública a partir de la
privada (otra opción habría sido convertir desde la clave pública en el formato
de Open<abbr title="Secure Sockets Layer">SSL</abbr> <code class="file docutils literal notranslate"><span class="pre">miclave.pem</span></code>).</p>
<p class="rubric">Notas al pie</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id14" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id1">1</a><span class="fn-bracket">]</span></span>
<p>Hasta la versión <em>7.0</em>, también existía una versión <a class="reference external" href="https://es.wikipedia.org/wiki/DSA">DSA</a>, pero acabó por deshabilitarse su uso al
considerarla débil (véase <a class="reference external" href="http://www.openssh.com/legacy.html">la información relativa</a> par más información).</p>
</aside>
<aside class="footnote brackets" id="id15" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id2">2</a><span class="fn-bracket">]</span></span>
<p>Las líneas aparecen comentadas, pero recordemos que en este fichero las
directivas comentadas muestran el valor predeterminado.</p>
</aside>
<aside class="footnote brackets" id="id16" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id3">3</a><span class="fn-bracket">]</span></span>
<p>Este comportamiento se deriva de la configuración predeterminada de las
últimas versiones de debian:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>grep<span class="w"> </span>-w<span class="w"> </span>HashKnownHosts<span class="w"> </span>/etc/ssh/ssh_config
<span class="go">    HashKnownHosts yes</span>
</pre></div>
</div>
</aside>
<aside class="footnote brackets" id="id17" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id4">4</a><span class="fn-bracket">]</span></span>
<p>No especificamos dónde está la clave (opción <code class="docutils literal notranslate"><span class="pre">-i</span></code>), pero carece de
relevancia puesto que estamos usando los nombres predeterminados.</p>
</aside>
<aside class="footnote brackets" id="id18" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id5">5</a><span class="fn-bracket">]</span></span>
<p>Tal es así, que podríamos haber hecho la subida de forma artesanal:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>ssh<span class="w"> </span>usuario@servidor<span class="w"> </span><span class="s2">&quot;mkdir -p ~/.ssh; cat &gt;&gt; ~/.ssh/authorized_keys&quot;</span><span class="w"> </span>&lt;<span class="w"> </span>~/.ssh/id_ecdsa.pub
</pre></div>
</div>
</aside>
<aside class="footnote brackets" id="id19" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id6">6</a><span class="fn-bracket">]</span></span>
<p>Consúltese el apartado <strong>TOKENS</strong> de la página de manual de <em>ssh_config</em>
para entender por qué <code class="docutils literal notranslate"><span class="pre">%h</span></code> se convierte en el nombre de la máquina remota
(<em>servidor</em>).</p>
</aside>
<aside class="footnote brackets" id="id20" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id7">7</a><span class="fn-bracket">]</span></span>
<p>Para leer una larga disscusión sobre los inconvenientes, puede echar un
ojo a <a class="reference external" href="https://smallstep.com/blog/use-ssh-certificates/">ester artículo de smallsetp</a>.</p>
</aside>
<aside class="footnote brackets" id="id21" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id8">8</a><span class="fn-bracket">]</span></span>
<p>Es cierto que podemos utilizar la <a class="reference internal" href="01.basico.html#ssh-match"><span class="std std-ref">directiva Match</span></a> en
la configuración pero lograr un efecto semejante, pero utilizar certificados
para este fin es mucho más cómodo y evita la obligación de modificar la
configuración.</p>
</aside>
<aside class="footnote brackets" id="id22" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id11">9</a><span class="fn-bracket">]</span></span>
<p>Obsérvese que el ejemplo el usuario remoto (del cliente) es «pepe» (como
se observa en el <em>prompt</em>) y el usuario del servidor también se llama «pepe».
La opción <kbd class="kbd docutils literal notranslate">-n</kbd>, obviamente, refiere nombres de usuario del servidor.</p>
</aside>
<aside class="footnote brackets" id="id23" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id12">10</a><span class="fn-bracket">]</span></span>
<p>La orden de exportación puede hacerse utilizando como argumento de la
opción <kbd class="kbd docutils literal notranslate">-f</kbd> tanto la clave pública como la clave privada. Con la privada
se requerirá introducir la contraseña de cifrado.</p>
</aside>
<aside class="footnote brackets" id="id24" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id13">11</a><span class="fn-bracket">]</span></span>
<p>La clave privada no tendrá contraseña que la proteja. Si se quiere
proteger con una, habrá que añadir una orden más:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>openssl<span class="w"> </span>ec<span class="w"> </span>-in<span class="w"> </span>miclave.key<span class="w"> </span>-aes256<span class="w"> </span>-out<span class="w"> </span>miclave.crypt.key
</pre></div>
</div>
<p>Una alternativa es cambiar la clave al formato <abbr title="Public-Key Cryptography Standards">PKCS</abbr>#8:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>openssl<span class="w"> </span>pkcs8<span class="w"> </span>-topk8<span class="w"> </span>-in<span class="w"> </span>miclave.key<span class="w"> </span>-out<span class="w"> </span>miclave.crypt.key
</pre></div>
</div>
</aside>
</aside>
</section>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
  <div>
    <h3><a href="../../index.html">Tabla de contenido</a></h3>
    <ul>
<li><a class="reference internal" href="#">4.5.4. Autenticación de clave pública</a><ul>
<li><a class="reference internal" href="#claves">4.5.4.1. Claves</a><ul>
<li><a class="reference internal" href="#identificacion-del-servidor">4.5.4.1.1. Identificación del servidor</a><ul>
<li><a class="reference internal" href="#claves-en-el-servidor">4.5.4.1.1.1. Claves en el servidor</a></li>
<li><a class="reference internal" href="#claves-en-el-cliente">4.5.4.1.1.2. Claves en el cliente</a></li>
</ul>
</li>
<li><a class="reference internal" href="#ssh-auth-claves">4.5.4.1.2. Identificación del cliente</a><ul>
<li><a class="reference internal" href="#cliente-openssh">4.5.4.1.2.1. Cliente <em>openssh</em></a></li>
<li><a class="reference internal" href="#cliente-putty">4.5.4.1.2.2. Cliente <strong class="program">putty</strong></a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#certificados">4.5.4.2. Certificados</a><ul>
<li><a class="reference internal" href="#id9">4.5.4.2.1. Identificación del servidor</a></li>
<li><a class="reference internal" href="#id10">4.5.4.2.2. Identificación del cliente</a></li>
</ul>
</li>
<li><a class="reference internal" href="#openssh-y-openssl">4.5.4.3. Open<abbr title="Security SHell">SSH</abbr> y Open<abbr title="Secure Sockets Layer">SSL</abbr></a><ul>
<li><a class="reference internal" href="#partiendo-de-openssh">4.5.4.3.1. Partiendo de Open<abbr title="Security SHell">SSH</abbr></a></li>
<li><a class="reference internal" href="#partiendo-de-openssl">4.5.4.3.2. Partiendo de Open<abbr title="Secure Sockets Layer">SSL</abbr></a></li>
</ul>
</li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>Tema anterior</h4>
    <p class="topless"><a href="01.basico.html"
                          title="capítulo anterior"><span class="section-number">4.5.1. </span>Instalación</a></p>
  </div>
  <div>
    <h4>Próximo tema</h4>
    <p class="topless"><a href="03.tuneles.html"
                          title="próximo capítulo"><span class="section-number">4.5.5. </span>Túneles</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>Esta página</h3>
    <ul class="this-page-menu">
      <li><a href="../../_sources/04.servidor/10.ssh/02.certificados.rst.txt"
            rel="nofollow">Mostrar el código</a></li>
    </ul>
   </div>
<search id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Búsqueda rápida</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Ir a" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="Related">
      <h3>Navegación</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="Índice General"
             >índice</a></li>
        <li class="right" >
          <a href="03.tuneles.html" title="4.5.5. Túneles"
             >siguiente</a> |</li>
        <li class="right" >
          <a href="01.basico.html" title="4.5.1. Instalación"
             >anterior</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">documentación de Linuxnomicón - rolling</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" ><span class="section-number">4. </span>Gestión del servidor</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="index.html" ><span class="section-number">4.5. </span>Administración remota</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href=""><span class="section-number">4.5.4. </span>Autenticación de clave pública</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
    &#169; Copyright CC BY 4.0, 2016-2025, José Miguel Sánchez Alés.
      Creado usando <a href="https://www.sphinx-doc.org/">Sphinx</a> 8.1.3.
    </div>
  </body>
</html>