


<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" lang="es">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>4.5.6. Aspectos adicionales &#8212; documentación de Linuxnomicón - rolling</title>
    <link rel="stylesheet" href="../../_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../_static/custom.css" />
    
    <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../_static/language_data.js"></script>
    <script type="text/javascript" src="../../_static/translations.js"></script>
    <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <link rel="index" title="Índice" href="../../genindex.html" />
    <link rel="search" title="Búsqueda" href="../../search.html" />
    <link rel="next" title="5. Dispositivos de almacenamiento" href="../../05.discos/index.html" />
    <link rel="prev" title="4.5.5. Túneles" href="03.tuneles.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navegación</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="Índice General"
             accesskey="I">índice</a></li>
        <li class="right" >
          <a href="../../05.discos/index.html" title="5. Dispositivos de almacenamiento"
             accesskey="N">siguiente</a> |</li>
        <li class="right" >
          <a href="03.tuneles.html" title="4.5.5. Túneles"
             accesskey="P">anterior</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">documentación de Linuxnomicón - rolling</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" >4. Gestión del servidor</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="index.html" accesskey="U">4.5. Administración remota</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="aspectos-adicionales">
<h1>4.5.6. Aspectos adicionales<a class="headerlink" href="#aspectos-adicionales" title="Enlazar permanentemente con este título">¶</a></h1>
<div class="section" id="transferencia-de-ficheros">
<h2>4.5.6.1. Transferencia de ficheros<a class="headerlink" href="#transferencia-de-ficheros" title="Enlazar permanentemente con este título">¶</a></h2>
<p>El protocolo <abbr title="Security SHell">SSH</abbr> permite también la transferencia de ficheros entre cliente y
servidor. Aunque puede <a class="reference internal" href="../../07.serre/01.ftp/03.ssh.html#ssh-ftp"><span class="std std-ref">configurarse de modo que sustituya perfectamente a
un servidor FTP</span></a>, por ahora nos limitaremos a usar la configuración
predeterminada y ver los clientes que nos permiten esta tarea.</p>
<p id="scp"><span id="index-0"></span>La primera forma de aprovechar las posibilidades de transferencia es usar una
herramienta de <em>copia remota</em> (<strong class="command">scp</strong> proporcionada por <em>openssh</em> o
<strong class="command">pscp.exe</strong> de la suite de <strong class="program">putty</strong>). El modo de usarlo es muy
semejante al de la orden <strong class="command">cp</strong> del mundo <em>unix</em>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> scp /path/local/fichero.txt usuario@servidor:path/en/el/servidor
</pre></div>
</div>
<p>es decir, un <em>origen</em> (en este caso un fichero del cliente) y un destino que se
expresa como al conectarnos con el cliente <strong class="command">ssh</strong> seguido de dos puntos.
Si la ruta en el servidor es relativa se sobreentiende que lo es respecto al
directorio peronal del usuario. Si no se expresa ruta alguna, el fichero se
copiará en el directorio personal. En el ejemplo, el origen es local y el
destino remoto, por lo que la consecuencia es que <em>subimos</em> el fichero al
servidor. Para descargar no hay más que escoger un origen remoto y un destino
local<a class="footnote-reference" href="#id11" id="id1">[1]</a>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> scp usuario@servidor:fichero_remoto.txt .
</pre></div>
</div>
<p id="sftp"><span id="index-1"></span>La segunda forma de transferir ficheros es usar un cliente <em>[s]ftp</em>, similiar al
cliente del <abbr title="File Transfer Protocol">FTP</abbr> tradicional. <em>openssh</em> proporciona <strong class="command">sftp</strong>, y
<strong class="program">putty</strong> su equivalente <strong class="command">psftp</strong></p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> sftp usuario@servidor
<span class="go">sftp&gt; put fichero_local</span>
<span class="go">sftp&gt; get fichero_remoto</span>
</pre></div>
</div>
<p>Algunos clientes gráficos de <abbr title="File Transfer Protocol">FTP</abbr> como <a class="reference external" href="https://filezilla-project.org/">filezilla</a>, soportan también el protocolo <em>sFTP</em>.</p>
<div class="admonition note">
<p class="first admonition-title">Nota</p>
<p class="last">Tanto <strong class="command">scp</strong> como <strong class="command">sftp</strong> hacen uso de la
configuración contenida en <code class="file docutils literal notranslate"><span class="pre">~/.ssh/config</span></code>, por lo que podremos
aprovechar las conexiones con nombre que hayamos creado en él.</p>
</div>
<p id="sshfs"><span id="index-2"></span>El tercer método para tranferir ficheros en sistemas <em>unix</em> es montar algún
directorio remoto del servidor en el cliente gracias a <strong class="program">sshfs</strong>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> sshfs usuario@servidor: /tmp/ssh
</pre></div>
</div>
<p>De este modo, podremos traer y llevar ficheros de modo transparente haciendo uso
de las herramientas habituales (<strong class="command">cp</strong>, <strong class="command">mv</strong>, etc). Para
desmontar el fichero (si no somos el administrador) puede hacerse:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> fusermount -u /tmp/ssh
</pre></div>
</div>
</div>
<div class="section" id="trampolin-de-acceso">
<span id="ssh-traampolin"></span><h2>4.5.6.2. Trampolín de acceso<a class="headerlink" href="#trampolin-de-acceso" title="Enlazar permanentemente con este título">¶</a></h2>
<p>Un servidor <abbr title="Security SHell">SSH</abbr> puede usarse como trampolín de acceso a servicios
inaccesibles, bien porque se encuentran en máquinas que no son accesibles desde
internet, bien porque, aunque lo sean, tengamos restringido su acceso.</p>
<ol class="arabic">
<li><p class="first">El método más simple y universal es establecer <a class="reference internal" href="03.tuneles.html#ssh-socks"><span class="std std-ref">un túnel dinámico</span></a>, tal como se explicó anteriormente.</p>
</li>
<li><p class="first">Para el caso particular de que queramos acceder a un servidor <abbr title="Security SHell">SSH</abbr>
inaccesible a través de otro servidor <abbr title="Security SHell">SSH</abbr> que sí es accesible podemos usar
<em>ProxyCommand</em>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> ssh -o <span class="s2">&quot;ProxyCommand ssh usuario1@servidor_accesible nc -q0 %h %p&quot;</span> usuario2@servidor_inaccesible
</pre></div>
</div>
<p>En este caso, antes de que el cliente <strong class="command">ssh</strong> intente cualquier
comunicación, usamos otro cliente que accede al servidor accesible y ejecuta
<a class="reference internal" href="../../02.conbas/99.misc/05.ordenes.html#netcat"><span class="std std-ref">netcat</span></a> para enchufarnos al servicio <abbr title="Security SHell">SSH</abbr> del inaccesible.
<strong class="program">netcat</strong> nos ofrece acceso crudo a tal servicio lo cual es
precisamente lo que necesitamos porque tenemos un cliente <strong class="command">ssh</strong>
esperando iniciar una conexión.</p>
<p>El único pero de este método es que necesitamos que el servidor accesible
tenga instalado <strong class="command">netcat</strong>. Sin embargo, a partir de la versión <em>5.4</em>
del cliente, <strong class="command">ssh</strong> tiene la opción <code class="docutils literal notranslate"><span class="pre">-W</span></code>, que sirve para suplir el
papel de <strong class="program">netcat</strong>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> ssh -o <span class="s2">&quot;ProxyCommand ssh -W %h:%p usuario1@servidor_accesible&quot;</span> usuario2@servidor_inaccesible
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Nota</p>
<p>A partir de la versión <em>7.2</em> usar un servidor <abbr title="Security SHell">SSH</abbr> como trampolín
para el acceso a otro es aún más fácil, porque se añade la opción
<em>ProxyJump</em>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> ssh -o <span class="s2">&quot;ProxyJump usuario1@servidor_accesible&quot;</span> usuario2@servidor_inaccesible
</pre></div>
</div>
<p>que incluso tiene una opción propio <kbd class="kbd docutils literal notranslate">-J</kbd>, que simplifica aún más la
sintaxis:</p>
<div class="last highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> ssh -J usuario1@servidor_accesible usuario2@servidor_inaccesible
</pre></div>
</div>
</div>
<p>Con <strong class="program">putty</strong> podemos hacer otro tanto, sabiendo que entre los
programas de la <em>suite</em> de <strong class="program">putty</strong> está <strong class="command">plink</strong> que es la
versión en línea de comandos del propio <strong class="program">putty</strong>. De este modo,
podemos configurar el programa así:</p>
<img alt="../../_images/SSHproxy_putty1.png" src="../../_images/SSHproxy_putty1.png" />
<img alt="../../_images/SSHproxy_putty2.png" src="../../_images/SSHproxy_putty2.png" />
<p>El comando es análogo al usado con <em>ProxyCommand</em> en <strong class="command">ssh</strong>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">C:\path\a\plink.exe %user@%proxyhost -nc %host %port</span>
</pre></div>
</div>
<div class="admonition-todo admonition" id="index-3">
<p class="first admonition-title">Por hacer</p>
<p class="last">Y, sin embargo.., no funciona.</p>
</div>
</li>
</ol>
</div>
<div class="section" id="persistencia-de-claves">
<span id="ssh-agent"></span><h2>4.5.6.3. Persistencia de claves<a class="headerlink" href="#persistencia-de-claves" title="Enlazar permanentemente con este título">¶</a></h2>
<div class="admonition note">
<p class="first admonition-title">Nota</p>
<p class="last">Este apartado sólo tiene interés cuando se usan clientes <em>linux</em>.</p>
</div>
<p>Ya se ha dicho muy a la ligera que el cliente de <em>openssh</em> sólo permite la
introducción de claves de manera interactiva, por lo que no hay opción que
permita pasarla al programa ni tampoco se lee esta de la entrada estándar. Si
optamos por el uso de certificados, podemos evitar la introducción de la
contraseña dejando la clave de paso en blanco, pero eso hace que ante un robo de
la clave privada, quedemos sin protección. Por otro lado, es posible que durante
nuestra sesión en el cliente necesitemos repetidamente acceder al servidor y, en
estos casos, será tedioso tener que estar repetidamente introduciendo la
contraseña.</p>
<p>Para paliar este inconveniente tenemos dos soluciones distintas, ambas basadas
en la autenticación con certificado y en <em>hacer coincidir la contraseña del
usuario local en el cliente con la clave de paso</em> que desbloquea la clave
privada.</p>
<div class="admonition warning">
<p class="first admonition-title">Advertencia</p>
<p class="last">Ambas soluciones exigen que la clave de paso sea la misma que la
contraseña del usuario en el cliente, es decir, si en el cliente somos el
usuario <em>pepe</em> con contraseña <em>pepesoyyo</em>, la clave de paso que debemos
escoger al crear el certificado debe ser <em>pepesoyyo</em>.</p>
</div>
<span class="target" id="index-4"></span><div class="section" id="index-5">
<span id="id2"></span><h3>4.5.6.3.1. <strong class="command">ssh-agent</strong><a class="headerlink" href="#index-5" title="Enlazar permanentemente con este título">¶</a></h3>
<p>Este programa permite almacenar claves de paso que luego se usarán cuando sea
necesario para desbloquear la clave privada. Su uso manual es el siguiente:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> ssh-agent
<span class="go">SSH_AUTH_SOCK=/tmp/ssh-wuZYTNFc1wq1/agent.656; export SSH_AUTH_SOCK;</span>
<span class="go">SSH_AGENT_PID=657; export SSH_AGENT_PID;</span>
<span class="go">echo Agent pid 657;</span>
</pre></div>
</div>
<p>Al arrancarlo devuelve su <em>PID</em> y el <em>socket</em> que usará para
comunicarse con el resto de programas de <em>ssh</em>. Para que sea así,
deben definirse como variables de ambiente las dos variables que se ven. De
hecho, la salida es el código que lleva a cabo tal cosa, por lo que la mejor
forma de poner en marcha el programa es así<a class="footnote-reference" href="#id12" id="id3">[2]</a>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> <span class="nb">eval</span> <span class="k">$(</span>ssh-agent<span class="k">)</span>
<span class="go">Agent pid 660</span>
</pre></div>
</div>
<p>de modo que directamente:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> env <span class="p">|</span> grep ^SSH
<span class="go">SSH_AUTH_SOCK=/tmp/ssh-K4lZOZ1jc1iQ/agent.659</span>
<span class="go">SSH_AGENT_PID=660</span>
</pre></div>
</div>
<p>Como ahora están definidas las variables de ambiente que identifican el
<strong class="command">ssh-agent</strong> encargado de gestionar claves, podemos usar
<strong class="command">ssh-add</strong> para añadir una:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> ssh-add
<span class="go">Enter passphrase for /home/usuario/.ssh/id_ecdsa:</span>
<span class="go">Identity added: /home/usuario/.ssh/id_ecdsa (/home/usuario/.ssh/id_ecdsa)</span>
</pre></div>
</div>
<p>Introducida la clave de paso, ya podremos usar en esta terminal las herramientas
de <abbr title="Security SHell">SSH</abbr> (<strong class="command">ssh</strong>, <strong class="command">sftp</strong>, <strong class="command">scp</strong>) sin necesidad de
introducir clave alguna. Si cambiamos a otra terminal tendremos que definir y
exportar las variables de ambiente anteriores (pero no volver a añadir la clave),
para hacer accesible el agente a las aplicaciones.</p>
<p>Aunque lo anterior funciona sin problemas, puede seguir resultando algo
engorroso; así que se le puede dar una vuelta de tuerca más e instalar:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> apt-get install libpam-ssh
</pre></div>
</div>
<p>Este es un módulo que está pensado para tomar la propia contraseña de
autenticación del usuario y usarla para arrancar <strong class="command">ssh-agent</strong> y
desbloquear la clave privada almacenada en <code class="file docutils literal notranslate"><span class="pre">~/.ssh/</span></code><a class="footnote-reference" href="#id13" id="id4">[3]</a>. No requiere de
configuración adicional, porque la instalación se encarga de añadirlo a <em>pam</em>
convenientemente. Hecho esto, no tenemos más que asegurarnos de que tenemos
creado un certificado:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> ssh-keygen -t ecdsa
</pre></div>
</div>
<p>en que la clave de paso coincide con la contraseña del usuario en el cliente (no
con la contraseña del usuario remoto).</p>
<div class="admonition note">
<p class="first admonition-title">Nota</p>
<p class="last">Desgraciadamente, el módulo <em>pam_ssh</em> no está disponible en <em>buster</em>,
ya que <a class="reference external" href="https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=859054">no es compatible con la versión que usa ésta de openssl</a></p>
</div>
<p>Como alternativa al uso de <em>pam_ssh</em>, en los clientes con entorno gráfico puede
compprobarse<a class="footnote-reference" href="#id14" id="id5">[4]</a> que está escrito lo siguiente en
<code class="file docutils literal notranslate"><span class="pre">/etc/X11/Xsession.options</span></code>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> grep ssh /etc/X11/Xsession.options
<span class="go">use-ssh-agent</span>
</pre></div>
</div>
<p>Esto provoca que al realizarse el login gráfico el entorno gráfico arranque
dentro de una sesión de <strong class="command">ssh-agent</strong>, por lo que todas las terminales de
texto que abramos dentro de él, tendrán definidas las dos variables que lo
identifican. Por tanto, basta realizar un <strong class="command">ssh-add</strong> para que a partir
de ese momento no requiramos introducir más claves de paso al acceder al
servidor. Para automatizar un poco el proceso, podemos añadir la siguiente línea
a <code class="file docutils literal notranslate"><span class="pre">.bashrc</span></code>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">[ -n &quot;$SSH_AGENT_PID&quot; ] &amp;&amp; { ssh-add -L &gt; /dev/null || ssh-add; }</span>
</pre></div>
</div>
<p>que provocará que se nos pida automáticamente la coontraseña al abrir la primera
terminal.</p>
<div class="admonition warning">
<p class="first admonition-title">Advertencia</p>
<p class="last">El uso del módulo de <em>pam</em> es más adecuado, ya que el arranque del
gestor de ventanas dentro del ambiente creado por <strong class="command">ssh-agent</strong> hace
que la definición de las dos variables de ambiente sólo exista dentro del
entorno gráfico, por lo que si salimos de él a una terminal de texto pura,
éstas no existen y tendremos que definirlas a mano. En cualquier
caso, si el módulo de <em>pam</em> no puede usarse y se opta por esta segunda vía,
no es necesario que la clave de paso coincida con la contraseña de usuario,
ya que la clave se introduce a posteriori de forma independiente.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Nota</p>
<p class="last">Más adelante, se propone cómo usar un <a class="reference internal" href="#pseudopam-ssh"><span class="std std-ref">script para emular el módulo
pam_ssh</span></a> si no disponemos en el sistema de él.</p>
</div>
</div>
<div class="section" id="gnome-keyring">
<h3>4.5.6.3.2. <strong class="command">gnome-keyring</strong><a class="headerlink" href="#gnome-keyring" title="Enlazar permanentemente con este título">¶</a></h3>
<div class="admonition-todo admonition" id="index-6">
<p class="first admonition-title">Por hacer</p>
<p class="last">Por investigar…</p>
</div>
</div>
</div>
<div class="section" id="acceso-no-interactivo">
<span id="ssh-no-interactivo"></span><h2>4.5.6.4. Acceso no interactivo<a class="headerlink" href="#acceso-no-interactivo" title="Enlazar permanentemente con este título">¶</a></h2>
<p>Se ha expuesto bajo el epígrafe anterior cómo evitar tener que escribir
constantemente la clave de paso, pero eso no da respuesta completa a cómo
ejecutar de manera no interactiva un acceso por <em>ssh</em>; no, al menos, antes de
que hayamos accedido al sistema y tenido oportunidad de escribir la clave, si es
que optamos por usar <strong class="command">ssh-agent</strong> y no disponemos del módulo <em>pam_ssh</em>.</p>
<p>Para poder hacer esto, es necesario saber que la variable <em>SSH_ASKPASS</em> le
indica a <strong class="command">ssh</strong> (y toda la familia de programas clientes) qué programa
usar para obtener la contraseña. Por este motivo, si creamos el programa
<code class="file docutils literal notranslate"><span class="pre">$XDG_RUNTIME_DIR/askpass.sh</span></code><a class="footnote-reference" href="#id15" id="id6">[5]</a>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span>!/bin/sh
<span class="go">cat</span>
</pre></div>
</div>
<p>Podremos añadir la clave de paso a <strong class="command">ssh-agent</strong> del siguiente modo:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> <span class="nb">echo</span> <span class="s2">&quot;mi clave de paso&quot;</span> <span class="p">|</span> <span class="nv">SSH_ASKPASS</span><span class="o">=</span><span class="nv">$XDG_RUNTIME_DIR</span>/askpass.sh ssh-add
</pre></div>
</div>
<p>Pasar la clave de paso<a class="footnote-reference" href="#id16" id="id7">[6]</a> directamente a <strong class="command">ssh</strong> es algo más
complicado y no resultará en una sesión interactiva (lo cual no es un problema,
si el propio acceso pretendemos que sea interactivo):</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span>  <span class="nb">echo</span> <span class="s2">&quot;mi clave de paso&quot;</span> <span class="p">|</span> <span class="nv">SSH_ASKPASS</span><span class="o">=</span><span class="nv">$XDG_RUNTIME_DIR</span>/askpass.sh setsid ssh castillo ls /
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Nota</p>
<p>Hay que hacer dos puntualizaciones a la orden anterior:</p>
<ol class="last arabic">
<li><p class="first">Se requiere que esté definida la variable de ambiente <em>DISPLAY</em>, que lo
estará si estamos usando una terminal gráfica. Si no es el caso, podemos
definirla con un valor cualquiera:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">export DISPLAY=dummy:0</span>
</pre></div>
</div>
</li>
<li><p class="first">Si no hemos accedido anteriormente al servidor, el acceso fallará porque
no seremos capaces de aceptar la clave. Para evitarlo es necesario
aceptarla autómaticamente añadiendo a <strong class="command">ssh</strong> la opción <code class="code docutils literal notranslate"><span class="pre">-o</span>
<span class="pre">StrictHostKeyChecking=no</span></code></p>
</li>
</ol>
</div>
<p>Lo anterior mostrará el contenido del directorio <code class="file docutils literal notranslate"><span class="pre">/</span></code> del servidor.</p>
<p class="rubric" id="pseudopam-ssh">Aplicación práctica</p>
<p>Todo esto tiene utlidad si se programa algún <em>script</em>, por ejemplo, uno que se
ejecute con <em>pam_exec</em> y que nos haga las veces del módulo <em>pam_ssh</em>, por si
definitivamente deja de ser efectivo en las versiones modernas de <em>debian</em>. Los
principios del <em>script</em> son los siguientes:</p>
<ol class="arabic simple">
<li>Al autenticarse, sólo si no hay sesiones abiertas para el usuario, el <em>script</em>
arranca <strong class="command">ssh-agent</strong>, guarda los valores de <code class="docutils literal notranslate"><span class="pre">SSH_AGENT_PID</span></code> y
<code class="docutils literal notranslate"><span class="pre">SSH_AUTH_SOCK</span></code> en un <em>fichero de ambiente</em> y desbloquea la clave privada con
<strong class="command">ssh-add</strong>.</li>
<li>Al abrir sesión, se usa <em>pam_env</em> para hacer que las dos variables contenidas
en el fichero sean variables de ambiente.</li>
<li>Al cerrar sesión, si no hay otras sesiones abiertas por el usuario, se borra
el fichero de ambiente y se mata <strong class="command">ssh-agent</strong>.</li>
</ol>
<p>El <em>script</em> es <a class="reference download internal" download="" href="../../_downloads/baf295208c3a1fbab64980258e9b5739/pam_ssh.sh"><code class="xref download docutils literal notranslate"><span class="pre">éste</span></code></a>, que debe alojarse en
<code class="file docutils literal notranslate"><span class="pre">/usr/local/bin/</span></code>. Para automatizar la manipulación de <em>pam</em> se incluye
<a class="reference download internal" download="" href="../../_downloads/b32ef6a1a8c233b5751383eb4fc8991c/pam-ssh"><code class="xref download docutils literal notranslate"><span class="pre">este</span> <span class="pre">otro</span> <span class="pre">fichero</span></code></a>, de manera que debemos hacer lo
siguiente:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> mv /path/donde/este/pam_ssh.sh /usr/local/bin
<span class="gp">#</span> mv /path/donde/este/pam-ssh /usr/share/pam-configs
<span class="gp">#</span> pam-auth-update
</pre></div>
</div>
<p>Para habilitar la acción del <em>script</em> debemos seleccionar el desbloqueo de
claves <abbr title="Security SHell">SSH</abbr>.</p>
<div class="admonition note">
<p class="first admonition-title">Nota</p>
<p>El <em>script</em> usa <strong class="command">ssh-add</strong> sin argumentos, así que se
detectará la clave privada si esta tiene su ubicación predeterminada. Además,
se ejecuta para los servicios <em>login</em>, <em>slim</em>, <em>lightdm</em>, <em>gdm</em>, <em>xdm</em> y
<em>kdm</em>. Es posible escoger otros servicios, manipulando <code class="file docutils literal notranslate"><span class="pre">pam-ssh</span></code> y
añadiendo a la dos líneas presentes en <em>Auth</em> y <em>Auth-Initial</em>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">optional pam_exec.so expose_authtok quiet /usr/local/bin/pam_ssh.sh</span>
</pre></div>
</div>
<p>el parámetro <em>start_if</em>, cuyo valor debe ser todos los servicios para los
que deseemos ejecutar el <em>script</em> separados por comas:</p>
<div class="last highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">optional pam_exec.so expose_authtok quiet /usr/local/bin/pam_ssh.sh start_if=login,sshd,slim</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="redes-restringidas">
<span id="redes-restr"></span><h2>4.5.6.5. Redes restringidas<a class="headerlink" href="#redes-restringidas" title="Enlazar permanentemente con este título">¶</a></h2>
<p>Entendemos como <em class="dfn">red restringida</em> aquella desde la que el cliente no puede
acceder normalmente al servidor <abbr title="Security SHell">SSH</abbr>, esto es, acceder conectándose al puerto
<strong>22</strong>. Dependiendo del grado de vigilancia y los puertos ya ocupados en el
servidor tenemos varias alternativas:</p>
<ol class="loweralpha">
<li><p class="first">Que el servicio escuche por otro puerto, para lo cual basta con modificar la
configuración del servidor y añadir varias directivas <kbd class="kbd docutils literal notranslate">Port</kbd>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">Port 22</span>
<span class="go">Port 443</span>
</pre></div>
</div>
<p>Alternativamente, puede usarse el cortafuegos para redirigir el
tráfico entrante hacia el puerto <strong>443</strong> al puerto <strong>22</strong>. Vea cómo
<a class="reference internal" href="../../08.redes/07.cortafuegos/index.html#firewall"><span class="std std-ref">configurar el cortafuegos</span></a> para ello.</p>
</li>
<li><p class="first">Si el puerto <strong>443</strong> está ya ocupado en el servidor, usar un multiplexor como
<a class="reference internal" href="../../07.serre/05.proxies/03.reverse/01.multi.html#sslh"><span class="std std-ref">sslh</span></a>.</p>
</li>
<li><p class="first">Tunelizar la conexión con <a class="reference external" href="https://v0ctor.me/websocket">Websockets</a>, bien usando el puerto <strong>80</strong>, bien
usando el puerto <strong>443</strong>.</p>
</li>
<li><p class="first">Encapsular con <abbr title="Secure Socket Layer">SSL</abbr>.</p>
</li>
</ol>
<p>Las dos primeras alternitivas suponen que el tráfico <abbr title="Security SHell">SSH</abbr> circule tal cual,
por lo que en la parte cliente no exigen otra cosa que cambiar el puerto de
destino:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> ssh -p443 usuario@servidor
</pre></div>
</div>
<p>En cambio, las dos últimas suponen una encapsulación y, a parte de cambios en la
parte del servidor, también exigen que los clientes se ejecuten de una
determinada forma.</p>
<div class="section" id="websockets">
<h3>4.5.6.5.1. Websockets<a class="headerlink" href="#websockets" title="Enlazar permanentemente con este título">¶</a></h3>
<p>Exige utilizar una aplicación que facilite la tunelización como <a class="reference internal" href="../../07.serre/05.proxies/03.reverse/01.multi.html#wstunnel"><span class="std std-ref">wstunnel</span></a> y configurar la parte de servidor con <a class="reference internal" href="../../07.serre/02.web/02.nginx/index.html#n-ginx"><span class="std std-ref">nginx</span></a> según lo
expuesto en el <a class="reference internal" href="../../07.serre/02.web/02.nginx/02.avanz/08.multiplex.html#nginx-websockets"><span class="std std-ref">epígrafe correspondiente</span></a>. En cualquier
caso, la configuración del servidor <abbr title="Security SHell">SSH</abbr> no necesita cambios.</p>
<p>En la parte cliente basta con utilizar como <em>proxy</em> para llevar a cabo la
conexión. Así, si se usa la conexión con el puerto <strong>80</strong>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> ssh -o <span class="nv">ProxyCommand</span><span class="o">=</span><span class="s2">&quot;wstunnel -L stdio:127.0.0.1:22 ws://%h&quot;</span> usuario@servidor
</pre></div>
</div>
<p>y para la conexión al puerto <strong>443</strong>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> ssh -o <span class="nv">ProxyCommand</span><span class="o">=</span><span class="s2">&quot;wstunnel -L stdio:127.0.0.1:22 wss://%h&quot;</span> usuario@servidor
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Nota</p>
<p class="last">Puede ayudarse del fichero de configuración para no tener que escribir
constatemente esta línea tan engorrosa. Échele un vistazo al epígrafe
siguiente.</p>
</div>
</div>
<div class="section" id="ssh-sobre-https">
<h3>4.5.6.5.2. <abbr title="Security SHell">SSH</abbr> sobre <abbr title="HyperText Transfer Protocol">HTTP</abbr>s<a class="headerlink" href="#ssh-sobre-https" title="Enlazar permanentemente con este título">¶</a></h3>
<p>En este caso, la estrategia es encapsular todo lo que vaya dirigido al puerto
<strong>443</strong> con <abbr title="Transport Layer Security">TLS</abbr>, que es en teoría el tráfico que debe circular hacia ese
destino<a class="footnote-reference" href="#id17" id="id8">[7]</a><a class="footnote-reference" href="#id18" id="id9">[8]</a>. Lo más apropiado para multiplexar los distintos tráficos en
el servidor es instalar y configurar <a class="reference internal" href="../../07.serre/05.proxies/03.reverse/01.multi.html#haproxy"><span class="std std-ref">haproxy</span></a>. La configuración
del servidor de <abbr title="Security SHell">SSH</abbr> no requiere ningún cambio.</p>
<p>Para poder acceder a través del túnel <abbr title="Secure Socket Layer">SSL</abbr> necesitamos en la parte cliente
que un <em>proxy</em> se encargue del encapsulamiento. Lo más cómo es usar
<strong class="command">openssl</strong><a class="footnote-reference" href="#id19" id="id10">[9]</a>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> ssh -p443 -o <span class="s2">&quot;ProxyCommand openssl s_client -quiet -connect %h:%p&quot;</span> usuario@servidor
</pre></div>
</div>
<p>lo cual es un poco engorroso, así que es mejor dejarlo ya escrito en el fichero
de configuración del cliente:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">Hostname *servidor</span>
<span class="go">   Host           mi.servidor.org</span>
<span class="go">   Username       usuario</span>
<span class="go">   Port           443</span>

<span class="go">Hostname ssl-*</span>
<span class="go">   ProxyCommand   openssl s_client -quiet -connect %h:%p</span>

<span class="go">Hostname ws-*</span>
<span class="go">   ProxyCommand wstunnel -L stdio:127.0.0.1:22 ws://%h</span>

<span class="go">Hostname wss-*</span>
<span class="go">   ProxyCommand wstunnel -L stdio:127.0.0.1:22 wss://%h</span>
</pre></div>
</div>
<p>que hará las conexiones tan sencillas como:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> ssh servidor
<span class="gp">$</span> ssh ssl-servidor
<span class="gp">$</span> ssh ws-servidor
<span class="gp">$</span> ssh wss-servidor
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Nota</p>
<p>Si quiséramos enviar un <abbr title="Server Name Identification">SNI</abbr> podríamos añadir a <strong class="command">openssl</strong> la
opción <code class="docutils literal notranslate"><span class="pre">-servername</span></code>:</p>
<div class="last highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">ProxyCommand   openssl s_client -quiet -connect %h:%p -servername ssh.%h</span>
</pre></div>
</div>
</div>
<p>Con <strong class="program">putty</strong> es posible hacer su equivalente, pero como careceremos de
<strong class="program">openssl</strong>, es necesario primero instalarlo. El modo más sencillo es
instalar la versión <em>light</em> que ofrece <a class="reference external" href="https://slproweb.com/products/Win32OpenSSL.html">esta página</a>, que no requerirá más que
vayamos aceptando los distintos pasos de instalación. Al término, tendremos un
ejecutable funcional en el directorio <code class="file docutils literal notranslate"><span class="pre">C:OpenSSL-Win32bin\</span></code>.</p>
<p>Instalado, basta configurar <strong class="program">putty</strong> de este modo:</p>
<img alt="../../_images/SSHoverSSL1.png" src="../../_images/SSHoverSSL1.png" />
<img alt="../../_images/SSHoverSSL2.png" src="../../_images/SSHoverSSL2.png" />
<p>esto es, configurar la sesión para conectarnos al puerto <strong>443</strong> del servidor
que en esta ocasión hemos llamado <em>example.net</em>. A continuación debemos escoger
<code class="docutils literal notranslate"><span class="pre">Connection&gt;Proxy</span></code>, escoger un <em>proxy</em> de tipo <em>local</em> y usar
<strong class="program">openssl</strong> para establecer el túnel del mismo modo en que lo usábamos
con <em>ProxyCommand</em>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">C:\OpenSSL-Win32\bin\openssl.exe s_client -connect %host:%port -quiet</span>
</pre></div>
</div>
<p class="rubric">Notas al pie</p>
<table class="docutils footnote" frame="void" id="id11" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td><p class="first">Observe que:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> scp usuario@servidor:fichero<span class="o">{</span><span class="m">1</span>,2<span class="o">}</span>.txt .
</pre></div>
</div>
<p>y:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> scp usuario@servidor:<span class="s2">&quot;fichero{1,2}.txt&quot;</span> .
</pre></div>
</div>
<p class="last">pretenden lo mismo: descargar los ficheros <code class="file docutils literal notranslate"><span class="pre">fichero1.txt</span></code> y
<code class="file docutils literal notranslate"><span class="pre">fichero2.txt</span></code> en el cliente, pero hay una diferencia importante entre
ellos. En el primer caso la expansión de la <em>shell</em> se produce en el cliente,
mientras que en la segunda se produce en el servidor. Como consecuencia, en
el primer caso habrá dos autenticaciones, mientras que en el segundo sólo
una. Así pues, es mejor usar la segunda forma.</p>
</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id12" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3">[2]</a></td><td><p class="first">Si antes queremos deshacernos del <strong class="command">ssh-agent</strong> ya en ejecucion
podemos hacer lo siguiente:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> <span class="nb">export</span> <span class="nv">SSH_AUTH_SOCK</span><span class="o">=</span>/tmp/ssh-wuZYTNFc1wq1/agent.656
<span class="gp">$</span> <span class="nb">export</span> <span class="nv">SSH_AGENT_PID</span><span class="o">=</span><span class="m">657</span>
<span class="gp">$</span> ssh-agent -k
</pre></div>
</div>
<p>o matarlo directamente, que es más rápido:</p>
<div class="last highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> <span class="nb">kill</span> -1 <span class="m">657</span>
</pre></div>
</div>
</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id13" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id4">[3]</a></td><td>Consúltese su página de manual para que la clave privada no sea una de
las predeterminadas de <strong class="command">ssh</strong> (<code class="file docutils literal notranslate"><span class="pre">~/.ssh/id_rsa</span></code>,
<code class="file docutils literal notranslate"><span class="pre">~/.ssh/id_ecdsa</span></code>, etc.)</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id14" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id5">[4]</a></td><td>Si se usa <em>pam_ssh</em> (o el <a class="reference internal" href="#pseudopam-ssh"><span class="std std-ref">script sustitutorio después propuesto</span></a>) conviene, precisamente, cerciorarse de que esto no está
activo comentando la opción)</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id15" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id6">[5]</a></td><td>No se usa directamente <strong class="command">cat</strong> porque <strong class="program">ssh-add</strong> y el
resto de programas pasan argumentos que lo malogran. El <em>script</em> desecha los
argumentos y sólo atiende a la entrada estándar que es lo que interesa.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id16" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id7">[6]</a></td><td>O la contraseña, no es necesario la autenticación mediante clave pública
y privada.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id17" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id8">[7]</a></td><td>En teoría, el tráfico debe ser <abbr title="HyperText Transfer Protocol">HTTP</abbr>s, es decir, <abbr title="HyperText Transfer Protocol">HTTP</abbr> ofuscado e
irreconocible gracias a la envoltura segura que ofrece <abbr title="Transport Layer Security">TLS</abbr>.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id18" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id9">[8]</a></td><td>De lo que se deduce que el epígrafe es inexacto: debería llamarse <em>SSH
sobre TLS</em>.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id19" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id10">[9]</a></td><td>Obviamente, este software de <em>proxy</em> para el cliente sólo es necesario si
necesitamos establecer el túnel <abbr title="Transport Layer Security">TLS</abbr>. Si no es el caso (segunda variante en
redes sin proxy que fiscalece la comunicación), en el cliente no hay más que
asegurarse de que nos conectamos al puerto <strong>443</strong>.</td></tr>
</tbody>
</table>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../../index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">4.5.6. Aspectos adicionales</a><ul>
<li><a class="reference internal" href="#transferencia-de-ficheros">4.5.6.1. Transferencia de ficheros</a></li>
<li><a class="reference internal" href="#trampolin-de-acceso">4.5.6.2. Trampolín de acceso</a></li>
<li><a class="reference internal" href="#persistencia-de-claves">4.5.6.3. Persistencia de claves</a><ul>
<li><a class="reference internal" href="#index-5">4.5.6.3.1. <strong class="command">ssh-agent</strong></a></li>
<li><a class="reference internal" href="#gnome-keyring">4.5.6.3.2. <strong class="command">gnome-keyring</strong></a></li>
</ul>
</li>
<li><a class="reference internal" href="#acceso-no-interactivo">4.5.6.4. Acceso no interactivo</a></li>
<li><a class="reference internal" href="#redes-restringidas">4.5.6.5. Redes restringidas</a><ul>
<li><a class="reference internal" href="#websockets">4.5.6.5.1. Websockets</a></li>
<li><a class="reference internal" href="#ssh-sobre-https">4.5.6.5.2. <abbr title="Security SHell">SSH</abbr> sobre <abbr title="HyperText Transfer Protocol">HTTP</abbr>s</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>Tema anterior</h4>
  <p class="topless"><a href="03.tuneles.html"
                        title="capítulo anterior">4.5.5. Túneles</a></p>
  <h4>Próximo tema</h4>
  <p class="topless"><a href="../../05.discos/index.html"
                        title="próximo capítulo">5. Dispositivos de almacenamiento</a></p>
  <div role="note" aria-label="source link">
    <h3>Esta página</h3>
    <ul class="this-page-menu">
      <li><a href="../../_sources/04.servidor/10.ssh/04.adicional.rst.txt"
            rel="nofollow">Mostrar el código</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Búsqueda rápida</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Ir a" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navegación</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="Índice General"
             >índice</a></li>
        <li class="right" >
          <a href="../../05.discos/index.html" title="5. Dispositivos de almacenamiento"
             >siguiente</a> |</li>
        <li class="right" >
          <a href="03.tuneles.html" title="4.5.5. Túneles"
             >anterior</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">documentación de Linuxnomicón - rolling</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" >4. Gestión del servidor</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="index.html" >4.5. Administración remota</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Derechos de autor CC BY 4.0, 2016-2020, José Miguel Sánchez Alés.
      Creado con <a href="http://sphinx-doc.org/">Sphinx</a> 1.8.5.
    </div>
  </body>
</html>