


<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" lang="es">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>4.5.6. Aspectos adicionales &#8212; documentación de Linuxnomicón - rolling</title>
    <link rel="stylesheet" href="../../_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../_static/custom.css" />
    
    <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../_static/language_data.js"></script>
    <script type="text/javascript" src="../../_static/translations.js"></script>
    <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <link rel="index" title="Índice" href="../../genindex.html" />
    <link rel="search" title="Búsqueda" href="../../search.html" />
    <link rel="next" title="5. Dispositivos de almacenamiento" href="../../05.discos/index.html" />
    <link rel="prev" title="4.5.5. Túneles" href="03.tuneles.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navegación</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="Índice General"
             accesskey="I">índice</a></li>
        <li class="right" >
          <a href="../../05.discos/index.html" title="5. Dispositivos de almacenamiento"
             accesskey="N">siguiente</a> |</li>
        <li class="right" >
          <a href="03.tuneles.html" title="4.5.5. Túneles"
             accesskey="P">anterior</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">documentación de Linuxnomicón - rolling</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" >4. Gestión del servidor</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="index.html" accesskey="U">4.5. Administración remota</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="aspectos-adicionales">
<h1>4.5.6. Aspectos adicionales<a class="headerlink" href="#aspectos-adicionales" title="Enlazar permanentemente con este título">¶</a></h1>
<div class="section" id="transferencia-de-ficheros">
<h2>4.5.6.1. Transferencia de ficheros<a class="headerlink" href="#transferencia-de-ficheros" title="Enlazar permanentemente con este título">¶</a></h2>
<p>El protocolo <abbr title="Security SHell">SSH</abbr> permite también la transferencia de ficheros entre cliente y
servidor. Aunque puede <a class="reference internal" href="../../07.serre/01.ftp/03.ssh.html#ssh-ftp"><span class="std std-ref">configurarse de modo que sustituya perfectamente a
un servidor FTP</span></a>, por ahora nos limitaremos a usar la configuración
predeterminada y ver los clientes que nos permiten esta tarea.</p>
<p id="scp"><span id="index-0"></span>La primera forma de aprovechar las posibilidades de transferencia es usar una
herramienta de <em>copia remota</em> (<strong class="command">scp</strong> proporcionada por <em>openssh</em> o
<strong class="command">pscp.exe</strong> de la suite de <strong class="program">putty</strong>). El modo de usarlo es muy
semejante al de la orden <strong class="command">cp</strong> del mundo <em>unix</em>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> scp /path/local/fichero.txt usuario@servidor:path/en/el/servidor
</pre></div>
</div>
<p>es decir, un <em>origen</em> (en este caso un fichero del cliente) y un destino que se
expresa como al conectarnos con el cliente <strong class="command">ssh</strong> seguido de dos puntos.
Si la ruta en el servidor es relativa se sobreentiende que lo es respecto al
directorio peronal del usuario. Si no se expresa ruta alguna, el fichero se
copiará en el directorio personal. En el ejemplo, el origen es local y el
destino remoto, por lo que la consecuencia es que <em>subimos</em> el fichero al
servidor. Para descargar no hay más que escoger un origen remoto y un destino
local<a class="footnote-reference" href="#id22" id="id1">[1]</a>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> scp usuario@servidor:fichero_remoto.txt .
</pre></div>
</div>
<p id="sftp"><span id="index-1"></span>La segunda forma de transferir ficheros es usar un cliente <em>[s]ftp</em>, similiar al
cliente del <abbr title="File Transfer Protocol">FTP</abbr> tradicional. <em>openssh</em> proporciona <strong class="command">sftp</strong>, y
<strong class="program">putty</strong> su equivalente <strong class="command">psftp</strong></p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> sftp usuario@servidor
<span class="go">sftp&gt; put fichero_local</span>
<span class="go">sftp&gt; get fichero_remoto</span>
</pre></div>
</div>
<p>Algunos clientes gráficos de <abbr title="File Transfer Protocol">FTP</abbr> como <a class="reference external" href="https://filezilla-project.org/">filezilla</a>, soportan también el protocolo <em>sFTP</em>.</p>
<div class="admonition note">
<p class="first admonition-title">Nota</p>
<p class="last">Tanto <strong class="command">scp</strong> como <strong class="command">sftp</strong> hacen uso de la
configuración contenida en <code class="file docutils literal notranslate"><span class="pre">~/.ssh/config</span></code>, por lo que podremos
aprovechar las conexiones con nombre que hayamos creado en él.</p>
</div>
<p id="sshfs"><span id="index-2"></span>El tercer método para tranferir ficheros en sistemas <em>unix</em> es montar algún
directorio remoto del servidor en el cliente gracias a <strong class="program">sshfs</strong>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> sshfs usuario@servidor: /tmp/ssh
</pre></div>
</div>
<p>De este modo, podremos traer y llevar ficheros de modo transparente haciendo uso
de las herramientas habituales (<strong class="command">cp</strong>, <strong class="command">mv</strong>, etc). Para
desmontar el fichero (si no somos el administrador) puede hacerse:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> fusermount -u /tmp/ssh
</pre></div>
</div>
</div>
<div class="section" id="trampolin-de-acceso">
<span id="ssh-traampolin"></span><h2>4.5.6.2. Trampolín de acceso<a class="headerlink" href="#trampolin-de-acceso" title="Enlazar permanentemente con este título">¶</a></h2>
<p>Un servidor <abbr title="Security SHell">SSH</abbr> puede usarse como trampolín de acceso a servicios
inaccesibles, bien porque se encuentran en máquinas que no son accesibles desde
internet, bien porque, aunque lo sean, tengamos restringido su acceso.</p>
<ol class="arabic">
<li><p class="first">El método más simple y universal es establecer <a class="reference internal" href="03.tuneles.html#ssh-socks"><span class="std std-ref">un túnel dinámico</span></a>, tal como se explicó anteriormente.</p>
</li>
<li><p class="first">Para el caso particular de que queramos acceder a un servidor <abbr title="Security SHell">SSH</abbr>
inaccesible a través de otro servidor <abbr title="Security SHell">SSH</abbr> que sí es accesible podemos usar
<em>ProxyCommand</em>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> ssh -o <span class="s2">&quot;ProxyCommand ssh usuario1@servidor_accesible nc -q0 %h %p&quot;</span> usuario2@servidor_inaccesible
</pre></div>
</div>
<p>En este caso, antes de que el cliente <strong class="command">ssh</strong> intente cualquier
comunicación, usamos otro cliente que accede al servidor accesible y ejecuta
<a class="reference internal" href="../../02.conbas/99.misc/05.ordenes.html#netcat"><span class="std std-ref">netcat</span></a> para enchufarnos al servicio <abbr title="Security SHell">SSH</abbr> del inaccesible.
<strong class="program">netcat</strong> nos ofrece acceso crudo a tal servicio lo cual es
precisamente lo que necesitamos porque tenemos un cliente <strong class="command">ssh</strong>
esperando iniciar una conexión.</p>
<p>El único pero de este método es que necesitamos que el servidor accesible
tenga instalado <strong class="command">netcat</strong>. Sin embargo, a partir de la versión <em>5.4</em>
del cliente, <strong class="command">ssh</strong> tiene la opción <code class="docutils literal notranslate"><span class="pre">-W</span></code>, que sirve para suplir el
papel de <strong class="program">netcat</strong>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> ssh -o <span class="s2">&quot;ProxyCommand ssh -W %h:%p usuario1@servidor_accesible&quot;</span> usuario2@servidor_inaccesible
</pre></div>
</div>
<p>Con <strong class="program">putty</strong> podemos hacer otro tanto, sabiendo que entre los
programas de la <em>suite</em> de <strong class="program">putty</strong> está <strong class="command">plink</strong> que es la
versión en línea de comandos del propio <strong class="program">putty</strong>. De este modo,
podemos configurar el programa así:</p>
<img alt="../../_images/SSHproxy_putty1.png" src="../../_images/SSHproxy_putty1.png" />
<img alt="../../_images/SSHproxy_putty2.png" src="../../_images/SSHproxy_putty2.png" />
<p>El comando es análogo al usado con <em>ProxyCommand</em> en <strong class="command">ssh</strong>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">C:\path\a\plink.exe %user@%proxyhost -nc %host %port</span>
</pre></div>
</div>
<div class="admonition-todo admonition" id="index-3">
<p class="first admonition-title">Por hacer</p>
<p class="last">Y, sin embargo.., no funciona.</p>
</div>
</li>
</ol>
</div>
<div class="section" id="redes-restringidas">
<span id="redes-restr"></span><h2>4.5.6.3. Redes restringidas<a class="headerlink" href="#redes-restringidas" title="Enlazar permanentemente con este título">¶</a></h2>
<p>Lo explicado bajo el epígrafe anterior, presupone que, desde la red local,
disponemos de acceso a un servidor <abbr title="Security SHell">SSH</abbr>. Sin embargo, es común encontrarse con
redes con políticas de acceso muy restrictivas a internet, en las que
prácticamente el único tráfico saliente permitido es el de navegación web
(<abbr title="HyperText Transfer Protocol">HTTP</abbr> y <abbr title="HyperText Transfer Protocol">HTTP</abbr>s). En estos caso, la única solución pàra poder burlar la
restricción es preparar nuestro servidor <abbr title="Security SHell">SSH</abbr> para que se pueda acceder
a él a través de uno de los dos puertos anteriores (nosotros usaremos el
<strong>443</strong><a class="footnote-reference" href="#id23" id="id2">[2]</a>). Ahora bien, dependiendo de los servicios adicionales que
ofrezcamos en el servidor y de las restricciones de la red del cliente, la
solución será más o menos inmediata. Las posibles situaciones son las
siguientes:</p>
<table border="1" class="docutils">
<colgroup>
<col width="18%" />
<col width="17%" />
<col width="65%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Puerto [443]</th>
<th class="head">Vigilancia</th>
<th class="head">Estrategia</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Libre</td>
<td>No</td>
<td><a class="reference internal" href="#ssh-443"><span class="std std-ref">escucha en el puerto 443</span></a></td>
</tr>
<tr class="row-odd"><td>Ocupado</td>
<td>No</td>
<td><a class="reference internal" href="#sslh"><span class="std std-ref">sslh</span></a></td>
</tr>
<tr class="row-even"><td>Libre</td>
<td>Sí</td>
<td><a class="reference internal" href="#haproxy"><span class="std std-ref">haproxy</span></a></td>
</tr>
<tr class="row-odd"><td>Ocupado</td>
<td>Sí</td>
<td><a class="reference internal" href="#haproxy"><span class="std std-ref">haproxy</span></a></td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Nota</p>
<p>Entiéndase que por <em>libre</em> entendemos que en nuestro servidor no usamos
el puerto <em>443</em> para dar ningún otro servicio. Este será el caso si no ofrecemos
servicio web seguro o si no necesitamos encauzar a través de este mismo puerto
otros servicios como una <abbr title="Virtual Private Network">VPN</abbr>.</p>
<p class="last">Por <em>vigilancia</em> entendemos que el tráfico de salida de la red cliente no
solamente está restringido por un cortafuegos, sino que además hay un <em>proxy</em>
que analice el protocolo del tráfico dirigido al puerto 443 y lo rechaza si
éste no es <abbr title="Transport Layer Security">TLS</abbr>.</p>
</div>
<div class="section" id="puerto-libre-sin-vigilancia">
<span id="ssh-443"></span><h3>4.5.6.3.1. Puerto libre sin vigilancia<a class="headerlink" href="#puerto-libre-sin-vigilancia" title="Enlazar permanentemente con este título">¶</a></h3>
<p>Es la situación menos restrictiva y, por tanto, la más fácil de solucionar, ya
que basta con hacer escuchar el servidor también en el puerto <strong>443</strong>. Para ello
no hay más que usar repetidamente la directiva <strong>Port</strong> en <code class="file docutils literal notranslate"><span class="pre">/etc/ssh/sshd_config</span></code>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">Port 22</span>
<span class="go">Port 443</span>
</pre></div>
</div>
</div>
<div class="section" id="multiplexacion">
<span id="sslh"></span><h3>4.5.6.3.2. Multiplexación<a class="headerlink" href="#multiplexacion" title="Enlazar permanentemente con este título">¶</a></h3>
<p>Cuando el puerto <strong>443</strong> ya lo tenemos ocupado con el servidor <em>web</em>, o bien,
prevemos que lo tendremos ocupado, la solución anterior es inviable. La
solución sencilla en este caso consiste en poner a escuchar el servidor web seguro
exclusivamente en el puerto <strong>443</strong> de la interfaz de <em>loopback</em> y reservar el
puerto de la interfaz física para el <a class="reference external" href="http://www.rutschle.net/tech/sslh/README.html">servicio SSLH</a>. Este servicio es, por decirlo
así, un <em>multiplexor de protocolos</em> que analiza el trafico recibido en un
determinado puerto (típicamente el <strong>443</strong>), analiza el tráfico y, en función de
su tipo, lo redirige al puerto de la interfaz que le indiquemos. Gracias a ello,
podemos ofrecer distintos servicios (p.e. <abbr title="HyperText Transfer Protocol">HTTP</abbr>s, <abbr title="Security SHell">SSH</abbr> y <abbr title="Virtual Private Network">VPN</abbr>) por el mismo
puerto <strong>443</strong> de la interfaz física. La estrategia, pues, consiste en levantar
los siguientes servicios, escuchando en los siguientes interfaces y puertos:</p>
<table border="1" class="docutils">
<colgroup>
<col width="34%" />
<col width="45%" />
<col width="20%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Servicio</th>
<th class="head">Interfaz</th>
<th class="head">Puerto</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><abbr title="Security SHell">SSH</abbr></td>
<td>0.0.0.0</td>
<td>22/TCP</td>
</tr>
<tr class="row-odd"><td><em>OpenVPN</em><a class="footnote-reference" href="#id24" id="id3">[3]</a></td>
<td>0.0.0.0</td>
<td>1194/TCP</td>
</tr>
<tr class="row-even"><td><abbr title="HyperText Transfer Protocol">HTTP</abbr>s</td>
<td>0.0.0.0</td>
<td>80/TCP</td>
</tr>
<tr class="row-odd"><td><em>SSLH</em></td>
<td>Todas excepto local</td>
<td>443/TCP</td>
</tr>
</tbody>
</table>
<p>Para llevarlo a cabo, es necesario instalar:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> apt-get install sslh
</pre></div>
</div>
<p>y configurar el fichero <code class="file docutils literal notranslate"><span class="pre">/etc/default/sslh</span></code> del siguiente modo:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">RUN=yes  # SSLH corre permanentemente, no a través de inetd.</span>

<span class="go">[...]</span>

<span class="go">DAEMON_OPTS=&quot;--user sslh --listen 172.22.0.2:443 \</span>
<span class="go">             --ssh 127.0.0.1:22 --ssl 127.0.0.1:443 --openvpn 127.0.0.1:1194 \</span>
<span class="go">             --pidfile /var/run/sslh/sslh.pid&quot;</span>
</pre></div>
</div>
<p>esto suponiendo que tengamos una sólo interfaz física y esta tenga por <em>ip</em>
<em>172.22.0.2</em>. Si hubiera varias, habría que colocar varias veces la opción
<code class="docutils literal notranslate"><span class="pre">--listen</span></code> con la <em>ip</em> correspondiente.</p>
<div class="admonition note">
<p class="first admonition-title">Nota</p>
<p class="last">Permitir es tráfico <abbr title="Virtual Private Network">VPN</abbr> es absolutamente accesorio. Como cuesta poco
(una opción para <em>sslh</em>) se ha incluido en la explicación.</p>
</div>
</div>
<div class="section" id="ssh-sobre-https">
<span id="haproxy"></span><h3>4.5.6.3.3. <abbr title="Security SHell">SSH</abbr> sobre <abbr title="HyperText Transfer Protocol">HTTP</abbr>s<a class="headerlink" href="#ssh-sobre-https" title="Enlazar permanentemente con este título">¶</a></h3>
<p>En este último caso, un proxy intermedio analiza si el tráfico que intentamos
dirigir hacia un puerto <strong>443</strong> sigue el protocolo <abbr title="Transport Layer Security">TLS</abbr>, como
en teoría debería ser<a class="footnote-reference" href="#id25" id="id4">[4]</a>. Ante esto, no podemos usar ninguna de las soluciones
anteriores, porque en ellas el tráfico <abbr title="Security SHell">SSH</abbr> viaja desnudo y éste no usa la
cobertura <abbr title="Transport Layer Security">TLS</abbr> que espera encontrar el <em>proxy</em>. Ahora bien, <abbr title="Transport Layer Security">TLS</abbr> es una
envoltura que cifra todo el contenido, lo que significa que tal <em>proxy</em> es
incapaz de saber a qué protocolo envuelve <abbr title="Transport Layer Security">TLS</abbr>. Por tanto, para el
<em>proxy</em>  no hay diferencia entre una comunicación <abbr title="HyperText Transfer Protocol">HTTP</abbr> envuelta en <abbr title="Transport Layer Security">TLS</abbr> (o
sea, <abbr title="HyperText Transfer Protocol">HTTP</abbr>s) o una comunicación <abbr title="Security SHell">SSH</abbr> envuelta en <abbr title="Transport Layer Security">TLS</abbr><a class="footnote-reference" href="#id26" id="id5">[5]</a><a class="footnote-reference" href="#id27" id="id6">[6]</a>.</p>
<p>Esta estrategia requiere que en el puerto <strong>443</strong> no escuche un simple
<em>multiplexor</em>, sino un <em>proxy</em>. Para la ocasión, usaremos <a class="reference external" href="http://www.haproxy.org/">el programa haproxy</a><a class="footnote-reference" href="#id28" id="id7">[7]</a> y supondremos que todos los servidores para
los que intermedia se encuentran en la misma máquina.</p>
<div class="section" id="servidor">
<h4>4.5.6.3.3.1. Servidor<a class="headerlink" href="#servidor" title="Enlazar permanentemente con este título">¶</a></h4>
<div class="admonition warning">
<p class="first admonition-title">Advertencia</p>
<p class="last">El presente epígrafe describe cómo configurar <em>exclusivamente</em>
<strong class="program">haproxy</strong> y <strong class="program">ssh</strong> (servidor y cliente). Su uso, sin
embargo, determina que otros servicios para los que también intermedia (como
<abbr title="HyperText Transfer Protocol">HTTP</abbr> o <abbr title="Virtual Private Network">VPN</abbr>) deban modificar asimismo sus configuraciones en el lado
cliente o servidor para adaptarse. Lea, al respecto, los epígrafes
correspondientes a su <a class="reference internal" href="../../07.serre/02.web/02.nginx/02.avanz/07.https.html#nginx-haproxy"><span class="std std-ref">uso con nginx</span></a> o su <a class="reference internal" href="../../07.serre/04.vpn/04.misc.html#vpn-haproxy"><span class="std std-ref">uso con
openvpn</span></a>.</p>
</div>
<p><strong class="program">haproxy</strong> es, en realidad, una solución bastante general y, no permite
sólo envolver el protocolo interno para hacerlo invisible al <em>proxy</em>, sino
también usarlo a la manera de un <em>multiplexor</em> como <a class="reference internal" href="#sslh"><span class="std std-ref">sslh</span></a> <a class="footnote-reference" href="#id29" id="id8">[8]</a>, de
modo que los protocolos (<abbr title="Security SHell">SSH</abbr>, <abbr title="Virtual Private Network">VPN</abbr>) viajen sin envolver y, al llegar a
<strong class="program">haproxy</strong> sean identificados y redirigidos al verdadero servidor.</p>
<p>Describiremos <strong>dos soluciones</strong> distintas:</p>
<ol class="arabic">
<li><p class="first">Una en la que todos los protocolos <abbr title="HyperText Transfer Protocol">HTTP</abbr>. <abbr title="Security SHell">SSH</abbr> y <abbr title="Virtual Private Network">VPN</abbr> van encapsulados con
<abbr title="Transport Layer Security">TLS</abbr> y es el propio <strong class="program">haproxy</strong> el que los desencapsula, los reconoce
y los envía al servidor correspondiente.</p>
</li>
<li><p class="first">Otra en que junto a tráfico <abbr title="Transport Layer Security">TLS</abbr>, se permite que <abbr title="Security SHell">SSH</abbr> y <abbr title="Virtual Private Network">VPN</abbr> circulen sin
encapsular, de manera que al llegar el tráfico a <strong class="program">haproxy</strong> se manda
a sus respectivos servidores. El tráfico <abbr title="Transport Layer Security">TLS</abbr>, por su parte, se desemcapsula
como en el caso anterior para comprobar si es <abbr title="HyperText Transfer Protocol">HTTP</abbr>, <abbr title="Security SHell">SSH</abbr> y <abbr title="Virtual Private Network">VPN</abbr> y,
reconocidos, se reenvían al servidor correspondiente.</p>
<p>En este segundo caso, la configuración permite enviar encapsulado o no el
tráfico <abbr title="Security SHell">SSH</abbr> y <abbr title="Virtual Private Network">VPN</abbr> según el grado de restricción de la red remota. Tenga
en cuenta que encapsular este tráfico, que ya es tráfico seguro, sólo tiene
por finalidad engañar a los proxies intermedios pero a costa de reducir el
rendimiento de la conexión (ya que la cobertura <abbr title="Transport Layer Security">TLS</abbr> ocupa espacio) y,
además, consume recursos del procesador al tener que cifrar y descifrar una
capa extra.</p>
</li>
</ol>
<div class="admonition note">
<p class="first admonition-title">Nota</p>
<p class="last">Obsérvese que todo esto exige incorporar capaz intermedias a la
comunicación con el consiguiente coste en el rendimiento.</p>
</div>
<p>Antes de entrar a configurar, es necesario instalar:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> apt-get install haproxy
</pre></div>
</div>
<p>y tener un certificado digital para el servicio, que puede ser autofirmado o
acreditado por una autoridad certificadora (véase <a class="reference internal" href="../../07.serre/02.web/02.nginx/02.avanz/07.https.html#tls-cert"><span class="std std-ref">cómo obtener uno</span></a>)<a class="footnote-reference" href="#id30" id="id9">[9]</a>.</p>
<p>Sea como sea, es preciso señalar que <strong class="program">haproxy</strong> requiere que todas las
claves públicas y la privada participantes en la autenticación estén reunidas en
un mismo fichero.</p>
<p>En el caso de un <em>certificado autofirmado</em>, muy probablemente tendremos que
hacer algo así:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> cat /etc/ssl/<span class="o">{</span>private/ssl-cert-snakeoil.key,certs/ssl-cert-snakeoil.pem<span class="o">}</span> &gt; /etc/haproxy/keycert.pem
<span class="gp">#</span> chmod <span class="m">600</span> /etc/haproxy/keycert.pem
</pre></div>
</div>
<p>y en el caso de haber usado <em>letsencrypt</em>, si no hemos creado un <em>gancho</em> de
postinstalación como se sugirió en las explicaciones:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> cat /etc/letsencrypt/live/mi.servidor.org/<span class="o">{</span>fullchain,privkey<span class="o">}</span>.pem &gt; /etc/haproxy/keycert.pem
<span class="gp">#</span> chmod <span class="m">600</span> /etc/haproxy/keycert.pem
</pre></div>
</div>
<p>Creado el certificado adecuado, podemos hacer la configuración propiamente
dicha, que es bastante más complicada y con muchísimas más variantes que la de
<a class="reference internal" href="#sslh"><span class="std std-ref">sslh</span></a>.</p>
<p class="rubric">Primera variante</p>
<p>En ella, <strong class="program">haproxy</strong> recibe tráfico cifrado con <abbr title="Transport Layer Security">TLS</abbr>, los descifra y,
dependiendo de su naturaleza, lo envía al servidor adecuado. Bajo estos
presupuestos la configuración en <code class="file docutils literal notranslate"><span class="pre">/etc/haproxy/haproxy.cfg</span></code> queda así:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>global
   # directivas que trae ya el fichero

   tune.ssl.default-dh-param 2048


default
   # directivas que trae ya el fichero


frontend ssl
   bind *:443 ssl crt /etc/haproxy/keycert.pem
   mode tcp
   option tcplog

   tcp-request inspect-delay 5s
   tcp-request content accept  if  { req.ssl_hello_type 1 }

   acl ssh_request     payload(0,7) -m bin 5353482d322e30  

   use_backend http     if HTTP
   use_backend ssh      if ssh_request
   use_backend vpn      if !{ req.ssl_hello_type 1 } !{ req.len 0 }


backend ssh
   mode tcp
   timeout 2h
   server ssh 127.0.0.1:22


backend vpn
   mode tcp
   timeout 2h
   server openvpn 127.0.0.1:1194
   

backend http
   mode http
   option forwardfor
   reqadd X-Forwarded-Proto:\ https
   server nginx 127.0.0.1:80
</pre></div>
</div>
<p>Las claves de esta configuración son las siguientes:</p>
<ul class="simple">
<li>Las cláusulas <em>frontend</em> definen las conexiones con el cliente y las cláusulas
<em>backend</em> las conexiones con los servidores, de lo que se deduce que
<strong class="program">haproxy</strong> escucha en el puerto <strong>443</strong> de la interfaz real (se ha
supuesto que su <em>ip</em> es <em>172.22.0.2</em>); y conecta con tres servidores: uno <abbr title="Security SHell">SSH</abbr>,
uno <abbr title="Virtual Private Network">VPN</abbr> y un web, todos en la propia máquina.</li>
<li>Es justamente ahí donde se cifra a la salida y se descifra a la entrada
por lo que se añade el parámetro <code class="docutils literal notranslate"><span class="pre">ssl</span></code> y se indica cuál el certificado<a class="footnote-reference" href="#id31" id="id10">[10]</a>.</li>
<li>Como consecuencia de que se descifra, es posible analizar el contenido
y distinguir entre los tres tráficos<a class="footnote-reference" href="#id32" id="id11">[11]</a>.</li>
<li>La conexión con el servidor web se hace en modo <abbr title="HyperText Transfer Protocol">HTTP</abbr> por la razón que
se dará más adelante. Por ello se envía la comunicación al puerto <strong>80</strong><a class="footnote-reference" href="#id33" id="id12">[12]</a>.Esto nos permite añadir los campos <code class="docutils literal notranslate"><span class="pre">X-Forwarder-For</span></code>
para indicar la <em>ip</em> del cliente y la cabecera <code class="docutils literal notranslate"><span class="pre">X-Forwarder-Proto</span></code> para
avisar de que el protocolo que usó el cliente fue <abbr title="HyperText Transfer Protocol">HTTP</abbr>s y no <abbr title="HyperText Transfer Protocol">HTTP</abbr> que es
el que ve el servidor. Si se tiene convenientemente configurado el servidor web,
las aplicaciones web podrán saber quién se conecta y cómo.</li>
</ul>
<div class="admonition warning">
<p class="first admonition-title">Advertencia</p>
<p class="last">A diferencia de <a class="reference internal" href="#sslh"><span class="std std-ref">sslh</span></a>, <strong class="command">haproxy</strong> es un proxy
y como tal establece dos conexiones distintas: una entre el cliente y él; y
otra entre él y el servidor.  Consecuentemente, el servidor destinatario
final es incapaz de conocer cuál es la <em>ip</em> del cliente, y entenderá que se
comunica siempre con la propia máquina local (o sea, <em>127.0.0.1</em>), ya que
<strong class="program">haproxy</strong> está situado en la misma máquina. Esto, por ejemplo,
nos impediría  <a class="reference internal" href="../../08.redes/99.ataques/02.tecnicas/03.brute.html#fail2ban"><span class="std std-ref">protegernos contra ataques de fuera bruta</span></a>,
cuando los ataques se dirigen al puerto <strong>443</strong>, en vez de al <strong>22</strong>. En el
caso concreto de esta variante, no tiene excesiva importancia, ya que la
conexión sólo es posible si se establece además un tunel <abbr title="Security SHell">SSH</abbr>, lo cual es
bastante improbable que intenten hacer estos atacantes chinos que hacen
búsuqedas automáticas de servidores <abbr title="Security SHell">SSH</abbr> en la red.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Nota</p>
<p class="last"><strong class="program">haproxy</strong> con la colaboración del núcleo de linux, puede
funcionar en modo transparente, de manera que el servidor reciba la <em>ip</em> del
cliente. Sin embargo, esto exige que el servidor se encuentre en una máquina
distinta a <strong class="program">haproxy</strong>. Por si es este nuestro caso, se deja <a class="reference internal" href="#haproxy-transparente"><span class="std std-ref">un
epígrafe específico para su explicación</span></a>.</p>
</div>
<p class="rubric" id="haproxy-2v">Segunda variante</p>
<p>Añade a la primera, la posibilidad de también conectarse al puerto <strong>443</strong> sin
necesidad de establecer el túnel <abbr title="Transport Layer Security">TLS</abbr>. Puede descargar el código de
<a class="reference download internal" download="" href="../../_downloads/02a910c105b53f8b0ca941b9fe76607f/haproxy_2.cfg"><code class="xref download docutils literal notranslate"><span class="pre">este</span> <span class="pre">enlace</span></code></a>.</p>
<div class="admonition note">
<p class="first admonition-title">Nota</p>
<p>Por el modo en que se ha realizado esta configuración del servidor (y
tambiém la anterior), éste no necesita conocer de antemano de qué naturaleza
es el tráfico escondido dentro de <abbr title="Transport Layer Security">TLS</abbr>, ya que antes de discriminar tal
tráfico desencapsula. Como encapsulado, el tráfico está cifrado y es
imposible conocer cuál es (esta es, precisamente, la base de que podamos
burlar cualquier <em>proxy</em>), el protocolo <abbr title="Transport Layer Security">TLS</abbr> habilita una manera de que en
la propia envoltura se indique el nombre del servidor: la extensión <abbr title="Server Name Identification">SNI</abbr>.</p>
<p>Una manera de distinguir el tipo de tráfico es hacer que el cliente incluya
un <abbr title="Server Name Identification">SNI</abbr> distinto para cada tipo de tráfico y reconocer éste leyendo el
<abbr title="Server Name Identification">SNI</abbr>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">frontend main</span>
<span class="go">   bind 172.22.0.2:443  # No descriframos en absoluto.</span>
<span class="go">   mode tcp</span>
<span class="go">   option tcplog</span>

<span class="go">   tcp-request inspect-delay 5s</span>
<span class="go">   tcp-request content accept if { req_ssl_hello_type 1 }</span>

<span class="go">   acl   ssh_request   req_ssl_sni -i ssh.mi.servidor.org</span>
<span class="go">   acl   vpn_request   req_ssl_sni -i vpn.mi.servidor.org</span>

<span class="go">   use_backend ssl-ssh   if ssh_request</span>
<span class="go">   use_backend ssl-vpn   if vpn_request</span>
<span class="go">   default_backend       http</span>
</pre></div>
</div>
<p class="last">Ahora bien, el tráfico sigue cifrado con <abbr title="Transport Layer Security">TLS</abbr> lo cual puede no ser un
problema para el servidor web<a class="footnote-reference" href="#id34" id="id13">[13]</a>, pero sí para los otros servidores. Eso
obligaría a que el backend (<em>ssl-ssh</em> o <em>ssl-vpn</em> en el ejemplo) no entregue
directamente el flujo, sino que cada uno de ellos lo envíe a un puerto local
particular en que escucha también <strong class="program">haproxy</strong> y que sea en este
<em>frontend</em> donde <strong class="program">haproxy</strong> aplique el certificado para descifrar.</p>
</div>
</div>
<div class="section" id="cliente">
<span id="haproxy-cliente"></span><h4>4.5.6.3.3.2. Cliente<a class="headerlink" href="#cliente" title="Enlazar permanentemente con este título">¶</a></h4>
<p class="rubric">UNIX</p>
<p>El cliente <strong class="command">ssh</strong> requiere ayudarse de un <em>software</em> que con <abbr title="Transport Layer Security">TLS</abbr>
envuelva su salida y desenvuelva su entrada, y esa labor la puede hacer
<strong class="command">openssl</strong><a class="footnote-reference" href="#id35" id="id14">[14]</a>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> ssh -p443 -o <span class="s2">&quot;ProxyCommand openssl s_client -quiet -connect %h:%p&quot;</span> usuario@mi.servidor.org
</pre></div>
</div>
<p>lo cual es un poco engorroso, así que es mejor dejarlo ya escrito en el fichero
de configuración del cliente:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">Hostname *servidor</span>
<span class="go">   Host           mi.servidor.org</span>
<span class="go">   Username       usuario</span>
<span class="go">   Port           443</span>

<span class="go">Hostname ssl*</span>
<span class="go">   ProxyCommand   openssl s_client -quiet -connect %h:%p</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Nota</p>
<p>Obsérvese que, de este modo, cuando no necesitemos encapsular el tráfico
podremos hacer:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> ssh servidor
</pre></div>
</div>
<p>y cuando queramos encapsularlo:</p>
<div class="last highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> ssh ssl-servidor
</pre></div>
</div>
</div>
<div class="admonition note">
<p class="first admonition-title">Nota</p>
<p>Si quiséramos enviar un <abbr title="Server Name Identification">SNI</abbr> podríamos añadir a <strong class="command">openssl</strong> la
opción <code class="docutils literal notranslate"><span class="pre">-servername</span></code>:</p>
<div class="last highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">ProxyCommand   openssl s_client -quiet -connect %h:%p -servername ssh.%h</span>
</pre></div>
</div>
</div>
<p class="rubric">Windows</p>
<p>Con <strong class="program">putty</strong> es posible hacer su equivalente, pero como careceremos de
<strong class="program">openssl</strong>, es necesario primero instalarlo. El modo más sencillo es
instalar la versión <em>light</em> que ofrece <a class="reference external" href="https://slproweb.com/products/Win32OpenSSL.html">esta página</a>, que no requerirá más que
vayamos aceptando los distintos pasos de instalación. Al término, tendremos un
ejecutable funcional en el directorio <code class="file docutils literal notranslate"><span class="pre">C:OpenSSL-Win32bin\</span></code>.</p>
<p>Instalado, basta configurar <strong class="program">putty</strong> de este modo:</p>
<img alt="../../_images/SSHoverSSL1.png" src="../../_images/SSHoverSSL1.png" />
<img alt="../../_images/SSHoverSSL2.png" src="../../_images/SSHoverSSL2.png" />
<p>esto es, configurar la sesión para conectarnos al puerto <strong>443</strong> del servidor
que en esta ocasión hemos llamado <em>example.net</em>. A continuación debemos escoger
<code class="docutils literal notranslate"><span class="pre">Connection&gt;Proxy</span></code>, escoger un <em>proxy</em> de tipo <em>local</em> y usar
<strong class="program">openssl</strong> para establecer el túnel del mismo modo en que lo usábamos
con <em>ProxyCommand</em>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">C:\OpenSSL-Win32\bin\openssl.exe s_client -connect %host:%port -quiet</span>
</pre></div>
</div>
</div>
<div class="section" id="modo-transparente">
<span id="haproxy-transparente"></span><h4>4.5.6.3.3.3. Modo transparente<a class="headerlink" href="#modo-transparente" title="Enlazar permanentemente con este título">¶</a></h4>
<p>Es posible hacer que <strong class="program">haproxy</strong> actúe como <em>proxy</em> absolutamente
transparente, pero ello exige algo más que reconfigurarlo. Para empezar, hay dos
condiciones:</p>
<ol class="arabic simple">
<li>El servidor destino de las conexiones (<abbr title="Security SHell">SSH</abbr>, web, etc.) debe estar en una
máquina distinta de la que corre <strong class="program">haproxy</strong>.</li>
<li>La máquina con <strong class="program">haproxy</strong> debe encontrarse en la ruta de salida de
los servidores hacia los clientes. Esta exigencia se debe a que al actuar
nuestro <em>proxy</em> de forma transparente, envía a los servidores como <em>ip</em> de
origen de la comunicación la <em>ip</em> del cliente original. Por ello, la
respuesta del servidor tendrá por destino la <em>ip</em> del cliente y, si el <em>proxy</em>
no se interpone, llegará al cliente sin haber pasado otra vez por el proxy.
Es preciso, pues, interponerse, capturar la respuesta y pasarla otra vez por
<strong class="program">haproxy</strong>.</li>
</ol>
<p>Para ilustrarlo consideraremos el siguiente esquema:</p>
<img alt="../../_images/haproxy-trans.png" src="../../_images/haproxy-trans.png" />
<p>que cumple con lo que decimos. La configuración exige:</p>
<ul>
<li><p class="first">La modificación de un par de parámetros del núcleo (en
<code class="file docutils literal notranslate"><span class="pre">/etc/sysctl/sysctl.conf</span></code>):</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">net.ipv4.ip_forward = 1</span>
<span class="go">net.ipv4.ip_nonlocal_bind = 1</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Nota</p>
<p>Si se quiere habilitarlos inmediatamente, se puede ejecutar:</p>
<div class="last highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> sysctl -p
</pre></div>
</div>
</div>
</li>
<li><p class="first">La adición de reglas de encaminamiento y reglas de <a class="reference internal" href="../../08.redes/07.cortafuegos/01.iptables/index.html#iptables"><span class="std std-ref">iptables</span></a><a class="footnote-reference" href="#id36" id="id15">[15]</a>. Como suponemos que usamos debian, podemos hacerlas perennes, manipulando
el fichero <code class="file docutils literal notranslate"><span class="pre">/etc/network/interfaces</span></code> y dejando así la configuración de
la interfaz que conecta con la red en la que están los servidores:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">allow-hotplug eth1</span>
<span class="go">iface eth1 inet static</span>
<span class="go">   address 192.168.255.1/24</span>
<span class="gp">   #</span> Creamos la reglas
<span class="go">   up   iptables -t mangle -A PREROUTING -i $IFACE -p tcp -m socket --transparent -j MARK --set-mark 111</span>
<span class="go">   up   ip rule add fwmark 111 lookup 100</span>
<span class="go">   up   ip route add local 0.0.0.0/0 dev lo table 100</span>
<span class="gp">   #</span> Y las destruimos
<span class="go">   down iptables -t mangle -D PREROUTING -i $IFACE -p tcp -m socket --transparent -j MARK --set-mark 111</span>
<span class="go">   down ip rule del fwmark 111 lookup 100</span>
<span class="go">   down ip route del local 0.0.0.0/0 dev lo table 100</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Nota</p>
<p>Nótese que por razones de encaminamiento es bastante probable que
necesitemos hacer enmascaramiento en la máquina router-proxy, así que la
interfaz externa puede estar configurada así:</p>
<div class="last highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">allow-hotplug eth0</span>
<span class="go">iface eth0 inet static</span>
<span class="go">   address 172.22.0.2/16</span>
<span class="go">   gateway 172.22.0.1</span>
<span class="go">   up   iptables -t nat -A POSTROUTING -o $IFACE -j MASQUERADE</span>
<span class="go">   down iptables -t nat -D POSTROUTING -o $IFACE -j MASQUERADE</span>
</pre></div>
</div>
</div>
</li>
<li><p class="first">La modificación (mínima) de la configuración de <strong class="program">haproxy</strong> que
implica:</p>
<ul>
<li><p class="first">Comentar en la sección <em>global</em> los líneas que impiden que
<strong class="program">haproxy</strong> se ejecute con premisos de administrador:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span>user haproxy
<span class="gp">#</span>group haproxy
</pre></div>
</div>
</li>
<li><p class="first">Añadir a todos los servidores con los que se quiere actuar como proxy
transparente una directiva más para que se envíen los paquetes utilizando
la <em>ip</em> del cliente como origen:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">backend ssh</span>
<span class="go">   mode tcp</span>
<span class="go">   source 0.0.0.0 usesrc clientip</span>
<span class="go">   server ssh 192.168.255.2:22</span>
</pre></div>
</div>
</li>
</ul>
</li>
</ul>
<div class="admonition note">
<p class="first admonition-title">Nota</p>
<p>En el supuesto de que clientes y servidores estén en la misma red, no
tiene efecto colocar como puerta de enlace de los servidores el <em>proxy</em> para
obligar a que la respuesta pase por él, De todos modos, aún puede hacer que
la comunicación pase por él, manipulando el encaminamiento de los servidores.
Suponiendo que la red sea la <em>192.168.255.0/24</em>, y la <em>ip</em> del <em>proxy</em> la
<em>192.168.255.10</em>, podríamos configurar la interfaz de cada servidor, así:</p>
<div class="last highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">allow-hotplug eth0</span>
<span class="go">iface eth0 inet static</span>
<span class="go">   address 192.168.255.100/24   # La IP que deba tener el servidor.</span>
<span class="go">   gateway 192.168.255.1</span>
<span class="go">   up   ip route add 192.168.255.0/24 via 192.168.255.10 metric 1 dev eth0</span>
<span class="go">   up   ip route del 192.168.255.0/24 dev eth0</span>
<span class="go">   down ip route del 192.168.255.0/24 viua 192.168.255.10 metric 1 dev eth0</span>
<span class="go">   down ip route add 192.168.255.0/24 dev eth0</span>
</pre></div>
</div>
</div>
</div>
</div>
</div>
<div class="section" id="persistencia-de-claves">
<span id="ssh-agent"></span><h2>4.5.6.4. Persistencia de claves<a class="headerlink" href="#persistencia-de-claves" title="Enlazar permanentemente con este título">¶</a></h2>
<div class="admonition note">
<p class="first admonition-title">Nota</p>
<p class="last">Este apartado sólo tiene interés cuando se usan clientes <em>linux</em>.</p>
</div>
<p>Ya se ha dicho muy a la ligera que el cliente de <em>openssh</em> sólo permite la
introducción de claves de manera interactiva, por lo que no hay opción que
permita pasarla al programa ni tampoco se lee esta de la entrada estándar. Si
optamos por el uso de certificados, podemos evitar la introducción de la
contraseña dejando la clave de paso en blanco, pero eso hace que ante un robo de
la clave privada, quedemos sin protección. Por otro lado, es posible que durante
nuestra sesión en el cliente necesitemos repetidamente acceder al servidor y, en
estos casos, será tedioso tener que estar repetidamente introduciendo la
contraseña.</p>
<p>Para paliar este inconveniente tenemos dos soluciones distintas, ambas basadas
en la autenticación con certificado y en <em>hacer coincidir la contraseña del
usuario local en el cliente con la clave de paso</em> que desbloquea la clave
privada.</p>
<div class="admonition warning">
<p class="first admonition-title">Advertencia</p>
<p class="last">Ambas soluciones exigen que la clave de paso sea la misma que la
contraseña del usuario en el cliente, es decir, si en el cliente somos el
usuario <em>pepe</em> con contraseña <em>pepesoyyo</em>, la clave de paso que debemos
escoger al crear el certificado debe ser <em>pepesoyyo</em>.</p>
</div>
<span class="target" id="index-4"></span><div class="section" id="index-5">
<span id="id16"></span><h3>4.5.6.4.1. <strong class="command">ssh-agent</strong><a class="headerlink" href="#index-5" title="Enlazar permanentemente con este título">¶</a></h3>
<p>Este programa permite almacenar claves de paso que luego se usarán cuando sea
necesario para desbloquear la clave privada. Su uso manual es el siguiente:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> ssh-agent
<span class="go">SSH_AUTH_SOCK=/tmp/ssh-wuZYTNFc1wq1/agent.656; export SSH_AUTH_SOCK;</span>
<span class="go">SSH_AGENT_PID=657; export SSH_AGENT_PID;</span>
<span class="go">echo Agent pid 657;</span>
</pre></div>
</div>
<p>Al arrancarlo devuelve su <em>PID</em> y el <em>socket</em> que usará para
comunicarse con el resto de programas de <em>ssh</em>. Para que sea así,
deben definirse como variables de ambiente las dos variables que se ven. De
hecho, la salida es el código que lleva a cabo tal cosa, por lo que la mejor
forma de poner en marcha el programa es así<a class="footnote-reference" href="#id37" id="id17">[16]</a>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> <span class="nb">eval</span> <span class="k">$(</span>ssh-agent<span class="k">)</span>
<span class="go">Agent pid 660</span>
</pre></div>
</div>
<p>de modo que directamente:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> env <span class="p">|</span> grep ^SSH
<span class="go">SSH_AUTH_SOCK=/tmp/ssh-K4lZOZ1jc1iQ/agent.659</span>
<span class="go">SSH_AGENT_PID=660</span>
</pre></div>
</div>
<p>Como ahora están definidas las variables de ambiente que identifican el
<strong class="command">ssh-agent</strong> encargado de gestionar claves, podemos usar
<strong class="command">ssh-add</strong> para añadir una:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> ssh-add
<span class="go">Enter passphrase for /home/usuario/.ssh/id_ecdsa:</span>
<span class="go">Identity added: /home/usuario/.ssh/id_ecdsa (/home/usuario/.ssh/id_ecdsa)</span>
</pre></div>
</div>
<p>Introducida la clave de paso, ya podremos usar en esta terminal las herramientas
de <abbr title="Security SHell">SSH</abbr> (<strong class="command">ssh</strong>, <strong class="command">sftp</strong>, <strong class="command">scp</strong>) sin necesidad de
introducir clave alguna. Si cambiamos a otra terminal tendremos que definir y
exportar las variables de ambiente anteriores (pero no volver a añadir la clave),
para hacer accesible el agente a las aplicaciones.</p>
<p>Aunque lo anterior funciona sin problemas, puede seguir resultando algo
engorroso; así que se le puede dar una vuelta de tuerca más e instalar:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> apt-get install libpam-ssh
</pre></div>
</div>
<p>Este es un módulo que está pensado para tomar la propia contraseña de
autenticación del usuario y usarla para arrancar <strong class="command">ssh-agent</strong> y
desbloquear la clave privada almacenada en <code class="file docutils literal notranslate"><span class="pre">~/.ssh/</span></code><a class="footnote-reference" href="#id38" id="id18">[17]</a>. No requiere de
configuración adicional, porque la instalación se encarga de añadirlo a <em>pam</em>
convenientemente. Hecho esto, no tenemos más que asegurarnos de que tenemos
creado un certificado:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> ssh-keygen -t ecdsa
</pre></div>
</div>
<p>en que la clave de paso coincide con la contraseña del usuario en el cliente (no
con la contraseña del usuario remoto).</p>
<div class="admonition note">
<p class="first admonition-title">Nota</p>
<p class="last">Desgraciadamente, el módulo <em>pam_ssh</em> no está disponible en <em>buster</em>,
ya que <a class="reference external" href="https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=859054">no es compatible con la versión que usa ésta de openssl</a></p>
</div>
<p>Como alternativa al uso de <em>pam_ssh</em>, en los clientes con entorno gráfico puede
compprobarse<a class="footnote-reference" href="#id39" id="id19">[18]</a> que está escrito lo siguiente en
<code class="file docutils literal notranslate"><span class="pre">/etc/X11/Xsession.options</span></code>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> grep ssh /etc/X11/Xsession.options
<span class="go">use-ssh-agent</span>
</pre></div>
</div>
<p>Esto provoca que al realizarse el login gráfico el entorno gráfico arranque
dentro de una sesión de <strong class="command">ssh-agent</strong>, por lo que todas las terminales de
texto que abramos dentro de él, tendrán definidas las dos variables que lo
identifican. Por tanto, basta realizar un <strong class="command">ssh-add</strong> para que a partir
de ese momento no requiramos introducir más claves de paso al acceder al
servidor. Para automatizar un poco el proceso, podemos añadir la siguiente línea
a <code class="file docutils literal notranslate"><span class="pre">.bashrc</span></code>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">[ -n &quot;$SSH_AGENT_PID&quot; ] &amp;&amp; { ssh-add -L &gt; /dev/null || ssh-add; }</span>
</pre></div>
</div>
<p>que provocará que se nos pida automáticamente la coontraseña al abrir la primera
terminal.</p>
<div class="admonition warning">
<p class="first admonition-title">Advertencia</p>
<p class="last">El uso del módulo de <em>pam</em> es más adecuado, ya que el arranque del
gestor de ventanas dentro del ambiente creado por <strong class="command">ssh-agent</strong> hace
que la definición de las dos variables de ambiente sólo exista dentro del
entorno gráfico, por lo que si salimos de él a una terminal de texto pura,
éstas no existen y tendremos que definirlas a mano. En cualquier
caso, si el módulo de <em>pam</em> no puede usarse y se opta por esta segunda vía,
no es necesario que la clave de paso coincida con la contraseña de usuario,
ya que la clave se introduce a posteriori de forma independiente.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Nota</p>
<p class="last">Más adelante, se propone cómo usar un <a class="reference internal" href="#pseudopam-ssh"><span class="std std-ref">script para emular el módulo
pam_ssh</span></a> si no disponemos en el sistema de él.</p>
</div>
</div>
<div class="section" id="gnome-keyring">
<h3>4.5.6.4.2. <strong class="command">gnome-keyring</strong><a class="headerlink" href="#gnome-keyring" title="Enlazar permanentemente con este título">¶</a></h3>
<div class="admonition-todo admonition" id="index-6">
<p class="first admonition-title">Por hacer</p>
<p class="last">Por investigar…</p>
</div>
</div>
</div>
<div class="section" id="acceso-no-interactivo">
<span id="ssh-no-interactivo"></span><h2>4.5.6.5. Acceso no interactivo<a class="headerlink" href="#acceso-no-interactivo" title="Enlazar permanentemente con este título">¶</a></h2>
<p>Se ha expuesto bajo el epígrafe anterior cómo evitar tener que escribir
constantemente la clave de paso, pero eso no da respuesta completa a cómo
ejecutar de manera no interactiva un acceso por <em>ssh</em>; no, al menos, antes de
que hayamos accedido al sistema y tenido oportunidad de escribir la clave, si es
que optamos por usar <strong class="command">ssh-agent</strong> y no disponemos del módulo <em>pam_ssh</em>.</p>
<p>Para poder hacer esto, es necesario saber que la variable <em>SSH_ASKPASS</em> le
indica a <strong class="command">ssh</strong> (y toda la familia de programas clientes) qué programa
usar para obtener la contraseña. Por este motivo, si creamos el programa
<code class="file docutils literal notranslate"><span class="pre">$XDG_RUNTIME_DIR/askpass.sh</span></code><a class="footnote-reference" href="#id40" id="id20">[19]</a>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span>!/bin/sh
<span class="go">cat</span>
</pre></div>
</div>
<p>Podremos añadir la clave de paso a <strong class="command">ssh-agent</strong> del siguiente modo:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> <span class="nb">echo</span> <span class="s2">&quot;mi clave de paso&quot;</span> <span class="p">|</span> <span class="nv">SSH_ASKPASS</span><span class="o">=</span><span class="nv">$XDG_RUNTIME_DIR</span>/askpass.sh ssh-add
</pre></div>
</div>
<p>Pasar la clave de paso<a class="footnote-reference" href="#id41" id="id21">[20]</a> directamente a <strong class="command">ssh</strong> es algo más
complicado y no resultará en una sesión interactiva (lo cual no es un problema,
si el propio acceso pretendemos que sea interactivo):</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span>  <span class="nb">echo</span> <span class="s2">&quot;mi clave de paso&quot;</span> <span class="p">|</span> <span class="nv">SSH_ASKPASS</span><span class="o">=</span><span class="nv">$XDG_RUNTIME_DIR</span>/askpass.sh setsid ssh castillo ls /
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Nota</p>
<p>Hay que hacer dos puntualizaciones a la orden anterior:</p>
<ol class="last arabic">
<li><p class="first">Se requiere que esté definida la variable de ambiente <em>DISPLAY</em>, que lo
estará si estamos usando una terminal gráfica. Si no es el caso, podemos
definirla con un valor cualquiera:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">export DISPLAY=dummy:0</span>
</pre></div>
</div>
</li>
<li><p class="first">Si no hemos accedido anteriormente al servidor, el acceso fallará porque
no seremos capaces de aceptar la clave. Para evitarlo es necesario
aceptarla autómaticamente añadiendo a <strong class="command">ssh</strong> la opción <code class="code docutils literal notranslate"><span class="pre">-o</span>
<span class="pre">StrictHostKeyChecking=no</span></code></p>
</li>
</ol>
</div>
<p>Lo anterior mostrará el contenido del directorio <code class="file docutils literal notranslate"><span class="pre">/</span></code> del servidor.</p>
<p class="rubric" id="pseudopam-ssh">Aplicación práctica</p>
<p>Todo esto tiene utlidad si se programa algún <em>script</em>, por ejemplo, uno que se
ejecute con <em>pam_exec</em> y que nos haga las veces del módulo <em>pam_ssh</em>, por si
definitivamente deja de ser efectivo en las versiones modernas de <em>debian</em>. Los
principios del <em>script</em> son los siguientes:</p>
<ol class="arabic simple">
<li>Al autenticarse, sólo si no hay sesiones abiertas para el usuario, el <em>script</em>
arranca <strong class="command">ssh-agent</strong>, guarda los valores de <code class="docutils literal notranslate"><span class="pre">SSH_AGENT_PID</span></code> y
<code class="docutils literal notranslate"><span class="pre">SSH_AUTH_SOCK</span></code> en un <em>fichero de ambiente</em> y desbloquea la clave privada con
<strong class="command">ssh-add</strong>.</li>
<li>Al abrir sesión, se usa <em>pam_env</em> para hacer que las dos variables contenidas
en el fichero sean variables de ambiente.</li>
<li>Al cerrar sesión, si no hay otras sesiones abiertas por el usuario, se borra
el fichero de ambiente y se mata <strong class="command">ssh-agent</strong>.</li>
</ol>
<p>El <em>script</em> es <a class="reference download internal" download="" href="../../_downloads/baf295208c3a1fbab64980258e9b5739/pam_ssh.sh"><code class="xref download docutils literal notranslate"><span class="pre">éste</span></code></a>, que debe alojarse en
<code class="file docutils literal notranslate"><span class="pre">/usr/local/bin/</span></code>. Para automatizar la manipulación de <em>pam</em> se incluye
<a class="reference download internal" download="" href="../../_downloads/b32ef6a1a8c233b5751383eb4fc8991c/pam-ssh"><code class="xref download docutils literal notranslate"><span class="pre">este</span> <span class="pre">otro</span> <span class="pre">fichero</span></code></a>, de manera que debemos hacer lo
siguiente:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> mv /path/donde/este/pam_ssh.sh /usr/local/bin
<span class="gp">#</span> mv /path/donde/este/pam-ssh /usr/share/pam-configs
<span class="gp">#</span> pam-auth-update
</pre></div>
</div>
<p>Para habilitar la acción del <em>script</em> debemos seleccionar el desbloqueo de
claves <abbr title="Security SHell">SSH</abbr>.</p>
<div class="admonition note">
<p class="first admonition-title">Nota</p>
<p>El <em>script</em> usa <strong class="command">ssh-add</strong> sin argumentos, así que se
detectará la clave privada si esta tiene su ubicación predeterminada. Además,
se ejecuta para los servicios <em>login</em>, <em>slim</em>, <em>lightdm</em>, <em>gdm</em>, <em>xdm</em> y
<em>kdm</em>. Es posible escoger otros servicios, manipulando <code class="file docutils literal notranslate"><span class="pre">pam-ssh</span></code> y
añadiendo a la dos líneas presentes en <em>Auth</em> y <em>Auth-Initial</em>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">optional pam_exec.so expose_authtok quiet /usr/local/bin/pam_ssh.sh</span>
</pre></div>
</div>
<p>el parámetro <em>start_if</em>, cuyo valor debe ser todos los servicios para los
que deseemos ejecutar el <em>script</em> separados por comas:</p>
<div class="last highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">optional pam_exec.so expose_authtok quiet /usr/local/bin/pam_ssh.sh start_if=login,sshd,slim</span>
</pre></div>
</div>
</div>
<p class="rubric">Notas al pie</p>
<table class="docutils footnote" frame="void" id="id22" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td><p class="first">Observe que:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> scp usuario@servidor:fichero<span class="o">{</span><span class="m">1</span>,2<span class="o">}</span>.txt .
</pre></div>
</div>
<p>y:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> scp usuario@servidor:<span class="s2">&quot;fichero{1,2}.txt&quot;</span> .
</pre></div>
</div>
<p class="last">pretenden lo mismo: descargar los ficheros <code class="file docutils literal notranslate"><span class="pre">fichero1.txt</span></code> y
<code class="file docutils literal notranslate"><span class="pre">fichero2.txt</span></code> en el cliente, pero hay una diferencia importante entre
ellos. En el primer caso la expansión de la <em>shell</em> se produce en el cliente,
mientras que en la segunda se produce en el servidor. Como consecuencia, en
el primer caso habrá dos autenticaciones, mientras que en el segundo sólo
una. Así pues, es mejor usar la segunda forma.</p>
</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id23" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[2]</a></td><td>El acceso por el puerto <strong>443</strong> ofrece la ventaja de que, en caso de que
un <em>proxy</em> vigile el tráfico, no podrá más que comprobar que existe protocolo
<abbr title="Transport Layer Security">TLS</abbr> y hacer algunas comprobaciones sobre éste (por ejemplo, la autenticidad
del certificado del servidor), ya que el contenido encapsulado está cifrado
y, consecuentemente, es totalmente opaco. Por contra, un <em>proxy</em> que vigile el
puerto <strong>80</strong> puede acceder al contenido y ver que esas supuestas páginas son
bastante raras. Si su filtrado también se basa en analizar el contenido, lo
más probable es que no pasemos su filtro.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id24" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3">[3]</a></td><td><p class="first">Donde queramos poner a escuchar <strong class="program">openvpn</strong> depende de nuestras
intenciones. Escoger el puerto <strong>1194</strong> responde a que ese es el puerto
estándar para esa aplicación (de hecho, aparece referido en
<code class="file docutils literal notranslate"><span class="pre">/etc/services</span></code>). Una buena estrategia es ponerlo a escuchar:</p>
<blockquote class="last">
<div><ul class="simple">
<li>En el puerto <em>1194/UDP</em> en todas las interfaces.</li>
<li>En el puerto <em>1194/TCP</em> de la interfaz local, cuya conexión remota se
haŕa gracias a la intermediación de <strong class="program">haproxy</strong>.</li>
</ul>
</div></blockquote>
</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id25" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id4">[4]</a></td><td>En teoría, el tráfico debe ser <abbr title="HyperText Transfer Protocol">HTTP</abbr>s, es decir, <abbr title="HyperText Transfer Protocol">HTTP</abbr> ofuscado e
irreconocible gracias a la envoltura segura que ofrece <abbr title="Transport Layer Security">TLS</abbr>.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id26" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id5">[5]</a></td><td>De lo que se deduce que el epígrafe es inexacto: debería llamarse <em>SSH
sobre TLS</em>.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id27" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id6">[6]</a></td><td>Como el <em>proxy</em> es capaz de <em>ver</em> la capa <abbr title="Transport Layer Security">TLS</abbr>, no solamente puede
comprobar si se usa tal protocolo, sino también exigir la validez del
certificado. En ese caso, no tendremos más remedio que generar un certificado
válido.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id28" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id7">[7]</a></td><td>También podría usarse el módulo <a class="reference external" href="https://httpd.apache.org/docs/2.4/mod/mod_proxy.html">mod_proxy</a> de <a class="reference external" href="http://apache.org/">apache</a> o <a class="reference external" href="http://www.squid-cache.org/">squid</a>.
Desgraciadamente, no puede usarse como <em>proxy</em> <a class="reference internal" href="../../07.serre/02.web/02.nginx/index.html#n-ginx"><span class="std std-ref">nginx</span></a>,
ya que éste sólo funciona como <em>proxy inverso</em>. En realidad,
<strong class="command">nginx</strong> tiene un módulo de terceros que sí lo permite,
<a class="reference external" href="https://github.com/chobits/ngx_http_proxy_connect_module">ngx_http_proxy_connect</a>, pero en el
estado actual en que se halla la modularidad de <strong class="program">nginx</strong> es un
engorro utilizarlo.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id29" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id8">[8]</a></td><td>Con una importante diferencia: se altera el origen de la conexión y el
servidor creerá que las peticiones las recibe de <strong class="program">haproxy</strong> (o sea,
la máquina local) y del cliente original. Se discutirá más adelante.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id30" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id9">[9]</a></td><td>Ahora bien, en la práctica deberemos usar un certificado fiable, porque
si el motivo de usar <strong class="program">haproxy</strong> es la existencia de un <em>proxy</em>, lo
necesitaremos; y, si tal <em>proxy</em> no existe, es mejor usar una solución como
<strong class="program">sslh</strong>.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id31" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id10">[10]</a></td><td>En el <em>gancho</em> propuesto el fichero con las claves no se llama
<em>keycert.pem</em>, sino <em>nombre_del_servidor.pem</em>. Téngalo en cuenta a la hora de
copiar la configuración de ejemplo.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id32" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id11">[11]</a></td><td>Todo cliente debe empezar su comunicación con la cadena «<em>SSH-2.0</em>», que
puesta en binario es el código hexadecimal escrito en la configuración.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id33" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id12">[12]</a></td><td>Para profundizar en la configuración del servidor web, cuando es el
<em>proxy</em> de cifrar y descifrar la comunicación, vea el <a class="reference internal" href="../../07.serre/02.web/02.nginx/02.avanz/07.https.html#nginx-haproxy"><span class="std std-ref">apartado
correspondiente</span></a>.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id34" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id13">[13]</a></td><td>En realidad sí lo es, porque no habrá forma de conocer el origen de la
petición, a menos que, además, se configure <strong class="program">haproxy</strong> en <a class="reference internal" href="#haproxy-transparente"><span class="std std-ref">modo
transparente</span></a>.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id35" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id14">[14]</a></td><td>Obviamente, este software de <em>proxy</em> para el cliente sólo es necesario si
necesitamos establecer el túnel <abbr title="Transport Layer Security">TLS</abbr>. Si no es el caso (segunda variante en
redes sin proxy que fiscalece la comunicación), en el cliente no hay más que
asegurarse de que nos conectamos al puerto <strong>443</strong>.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id36" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id15">[15]</a></td><td><p class="first">Esta configuración requiere que el núcleo se haya compilado con el módulo
<code class="docutils literal notranslate"><span class="pre">NETFILTER_XT_MATCH_SOCKET</span></code>, pero esto es así en las <em>debian</em> modernas:</p>
<div class="last highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> grep -i match_socket /boot/config-<span class="sb">`</span>uname -r<span class="sb">`</span>
<span class="go">CONFIG_NETFILTER_XT_MATCH_SOCKET=m</span>
</pre></div>
</div>
</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id37" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id17">[16]</a></td><td><p class="first">Si antes queremos deshacernos del <strong class="command">ssh-agent</strong> ya en ejecucion
podemos hacer lo siguiente:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> <span class="nb">export</span> <span class="nv">SSH_AUTH_SOCK</span><span class="o">=</span>/tmp/ssh-wuZYTNFc1wq1/agent.656
<span class="gp">$</span> <span class="nb">export</span> <span class="nv">SSH_AGENT_PID</span><span class="o">=</span><span class="m">657</span>
<span class="gp">$</span> ssh-agent -k
</pre></div>
</div>
<p>o matarlo directamente, que es más rápido:</p>
<div class="last highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> <span class="nb">kill</span> -1 <span class="m">657</span>
</pre></div>
</div>
</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id38" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id18">[17]</a></td><td>Consúltese su página de manual para que la clave privada no sea una de
las predeterminadas de <strong class="command">ssh</strong> (<code class="file docutils literal notranslate"><span class="pre">~/.ssh/id_rsa</span></code>,
<code class="file docutils literal notranslate"><span class="pre">~/.ssh/id_ecdsa</span></code>, etc.)</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id39" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id19">[18]</a></td><td>Si se usa <em>pam_ssh</em> (o el <a class="reference internal" href="#pseudopam-ssh"><span class="std std-ref">script sustitutorio después propuesto</span></a>) conviene, precisamente, cerciorarse de que esto no está
activo comentando la opción)</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id40" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id20">[19]</a></td><td>No se usa directamente <strong class="command">cat</strong> porque <strong class="program">ssh-add</strong> y el
resto de programas pasan argumentos que lo malogran. El <em>script</em> desecha los
argumentos y sólo atiende a la entrada estándar que es lo que interesa.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id41" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id21">[20]</a></td><td>O la contraseña, no es necesario la autenticación mediante clave pública
y privada.</td></tr>
</tbody>
</table>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../../index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">4.5.6. Aspectos adicionales</a><ul>
<li><a class="reference internal" href="#transferencia-de-ficheros">4.5.6.1. Transferencia de ficheros</a></li>
<li><a class="reference internal" href="#trampolin-de-acceso">4.5.6.2. Trampolín de acceso</a></li>
<li><a class="reference internal" href="#redes-restringidas">4.5.6.3. Redes restringidas</a><ul>
<li><a class="reference internal" href="#puerto-libre-sin-vigilancia">4.5.6.3.1. Puerto libre sin vigilancia</a></li>
<li><a class="reference internal" href="#multiplexacion">4.5.6.3.2. Multiplexación</a></li>
<li><a class="reference internal" href="#ssh-sobre-https">4.5.6.3.3. <abbr title="Security SHell">SSH</abbr> sobre <abbr title="HyperText Transfer Protocol">HTTP</abbr>s</a><ul>
<li><a class="reference internal" href="#servidor">4.5.6.3.3.1. Servidor</a></li>
<li><a class="reference internal" href="#cliente">4.5.6.3.3.2. Cliente</a></li>
<li><a class="reference internal" href="#modo-transparente">4.5.6.3.3.3. Modo transparente</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#persistencia-de-claves">4.5.6.4. Persistencia de claves</a><ul>
<li><a class="reference internal" href="#index-5">4.5.6.4.1. <strong class="command">ssh-agent</strong></a></li>
<li><a class="reference internal" href="#gnome-keyring">4.5.6.4.2. <strong class="command">gnome-keyring</strong></a></li>
</ul>
</li>
<li><a class="reference internal" href="#acceso-no-interactivo">4.5.6.5. Acceso no interactivo</a></li>
</ul>
</li>
</ul>

  <h4>Tema anterior</h4>
  <p class="topless"><a href="03.tuneles.html"
                        title="capítulo anterior">4.5.5. Túneles</a></p>
  <h4>Próximo tema</h4>
  <p class="topless"><a href="../../05.discos/index.html"
                        title="próximo capítulo">5. Dispositivos de almacenamiento</a></p>
  <div role="note" aria-label="source link">
    <h3>Esta página</h3>
    <ul class="this-page-menu">
      <li><a href="../../_sources/04.servidor/10.ssh/04.adicional.rst.txt"
            rel="nofollow">Mostrar el código</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Búsqueda rápida</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Ir a" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navegación</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="Índice General"
             >índice</a></li>
        <li class="right" >
          <a href="../../05.discos/index.html" title="5. Dispositivos de almacenamiento"
             >siguiente</a> |</li>
        <li class="right" >
          <a href="03.tuneles.html" title="4.5.5. Túneles"
             >anterior</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">documentación de Linuxnomicón - rolling</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" >4. Gestión del servidor</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="index.html" >4.5. Administración remota</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Derechos de autor CC BY 4.0, 2016-2020, José Miguel Sánchez Alés.
      Creado con <a href="http://sphinx-doc.org/">Sphinx</a> 1.8.5.
    </div>
  </body>
</html>