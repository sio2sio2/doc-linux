

<!DOCTYPE html>

<html lang="es" data-content_root="../../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>9.1.3.4. Protocolos seguros de red &#8212; documentación de Linuxnomicón - rolling</title>
    <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=b76e3c8a" />
    <link rel="stylesheet" type="text/css" href="../../../_static/classic.css?v=514cf933" />
    <link rel="stylesheet" href="../../../_static/custom.css" type="text/css" />
    
    <script src="../../../_static/documentation_options.js?v=a621b78a"></script>
    <script src="../../../_static/doctools.js?v=888ff710"></script>
    <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../_static/translations.js?v=efdbd0b9"></script>
    
    <link rel="index" title="Índice" href="../../../genindex.html" />
    <link rel="search" title="Búsqueda" href="../../../search.html" />
    <link rel="next" title="9.1.3.5. Autenticación" href="05.auth.html" />
    <link rel="prev" title="9.1.3.3. Correo electrónico" href="03.correo.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navegación</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="Índice General"
             accesskey="I">índice</a></li>
        <li class="right" >
          <a href="05.auth.html" title="9.1.3.5. Autenticación"
             accesskey="N">siguiente</a> |</li>
        <li class="right" >
          <a href="03.correo.html" title="9.1.3.3. Correo electrónico"
             accesskey="P">anterior</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">documentación de Linuxnomicón - rolling</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" ><span class="section-number">9. </span>Apéndices</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="../index.html" ><span class="section-number">9.1. </span>Criptografía</a> &#187;</li>
          <li class="nav-item nav-item-3"><a href="../03.aplicaciones.html" accesskey="U"><span class="section-number">9.1.3. </span>Aplicaciones de la criptografía</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href=""><span class="section-number">9.1.3.4. </span>Protocolos seguros de red</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="protocolos-seguros-de-red">
<span id="proto-seguro"></span><h1><span class="section-number">9.1.3.4. </span>Protocolos seguros de red<a class="headerlink" href="#protocolos-seguros-de-red" title="Link to this heading">¶</a></h1>
<p>Para la comunicación segura entre extremos se han desarrollado distintos protocolos
que recurren al <a class="reference internal" href="../02.algo.html#hibrido"><span class="std std-ref">cifrado híbrido</span></a>. Todos los protocolos modernos
incluyen la seguridad en su diseño, pero para asegurar antiguos carentes de
ella, nació <a class="reference internal" href="#ssl"><span class="std std-ref">SSL</span></a> que es tan sólo un protocolo que permite crear un
canal seguro sobre el que puedan actuar protocolos inseguros.</p>
<section id="vpn">
<h2><span class="section-number">9.1.3.4.1. </span><abbr title="Virtual Private Network">VPN</abbr><a class="headerlink" href="#vpn" title="Link to this heading">¶</a></h2>
<p>No es propiamente un protocolo, sino una red privada virtual, esto es una
tecnología de comunicación entre redes de ordenadores que permite, a través de
una red pública (internet), la conexión segura punto a punto entre dos redes
locales de ordenadores. Esta conexión puede ser efectuada en capa 3, en cuyo
caso las dos redes extremas serán redes distintas; o en capa 2, en cuyo caso el
enlace conectará las dos redes extremas como dos segmentos de una misma red.</p>
<p>Para establecer una <abbr title="Virtual Private Network">VPN</abbr> no hay un único protocolo, sino toda pléyade de
protocolos que se pueden agrupar en cuatro familias: el obsoleto <abbr title="Point-tp-Point Tunneling Protocol">PPTP</abbr>, las que
usan <em>IPSec</em>, los que usan <abbr title="Secure Socket Layer">SSL</abbr> y otros que se basan en <a class="reference external" href="http://www.noiseprotocol.org">Noise</a>.</p>
<div class="admonition seealso">
<p class="admonition-title">Ver también</p>
<p>Hay <a class="reference internal" href="../../../07.serre/04.vpn/index.html#vpn"><span class="std std-ref">un extenso epígrafe</span></a> dedicado a este tipo de
protocolos.</p>
</div>
</section>
<section id="ssh">
<span id="crypto-ssh"></span><h2><span class="section-number">9.1.3.4.2. </span><abbr title="Security SHell">SSH</abbr><a class="headerlink" href="#ssh" title="Link to this heading">¶</a></h2>
<p>Surgió como reemplazo al protocolo <em>telnet</em> que se usaba para la administración
remota de servidores. Sin embargo, no se limita a esto y es capaz de ofrecer
otros servicios seguros como la <a class="reference internal" href="../../../07.serre/01.ftp/03.ssh.html#ssh-ftp"><span class="std std-ref">transferencia de ficheros</span></a> o la
<a class="reference internal" href="../../../04.servidor/10.ssh/03.tuneles.html#tunel-ssh"><span class="std std-ref">tunelización de otras comunicaciones</span></a>, funcionalidad esta
análoga a la que ofrece <a class="reference internal" href="#ssl"><span class="std std-ref">SSL</span></a>. Utiliza clave pública para
implementar el <a class="reference internal" href="../02.algo.html#hibrido"><span class="std std-ref">cifrado híbrido</span></a> e implementa la identificación
de servidor y cliente tanto mediante el uso de simples claves como mediante el
uso de certificados, aunque éstos tienen un formato propio ajeno al estándar de
los <a class="reference internal" href="01.certdig.html#cert-digital"><span class="std std-ref">certificados digitales X.509</span></a>.</p>
<p>Es pertinente para este epígrafe estudiar cómo funciona la <a class="reference internal" href="../../../04.servidor/10.ssh/02.certificados.html#ssh-cert"><span class="std std-ref">autenticación
de clave pública</span></a> y sus dos variantes:</p>
<ul class="simple">
<li><p><a class="reference internal" href="../../../04.servidor/10.ssh/02.certificados.html#ssh-auth-keys"><span class="std std-ref">Autenticación con claves</span></a>.</p></li>
<li><p><a class="reference internal" href="../../../04.servidor/10.ssh/02.certificados.html#ssh-auth-certs"><span class="std std-ref">Autenticación con certificado digital</span></a>.</p></li>
</ul>
</section>
<section id="ssl-tls">
<span id="ssl"></span><h2><span class="section-number">9.1.3.4.3. </span><abbr title="Secure Socket Layer">SSL</abbr>/<abbr title="Transport Layer Security">TLS</abbr><a class="headerlink" href="#ssl-tls" title="Link to this heading">¶</a></h2>
<p>En realidad son el mismo protocolo, ya que <abbr title="Transport Layer Security">TLS</abbr> es el sucesor de <abbr title="Secure Socket Layer">SSL</abbr>, aunque
es común que se le siga denominando <abbr title="Secure Socket Layer">SSL</abbr>. Básicamente es un protocolo que
permite encapsular de modo seguro otro protocolo de red. Surgió en 1994 para
encapsular el protocolo <abbr title="HyperText Transfer Protocol">HTTP</abbr> (y crear <abbr title="HyperText Transfer Protocol">HTTP</abbr>s) en los navegadores <a class="reference external" href="https://es.wikipedia.org/wiki/Netscape_">Netscape</a>.</p>
<p><abbr title="Secure Socket Layer">SSL</abbr> es independiente del protocolo no seguro que cifre y, simplemente,
establece un encapsulamiento cifrado bajo el cual circula el protocolo plano sin
modificaciones. Su funcionamiento básicamente es el siguiente:</p>
<ul class="simple">
<li><p>Los extremos establecen una conexión segura según lo explicado en el
<a class="reference internal" href="../02.algo.html#hibrido"><span class="std std-ref">cifrado híbrido</span></a> a fin de que la clave simétrica esté presente
en ambos extremos y pueda establecerse el túnel.</p></li>
<li><p>En el cliente, la comunicación en el protocolo arbitrario se cifra gracias a
<abbr title="Secure Socket Layer">SSL</abbr> y se envía al servidor donde el protocolo <abbr title="Secure Socket Layer">SSL</abbr> se encarga de descifrar
y entregar la comunicación en claro al servidor.</p></li>
<li><p>La respuesta del servidor se cifra, se envía a través de la red, y al llegar
al cliente, se descifra y se entrega al cliente.</p></li>
</ul>
<p>Podemos pues considerar al protocolo <abbr title="Secure Socket Layer">SSL</abbr> como un mero intérprete que se
encarga de cifrar la comunicación al salir y descifrarla al entrar.</p>
<img alt="../../../_images/ssl.png" src="../../../_images/ssl.png" />
<p>Por tanto, servidor y cliente siguen comunicándose a través del mismo protocolo
en claro. Lo que suele ocurrir, no obstante, es que ambos, servidor y cliente,
lleven incorporada la capacidad de cifrar con <abbr title="Secure Socket Layer">SSL</abbr>. Por ejemplo, en una
comunicación <abbr title="HyperText Transfer Protocol">HTTP</abbr>s, que no es más que <abbr title="HyperText Transfer Protocol">HTTP</abbr> sobre <abbr title="Secure Socket Layer">SSL</abbr>, se comunican
directamente navegador con servidor web, porque son ellos dos los que también
cifran y descifran. Sin embargo, esto no tiene por qué ser así. Es bastante
común el siguiente esquema:</p>
<img alt="../../../_images/https.png" src="../../../_images/https.png" />
<p>en el que no es el servidor web el que cifra usando el protocolo <abbr title="Secure Socket Layer">SSL</abbr>, sino un
proxy web intermedio. Este proxy web inverso, se encuentra en la misma máquina
que el servidor o en una máquina de la misma red, por lo que no se compromete la
seguridad y facilita que se pueda colocar entre él y el servidor web, un proxy
de cacheo como <a class="reference external" href="https://varnish-cache.org/">varnish</a> que, con una buena política, permite agilizar el
servicio de páginas dinámicas.</p>
<p><abbr title="Secure Socket Layer">SSL</abbr> usa <a class="reference internal" href="01.certdig.html#cert-digital"><span class="std std-ref">certificados digitales X.509</span></a>. que, además,
de contribuir al cifrado, permiten al cliente confirmar la identidad del
servidor.</p>
<section id="sni">
<span id="id1"></span><h3><span class="section-number">9.1.3.4.3.1. </span><abbr title="Server Name Indication">SNI</abbr><a class="headerlink" href="#sni" title="Link to this heading">¶</a></h3>
<p>Al cifrar <abbr title="Transport Layer Security">TLS</abbr> por completo el protocolo subyacente, es preciso que opere el
certificado antes de poder acceder a cualquier información de capa de
aplicación. Esto supone un problema cuando un servidor maneja varios
certificados, cada uno asociado a un nombre de máquina, y se precisa conocer de
antemano qué nombre ha utilizado el cliente al hacer la petición para que el
servidor utilice el certificado correspondiente. En este caso, no hay modo de
saber el nombre sin descifrar y no se puede descifrar hasta no conocer cuál es
el nombre de máquina.</p>
<p>Para sortear este inconveniente se creó la extensión <abbr title="Server Name Indication">SNI</abbr>, que permite incluir
sin cifrar el nombre de la máquina a la que se conecta el cliente, de modo que
el servidor pueda escoger el certificado adecuado. Todos los navegadores
modernos soportan esta extensión.</p>
</section>
<section id="starttls">
<span id="id2"></span><h3><span class="section-number">9.1.3.4.3.2. </span>STARTTLS<a class="headerlink" href="#starttls" title="Link to this heading">¶</a></h3>
<p>El uso de <abbr title="Secure Socket Layer">SSL</abbr> tiene, sin embargo, un inconveniente: al tener que establecerse
previamente el túnel seguro, dentro del cual circula el protocolo en claro, es
necesario utilizar un puerto distinto de escucha, ya que o se escucha para
establecer una comunicación con el protocolo en claro o se escucha para
establecer un canal seguro. Esa es la razón por la que los servidores web
escuchan habitualmente en el puerto <strong>80</strong> (<abbr title="HyperText Transfer Protocol">HTTP</abbr>) y en el puerto <strong>443</strong>
(<abbr title="HyperText Transfer Protocol">HTTP</abbr>s).</p>
<table class="starttls docutils align-default" id="id5">
<caption><span class="caption-text"><strong>Puertos de escucha</strong></span><a class="headerlink" href="#id5" title="Link to this table">¶</a></caption>
<thead>
<tr class="row-odd"><th class="head"><p>Puerto original</p></th>
<th class="head"><p>Puerto seguro</p></th>
<th class="head"><p>Propósito</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><abbr title="Simple Mail Transfer Protocol">SMTP</abbr>/25</p></td>
<td><p><abbr title="Simple Mail Transfer Protocol">SMTP</abbr>S/465</p></td>
<td><p>Envío de correo electrónico.</p></td>
</tr>
<tr class="row-odd"><td><p><abbr title="HyperText Transfer Protocol">HTTP</abbr>/80</p></td>
<td><p><abbr title="HyperText Transfer Protocol">HTTP</abbr>S/443</p></td>
<td><p>Servicio web.</p></td>
</tr>
<tr class="row-even"><td><p><abbr title="Post Office Protocol v3">POP3</abbr>/110</p></td>
<td><p><abbr title="Post Office Protocol v3">POP3</abbr>S/995</p></td>
<td><p>Buzón de correo electrónico.</p></td>
</tr>
<tr class="row-odd"><td><p><abbr title="Internet Message Access Protocol">IMAP</abbr>/143</p></td>
<td><p><abbr title="Internet Message Access Protocol">IMAP</abbr>S/993</p></td>
<td><p>Buzón de correo electrónico.</p></td>
</tr>
<tr class="row-even"><td><p><abbr title="Lightweight Directory Access Protocol">LDAP</abbr>/389</p></td>
<td><p><abbr title="Lightweight Directory Access Protocol">LDAP</abbr>S/636</p></td>
<td><p>Servicio de directorio.</p></td>
</tr>
</tbody>
</table>
<p>Para evitarlo, se ideó <em class="dfn">STARTTLS</em> que es una extensión para los protocolos
en claro (<abbr title="Simple Mail Transfer Protocol">SMTP</abbr>, <abbr title="Internet Message Access Protocol">IMAP</abbr>, <abbr title="Lightweight Directory Access Protocol">LDAP</abbr>, etc.) que permite negociar el cifrado, de
manera que servidor y cliente establecen comunicación con el protocolo
correspondiente y negocian para que la comunicación pase a cifrarse con <abbr title="Secure Socket Layer">SSL</abbr>.
Gracias a ello, no es necesario ocupar dos puertos distintos y la comunicación,
segura o no, puede realizarse siempre por el puerto tradicional. No obstante:</p>
<ul class="simple">
<li><p>A diferencia de lo que ocurre en el resto de protocolos, en la comunicación
web, sigue sin usarse STARTTLS. En los demás, se ha ido abandonando el uso del
protocolo seguro por la negociación del cifrado.</p></li>
<li><p>En el protocolo <abbr title="Simple Mail Transfer Protocol">SMTP</abbr> suelen usarse dos puertos distintos para negociación
STARTTLS: el <strong>25</strong> para comunicación entre servidores, por lo general, sin
autenticación; y el <strong>587</strong> para comunicación con autenticación
cliente-servidor.</p></li>
</ul>
</section>
<section id="pruebas-practicas">
<h3><span class="section-number">9.1.3.4.3.3. </span>Pruebas prácticas<a class="headerlink" href="#pruebas-practicas" title="Link to this heading">¶</a></h3>
<p>Es posible ilustrar cómo actúa el protocolo <abbr title="Secure Socket Layer">SSL</abbr> con algunas órdenes sencillas
y a ello dedicaremos el epígrafe:</p>
<section id="conexiones-ssl">
<h4><span class="section-number">9.1.3.4.3.3.1. </span>Conexiones <abbr title="Secure Socket Layer">SSL</abbr><a class="headerlink" href="#conexiones-ssl" title="Link to this heading">¶</a></h4>
<p>Empecemos probando sobre un servidor de correo (protocolo <abbr title="Simple Mail Transfer Protocol">SMTP</abbr>) que utiliza
<abbr title="Secure Socket Layer">SSL</abbr> para asegurar el secreto de la información. Como ya hemos dejado dicho, en
el puerto <strong>587</strong> se habilita una negociación. Por tanto, si el cliente no
entiende <abbr title="Secure Socket Layer">SSL</abbr> y utiliza directamente el protocolo <abbr title="Simple Mail Transfer Protocol">SMTP</abbr>, la conexión
simplemente será no segura:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>telnet<span class="w"> </span>smtp.gmail.com<span class="w"> </span><span class="m">587</span>
<span class="go">Trying 108.177.15.108...</span>
<span class="go">Connected to gmail-smtp-msa.l.google.com.</span>
<span class="go">Escape character is &#39;^]&#39;.</span>
<span class="go">220 smtp.gmail.com ESMTP r12sm6291342wrq.3 - gsmtp</span>
<span class="hll"><span class="go">EHLO localhost</span>
</span><span class="go">250-smtp.gmail.com at your service, [81.0.56.71]</span>
<span class="go">250-SIZE 35882577</span>
<span class="go">250-8BITMIME</span>
<span class="go">250-STARTTLS</span>
<span class="go">250-ENHANCEDSTATUSCODES</span>
<span class="go">250-PIPELINING</span>
<span class="go">250-CHUNKING</span>
<span class="go">250 SMTPUTF8</span>
<span class="hll"><span class="go">QUIT</span>
</span><span class="go">221 2.0.0 closing connection r12sm6291342wrq.3 - gsmtp</span>
<span class="go">Connection closed by foreign host.</span>
</pre></div>
</div>
<p>que es lo que se ilustra en el código de arriba. Si por el contrario quisiéramos
negociar la seguridad para que la conexión sea cifrada, podemos usar
convenientemente <strong class="command">openssl</strong> sobre el mismo puerto:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>openssl<span class="w"> </span>s_client<span class="w"> </span>-connect<span class="w"> </span>smtp.gmail.com:587<span class="w"> </span>-starttls<span class="w"> </span>smtp<span class="w"> </span>-quiet
<span class="go">depth=2 OU = GlobalSign Root CA - R2, O = GlobalSign, CN = GlobalSign</span>
<span class="go">verify return:1</span>
<span class="go">depth=1 C = US, O = Google Trust Services, CN = Google Internet Authority G3</span>
<span class="go">verify return:1</span>
<span class="go">depth=0 C = US, ST = California, L = Mountain View, O = Google LLC, CN =</span>
<span class="go">smtp.gmail.com</span>
<span class="go">verify return:1</span>
<span class="go">250 SMTPUTF8</span>
<span class="hll"><span class="go">EHLO localhost</span>
</span><span class="go">250-smtp.gmail.com at your service, [81.0.56.71]</span>
<span class="go">250-SIZE 35882577</span>
<span class="go">250-8BITMIME</span>
<span class="go">250-AUTH LOGIN PLAIN XOAUTH2 PLAIN-CLIENTTOKEN OAUTHBEARER XOAUTH</span>
<span class="go">250-ENHANCEDSTATUSCODES</span>
<span class="go">250-PIPELINING</span>
<span class="go">250-CHUNKING</span>
<span class="go">250 SMTPUTF8</span>
<span class="hll"><span class="go">QUIT</span>
</span><span class="go">221 2.0.0 closing connection 200sm9064552wmw.31 - gsmtp</span>
<span class="go">read:errno=0</span>
</pre></div>
</div>
<p>Por últimos, podemos establecer el canal seguro y, una vez establecido, iniciar la
conversación, o sea, utlizar <abbr title="Simple Mail Transfer Protocol">SMTP</abbr>s. Para ello, podemos conectarnos al puerto
<strong>446</strong> con <strong class="command">openssl</strong>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>openssl<span class="w"> </span>s_client<span class="w"> </span>-connect<span class="w"> </span>smtp.gmail.com:465<span class="w"> </span>-quiet
<span class="go">depth=2 OU = GlobalSign Root CA - R2, O = GlobalSign, CN = GlobalSign</span>
<span class="go">verify return:1</span>
<span class="go">depth=1 C = US, O = Google Trust Services, CN = Google Internet Authority G3</span>
<span class="go">verify return:1</span>
<span class="go">depth=0 C = US, ST = California, L = Mountain View, O = Google LLC, CN =</span>
<span class="go">smtp.gmail.com</span>
<span class="go">verify return:1</span>
<span class="go">220 smtp.gmail.com ESMTP h16sm24225437wrb.62 - gsmtp</span>
<span class="hll"><span class="go">EHLO localhost</span>
</span><span class="go">250-smtp.gmail.com at your service, [81.0.56.71]</span>
<span class="go">250-SIZE 35882577</span>
<span class="go">250-8BITMIME</span>
<span class="go">250-AUTH LOGIN PLAIN XOAUTH2 PLAIN-CLIENTTOKEN OAUTHBEARER XOAUTH</span>
<span class="go">250-ENHANCEDSTATUSCODES</span>
<span class="go">250-PIPELINING</span>
<span class="go">250-CHUNKING</span>
<span class="go">250 SMTPUTF8</span>
<span class="hll"><span class="go">QUIT</span>
</span><span class="go">221 2.0.0 closing connection h16sm24225437wrb.62 - gsmtp</span>
<span class="go">read:errno=0</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>Para incluir <abbr title="Server Name Indication">SNI</abbr> en la petición de <strong class="command">openssl</strong> puede añadirse
la opción <kbd class="kbd compound docutils literal notranslate"><kbd class="kbd docutils literal notranslate">-servername</kbd> <kbd class="kbd docutils literal notranslate">smtp.gmail.com</kbd></kbd>.</p>
</div>
</section>
<section id="tunelizacion">
<h4><span class="section-number">9.1.3.4.3.3.2. </span>Tunelización<a class="headerlink" href="#tunelizacion" title="Link to this heading">¶</a></h4>
<p>Nuestra intención ahora es investigar cómo tunelizar cualquier conexión insegura
con <abbr title="Secure Socket Layer">SSL</abbr>:</p>
<img alt="../../../_images/tunel-ssl.png" src="../../../_images/tunel-ssl.png" />
<p>Como se representa en el gráfico se interpone un cliente-servidor <abbr title="Secure Socket Layer">SSL</abbr> en la
comunicación, independiente de los cliente-servidor inseguros que quieren
comunicarse. Ambos clientes están en una misma máquina y ambos servidores en
otra distinta.  En consecuencia, el tráfico de red que circula entre distintas
máquinas está cifrado. El cliente conecta con el cliente <abbr title="Secure Socket Layer">SSL</abbr> a través de un
puerto en la interfaz local (p.e. <strong>11111</strong>), este último contacta con el
servidor <abbr title="Secure Socket Layer">SSL</abbr> en el puerto <strong>10443</strong>, el cual, a su vez, conecta con el
servidor que escucha emn otro puerto de la interfaz local (<strong>12345</strong>).</p>
<p>Utilizaremos dos herramientas distintas:</p>
<ul class="simple">
<li><p><strong class="command">openssl</strong> que nos permite hacer pruebas circunstanciales bien para
poner en práctica el concepto, bien para resolver una situación particular en
que queramos asegurar de forma puntual una comunicación insegura.</p></li>
<li><p><strong class="command">stunnel</strong> que puede actuar como un servicio permanente de
tunelización (p.e. para <a class="reference internal" href="../../../04.servidor/10.ssh/04.adicional.html#ssh-https"><span class="std std-ref">ocultar dentro de un túnel SSL una conexión SSH</span></a>).</p></li>
</ul>
<p>Podemos tunelizar cualquier servicio, pero para no desviar la atención hacia el
propio servicio utilizaremos <a class="reference internal" href="../../../02.conbas/99.misc/10.netcat.html#netcat"><span class="std std-ref">netcat</span></a>. Además, necesitamos un
<a class="reference internal" href="01.certdig.html#cert-digital"><span class="std std-ref">certificado digital</span></a> que permita identificar al servidor.
Utilizaremos uno autofirmado para el servidor:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>openssl<span class="w"> </span>req<span class="w"> </span>-x509<span class="w"> </span>-newkey<span class="w"> </span>rsa:4096<span class="w"> </span>-keyout<span class="w"> </span>tunnel.pem<span class="w"> </span>-out<span class="w"> </span>tunnel.pem<span class="w"> </span>-nodes<span class="w"> </span>-subj<span class="w"> </span><span class="s2">&quot;/CN=localhost&quot;</span>
</pre></div>
</div>
<p class="rubric">openssl</p>
<p><strong class="command">openssl</strong> tiene dos subcomandos que implementan un cliente
(<em class="manpage"><a class="manpage reference external" href="https://manpages.debian.org/s_client">s_client</a></em>) y un servidor (<em class="manpage"><a class="manpage reference external" href="https://manpages.debian.org/s_server">s_server</a></em>) <abbr title="Secure Socket Layer">SSL</abbr> que se limitan a
establecer el canal y, una vez hecho, a pasar en crudo la información. Así, si en el
servidor hacemos:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">u@servidor:~$ </span>openssl<span class="w"> </span>s_server<span class="w"> </span>-port<span class="w"> </span><span class="m">12345</span><span class="w"> </span>-cert<span class="w"> </span>tunnel.pem<span class="w"> </span>-key<span class="w"> </span>tunnel.pem<span class="w"> </span>-quiet
</pre></div>
</div>
<p>quedará escuchando el servicio en el puerto <strong>12345</strong>. Por su parte, en el
cliente podemos hacer:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">u@cliente:~$ </span>openssl<span class="w"> </span>s_client<span class="w"> </span>-connect<span class="w"> </span>IP.DEL.SERVIDOR:12345<span class="w"> </span>-quiet
</pre></div>
</div>
<p>Y podremos conversar entre ambas máquinas de manera que lo se escribe en un
extremo se ve en el otro, pero los mensajes viajarán cifrados entre ambos
extremos. Nuestra intención, no obstante, no es ésta, sino tunelizar cualquier
servicio. Para ello supongamos que tenemos un servicio inseguro escuchando
en el puerto <strong>10443</strong><a class="footnote-reference brackets" href="#id4" id="id3" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a> del servidor:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">u@servidor:~$ </span>netcat<span class="w"> </span>-l<span class="w"> </span>-s<span class="w"> </span>localhost<span class="w"> </span>-p<span class="w"> </span><span class="m">10443</span>
</pre></div>
</div>
<p><kbd class="kbd compound docutils literal notranslate"><kbd class="kbd docutils literal notranslate">openssl</kbd> <kbd class="kbd docutils literal notranslate">s_server</kbd></kbd>. desgraciadamente, sólo puede escribir en pantalla y
leer de teclado, así que no tiene capacidad para utilizar como entrada/salida el
puerto <strong>10443</strong> que es en realidad lo que realmente necesitamos. Sin embargo,
podemos <a class="reference internal" href="../../../02.conbas/08.redirecciones/02avanzada.html#exec"><span class="std std-ref">usar con destreza las redirecciones</span></a> para suplir esta carencia:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">u@servidor:~$ </span><span class="nb">exec</span><span class="w"> </span><span class="m">3</span>&lt;&gt;/dev/tcp/localhost/10443
<span class="gp">u@servidor:~$ </span>openssl<span class="w"> </span>s_server<span class="w"> </span>-port<span class="w"> </span><span class="m">12345</span><span class="w"> </span>-cert<span class="w"> </span>cert.pem<span class="w"> </span>-key<span class="w"> </span>cert.key<span class="w"> </span>-quiet<span class="w"> </span>&lt;<span class="p">&amp;</span><span class="m">3</span><span class="w"> </span>&gt;<span class="p">&amp;</span><span class="m">3</span>
</pre></div>
</div>
<p>esto es, hacemos que el descriptor <strong>3</strong> lea y escriba en el puerto en el que
escucha nuestro servicio y redirigimos <strong class="command">openssl</strong> para que lea y escriba
en ese descriptor. En consecuencia, <strong class="command">openssl</strong> será capaz de escribir y
leer en el puerto del servicio.</p>
<p>En el cliente tenemos el mismo problema: <kbd class="kbd compound docutils literal notranslate"><kbd class="kbd docutils literal notranslate">openssl</kbd> <kbd class="kbd docutils literal notranslate">s_client</kbd></kbd> utiliza entrada
y salida estándar y no hay forma de que exponga un puerto de escucha para que un
cliente (el cliente correspondiente al servicio anterior) pueda comunicarse
con él para que le sirva de intérprete. Sin embargo también tenemos una
argucia:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">u@cliente:~$ </span>netcat<span class="w"> </span>-l<span class="w"> </span>-s<span class="w"> </span>localhost<span class="w"> </span>-p<span class="w"> </span><span class="m">11111</span><span class="w"> </span>-c<span class="w"> </span><span class="s2">&quot;openssl s_client -connect IP.DEL.SERVIDOR:12345 -quiet&quot;</span>
</pre></div>
</div>
<p>que consiste en poner a escuchar a <strong class="command">netcat</strong> en un puerto local pero
haciendo que su entrada/salida no sea la entrada y salida estándar sino la
entrada/salida de <strong class="command">openssl</strong>, que se encarga de cifrar/descifrar y
comunicarse con el otro extremo.  Ahora bastará con usar el programa cliente
para que se conecte al puerto <strong>11111</strong> de la interfaz local. Como nuestro
servicio en el servidor lo montamos con <strong class="command">netcat</strong>, tendremos que usar
como cliente <strong class="command">netcat</strong>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">u@cliente:~$ </span>netcat<span class="w"> </span>localhost<span class="w"> </span><span class="m">11111</span>
</pre></div>
</div>
<p>El esquema de conexiones es el siguiente:</p>
<img alt="../../../_images/openssl-tunel.png" src="../../../_images/openssl-tunel.png" />
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>Es obvio que hemos complicado todo muchísimo en el ejemplo para acabar
teniendo el mismo resultado que cuando se usaron <kbd class="kbd compound docutils literal notranslate"><kbd class="kbd docutils literal notranslate">openssl</kbd> <kbd class="kbd docutils literal notranslate">s_client</kbd></kbd> y
<kbd class="kbd compound docutils literal notranslate"><kbd class="kbd docutils literal notranslate">openssl</kbd> <kbd class="kbd docutils literal notranslate">s_server</kbd></kbd> directamente. Esto, no obstante, es debido que para
ilustrar la técnica hemos utilizado como servicio <strong class="command">netcat</strong>, pero
podría haber usado cualquier otro servicio distinto (p.e. <strong class="command">telnet</strong>).</p>
</div>
<p class="rubric" id="stunnel">stunnel</p>
<p>En este caso, es probable que no tengamos instalado el servicio:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp"># </span>apt<span class="w"> </span>install<span class="w"> </span>stunnel4
</pre></div>
</div>
<p>que necesitará el certificado digital autofirmado que debimos generar con
<strong class="command">openssl</strong>. Supondremos que el certificado lo guardamos en
<code class="file docutils literal notranslate"><span class="pre">/etc/stunnel/tunnel.pem</span></code>. Configuremos la parte de servidor creando el
archivo <code class="file docutils literal notranslate"><span class="pre">/etc/stunnel/nc.conf</span></code> (el nombre es irrelevante: basta con su
extensión sea <em>.conf</em>):</p>
<div class="highlight-ini notranslate"><div class="highlight"><pre><span></span><span class="k">[netcat-ssl]</span>
<span class="na">cert</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">/etc/stunnel/stunnel.pem</span>
<span class="na">accept</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">IP.DEL.SERVIDOR:10443</span>
<span class="na">connect</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">127.0.0.1:12345</span>
</pre></div>
</div>
<p>De esta forma, <strong class="program">stunnel</strong> escucha como servidor <abbr title="Secure Socket Layer">SSL</abbr> en la interfaz
pública del puerto <strong>10443</strong> y traslada la información en claro al servicio que
escucha en el puerto <strong>12345</strong> de la interfaz local.</p>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>En <a class="reference external" href="https://www.debian.org/News/2017/20170617">Stretch</a> es necesario también habilitar explícitamente el
servicio editando el fichero <code class="file docutils literal notranslate"><span class="pre">/etc/default/stunnel4</span></code>:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="nv">ENABLED</span><span class="o">=</span><span class="m">1</span>
</pre></div>
</div>
</div>
<p>Hecha la configuración, podemos reiniciar el servicio:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">root@servidor:~# </span>invoke-rc.d<span class="w"> </span>stunnel4<span class="w"> </span>restart
</pre></div>
</div>
<p>Solo falta, poner a escuchar el servidor según lo especificado en la
configuración:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">u@servidor:~$ </span>nc<span class="w"> </span>-l<span class="w"> </span>-s<span class="w"> </span>localhost<span class="w"> </span>-p<span class="w"> </span><span class="m">12345</span>
</pre></div>
</div>
<p>Por su parte, en el <strong>cliente</strong> debemos también instalar <strong class="program">stunnel</strong> y
arrancarlo con esta configuración:</p>
<div class="highlight-ini notranslate"><div class="highlight"><pre><span></span><span class="k">[netcat-ssl]</span>
<span class="na">client</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">yes</span>
<span class="na">accept</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">127.0.0.1:11111</span>
<span class="na">connect</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">IP.DEL.SERVIDOR:10443</span>
</pre></div>
</div>
<p>Y listo, la comunicación ya puede establecerse:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">u@cliente:~# </span>netcat<span class="w"> </span>localhost<span class="w"> </span><span class="m">11111</span>
</pre></div>
</div>
<div class="admonition warning">
<p class="admonition-title">Advertencia</p>
<p>Aunque la comunicación se lleva a cabo perfectamente, hay, sin
embargo, una muy grande diferencia respecto a cuando hicimos la conexión
directa (y sin cifrar): el <strong class="program">netcat</strong> servidor siempre conecta con el
<strong class="program">stunnel</strong> local con lo que para él todas las conexiones son locales
y desconoce por completo cuál es la <abbr title="Internet Protocol">IP</abbr> del cliente con el que se está
comunicando. En el cliente ocurre otro tanto, aunque en este caso es menos
importante. Para paliar esto, la parte servidor de <strong class="command">stunnel</strong> debería
ejecutarse como un <a class="reference internal" href="../../../07.serre/05.proxies/03.reverse/02.transparencia.html#proxy-transparente"><span class="std std-ref">proxy transparente</span></a>.</p>
</div>
<p class="rubric">Notas al pie</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id4" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id3">1</a><span class="fn-bracket">]</span></span>
<p>En realidad, sólo escucha en la interfaz de <em>loopback</em>, ya que como el
servicio es inseguro, no queremos que nadie externo a la máquina se conecte a
él.</p>
</aside>
</aside>
</section>
</section>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <div>
    <h3><a href="../../../index.html">Tabla de contenido</a></h3>
    <ul>
<li><a class="reference internal" href="#">9.1.3.4. Protocolos seguros de red</a><ul>
<li><a class="reference internal" href="#vpn">9.1.3.4.1. <abbr title="Virtual Private Network">VPN</abbr></a></li>
<li><a class="reference internal" href="#ssh">9.1.3.4.2. <abbr title="Security SHell">SSH</abbr></a></li>
<li><a class="reference internal" href="#ssl-tls">9.1.3.4.3. <abbr title="Secure Socket Layer">SSL</abbr>/<abbr title="Transport Layer Security">TLS</abbr></a><ul>
<li><a class="reference internal" href="#sni">9.1.3.4.3.1. <abbr title="Server Name Indication">SNI</abbr></a></li>
<li><a class="reference internal" href="#starttls">9.1.3.4.3.2. STARTTLS</a></li>
<li><a class="reference internal" href="#pruebas-practicas">9.1.3.4.3.3. Pruebas prácticas</a><ul>
<li><a class="reference internal" href="#conexiones-ssl">9.1.3.4.3.3.1. Conexiones <abbr title="Secure Socket Layer">SSL</abbr></a></li>
<li><a class="reference internal" href="#tunelizacion">9.1.3.4.3.3.2. Tunelización</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>Tema anterior</h4>
    <p class="topless"><a href="03.correo.html"
                          title="capítulo anterior"><span class="section-number">9.1.3.3. </span>Correo electrónico</a></p>
  </div>
  <div>
    <h4>Próximo tema</h4>
    <p class="topless"><a href="05.auth.html"
                          title="próximo capítulo"><span class="section-number">9.1.3.5. </span>Autenticación</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>Esta página</h3>
    <ul class="this-page-menu">
      <li><a href="../../../_sources/98.apendice/01.cryto/03.aplicaciones/04.ssl.rst.txt"
            rel="nofollow">Mostrar el código</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Búsqueda rápida</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Ir a" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navegación</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="Índice General"
             >índice</a></li>
        <li class="right" >
          <a href="05.auth.html" title="9.1.3.5. Autenticación"
             >siguiente</a> |</li>
        <li class="right" >
          <a href="03.correo.html" title="9.1.3.3. Correo electrónico"
             >anterior</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">documentación de Linuxnomicón - rolling</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" ><span class="section-number">9. </span>Apéndices</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="../index.html" ><span class="section-number">9.1. </span>Criptografía</a> &#187;</li>
          <li class="nav-item nav-item-3"><a href="../03.aplicaciones.html" ><span class="section-number">9.1.3. </span>Aplicaciones de la criptografía</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href=""><span class="section-number">9.1.3.4. </span>Protocolos seguros de red</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
    &#169; Copyright CC BY 4.0, 2016-2023, José Miguel Sánchez Alés.
      Creado usando <a href="https://www.sphinx-doc.org/">Sphinx</a> 7.2.6.
    </div>
  </body>
</html>