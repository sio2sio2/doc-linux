


<!DOCTYPE html>

<html lang="es">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>9.1.2. Operaciones criptográficas &#8212; documentación de Linuxnomicón - rolling</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/classic.css" />
    <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
    
    <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/translations.js"></script>
    <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    
    <link rel="index" title="Índice" href="../../genindex.html" />
    <link rel="search" title="Búsqueda" href="../../search.html" />
    <link rel="next" title="9.1.3. Aplicaciones de la criptografía" href="03.aplicaciones.html" />
    <link rel="prev" title="9.1.1. Introducción" href="01.intro.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navegación</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="Índice General"
             accesskey="I">índice</a></li>
        <li class="right" >
          <a href="03.aplicaciones.html" title="9.1.3. Aplicaciones de la criptografía"
             accesskey="N">siguiente</a> |</li>
        <li class="right" >
          <a href="01.intro.html" title="9.1.1. Introducción"
             accesskey="P">anterior</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">documentación de Linuxnomicón - rolling</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" ><span class="section-number">9. </span>Apéndices</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="index.html" accesskey="U"><span class="section-number">9.1. </span>Criptografía</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href=""><span class="section-number">9.1.2. </span>Operaciones criptográficas</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="operaciones-criptograficas">
<span id="tecnicas-crypto"></span><h1><span class="section-number">9.1.2. </span>Operaciones criptográficas<a class="headerlink" href="#operaciones-criptograficas" title="Enlazar permanentemente con este título">¶</a></h1>
<p>Estudiaremos bajo este epígrafe tres operaciones propies de la criptografía:</p>
<ul class="simple">
<li><p>Resumen criptográfico, gracias a las funciones <em>hash</em>.</p></li>
<li><p>El cifrado y cuáles son los algoritmos que se usan para ello.</p></li>
<li><p>La firma digital.</p></li>
</ul>
<p>Remataremos con un apéndice práctico que indique cómo llevar a cabo estas tareas
en un sistema <em>Linux</em>.</p>
<section id="resumen-criptografico">
<span id="hash"></span><h2><span class="section-number">9.1.2.1. </span>Resumen criptográfico<a class="headerlink" href="#resumen-criptografico" title="Enlazar permanentemente con este título">¶</a></h2>
<p>Las <em class="dfn">funciones hash</em> o <em class="dfn">funciones digest</em> o <em class="dfn">funciones resumen</em>
son funciones que, dada una entrada, generan una salida, llamada <em class="dfn">resumen</em>,
caracterizada porque:</p>
<ul class="simple">
<li><p>siempre tiene el mismo tamaño, con independencia del tamaño de la entrada. Por
tanto, si la función genera resúmenes de 256 <em>bits</em>, cualquier entrada se
resumirá en 256 <em>bits</em>. La consecuencia de ello es que operan en un solo
sentido, esto es, a partir del original obtenemos su resumen, pero a partir
del resumen es imposible averiguar cuál era la información de partida.</p></li>
<li><p>es <em>determinista</em>, esto es, para una misma entrada la salida siempre es la
misma.</p></li>
<li><p>se minimizan las <em class="dfn">colisiones</em>, esto es, se minimiza la posibilidad de
obtener una misma salida para dos entradas distintas.</p></li>
</ul>
<p>La actividad de resumir criptográficamente la información está relacionada con
el <a class="reference internal" href="01.intro.html#crypto-objetivos"><span class="std std-ref">objetivo de la integridad</span></a>, ya que dadas las
propiedades de las funciones <em>hash</em>, es prácticamente imposible que un contenido
que ha sufrido algún cambio, no cambie su resumen. En cualquier caso, aunque
puede hacerse sin más el resumen de un archivo o un flujo de datos, lo habitual
es que esta técnica criptográfica se integre dentro de la <a class="reference internal" href="#firma-digital"><span class="std std-ref">firma digital</span></a>.</p>
<p>Entre las funciones de <em>hash</em> más conocidas se encuentran:</p>
<dl class="simple">
<dt><abbr title="Message Digest Algorithm 5">MD5</abbr></dt><dd><p>Genera un resumen de 128 <em>bits</em> representado habitualmente por 32 dígitos
hexadecimales. Es muy común usarlo como comprobación de la integridad de
ficheros. Su seguridad está en entredicho, ya que presenta problemas de
colisiones.</p>
</dd>
<dt><abbr title="sechure Hash Algorithm">SHA</abbr></dt><dd><p>Es una familia de funciones <em>hash</em> que ha ido sufriendo diversas revisiones:
<abbr title="sechure Hash Algorithm">SHA</abbr>-0, <abbr title="sechure Hash Algorithm">SHA</abbr>-1, <abbr title="sechure Hash Algorithm">SHA</abbr>-2 y <abbr title="sechure Hash Algorithm">SHA</abbr>-3. Tanto <abbr title="sechure Hash Algorithm">SHA</abbr>-0 como <abbr title="sechure Hash Algorithm">SHA</abbr>-1
generan resúmenes de 160 <em>bits</em>. Ambas se consideran inseguras y se
desaconseja su uso. Para paliarlo, se desarrolló <abbr title="sechure Hash Algorithm">SHA</abbr>-2, que implementa
funciones <em>hash</em> de 224, 256, 364 y 512 <em>bits</em>. Se las conoce habitualmente
como <abbr title="sechure Hash Algorithm">SHA</abbr>-224, <abbr title="sechure Hash Algorithm">SHA</abbr>-256, <abbr title="sechure Hash Algorithm">SHA</abbr>-364 y <abbr title="sechure Hash Algorithm">SHA</abbr>-512. <abbr title="sechure Hash Algorithm">SHA</abbr>-3, por su
parte, cambia internamente los algoritmos, pero está pensada para generar
resúmenes de la misma longitud que <abbr title="sechure Hash Algorithm">SHA</abbr>-2.</p>
</dd>
</dl>
</section>
<section id="cifrado">
<h2><span class="section-number">9.1.2.2. </span>Cifrado<a class="headerlink" href="#cifrado" title="Enlazar permanentemente con este título">¶</a></h2>
<p>Por <em class="dfn">cifrado</em> nos referimos particularmente a la acción de ofuscar cierta
información con el objeto de que pueda ser posteriormente desofuscada.
Si se ofusca con la intención de que sólo pueda deshacerla un tercero
expresamente autorizado, entonces el cifrado se encamina a la <em>privacidad</em> y
tenemos propiamente aquello que comúnmente se refiere como <em>cifrado</em>. En cambio,
si cualquier tercero puede desofuscar, el propósito no es la <em>privacidad</em>, y
entraríamos en el terreno de la <a class="reference internal" href="#firma-digital"><span class="std std-ref">firma digital</span></a>, que
trataremos más adelante.</p>
<p>Ya se ha comentado que los algoritmos modernos de cifrado se basan en el
secreto de la clave y no en el secreto del propio algoritmo, por lo que nos
centraremos en los algoritmos basados en clave. Atendiendo a ella hay dos tipos
de algoritmos.</p>
<dl class="simple">
<dt><strong>De clave simétrica</strong></dt><dd><p>También conocidos como <em class="dfn">de clave privada</em> o de <em class="dfn">clave única</em>. Son
aquellos en que se usa la misma clave para cifrar y descifrar.</p>
</dd>
<dt><strong>De clave asimétrica</strong></dt><dd><p>También conocidos como <em class="dfn">de clave pública</em> o <em class="dfn">de doble clave</em>. Son
aquellos que emplean una pareja de claves, de manera que si una se usa para
cifrar la otra sirve para descifrar los mensajes cifrados con la primera.</p>
</dd>
</dl>
<p>Son comunes las técnicas que usan combinadamente clave simétrica y asimétrica,
lo cual se conoce como <a class="reference internal" href="#hibrido"><span class="std std-ref">cifrado híbrido</span></a>.</p>
<section id="cifrado-simetrico">
<h3><span class="section-number">9.1.2.2.1. </span>Cifrado simétrico<a class="headerlink" href="#cifrado-simetrico" title="Enlazar permanentemente con este título">¶</a></h3>
<p>En este tipo de cifrado se usa la misma clave tanto para cifrar como para
descifrar. Cuando las dos partes se encuentran alejadas, ese, precisamente, es
su punto débil, ya que exige que la clave se encuentre en ambos extremos con
anterioridad a la comunicación, lo cual puede lograrse:</p>
<ul class="simple">
<li><p>Encontrándose físicamente ambas partes para intercambiar en mano la clave,
lo cual es costoso en tiempo y en recursos.</p></li>
<li><p>Transmitiendo previamente la clave en claro, lo cual es sumamente arriesgado
porque puede provocar su intercepción y la inutilidad del cifrado posterior.</p></li>
</ul>
<p>Obviando lo anterior, el factor decisivo en la robustez de la clave es su
longitud: cuanto más larga sea, más difícil es averiguarla por fuerza bruta.
Por ejemplo, una clave de <strong>8</strong> <em>bits</em> sólo puede tener 2<sup>8</sup>, o sea,
<strong>256</strong> valores distintos, lo que implica que podría adivinarse con un máximo
de <strong>256</strong> intentos.</p>
<p>Algunos algoritmos de cifrado simétrico muy conocidos son:</p>
<dl class="simple">
<dt><abbr title="Data Encryption Standard">DES</abbr></dt><dd><p>Considerado actualmente inseguro para la capacidad computacional de los
ordenadores modernos, ya que tiene una longitud de sólo <strong>56</strong> <em>bits</em>.
Su sucesor directo es el 3<abbr title="Data Encryption Standard">DES</abbr> (Triple <abbr title="Data Encryption Standard">DES</abbr>) que usa el triple de
longitud para la clave (<strong>168</strong> bits), aunque también se ha ido desplazando
en favor de otros algoritmos.</p>
</dd>
<dt><abbr title="Advanced Encryption Standard">AES</abbr></dt><dd><p>Sustituyó al algoritmo anterior y tiene una longitud de <strong>256</strong> <em>bits</em>. Es
más rápido y, además, no se le conocen vulnerabilidades. Es modernamente el
algoritmo de clave simétrica más utilizado<a class="footnote-reference brackets" href="#id17" id="id1">1</a>.</p>
</dd>
</dl>
<p>Existen otros algoritmos como <a class="reference external" href="https://es.wikipedia.org/wiki/Twofish">Twofish</a>, <a class="reference external" href="https://es.wikipedia.org/wiki/Serpent">Serpent</a>
o <a class="reference external" href="https://es.wikipedia.org/wiki/Blowfish">Blowfish</a>.</p>
</section>
<section id="cifrado-asimetrico">
<span id="asimetrico"></span><h3><span class="section-number">9.1.2.2.2. </span>Cifrado asimétrico<a class="headerlink" href="#cifrado-asimetrico" title="Enlazar permanentemente con este título">¶</a></h3>
<p>Se basa en el uso de una pareja de claves, una privada y otra pública generada
a partir de ella, que se caracterizan por que lo que se haya cifrado con una
sólo es posible descifrarlo con la otra. Por ello:</p>
<ul class="simple">
<li><p>La clave <strong>privada</strong> debe mantenerla en secreto su propietario.</p></li>
<li><p>La clave <strong>pública</strong> se comunica a los demás.</p></li>
</ul>
<p>De este modo, cuando se desease enviar un mensaje secreto a un destinatario, se
podría usar la clave <em>pública</em> de éste, ya que tal mensaje sólo podría
ser descifrado usando su clave <em>privada</em> correspondiente, que sólo está en
posesión del destinatario. Por ello, el cifrado con la clave <em>pública</em>,
garantizaría la privacidad.</p>
<p>Por otra parte, si un emisor usase su clave <strong>privada</strong> para cifrar, el mensaje
podría descifrarse con su clave <em>pública</em> correspondiente. Como la clave
<em>pública</em> es, eso mismo, pública, no sirve para salvaguardar ninguna privacidad,
pero sí para asegurar que el emisor del mensaje es el dueño de las claves.
Afinaremos esto más adelante<a class="footnote-reference brackets" href="#id18" id="id2">2</a>.</p>
<p>Los algoritmos más conocidos de cifrado asimétrico son:</p>
<dl>
<dt><abbr title="Rivest, Shamir y Adleman">RSA</abbr></dt><dd><p>Es el primer sistema criptográfico de clave asimétrica y aún se considera
válido (esto es, suficientemente seguro) tanto para cifrar y como firmar
digitalmente. Por lo general, utiliza claves con una longitud entre 1024 y
4096 <em>bits</em>.</p>
<p>Los <a class="reference internal" href="03.aplicaciones/01.certdig.html#cert-digital"><span class="std std-ref">certificados digitales</span></a> X.509 y <abbr title="Pretty Good Privacy">PGP</abbr> suelen incluir
claves generadas con este algoritmo<a class="footnote-reference brackets" href="#id19" id="id3">3</a>.</p>
</dd>
<dt><abbr title="Digital Signature Algorithm">DSA</abbr></dt><dd><p>Es otro sistema criptográfico de clave asimétrica que en la actualidad se
considera débil, por lo que se desaconseja su uso para cifrar información<a class="footnote-reference brackets" href="#id20" id="id4">4</a>. Sus claves tienen una longitud entre 512 y 1024 <em>bits</em>.</p>
<p>Variantes de este sistema que mejoran la fortaleza de las claves y, por
tanto, permiten su uso para cifrado, son:</p>
<ul class="simple">
<li><p><abbr title="Elliptic Curve Digital Signature Algorithm">ECDSA</abbr>, que usa <a class="reference external" href="https://es.wikipedia.org/wiki/Criptograf%C3%ADa_de_curva_el%C3%ADptica">criptografía de curva elíptica</a>.</p></li>
<li><p><abbr title="EDwards-curve Curve Digital Signature Algorithm">EdDSA</abbr>, que usa también criptografía de curva elíptica. y se desarrolló
para mejorar la velocidad de cifrado sin sacrificar velocidad. Un tipo
particular de este sistema es <em>Ed22519</em>, que permiten usar las últimas
versiones de <strong class="program">openssh</strong>.</p></li>
</ul>
</dd>
</dl>
<p>La desventaja fundamental del cifrado asimétrico frente al simétrico es su costo
computacional: para un mismo nivel de seguridad requiere claves más largas y,
además, para una misma longitud de clave es más costoso en tiempo. Este hecho
hace que en la práctica el cifrado asimétrico sólo se utilice para cifrar una
cantidad de información muy pequeña.</p>
</section>
<section id="cifrado-hibrido">
<span id="hibrido"></span><h3><span class="section-number">9.1.2.2.3. </span>Cifrado híbrido<a class="headerlink" href="#cifrado-hibrido" title="Enlazar permanentemente con este título">¶</a></h3>
<p>De lo expuesto para los cífrados simétrico y asimétrico concluimos que:</p>
<ul class="simple">
<li><p>El cifrado <em>asimétrico</em> en la práctica habitual es inútil para cifrar
información, por cuanto sólo es apto para cantidades muy pequeñas de
información.</p></li>
<li><p>El cifrado <em>simétrico</em> sí es válido, pero es intrínsecamente inseguro para
transmitir información por cuanto nos obliga a enviar previamente (y, por
tanto, en claro) la clave al otro extremo. Si el atacante ya escucha en este
instante previo y captura la clave, todo el cifrado posterior, por bueno que
sea el algoritmo con que se realiza, es inútil.</p></li>
</ul>
<p id="clave-sesion">Estas conclusiones derivan en el <em class="dfn">problema de intercambio de clave</em>, esto
es, en resolver cómo intercambiar una clave simétrica de forma segura a través
de un medio inseguro. Logrado esto, se dispondrá de una clave simétrica con la
que cifrar la comunicación entre ambos extremos el tiempo que dure ésta (la
llamada <em class="dfn">clave de sesión</em>). Pero, en cualquier caso, es preciso resolver el
problema de su seguridad. Hay dos alternativas habituales:</p>
<ol class="loweralpha">
<li><p><em>Intercambio de clave basado en clave pública</em></p>
<p>Consiste en que uno de los extremos genera la clave simétrica, la cifra con
la clave pública del otro extremo y se la envía cifrada. Al recibirla, este
otro extremo la descifra con su clave privada y obtiene la clave simétrica
que usarán ambos durante la comunicación.</p>
</li>
<li><p><em>Intercambio de clave Diffie-Hellman</em></p>
<p>Consiste en que ambos extremos acuerdan en claro los parámetros que usarán
(el módulo y la base) y generan <em>ad hoc</em>, cada uno por su cuenta, sendas claves
privadas (<span class="math notranslate nohighlight">\(x\)</span> e <span class="math notranslate nohighlight">\(y\)</span>). Con estas claves y los parámetros, generan
sendas claves públicas <span class="math notranslate nohighlight">\(g^x\)</span> y <span class="math notranslate nohighlight">\(g^y\)</span> que comunican a la otra
parte. Las matemáticas involucradas propician que, cuando ambos aplican su
propia clave privada sobre la clave pública recibida desde la otra parte
(<span class="math notranslate nohighlight">\((g^x)^y\)</span> y <span class="math notranslate nohighlight">\((g^y)^x\)</span>), el resultado en ambas partes coincide y
éste es la clave simétrica con la que cifrarán la comunicación (<span class="math notranslate nohighlight">\(K =
(g^x)^y = (g^y)^x\)</span>). Un atacante que esté escuchando es capaz de capturar
ambas claves públicas, pero no dispone de ninguna de las claves privadas, por
lo que no podrá calcular la clave de sesión como hacen ambos extremos
legítimos<a class="footnote-reference brackets" href="#id21" id="id5">5</a>.</p>
<p>Para ilustrar cómo funciona este mecanismo sin necesidad de entender las
matemáticas subyacentes suele recurrirse a una analogía cromática:</p>
<img alt="../../_images/colores-dh.png" src="../../_images/colores-dh.png" />
<p>O sea, Alice y Bob acuerdan un color base verdoso y cada uno de ellos por
su cuenta escoge un color secreto (naranja y azul respectivamente).
Componen un nuevo color con el color base y su color secreto y obtienen una
mezcla (amarillo y azul claro, respectivamente) que
sí publican comunicándolo al otro. Ambos finalmente mezclan el color
comunicado con su propio color secreto y obtienen un mismo color resultante:
una especie de violeta.</p>
</li>
</ol>
<p>Las dos estrategias cumplen con el propósito y combinan una técnica inicial de
cifrado asimétrico para establecer secretamente la clave de cifrado simétrico
con la que se asegura finalmente la comunicación. Son, por tanto, técnicas de
<em class="dfn">cifrado híbrido</em>.  Obsérvese, no obstante, que existe una diferencia
capital entre ambas: la primera resolución utiliza una pareja de claves
<strong>preexistente</strong> y <strong>persistente</strong>, mientras que la segunda usa un par de
parejas de claves <strong>efímeras</strong>, que se crean para la ocasión y se abandonan
acabada esta:</p>
<ul class="simple">
<li><p>La <em>preexistencia</em> determina que no haya que generar las claves asimétricas y,
por tanto, se agilice el mecanismo para establecer el canal seguro.</p></li>
<li><p>La <em>persistencia</em> de una pareja de claves permite que la otra parte pueda
comprobar la identidad de su propietario. Por ejemplo, podemos estar seguros
de que el otro extremo es quien dice ser, porque en una ocasión anterior nos
entregó en mano su clave pública<a class="footnote-reference brackets" href="#id22" id="id6">6</a>. Esto con claves efímeras generadas
<em>ad hoc</em> es imposible; lo que determina que un atacante pueda realizar un
ataque <abbr title="Man in the Middle">MiTM</abbr>.</p></li>
<li><p>La <em>efimeridad</em> de las claves privadas mejora la seguridad, porque, si la
la clave de sesión se cifró con la clave pública persistente de uno de
los extremos, un atacante que haya guardado la conversación completa será
incapaz de leerla en el momento; pero, si en el futuro logra hacerse con la
clave privada, entonces podrá volver a recuperar la conversación y
descrifrarla. Por contra, si las claves son efímeras, nunca se sufrirá este
problema.</p></li>
</ul>
<p>El cifrado híbrido es la base de todos los <a class="reference internal" href="03.aplicaciones/04.ssl.html#proto-seguro"><span class="std std-ref">protocolos seguros de red</span></a> como <abbr title="Transport Layer Security">TLS</abbr>/<abbr title="Secure Socket Layer">SSL</abbr> o <abbr title="Security SHell">SSH</abbr>. Para resolver el <em>problema del
intercambio de la clave simétrica</em> estos protocolos pueden optar por una de las
dos estrategias o dejar libertad para que alguno de los extremos escoja cuál
prefiere. Sea cual sea la estrategia de intercambio, es indispensable que al
menos el cliente se asegure de la identidad del servidor, por lo que para la
identificación siempre se usa una técnica de clave pública.</p>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>Hemos centrado la explicación en la comunicación segura, pero el
<em>cifrado híbrido</em> también es útil para cifrar previamente un archivo que
queremos transmitir posteriormente mediante una comunicación no segura (p.e.
el envío de un correo electrónico). En este caso, se usa la clave pública del
destinatario para cifrar una clave simétrica con la que se ofusca la
información y, ambas cosas, clave cifrada e informacion ofuscada, son las que
se remiten.</p>
</div>
</section>
<section id="conclusiones">
<h3><span class="section-number">9.1.2.2.4. </span>Conclusiones<a class="headerlink" href="#conclusiones" title="Enlazar permanentemente con este título">¶</a></h3>
<p>En vista de todo lo ya expuesto, lo adecuado al cifrar es usar:</p>
<ol class="loweralpha simple">
<li><p>Cifrado <strong>simétrico</strong> sobre:</p>
<ul class="simple">
<li><p>Información que no se requiere transmitir (p.e. <a class="reference internal" href="03.aplicaciones/06.discos.html#disk-encrypt"><span class="std std-ref">cifrado de disco</span></a>).</p></li>
<li><p>Información que se transmite siempre que la clave simétrica se transmita
cifrada asimétricamente, lo cual ya hemos definido como <a class="reference internal" href="#hibrido"><span class="std std-ref">cifrado híbrido</span></a>.</p></li>
</ul>
</li>
<li><p>Cifrado <strong>asimétrico</strong> sobre una muy pequeña cantidad de información:</p>
<ul class="simple">
<li><p>Una clave simétrica que se desea transmitir, que es el complemento del
<a class="reference internal" href="#hibrido"><span class="std std-ref">cifrado híbrido</span></a> que se acaba de citar.</p></li>
<li><p>Un resumen generado con una función <em>hash</em>. Este acción de cifrado, sin
embargo, es propia de la <em>firma digital</em>; y la entenderemos a continuación.</p></li>
</ul>
</li>
</ol>
</section>
</section>
<section id="firma-digital">
<span id="id7"></span><h2><span class="section-number">9.1.2.3. </span>Firma digital<a class="headerlink" href="#firma-digital" title="Enlazar permanentemente con este título">¶</a></h2>
<p>En el mundo <em>analógico</em>, una firma manuscrita sobre papel es una marca que
certifica que los términos expresados en un texto son ratificados por los
firmantes. Por tanto, dejando al margen posibles falsificaciones, certifica la
identidad de los participantes (autenticidad) y el contenido del texto
(integridad).</p>
<p>Correspondientemente, una <em class="dfn">firma digital</em> (o <em class="dfn">firma electrónica</em>) es
una técnica criptográfica que permite asegurar que unos datos (un archivo, un
mensaje de correo, un flujo de datos) no han cambiado desde el momento en que
los validaron uno o más suscribientes. Por ejemplo, el emisor de un correo
electrónico puede firmar un mensaje para que el destinatario puede estar seguro
de que él es el autor del mensaje y de que éste no ha sido alterado durante el
proceso de comunicación.</p>
<p>La <em>firma digital</em> no es una operación atómica como las dos anteriores (resumir
y cifrar), sino un conjunto de acciones de resumen y cifrado que permiten
asegurar la identidad del emisor y la integridad del mensaje. Esquemáticamente,
firmar consiste en:</p>
<ul class="simple">
<li><p>Obtener <a class="reference internal" href="#hash"><span class="std std-ref">un resumen</span></a> de los datos mediante una función <em>hash</em>.</p></li>
<li><p>Cifrar tal resumen con la clave privada del firmante.</p></li>
<li><p>Añadir metainformacion relevante sobre la operación como el momento de
tiempo en que se lleva a cabo o la clave pública del firmante.</p></li>
<li><p>Transmitir (o almacenar) el conjunto de datos originales, resumen cifrado y
metainformación.</p></li>
</ul>
<img alt="../../_images/firma.png" src="../../_images/firma.png" />
<p>Ante esto, un tercero (por ejemplo, el destinatario de un mensaje de correo
firmado), es capaz de certificar que el origen es quien dice ser, ya que
descifrará el resumen con la clave pública de éste y, por otra parte, podrá
comprobar si los datos conservan su integridad gracias al propio resumen
descifrado<a class="footnote-reference brackets" href="#id23" id="id8">7</a>.</p>
</section>
<section id="apendice-practico">
<h2><span class="section-number">9.1.2.4. </span>Apéndice práctico<a class="headerlink" href="#apendice-practico" title="Enlazar permanentemente con este título">¶</a></h2>
<p>Para poner en práctica los conceptos anteriores utilizaremos fundamentalmente
Open<abbr title="Secure Socket Layer">SSL</abbr>. También podríamos usar <abbr title="GNU Provacy Guard">GnuPG</abbr>, que implementa el estándar <a class="reference external" href="https://www.openpgp.org/">OpenPGP</a>; pero, dado que este estándar se usa
fundamentalmente en el correo electrónico, introduciremos la orden en el
<a class="reference internal" href="03.aplicaciones/03.correo.html#email-seguro"><span class="std std-ref">epígrafe correspondiente</span></a>.</p>
<div class="admonition note" id="entropia">
<p class="admonition-title">Nota</p>
<p>En caso de que hagamos pruebas en una máquina virtual puede que sea
conveniente aumentar la entropía del sistema para mejorar y acelerar la
creación de claves asimétricas. Para lograrlo puede obrarse del siguiente
modo<a class="footnote-reference brackets" href="#id24" id="id9">8</a>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> cat /proc/sys/kernel/random/entropy_avail  <span class="c1"># Entropía inicial</span>
<span class="go">234</span>
<span class="gp">#</span> apt install rng-tools
<span class="gp">#</span> <span class="nb">echo</span> <span class="s1">&#39;HRNGDEVICE=/dev/urandom&#39;</span> &gt;&gt; /etc/default/rng-tools
<span class="gp">#</span> <span class="nb">echo</span> <span class="s1">&#39;RNGDOPTIONS=&quot;--fill-watermark=90%&quot;&#39;</span> &gt;&gt; /etc/default/rng-tools
<span class="gp">#</span> invoke-rc.d rng-tools start
<span class="gp">#</span> cat /proc/sys/kernel/random/entropy_avail
<span class="go">2159</span>
</pre></div>
</div>
</div>
<span class="target" id="index-0"></span><section id="resumenes">
<span id="shasum"></span><span id="md5sum"></span><span id="index-1"></span><h3><span class="section-number">9.1.2.4.1. </span>Resúmenes<a class="headerlink" href="#resumenes" title="Enlazar permanentemente con este título">¶</a></h3>
<p>Para la generación de resúmenes <em>hash</em> de ficheros y flujos de texto, existen
dos órdenes fundamentales: <strong class="command">md5sum</strong> y la familia de comandos
<strong class="program">shasum</strong> (<strong class="command">sha256sum</strong>, <strong class="command">sha384sum</strong>,
<strong class="command">sha512sum</strong>), que comparten una misma interfaz, con lo que es
indiferente ilustrar el uso de una u otra orden. Suelen encontrarse todas
instaldas en el sistema.</p>
<p>La generación del resumen puede hacerse del siguiente modo:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> <span class="nb">echo</span> <span class="s2">&quot;Hola, caracola&quot;</span> &gt; saludo1.txt
<span class="gp">$</span> md5sum saludo1.txt
<span class="go">b18a245aba5384920d7f6a488d725181  saludo1.txt</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>Si se incluyen varios ficheros como argumento, se calculará el resumen
de cada uno de ellos.</p>
</div>
<p>También es posible calcular el resumen de un flujo de datos:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> <span class="nb">echo</span> <span class="s2">&quot;Hola, caracola&quot;</span> <span class="p">|</span> sha256sum
<span class="go">d261be2aa264d38cad717fa8493dacc0b3f33f949869d39ecf7611689fb617ad  -</span>
</pre></div>
</div>
<p>Habitualmente, los resúmenes generados se almacenan, a fin de que puedan servir
más adelante para comprobar la integridad de los ficheros:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> md5sum saludo1.txt saludo2.txt &gt; saludos.md5
</pre></div>
</div>
<p>Con posterioridad, podrá comprobarse la integridad del siguiente modo<a class="footnote-reference brackets" href="#id25" id="id10">9</a>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> <span class="nv">LC_ALL</span><span class="o">=</span>C md5sum -c saludos.md5
<span class="go">saludo1.txt: OK</span>
<span class="go">saludo2.txt: OK</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>Si se almacenó el resumen de un flujo de datos (obsérvese que aparece
un «-», en vez de el nombre del fichero), puede comprobarse que otro flujo es
el mismo pasándolo a través de la entrada estándar:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> <span class="nb">echo</span> <span class="s2">&quot;Hola, caracola&quot;</span> <span class="p">|</span> md5sum &gt; flujo.md5
<span class="gp">$</span> <span class="nb">echo</span> <span class="s2">&quot;Hola, caracola&quot;</span> <span class="p">|</span> <span class="nv">LC_ALL</span><span class="o">=</span>C md5sum -c flujo.md5
<span class="go">-: OK</span>
</pre></div>
</div>
</div>
<p>También es posible utilizar para este fin (aunque no es lo habitual) las
herramientas que usaremos después para ilustrar el cifrado y la firma digital:</p>
<ul>
<li><p><a class="reference internal" href="03.aplicaciones/03.correo.html#gnupg"><span class="std std-ref">GnuPG</span></a>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> gpg --print-md sha512 fichero.txt
</pre></div>
</div>
<p>e incluso hay una opción que calcula los resúmenes según todos los algoritmos
disponibles:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> gpg --print-mds fichero.txt
</pre></div>
</div>
</li>
<li><p><a class="reference internal" href="#openssl"><span class="std std-ref">OpenSSL</span></a>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> openssl dgst -sha512 fichero.txt
</pre></div>
</div>
</li>
</ul>
<section id="openssl">
<span id="id11"></span><h4><span class="section-number">9.1.2.4.1.1. </span>Cifrado simétrico<a class="headerlink" href="#openssl" title="Enlazar permanentemente con este título">¶</a></h4>
<p>Una forma de llevarlo a cabo es esta:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> openssl enc -aes256 -pbkdf2 -a -in fichero.txt -out fichero.txt.enc
</pre></div>
</div>
<p>que utiliza <abbr title="Advanced Encryption Standard">AES</abbr>-256 para el proceso y genera un cifrado en <a class="reference external" href="https://es.wikipedia.org/wiki/Base64">base64</a> gracias a la opción <cite>-a</cite>. Para
descifrar basta con añadir la opción <kbd class="kbd docutils literal notranslate">-d</kbd> y, obviamente, utilizar como
entrada el texto cifrado:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> openssl enc -aes256 -a -d -in fichero.txt.enc -out fichero-recuperado.txt
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>Tanto <kbd class="kbd docutils literal notranslate">-in</kbd> como <kbd class="kbd docutils literal notranslate">-out</kbd> son opcionales y, si no se
especifican, se entenderá que la entrada es la entrada estándar y la salida
la salida estándar.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>La clave simétrica para el cifrado/descifrado se pide de forma
interactiva. Puede proporcionarse en la propia orden incluyendo la opción
<kbd class="kbd docutils literal notranslate">-pass</kbd>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> openssl enc -aes256 -pbkdf2 -a -pass pass:clave-secreta -in fichero.txt -out fichero.txt.enc
</pre></div>
</div>
</div>
</section>
<section id="openssl-asi">
<span id="id12"></span><h4><span class="section-number">9.1.2.4.1.2. </span>Cifrado asimétrico<a class="headerlink" href="#openssl-asi" title="Enlazar permanentemente con este título">¶</a></h4>
<p>Llevarlo a cabo requiere generar un par de claves (<abbr title="Rivest, Shamir y Adleman">RSA</abbr> en concreto<a class="footnote-reference brackets" href="#id26" id="id13">10</a>):</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> openssl genrsa -aes128 -out privkey.pem <span class="m">4096</span>
<span class="gp">#</span> openssl rsa -in privkey.pem -pubout -out pubkey.pem
</pre></div>
</div>
<p>Las órdenes generan un par de claves <abbr title="Rivest, Shamir y Adleman">RSA</abbr> (<code class="file docutils literal notranslate"><span class="pre">privkey.pem</span></code> y
<code class="file docutils literal notranslate"><span class="pre">pubkey.pem</span></code>) de 4096 <em>bits</em>. Para proteger la clave privada con una
contraseña (esto es, con una clave simétrica) hemos usado la opción
<kbd class="kbd docutils literal notranslate">-aes128</kbd>. Esto último es un simple mecanismo de seguridad para que sea
imposible usar la clave privada sin conocer esta contraseña. Así, en caso de
robo, el ladrón aún deberá averiguarla.</p>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>Las claves que se piden interactivamente pueden pasarse a través de
las opciones <kbd class="kbd docutils literal notranslate">-passin</kbd> o <kbd class="kbd docutils literal notranslate">-passout</kbd> (vease <em class="manpage"><a class="manpage reference external" href="https://manpages.debian.org/openssl(1ssl)">openssl(1ssl)</a></em>
para más información)</p>
</div>
<div class="admonition note" id="formato-pem">
<p class="admonition-title">Nota</p>
<p>Ambas claves usan para su información <a class="reference external" href="https://es.wikipedia.org/wiki/ASN.1">notación ASN.1</a> codificada en el formato binario
<abbr title="Distinguised Encoding Rules">DER</abbr> que a continuación se recodifica en <a class="reference external" href="https://es.wikipedia.org/wiki/Base64">Base64</a> para que resulte un archivo
imprimible. Lo mismo sucede con certificados digitales, archivos de firmas,
etc. que iremos viendo a lo largo de este apéndice. Es por ello que todos
los archivos tienen un aspecto semejante al consultarse con un <a class="reference internal" href="../../02.conbas/02.informacion/03.ficheros.html#cat"><span class="std std-ref">cat</span></a>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> cat pukey.pem
<span class="go">-----BEGIN PUBLIC KEY-----</span>
<span class="go">MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAxEUMJf+6dKU85GxWtbZv</span>
<span class="go">gSwYqCMfydr7Pj0zNEd4QYEVnkqIny3qkreC5iBX1Afg1yl2XYDCI0IJW8iQ6e24</span>
<span class="go">jS0FZkkHkbOjGMNwpyevdTNEItu0njgrl34HQ+fN89kauZQQUd32uaBW+QX4+zfl</span>
<span class="go">pvRscvFNHkd90uLOzVymvx7n9xdNx+AScDdVpDz6Q/I9J2nB5YUSOemQiS3NpOLv</span>
<span class="go">R7uEae0cPpEczuqX2kJzhxf+A/yteaJIR3fwZ4zcCNwsDRBhLSwXtYsYywdtNvf6</span>
<span class="go">A1ZgmYPr7ZbqlWvd4BfROZNZlvm+OOVN1B51Z1GoSBGOTu/A6ZiRZGArveRUujtD</span>
<span class="go">JwIDAQAB</span>
<span class="go">-----END PUBLIC KEY-----</span>
</pre></div>
</div>
<p>esto es, unas marcas de comienzo y final cuya leyenda exacta depende de qué
se haya codificado (en el ejemplo, una clave pública) y una serie de
caracteres imprimibles que son la citada <a class="reference external" href="https://es.wikipedia.org/wiki/Base64">Base64</a> del formato binario <abbr title="Distinguised Encoding Rules">DER</abbr>.
En ocasiones <strong class="command">openssl</strong> nos ofrece un modo de hacer legible la
información almacenada y para el caso de claves <abbr title="Rivest, Shamir y Adleman">RSA</abbr>, lo hace:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> openssl rsa -in privkey.pem -text -noout
<span class="gp">$</span> openssl rsa -in pubkey.pem -pubin -text -noout
</pre></div>
</div>
<p>Obsérvese que ambas claves son pareja porque tienen el mismo módulo (que se
puede consultar independientemente sustituyendo <kbd class="kbd docutils literal notranslate">-text</kbd> pòr
<kbd class="kbd docutils literal notranslate">-modulus</kbd>)<a class="footnote-reference brackets" href="#id27" id="id14">11</a>.</p>
</div>
<p>Con ellas podemos cifrar y descifrar <strong>pequeños</strong><a class="footnote-reference brackets" href="#id28" id="id15">12</a> ficheros. Usando la
clave pública para cifrar y la privada para descifrar:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> <span class="nb">echo</span> <span class="s2">&quot;Hola&quot;</span> &gt; saludo.txt
<span class="gp">#</span> openssl rsautl -encrypt -inkey pubkey.pem -pubin -in saludo.txt -out saludo.enc
<span class="gp">#</span> openssl rsautl -decrypt -inkey privkey.pem -in saludo.enc
<span class="go">Hola</span>
</pre></div>
</div>
<p>¿Podemos cifrar con la privada y descifrar con la pública? También:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> openssl rsautl -sign -inkey privkey.pem -in saludo.txt -out saludo.enc
<span class="gp">#</span> openssl rsautl -verify -inkey pubkey.pem -pubin -in saludo.enc
<span class="go">Hola</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>Si en vez de un un simple par de claves, tenemos un <a class="reference internal" href="03.aplicaciones/01.certdig.html#cert-digital"><span class="std std-ref">certificado
digital</span></a>, aún podremos realizar estas operaciones sustituyendo
<kbd class="kbd docutils literal notranslate">-pubin</kbd> por <kbd class="kbd docutils literal notranslate">-certin</kbd></p>
</div>
</section>
<section id="id16">
<h4><span class="section-number">9.1.2.4.1.3. </span>Firma digital<a class="headerlink" href="#id16" title="Enlazar permanentemente con este título">¶</a></h4>
<p>Partiendo de las claves <abbr title="Rivest, Shamir y Adleman">RSA</abbr> ya generadas en el apartado anterior
(<code class="file docutils literal notranslate"><span class="pre">privkey.pem</span></code>, <code class="file docutils literal notranslate"><span class="pre">pubkey.pem</span></code>), podemos hacer una primera
aproximación tomando la <a class="reference internal" href="#firma-digital"><span class="std std-ref">descripción de lo que es la firma digital</span></a>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> <span class="nb">echo</span> <span class="s2">&quot;Este es el contenido del fichero que firmo&quot;</span> &gt; fichero.txt
<span class="gp">$</span> sha256sum fichero.txt <span class="p">|</span> tee /dev/tty <span class="p">|</span> openssl rsautl -sign -inkey privkey.pem -out fichero.sign
<span class="go">47ebcc00b179c0f1fc8f45fec4a3e6a55fbb1aeddd8a5bb6ee52c5d7f57d1d3a  fichero.txt</span>
</pre></div>
</div>
<p>Ya tenemos el archivo original (<code class="file docutils literal notranslate"><span class="pre">fichero.txt</span></code>) y la firma
(<code class="file docutils literal notranslate"><span class="pre">fichero.sign</span></code>) generada con la clave privada. Con ellos dos y la clave
publica correspondiente, podemos comprobar integridad e identidad:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> sha256sum fichero.txt
<span class="go">47ebcc00b179c0f1fc8f45fec4a3e6a55fbb1aeddd8a5bb6ee52c5d7f57d1d3a  fichero.txt</span>
<span class="gp">$</span> openssl rsautl -verify -inkey pubkey.pem -pubin -in fichero.sign
<span class="go">47ebcc00b179c0f1fc8f45fec4a3e6a55fbb1aeddd8a5bb6ee52c5d7f57d1d3a  fichero.txt</span>
</pre></div>
</div>
<p>Dado que coincide el resumen del archivo con la firma descifrada con la clave
pública, podemos concluir que el archivo no ha cambiado y que lo certificó el
propietario de la clave. En cualquier caso esto es sólo una aproximación al
concepto ya que en una firma también es importante cuándo se produjo y con esta
firma manual es imposible saberlo.</p>
<p>En realidad, para firmar con más comodidad, aunque nos abstraigamos del
concepto:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> openssl dgst -sha256 -sign privkey.pem -out fichero.sign fichero.txt
</pre></div>
</div>
<p>Y para verificar la firma:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> openssl dgst -sha256 -verify pubkey.pem -signature fichero.sign fichero.txt
<span class="go">Verified OK</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>Cuando lo que se tiene no es un simple par de claves, sino un
<a class="reference internal" href="03.aplicaciones/01.certdig.html#cert-digital"><span class="std std-ref">certificado digital</span></a> aún puede hacerse este proceso
extrayendo previamente la clave pública del certificado:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> openssl x509 -in micert.pem -pubkey -nooout &gt; pubkey.pem
</pre></div>
</div>
<p>aunque lo más adecuado, en realidad, sería firmar con <a class="reference internal" href="03.aplicaciones/03.correo.html#smime"><span class="std std-ref">S/MIME</span></a> y
<a class="reference internal" href="03.aplicaciones/03.correo.html#gnupg"><span class="std std-ref">OpenPGP</span></a>.</p>
</div>
<p class="rubric">Notas al pie</p>
<dl class="footnote brackets">
<dt class="label" id="id17"><span class="brackets"><a class="fn-backref" href="#id1">1</a></span></dt>
<dd><p><abbr title="Advanced Encryption Standard">AES</abbr> fue el ganador de un concurso organizado en 1997 por la <abbr title="National Institute of Standards and Technology">NIST</abbr> para
escoger un nuevo algoritmo de cifrado simétrico en sustitución de <abbr title="Data Encryption Standard">DES</abbr>. De
hecho, su nombre original es <em>Rijndael</em>, el nombre <abbr title="Advanced Encryption Standard">AES</abbr> lo tomó de haberse
constituido como el estándar.</p>
</dd>
<dt class="label" id="id18"><span class="brackets"><a class="fn-backref" href="#id2">2</a></span></dt>
<dd><p>Se ha usado en este párrafo y el anterior el condicional, porque
teóricamente esto es así. En la práctica, el cifrado con clave asimétrica es
muy costoso comptuacionalmente, así que se recurre a una argucia (el <a class="reference internal" href="#hibrido"><span class="std std-ref">cifrado
híbrido</span></a>) pero reducir al máximo la cantidad de información
que se cifra con clave asimétrica.</p>
</dd>
<dt class="label" id="id19"><span class="brackets"><a class="fn-backref" href="#id3">3</a></span></dt>
<dd><p>Pero no es obligatorio. Puedo probar a generar un certificado partiendo
de una clave privada <abbr title="Elliptic Curve Digital Signature Algorithm">ECDSA</abbr> generada con Open<abbr title="Secure Socket Layer">SSL</abbr> como se ilustra en el
<a class="reference internal" href="../../04.servidor/10.ssh/02.certificados.html#openssh-openssl"><span class="std std-ref">epígrafe en que se describe cómo convertir claves SSH en un formato
inteligible por OpenSSL</span></a></p>
</dd>
<dt class="label" id="id20"><span class="brackets"><a class="fn-backref" href="#id4">4</a></span></dt>
<dd><p>De hecho, <a class="reference external" href="https://www.openssh.com/">OpenSSH</a>, para su versión 7,
<a class="reference external" href="https://www.openssh.com/txt/release-7.0">deshabilitó el uso de DSA</a> (búsquese por <abbr title="Digital Signature Standard">DSS</abbr>).</p>
</dd>
<dt class="label" id="id21"><span class="brackets"><a class="fn-backref" href="#id5">5</a></span></dt>
<dd><p>¿Y si no es posible el contacto físico previo? Precisamente para eso
existen los <a class="reference internal" href="03.aplicaciones/01.certdig.html#cert-digital"><span class="std std-ref">certificados digitales</span></a> que introduciremos
más adelante.</p>
</dd>
<dt class="label" id="id22"><span class="brackets"><a class="fn-backref" href="#id6">6</a></span></dt>
<dd><p>En realidad, llegar a calcularlo es tan extremadamente costoso
computacionalmente que está fuera del alcance de cualquier supercomputador
moderno.</p>
</dd>
<dt class="label" id="id23"><span class="brackets"><a class="fn-backref" href="#id8">7</a></span></dt>
<dd><p>Pero para que todo esto no haga aguas es necesario confiar en que la clave
pública es de aquel de quien parece ser. Resolveremos este último escollo al
introducir el concepto de <a class="reference internal" href="03.aplicaciones/01.certdig.html#cert-digital"><span class="std std-ref">certificado digital</span></a>.</p>
</dd>
<dt class="label" id="id24"><span class="brackets"><a class="fn-backref" href="#id9">8</a></span></dt>
<dd><p>Usar, sin embargo, el propio kernel para la generación de la
entropía no es muy recomendable. Debería usarse el dispositivo
hardware (/dev/hwrng), pero en la máquina virtual es posible que
no esté. Para <strong class="program">qemu</strong> véase
<a class="reference external" href="https://wiki.qemu.org/Features/VirtIORNG">su wiki</a>.</p>
</dd>
<dt class="label" id="id25"><span class="brackets"><a class="fn-backref" href="#id10">9</a></span></dt>
<dd><p>Se fuerza a que la orden se ejecute en inglés, para que el resultado se
exprese como <em>OK</em> o <em>FAILED</em>. En castellano, la leyenda se expresa de forma
muy farragosa.</p>
</dd>
<dt class="label" id="id26"><span class="brackets"><a class="fn-backref" href="#id13">10</a></span></dt>
<dd><p>Podríamos también generar claves de curva elíptica. Hay algún ejemplo
en el <a class="reference internal" href="../../04.servidor/10.ssh/02.certificados.html#openssh-openssl"><span class="std std-ref">epígrafe en que se comparan las claves SSH con las generadas por
OpenSSL</span></a>.`</p>
</dd>
<dt class="label" id="id27"><span class="brackets"><a class="fn-backref" href="#id14">11</a></span></dt>
<dd><p>La clave pública se compone de un módulo y un exponente</p>
</dd>
<dt class="label" id="id28"><span class="brackets"><a class="fn-backref" href="#id15">12</a></span></dt>
<dd><p>Recordemos que el cifrado asimétrico está pensado para aplicarse sobre
una cantidad muy pequeña de información (un resumen o una clave simétrica).
La orden, de utilidad únicamente teórica, nos permite usar cifrado
asimétrico puro sobre un archivo arbitrario, pero si este es grande generará
un error (<em>data too large for key size</em>). Lo realista si queremos pasar a un
tercero el archivo es utilizar cifrado híbrido (p.e. aplicando el <a class="reference internal" href="03.aplicaciones/03.correo.html#smime"><span class="std std-ref">estándar
S/MIME</span></a> con el proprio <strong class="command">openssl</strong>).</p>
</dd>
</dl>
</section>
</section>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../../index.html">Tabla de contenido</a></h3>
  <ul>
<li><a class="reference internal" href="#">9.1.2. Operaciones criptográficas</a><ul>
<li><a class="reference internal" href="#resumen-criptografico">9.1.2.1. Resumen criptográfico</a></li>
<li><a class="reference internal" href="#cifrado">9.1.2.2. Cifrado</a><ul>
<li><a class="reference internal" href="#cifrado-simetrico">9.1.2.2.1. Cifrado simétrico</a></li>
<li><a class="reference internal" href="#cifrado-asimetrico">9.1.2.2.2. Cifrado asimétrico</a></li>
<li><a class="reference internal" href="#cifrado-hibrido">9.1.2.2.3. Cifrado híbrido</a></li>
<li><a class="reference internal" href="#conclusiones">9.1.2.2.4. Conclusiones</a></li>
</ul>
</li>
<li><a class="reference internal" href="#firma-digital">9.1.2.3. Firma digital</a></li>
<li><a class="reference internal" href="#apendice-practico">9.1.2.4. Apéndice práctico</a><ul>
<li><a class="reference internal" href="#resumenes">9.1.2.4.1. Resúmenes</a><ul>
<li><a class="reference internal" href="#openssl">9.1.2.4.1.1. Cifrado simétrico</a></li>
<li><a class="reference internal" href="#openssl-asi">9.1.2.4.1.2. Cifrado asimétrico</a></li>
<li><a class="reference internal" href="#id16">9.1.2.4.1.3. Firma digital</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>Tema anterior</h4>
  <p class="topless"><a href="01.intro.html"
                        title="capítulo anterior"><span class="section-number">9.1.1. </span>Introducción</a></p>
  <h4>Próximo tema</h4>
  <p class="topless"><a href="03.aplicaciones.html"
                        title="próximo capítulo"><span class="section-number">9.1.3. </span>Aplicaciones de la criptografía</a></p>
  <div role="note" aria-label="source link">
    <h3>Esta página</h3>
    <ul class="this-page-menu">
      <li><a href="../../_sources/98.apendice/01.cryto/02.algo.rst.txt"
            rel="nofollow">Mostrar el código</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Búsqueda rápida</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Ir a" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navegación</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="Índice General"
             >índice</a></li>
        <li class="right" >
          <a href="03.aplicaciones.html" title="9.1.3. Aplicaciones de la criptografía"
             >siguiente</a> |</li>
        <li class="right" >
          <a href="01.intro.html" title="9.1.1. Introducción"
             >anterior</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">documentación de Linuxnomicón - rolling</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" ><span class="section-number">9. </span>Apéndices</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="index.html" ><span class="section-number">9.1. </span>Criptografía</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href=""><span class="section-number">9.1.2. </span>Operaciones criptográficas</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Derechos de autor CC BY 4.0, 2016-2021, José Miguel Sánchez Alés.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 4.3.1.
    </div>
  </body>
</html>