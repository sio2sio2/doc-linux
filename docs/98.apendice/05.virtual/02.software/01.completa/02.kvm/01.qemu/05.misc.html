


<!DOCTYPE html>

<html lang="es">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />

    <title>9.2.2.1.2.1.4. Otros aspectos &#8212; documentación de Linuxnomicón - rolling</title>
    <link rel="stylesheet" type="text/css" href="../../../../../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../../../../../_static/classic.css" />
    <link rel="stylesheet" href="../../../../../../_static/custom.css" type="text/css" />
    
    <script data-url_root="../../../../../../" id="documentation_options" src="../../../../../../_static/documentation_options.js"></script>
    <script src="../../../../../../_static/jquery.js"></script>
    <script src="../../../../../../_static/underscore.js"></script>
    <script src="../../../../../../_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="../../../../../../_static/doctools.js"></script>
    <script src="../../../../../../_static/sphinx_highlight.js"></script>
    <script src="../../../../../../_static/translations.js"></script>
    
    <link rel="index" title="Índice" href="../../../../../../genindex.html" />
    <link rel="search" title="Búsqueda" href="../../../../../../search.html" />
    <link rel="next" title="9.2.2.1.2.1.5. Script" href="06.script.html" />
    <link rel="prev" title="9.2.2.1.2.1.3. Red" href="03.red.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navegación</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../../../../genindex.html" title="Índice General"
             accesskey="I">índice</a></li>
        <li class="right" >
          <a href="06.script.html" title="9.2.2.1.2.1.5. Script"
             accesskey="N">siguiente</a> |</li>
        <li class="right" >
          <a href="03.red.html" title="9.2.2.1.2.1.3. Red"
             accesskey="P">anterior</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../../../../index.html">documentación de Linuxnomicón - rolling</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../../../../index.html" ><span class="section-number">9. </span>Apéndices</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="../../../../index.html" ><span class="section-number">9.2. </span>Virtualización</a> &#187;</li>
          <li class="nav-item nav-item-3"><a href="../../../../02.software.html" ><span class="section-number">9.2.2. </span>Software de virtualización</a> &#187;</li>
          <li class="nav-item nav-item-4"><a href="../../02.kvm.html" accesskey="U"><span class="section-number">9.2.2.1.2. </span><abbr title="Kernel-based Virtual Machine">KVM</abbr></a> &#187;</li>
        <li class="nav-item nav-item-this"><a href=""><span class="section-number">9.2.2.1.2.1.4. </span>Otros aspectos</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="otros-aspectos">
<h1><span class="section-number">9.2.2.1.2.1.4. </span>Otros aspectos<a class="headerlink" href="#otros-aspectos" title="Enlace permanente a este encabezado">¶</a></h1>
<p>Reservamos este epígrafe para aspectos variados que no requieren excesivo
desarrollo, pero pueden resultar muy útiles.</p>
<section id="procesadores">
<h2><span class="section-number">9.2.2.1.2.1.4.1. </span>Procesadores<a class="headerlink" href="#procesadores" title="Enlace permanente a este encabezado">¶</a></h2>
<p>Para especificar el número de procesadores puede usarse la opción <kbd class="kbd docutils literal notranslate">-smp</kbd>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>qemu-system-vga<span class="w"> </span>-smp<span class="w"> </span><span class="m">2</span><span class="w"> </span>-hda<span class="w"> </span>disco.qcw
</pre></div>
</div>
</section>
<section id="firmware-de-la-placa-base">
<span id="qemu-efi"></span><h2><span class="section-number">9.2.2.1.2.1.4.2. </span>Firmware de la placa base<a class="headerlink" href="#firmware-de-la-placa-base" title="Enlace permanente a este encabezado">¶</a></h2>
<p>Por defecto, al virtualizar plataformas x86, <strong class="program">QEmu</strong> utiliza como
firmware la <abbr title="Basic I/O System">BIOS</abbr> de 16 <em>bits</em> proporcionada por el proyecto <a class="reference external" href="https://www.seabios.org/SeaBIOS">SeaBIOS</a>. Esto es
suficiente en la mayoría de los casos (especialmente <em>Linux</em>), pero cuando el
huésped debe correr on sistema operativo que lo exija (el caso de <em>Windows</em> 11)
o quieren precisamente hacerse pruebas sobre el arranque, surge la necesidad
de que el huésped arranque un firmware <abbr title="Extensible Firmware Interface">EFI</abbr>.</p>
<p>Para utilizar <abbr title="Extensible Firmware Interface">EFI</abbr> basta con indicarle un archivo que contenga el <em>firmware</em>
apropiado que habrá de descargarse o instalarse primero en el anfitrión. El
usado habitualmente es <a class="reference external" href="https://github.com/tianocore/tianocore.github.io/wiki/OVMF">OVMF</a> para el que existe el paquete <a class="reference external" href="https://packages.debian.org/stable/ovmf">ovmf</a> en
<em>Debian</em>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp"># </span>apt<span class="w"> </span>install<span class="w"> </span>ovmf
</pre></div>
</div>
<p>Con el paquete instalado, es tan fácil cambiar el <em>firmware</em> como añadir:</p>
<p><code class="code docutils literal notranslate"><span class="pre">-bios</span> <span class="pre">/usr/share/ovmf/OVMF.fd</span></code></p>
<p>donde la ruta es el lugar donde el paquete almacena el <em>firmware</em>.</p>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>Para emular la <abbr title="Non Volatile RAM">NVRAM</abbr>, <abbr title="Open Virtual Machine Firmware">OVMF</abbr> crear un archivo dentro de la partición
<abbr title="EFI System Partition">ESP</abbr> denominado <code class="file docutils literal notranslate"><span class="pre">NvVars</span></code>.</p>
</div>
<p>Es fundamental tener presente que al cargar este <em>firmware</em>, deja de tener
efecto la secuencia de arranque establecida según lo expuesto en el
<a class="reference internal" href="02.arranque.html#qemu-arranque-basico"><span class="std std-ref">arranque básico</span></a>. Para manipular la secuencia es
necesario pulsar <kbd class="kbd docutils literal notranslate">F2</kbd> durante el arranque de la máquina virtual, lo cual
permitirá entrar en un entorno desde el cuál puede escogerse qué sistema
operativo arrancar o alterar permanentemente el orden.</p>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>La secuencia de arranque <abbr title="Extensible Firmware Interface">EFI</abbr> también puede manipularse desde un
<em>Linux</em> huésped utilizando la orden <a class="reference external" href="https://www.linuxbabe.com/command-line/how-to-use-linux-efibootmgr-examples">efibootmgr</a>. Hay unos pocos ejemplos de
uso en <a class="reference internal" href="../../../../../../05.discos/01.division/03.pract.html#efi-entradas-grub"><span class="std std-ref">este epígrafe del manual</span></a>.</p>
</div>
</section>
<section id="soporte-para-vhost-net">
<span id="qemu-vhost-net"></span><h2><span class="section-number">9.2.2.1.2.1.4.3. </span>Soporte para <em>vhost-net</em><a class="headerlink" href="#soporte-para-vhost-net" title="Enlace permanente a este encabezado">¶</a></h2>
<p>La mejora en el rendimiento que supone <em>virtio-net</em> sólo será efectiva si puede
comunicarse directamente con el núcleo del anfitrión a través de su módulo
<em>vhost-net</em>. Para ello es necesario asegurarse de que el módulo se cargará
durante el arranque del anfitrión<a class="footnote-reference brackets" href="#id5" id="id1" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp"># </span><span class="nb">echo</span><span class="w"> </span><span class="s2">&quot;vhost_net&quot;</span><span class="w"> </span>&gt;&gt;<span class="w"> </span>/etc/modules
</pre></div>
</div>
<p>Y asegurarnos, además, de que el dispositivo de caracteres que crea
(<code class="file docutils literal notranslate"><span class="pre">/dev/vhost-net</span></code>) es accesible por el usuario que utiliza
<strong class="program">QEmu</strong>, para lo cual podemos valernos un mecanismo ya utilizado para
otros casos:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp"># </span>cat<span class="w"> </span>&gt;&gt;<span class="w"> </span>/etc/udev/rules.d/55-qemuperm.rules
<span class="go">KERNEL==&quot;vhost-net&quot;, ACTION==&quot;add&quot;, GROUP=&quot;qemusers&quot;, MODE=&quot;0660&quot;</span>
</pre></div>
</div>
<p>que concede permisos al grupo <em>qemusers</em>.</p>
<p>Con estos mimbres ya podremos hacer uso del módulo. Recordemos que, usando el
dispositivo <em>virtio-net</em>, utilizábamos una <a class="reference internal" href="03.red.html#qemu-red-puente-macvtap"><span class="std std-ref">interfaz macvtap0 para dejar la
interfaz como adaptador puente</span></a> así:</p>
<p><code class="code docutils literal notranslate"><span class="pre">-netdev</span> <span class="pre">tap,id=nic,fd=3</span></code></p>
<p>Pues bien, ahora la tendremos que utilizar así:</p>
<p><code class="code docutils literal notranslate"><span class="pre">-netdev</span> <span class="pre">tap,id=nic,fd=3,vhost=on,vhostfd=4</span></code></p>
<p>donde <strong>4</strong> es el descriptor de archivo usado a cuya entrada/salida
redirigiremos <code class="file docutils literal notranslate"><span class="pre">/dev/vhost-net</span></code>. Por tanto, la orden quedaría ahora así:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>qemu-system-vga<span class="w"> </span>-hda<span class="w"> </span>disco.qcw<span class="w"> </span>-device<span class="w"> </span>virtio-net,netdev<span class="o">=</span>nic,mac<span class="o">=</span><span class="k">$(</span>&lt;/sys/class/net/macvtap0/address<span class="k">)</span><span class="w"> </span><span class="se">\</span>
<span class="w">   </span>-netdev<span class="w"> </span>tap,id<span class="o">=</span>nic,fd<span class="o">=</span><span class="m">3</span>,vhost<span class="o">=</span>on,vhostfd<span class="o">=</span><span class="m">4</span><span class="w"> </span><span class="m">3</span>&lt;&gt;/dev/tap<span class="k">$(</span>&lt;/sys/class/net/macvtap0/ifindex<span class="k">)</span><span class="w"> </span><span class="m">4</span>&lt;&gt;/dev/vhost-net
</pre></div>
</div>
<p>En el caso de una interfaz <em>TAP</em>, hay más diferencias. Propusimos:</p>
<p><code class="code docutils literal notranslate"><span class="pre">-netdev</span> <span class="pre">bridge,id=nic,br=br0</span></code></p>
<p>El problema es que <em>bridge</em> no admite <kbd class="kbd docutils literal notranslate">vhost</kbd> ni <kbd class="kbd docutils literal notranslate">vhostfd</kbd>, así que
tenemos que echar mano de <em>tap</em>. La línea equivalente es:</p>
<p><code class="code docutils literal notranslate"><span class="pre">-netdev</span> <span class="pre">tap,id=nic,br=br0,helper=/usr/lib/qemu/qemu-bridge-helper</span></code></p>
<p>en que hay explícitamente que especificar el <em>helper</em>. Escrito así, sí podemos
hacer el añadido:</p>
<p><code class="code docutils literal notranslate"><span class="pre">-netdev</span> <span class="pre">tap,id=nic,br=br0,helper=/usr/lib/qemu/qemu-bridge-helper,vhost=on,vhostfd=4</span></code></p>
<p>con lo que la orden completa quedaría así:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>qemu-system-vga<span class="w"> </span>-hda<span class="w"> </span>disco.qcw<span class="w"> </span>-device<span class="w"> </span>virtio-net,netdev<span class="o">=</span>nic<span class="w"> </span><span class="se">\</span>
<span class="w">   </span>-netdev<span class="w"> </span>tap,id<span class="o">=</span>nic,br<span class="o">=</span>br0,helper<span class="o">=</span>/usr/lib/qemu/qemu-bridge-helper,vhost<span class="o">=</span>on,vhostfd<span class="o">=</span><span class="m">4</span><span class="w"> </span><span class="m">4</span>&lt;&gt;/dev/vhost-net
</pre></div>
</div>
</section>
<section id="virtio-scsi">
<span id="qemu-virtio-scsi"></span><h2><span class="section-number">9.2.2.1.2.1.4.4. </span>virtio-scsi<a class="headerlink" href="#virtio-scsi" title="Enlace permanente a este encabezado">¶</a></h2>
<p>Es un <em>driver</em> bastante eficiente que emula completamente una controladora
<abbr title="Small Computer System Interface">SCSI</abbr>. Para utilizarlo con un este disco:</p>
<p><code class="code docutils literal notranslate"><span class="pre">-blockdev</span> <span class="pre">&quot;driver=file,node-name=f1,filename=disco.qcw&quot;</span> <span class="pre">-blockdev</span> <span class="pre">&quot;driver=qcow2,node-name=hdd,file=f1&quot;</span></code></p>
<p>podemos añadir lo siguiente:</p>
<p><code class="code docutils literal notranslate"><span class="pre">-device</span> <span class="pre">virtio-scsi,id=scsi0</span> <span class="pre">-device</span> <span class="pre">scsi-hd,drive=hdd,bus=scsi0.0,channel=0,scsi-id=0,lun=0</span></code></p>
<p>donde podemos ir cambiando el valor de <kbd class="kbd docutils literal notranslate">lun</kbd>, si añadimos más discos; o
<kbd class="kbd compound docutils literal notranslate"><kbd class="kbd docutils literal notranslate">scsi</kbd>-<kbd class="kbd docutils literal notranslate">hd</kbd></kbd> por <kbd class="kbd compound docutils literal notranslate"><kbd class="kbd docutils literal notranslate">scsi</kbd>-<kbd class="kbd docutils literal notranslate">cd</kbd></kbd>, si de lo que se trata es de una unidad
óptica. De este modo, una máquina con una disco y un dispositivo óptico
podríamos arrancarla así:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>qemu-system-vga<span class="w"> </span>-device<span class="w"> </span>virtio-scsi,id<span class="o">=</span>scsi0<span class="w"> </span><span class="se">\</span>
<span class="w">   </span>-blockdev<span class="w"> </span><span class="s2">&quot;driver=file,node-name=f1,filename=disco.qcw&quot;</span><span class="w"> </span>-blockdev<span class="w"> </span><span class="s2">&quot;driver=qcow2,node-name=hdd,file=f1&quot;</span><span class="w"> </span><span class="se">\</span>
<span class="w">   </span>-device<span class="w"> </span>scsi-hd,drive<span class="o">=</span>hdd,bus<span class="o">=</span>scsi0.0,channel<span class="o">=</span><span class="m">0</span>,scsi-id<span class="o">=</span><span class="m">0</span>,lun<span class="o">=</span><span class="m">0</span>,bootindex<span class="o">=</span><span class="m">1</span><span class="w"> </span><span class="se">\</span>
<span class="w">   </span>-blockdev<span class="w"> </span><span class="s2">&quot;driver=file,node-name=cdrom,filename=gparted.iso&quot;</span><span class="w"> </span><span class="se">\</span>
<span class="w">   </span>-device<span class="w"> </span>scsi-cd,drive<span class="o">=</span>cdrom,bus<span class="o">=</span>scsi0.0,channel<span class="o">=</span><span class="m">0</span>,scsi-id<span class="o">=</span><span class="m">0</span>,lun<span class="o">=</span><span class="m">1</span>,bootindex<span class="o">=</span><span class="m">0</span>
</pre></div>
</div>
<p>Puede obtenerse mejoras en el rendimiento añadiendo 4 colas:</p>
<p><code class="code docutils literal notranslate"><span class="pre">-device</span> <span class="pre">virtio-scsi,id=scsi0,num_queues=4</span></code></p>
<p>y, tanto para este driver como para <em>virtio-blk</em>, hay mejora también si se
define el objeto:</p>
<p><code class="code docutils literal notranslate"><span class="pre">-object</span> <span class="pre">iothread,id=iothread0</span></code></p>
<p>y se añade su uso a <em>virtio-scsi</em> (o <em>virtio-blk</em>):</p>
<p><code class="code docutils literal notranslate"><span class="pre">-device</span> <span class="pre">virtio-scsi,id=scsi0,iothread=iothread0</span></code></p>
</section>
<section id="usb">
<span id="qemu-usb"></span><h2><span class="section-number">9.2.2.1.2.1.4.5. </span><abbr title="Universal Serial Bus">USB</abbr><a class="headerlink" href="#usb" title="Enlace permanente a este encabezado">¶</a></h2>
<p>Para habilitar <abbr title="Universal Serial Bus">USB</abbr> en el huésped es necesario arrancar la máquina con:</p>
<p><code class="code docutils literal notranslate"><span class="pre">-device</span> <span class="pre">qemu-xhci</span></code><a class="footnote-reference brackets" href="#id6" id="id2" role="doc-noteref"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></a></p>
<p>Este epígrafe, no obstante, está dedicado a describir cómo hacer que un
dispositivo <abbr title="Universal Serial Bus">USB</abbr> conectado al anfitrión aparezca directamente en el huésped.
Necesitaremos dos cosas:</p>
<ol class="arabic">
<li><p>Si se usa <strong class="program">QEmu</strong> como usuario sin privilegios, permitir que éste
tenga permisos de escritura. Esto se hace de modo análogo a como <a class="reference internal" href="03.red.html#qemu-red-puente-macvtap"><span class="std std-ref">se permite
la escritura en dispositivos TAP de caracteres</span></a>:
definiendo un grupo <em>qemusers</em> donde se encuentren los usuarios que
virtualicen y añadiendo una regla para la creación de dispositivos <abbr title="Universal Serial Bus">USB</abbr>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp"># </span>cat<span class="w"> </span>&gt;&gt;<span class="w"> </span>/etc/udev/rules.d/55-qemuperm.rules
<span class="go">SUBSYSTEM==&quot;usb&quot;, ACTION==&quot;add&quot;, GROUP=&quot;qemusers&quot;, MODE=&quot;0660&quot;</span>
</pre></div>
</div>
</li>
<li><p>Pasar al huésped el dispositivo <abbr title="Universal Serial Bus">USB</abbr> que queremos tener disponible en él,
para lo cual tenemos que identificar en el anfitrión tal dispositivo:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>lsusb
<span class="go">[...]</span>
<span class="go">Bus 001 Device 007: ID abcd:1234 Unknown UDisk</span>
<span class="go">[...]</span>
</pre></div>
</div>
<p>Supongamos que el dispositivo es éste. Si queremos tener una salida más
prolija de sus características, podemos hacer:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>lsusb<span class="w"> </span>-v<span class="w"> </span>-s<span class="w"> </span><span class="m">1</span>:7
<span class="go">[...]</span>
<span class="go">    idVendor           0xabcd Unknown</span>
<span class="go">    idProduct          0x1234</span>
<span class="go">[...]</span>
</pre></div>
</div>
<p>donde <kbd class="kbd docutils literal notranslate">1:7</kbd> son el número de bus y dispositivo que se han observado en
la salida sucinta primera. Consultado estos datos podemos pasar la gestión
del dispositivo <abbr title="Universal Serial Bus">USB</abbr> al huésped añadiendo:</p>
<p><code class="code docutils literal notranslate"><span class="pre">-device</span> <span class="pre">usb-host,hostbus=1,hostaddr=7</span></code><a class="footnote-reference brackets" href="#id7" id="id3" role="doc-noteref"><span class="fn-bracket">[</span>3<span class="fn-bracket">]</span></a></p>
<p>Estos dos números (<strong>1</strong> y <strong>7</strong>) son cambiantes. Una alternativa es
identificar el dispositivo con su código de vendedor y producto que sí son
fijos y, por tanto, no exigirán que los consultemos cada vez que conectamos
el dispositivo al equipo:</p>
<p><code class="code docutils literal notranslate"><span class="pre">-device</span> <span class="pre">usb-host,vendorid=0xabcd,productid=0x1234</span></code></p>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>El dispositivo <abbr title="Universal Serial Bus">USB</abbr> no estará disponible en el anfitrión, mientras
esté siendo gestionado por el huésped.</p>
</div>
</li>
</ol>
<p>En definitiva, que si queremos que un huésped se haga cargo de la gestión de un
dispositivo <abbr title="Universal Serial Bus">USB</abbr> (con identificador de vendedor <strong>0xabcd</strong> e identicador de
producto <strong>0x1234</strong>), deberemos arrancarlo así:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>qemu-system-vga<span class="w"> </span>-hda<span class="w"> </span>disco.qcw<span class="w"> </span>-device<span class="w"> </span>qemu-xhci<span class="w"> </span>-device<span class="w"> </span>usb-host,vendorid<span class="o">=</span>0xabcd,productid<span class="o">=</span>0x1234
</pre></div>
</div>
</section>
<section id="directorio-compartido">
<span id="qemu-virtio-fs"></span><h2><span class="section-number">9.2.2.1.2.1.4.6. </span>Directorio compartido<a class="headerlink" href="#directorio-compartido" title="Enlace permanente a este encabezado">¶</a></h2>
<p>Un aspecto muy importante de la virtualización es tener algún mecanismo
eficiente para compartir archivos entre el anfitrión y el huésped. Esto, en
principio y siempre que el huésped tenga conectividad de red con el anfitrión,
puede llevarse a cabo haciendo uso de un sistema de archivos en red como <abbr title="Network File System">NFS</abbr>
o <abbr title="Common Internet File System">CIFS</abbr>, pero no es eficiente. La mejor solución es utilizar <a class="reference external" href="https://virtio-fs.gitlab.io">virtio-fs</a>, que
está pensado específicamente para este propósito.</p>
<p>Para compartir un directorio del anfitrión debemos antes utilizar en él el
demonio <strong class="program">virtiofsd</strong> como administrador:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp"># </span>/usr/lib/qemu/virtiofsd<span class="w"> </span>--socket-path<span class="o">=</span>/var/run/vm1.sock<span class="w"> </span>-o<span class="w"> </span><span class="nv">source</span><span class="o">=</span>/var/lib/share<span class="w"> </span>--socket-group<span class="o">=</span>qemusers
</pre></div>
</div>
<p>donde estamos suponiendo, como llevamos haciendo esta ahora, que <em>qemusers</em> es
un grupo al que pertenecen los usuarios que arrancan máquinas virtuales de
<strong class="program">QEmu</strong>.</p>
<p>Hecho lo cual, podemos arrancar el huésped, que usará el <em>socket</em> creado por la
orden para comunicarse con el anfitrión:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>qemu-system-vga<span class="w"> </span>-hda<span class="w"> </span>disco.qcw<span class="w"> </span>-chardev<span class="w"> </span>socket,id<span class="o">=</span>char0,path<span class="o">=</span>/var/run/vm1.sock<span class="w"> </span><span class="se">\</span>
<span class="w">   </span>-device<span class="w"> </span>vhost-user-fs-pci,chardev<span class="o">=</span>char0,tag<span class="o">=</span>anfitrion,queue-size<span class="o">=</span><span class="m">1024</span><span class="w"> </span><span class="se">\</span>
<span class="w">   </span>-object<span class="w"> </span>memory-backend-file,id<span class="o">=</span>mem,size<span class="o">=</span>512M,mem-path<span class="o">=</span>/dev/shm,share<span class="o">=</span>on<span class="w"> </span>-numa<span class="w"> </span>node,memdev<span class="o">=</span>mem
</pre></div>
</div>
<p>«<em>anfitrion</em>» es una etiqueta que se utilizará cuando en el huésped queramos
montar el directorio compartido:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp"># </span>mount<span class="w"> </span>-t<span class="w"> </span>virtiofs<span class="w"> </span>anfitrion<span class="w"> </span>/mnt
</pre></div>
</div>
</section>
<section id="compactacion-de-discos">
<span id="qemu-disco-compact"></span><h2><span class="section-number">9.2.2.1.2.1.4.7. </span>Compactación de discos<a class="headerlink" href="#compactacion-de-discos" title="Enlace permanente a este encabezado">¶</a></h2>
<p>La intención del epígrafe es lograr un disco en formato <abbr title="Qemu Copy-On-Write">QCOW</abbr>2 con el menor
tamaño posible, propósito que requiere tres tareas:</p>
<ol class="arabic simple">
<li><p>Eliminar los archivos innecesarios.</p></li>
<li><p>Rellenar con ceros los bloques del sistema de archivos que en algún momento se
hubieran escrito y se liberaran posteriormente.</p></li>
<li><p>Comprimir la imagen.</p></li>
</ol>
<p>Para ello tomemos una imagen llamada <code class="file docutils literal notranslate"><span class="pre">disco.qcw</span></code> y obremos sobre ella. Las
dos primeras tareas requieren acceso a su contenido, para lo cual lo mejor es
<a class="reference internal" href="01.discos.html#qemu-nbd"><span class="std std-ref">montar el disco</span></a> en vez de arrancar el sistema huésped:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp"># </span>modprobe<span class="w"> </span>nbd<span class="w"> </span><span class="nv">max_part</span><span class="o">=</span><span class="m">63</span>
<span class="gp"># </span>qemu-nbd<span class="w"> </span>-c<span class="w"> </span>/dev/nbd0<span class="w"> </span>disco.qcw
<span class="gp"># </span>partx<span class="w"> </span>-a<span class="w"> </span>/dev/nbd0
</pre></div>
</div>
<p>Esto debería dejar disponibles las particiones de la imagen
(<code class="file docutils literal notranslate"><span class="pre">/dev/nbd0p1</span></code>, <code class="file docutils literal notranslate"><span class="pre">/dev/nbd0p2</span></code>, etc.). El siguiente paso es ir
montando uno a uno los sistemas de archivos para realizar sobre ellos las dos
primeras acciones: borrar lo innecesario y rellenar con ceros. Lo primero es
trivial y lo segundo depende de cuál sea el sistema de archivos:</p>
<ul>
<li><p>Si es <em>ext4</em>, podemos usar <em class="manpage"><a class="manpage reference external" href="https://manpages.debian.org/zerofree">zerofree</a></em> (incluido en el paquete del
mismo nombre):</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp"># </span>zerofree<span class="w"> </span>-v<span class="w"> </span>/dev/nbd0p1
</pre></div>
</div>
</li>
<li><p>Si es <abbr title="New Technology File System">NTFS</abbr>, podemos usar <em class="manpage"><a class="manpage reference external" href="https://manpages.debian.org/ntfswipe">ntfswipe</a></em> (incluido en el paquete
<a class="reference external" href="https://packages.debian.org/stable/ntfs-3g">ntfs-3g</a>):</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp"># </span>ntfswipe<span class="w"> </span>-uvb0<span class="w"> </span>/dev/nbd0p1
</pre></div>
</div>
</li>
</ul>
<p>Una vez que hayamos terminado con todos los sistemas de archivos, deberemos
desmontar la imagen de disco:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp"># </span>qemu-nbd<span class="w"> </span>-d<span class="w"> </span>/dev/nbd0
</pre></div>
</div>
<p>Y, finalmente, hacer una <a class="reference internal" href="01.discos.html#qemu-discos-conv"><span class="std std-ref">conversión de la imagen</span></a> para
comprimirla:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>mv<span class="w"> </span>disco<span class="o">{</span>,_z<span class="o">}</span>.qcw
<span class="gp">$ </span>qemu-img<span class="w"> </span>convert<span class="w"> </span>-c<span class="w"> </span>-p<span class="w"> </span>-f<span class="w"> </span>qcow2<span class="w"> </span>disco_z.qcw<span class="w"> </span>-O<span class="w"> </span>qcow2<span class="w"> </span>disco.qcw
<span class="gp">$ </span>rm<span class="w"> </span>-f<span class="w"> </span>disco_z.qcw
</pre></div>
</div>
<p>donde la opción <kbd class="kbd docutils literal notranslate">-c</kbd> es la que obra la compresión.</p>
</section>
<section id="cifrado-de-discos">
<span id="qemu-disco-cifrado"></span><h2><span class="section-number">9.2.2.1.2.1.4.8. </span>Cifrado de discos<a class="headerlink" href="#cifrado-de-discos" title="Enlace permanente a este encabezado">¶</a></h2>
<p>El formato <abbr title="Qemu Copy-On-Write">QCOW</abbr>2 ofrece la posibilidad de cifrar las propias imágenes de
disco, de manera que su contenido esté bloqueado mientras no se conozca cuál es
la contraseña usada para su cifrado.</p>
<p>Para ello, lo primero es <a class="reference internal" href="01.discos.html#qemu-img-create"><span class="std std-ref">crear una imagen</span></a> de disco cifrada:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>qemu-img<span class="w"> </span>create<span class="w"> </span>-f<span class="w"> </span>qcow2<span class="w"> </span>--object<span class="w"> </span><span class="s2">&quot;secret,id=pass,data=micontraseña&quot;</span><span class="w"> </span><span class="se">\</span>
<span class="w">   </span>-o<span class="w"> </span><span class="s2">&quot;encrypt.format=luks,encrypt.key-secret=pass&quot;</span><span class="w"> </span>cifrado.qcw<span class="w"> </span>4G
</pre></div>
</div>
<p>Hecho esto, la imagen estará cifrada, por lo que cada vez que quiera usarse
deberá proporcionarse la contraseña. Así, para <a class="reference internal" href="01.discos.html#qemu-nbd"><span class="std std-ref">montar el disco</span></a>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp"># </span>qemu-nbd<span class="w"> </span>-c<span class="w"> </span>/dev/nbd0<span class="w"> </span>--object<span class="w"> </span><span class="s2">&quot;secret,id=pass,data=micontraseña&quot;</span><span class="w"> </span><span class="se">\</span>
<span class="w">   </span>--image-opts<span class="w"> </span><span class="s2">&quot;driver=qcow2,encrypt.format=luks,encrypt.key-secret=pass,file.filename=cifrado.qcw&quot;</span>
</pre></div>
</div>
<p>y para usarla en una máquina virtual:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>qemu-system-vga<span class="w"> </span>-object<span class="w"> </span><span class="s2">&quot;secret,id=pass,data=micontraseña&quot;</span><span class="w"> </span>-blockdev<span class="w"> </span><span class="s2">&quot;driver=file,node-name=disco,filename=cifrado.qcw&quot;</span><span class="w"> </span><span class="se">\</span>
<span class="w">   </span>-blockdev<span class="w"> </span><span class="s2">&quot;driver=qcow2,encrypt.format=luks,encrypt.key-secret=pass,node-name=hdd,file=disco&quot;</span><span class="w"> </span>-device<span class="w"> </span><span class="s2">&quot;virtio-blk,drive=hdd&quot;</span>
</pre></div>
</div>
</section>
<section id="chip-tpm">
<span id="qemu-tpm"></span><h2><span class="section-number">9.2.2.1.2.1.4.9. </span>Chip <abbr title="Trusted Platform Module">TPM</abbr><a class="headerlink" href="#chip-tpm" title="Enlace permanente a este encabezado">¶</a></h2>
<p>Puede ser muy interesante disponer en el huésped de un <em>chip</em> <abbr title="Trusted Platform Module">TPM</abbr>:</p>
<ol class="arabic">
<li><p>Si el anfitrión es un <em>Linux</em> y dispone de <em>chip</em>, podemos utilizar el <em>chip</em>
también en el huésped añadiendo las siguientes opciones:</p>
<p><code class="code docutils literal notranslate"><span class="pre">-device</span> <span class="pre">tpm-tis,tpmdev=tpm0</span> <span class="pre">-tpmdev</span> <span class="pre">passthrough,id=tpm0</span></code></p>
</li>
<li><p>Si no dispone del <em>chip</em>, aún podemos emularlo del siguiente modo:</p>
<ol class="loweralpha">
<li><p>Instalamos en el anfitrión el <em>software</em> apropiado:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp"># </span>apt<span class="w"> </span>install<span class="w"> </span>swtpm-tools
</pre></div>
</div>
</li>
<li><p>Creamos un directorio donde almacenar los estados del <abbr title="Trusted Platform Module">TPM</abbr>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$  </span>mkdir<span class="w"> </span>vmtpm0
</pre></div>
</div>
</li>
<li><p>Lanzamos el <em>software</em> que crea un <em>socket</em> para la comunicación<a class="footnote-reference brackets" href="#id8" id="id4" role="doc-noteref"><span class="fn-bracket">[</span>4<span class="fn-bracket">]</span></a>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>swtpm<span class="w"> </span>socket<span class="w"> </span>--tpmstate<span class="w"> </span><span class="nv">dir</span><span class="o">=</span>vmtpm0<span class="w"> </span>--ctrl<span class="w"> </span><span class="nv">type</span><span class="o">=</span>unixio,path<span class="o">=</span>vmtpm0/swtpm-sock
</pre></div>
</div>
</li>
<li><p>Una vez hechos estos preparativos, ya podremos arrancar máquinas virtuales
con un <em>chip</em> virtual <abbr title="Trusted Platform Module">TPM</abbr> añadiendo lo siguiente:</p>
<p><code class="code docutils literal notranslate"><span class="pre">-chardev</span> <span class="pre">socket,id=chrtpm,path=vmtpm0/swtpm-sock</span> <span class="pre">-tpmdev</span> <span class="pre">emulator,id=tpm0,chardev=chrtpm</span> <span class="pre">-device</span> <span class="pre">tpm-tis,tpmdev=tpm0</span></code></p>
<p>donde el <em>socket</em> es el creado por <strong class="command">swtpm</strong>. Si todo ha ido bien,
el huésped debería disponer de un dispositivo <code class="file docutils literal notranslate"><span class="pre">/dev/tpm0</span></code>. Además,
al apagar la máquina, <strong class="command">swtpm</strong> también completará  su ejecución.</p>
</li>
</ol>
</li>
</ol>
</section>
<section id="pausado">
<h2><span class="section-number">9.2.2.1.2.1.4.10. </span>Pausado<a class="headerlink" href="#pausado" title="Enlace permanente a este encabezado">¶</a></h2>
<p>Supongamos que de una máquina arrancada con:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>qemu-system-vga<span class="w"> </span>-hda<span class="w"> </span>disco.qcw<span class="w"> </span>-device<span class="w"> </span>virtio-net,netdev<span class="o">=</span>nic<span class="w"> </span>-netdev<span class="w"> </span>user,id<span class="o">=</span>nic
</pre></div>
</div>
<p>quiere pausarse su ejecución. Para ello, basta con acudir al monitor y ejecutar
la orden:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>(qemu) stop
</pre></div>
</div>
<p>Si se quiere volver a poner en ejecución, basta con:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>(qemu) cont
</pre></div>
</div>
<p>Esto proceder, no obstante, sólo es válido mientras no se aborte la ejecución
de la máquina. Si nuestra intención,  es pausar la máquina, abortar la ejecución
y tiempo más adelante volver a arrancar la máquina con el estado justo que tenía
cuando se pausó es necesario más:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>(qemu) stop
(qemu) migrate &quot;exec:xz -c &gt; estado_disco.xz&quot;
(qemu) quit
</pre></div>
</div>
<p>Con esto habremos no solo parado la máquina, sino guardado su estado en el
archivo <code class="file docutils literal notranslate"><span class="pre">estado_disco.xz</span></code>.  Si al reiniciar la máquina queremos recuperar el
estado de ejecución, deberemos arrancar la máquina exactamente del mismo modo:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>qemu-system-vga<span class="w"> </span>-hda<span class="w"> </span>disco.qcw<span class="w"> </span>-device<span class="w"> </span>virtio-net,netdev<span class="o">=</span>nic<span class="w"> </span>-netdev<span class="w"> </span>user,id<span class="o">=</span>nic<span class="w"> </span><span class="se">\</span>
<span class="w">   </span>-incoming<span class="w"> </span><span class="s2">&quot;exec:xz -dc estado_disco.xz&quot;</span>
</pre></div>
</div>
<p>pero añadiendo la opción <kbd class="kbd docutils literal notranslate">-incoming</kbd>. Obviamente, la máquina se encontrará
pausada, porque fue así como estaba cuando guardamos su estado, así que será
necesario abrir el monitor y:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>(qemu) cont
</pre></div>
</div>
<p class="rubric">Notas al pie</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id5" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id1">1</a><span class="fn-bracket">]</span></span>
<p>Hasta que arranquemos no se cargará, así que si queremos hacer pruebas
sobre la marcha, habrá que cargarlo por esta vez a mano:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp"># </span>modprobe<span class="w"> </span>vhost_net
</pre></div>
</div>
</aside>
<aside class="footnote brackets" id="id6" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id2">2</a><span class="fn-bracket">]</span></span>
<p>De ahí que tuviéramos que incluir esto al querer emular el comportamiento
del puntero en una pantalla táctil (<kbd class="kbd compound docutils literal notranslate"><kbd class="kbd docutils literal notranslate">-device</kbd> <kbd class="kbd docutils literal notranslate">usb</kbd>-<kbd class="kbd docutils literal notranslate">tablet</kbd></kbd>) tal como
recomienda el manual cuando la salida es <abbr title="Virtual Network Computing">VNC</abbr>.</p>
</aside>
<aside class="footnote brackets" id="id7" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id3">3</a><span class="fn-bracket">]</span></span>
<p>Obviamente, el huésped debe tener habilitado el <abbr title="Universal Serial Bus">USB</abbr>, de modo que
también deberá usarse <code class="code docutils literal notranslate"><span class="pre">-device</span> <span class="pre">qemu-xhci</span></code>.</p>
</aside>
<aside class="footnote brackets" id="id8" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id4">4</a><span class="fn-bracket">]</span></span>
<p><strong class="command">swtpm</strong> tiene una opción para correr en segundo plano (<kbd class="kbd docutils literal notranslate">-d</kbd>),
pero <strong class="program">QEmu</strong> no funciona cuando se usa. ?:/</p>
</aside>
</aside>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <div>
    <h3><a href="../../../../../../index.html">Tabla de contenido</a></h3>
    <ul>
<li><a class="reference internal" href="#">9.2.2.1.2.1.4. Otros aspectos</a><ul>
<li><a class="reference internal" href="#procesadores">9.2.2.1.2.1.4.1. Procesadores</a></li>
<li><a class="reference internal" href="#firmware-de-la-placa-base">9.2.2.1.2.1.4.2. Firmware de la placa base</a></li>
<li><a class="reference internal" href="#soporte-para-vhost-net">9.2.2.1.2.1.4.3. Soporte para <em>vhost-net</em></a></li>
<li><a class="reference internal" href="#virtio-scsi">9.2.2.1.2.1.4.4. virtio-scsi</a></li>
<li><a class="reference internal" href="#usb">9.2.2.1.2.1.4.5. <abbr title="Universal Serial Bus">USB</abbr></a></li>
<li><a class="reference internal" href="#directorio-compartido">9.2.2.1.2.1.4.6. Directorio compartido</a></li>
<li><a class="reference internal" href="#compactacion-de-discos">9.2.2.1.2.1.4.7. Compactación de discos</a></li>
<li><a class="reference internal" href="#cifrado-de-discos">9.2.2.1.2.1.4.8. Cifrado de discos</a></li>
<li><a class="reference internal" href="#chip-tpm">9.2.2.1.2.1.4.9. Chip <abbr title="Trusted Platform Module">TPM</abbr></a></li>
<li><a class="reference internal" href="#pausado">9.2.2.1.2.1.4.10. Pausado</a></li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>Tema anterior</h4>
    <p class="topless"><a href="03.red.html"
                          title="capítulo anterior"><span class="section-number">9.2.2.1.2.1.3. </span>Red</a></p>
  </div>
  <div>
    <h4>Próximo tema</h4>
    <p class="topless"><a href="06.script.html"
                          title="próximo capítulo"><span class="section-number">9.2.2.1.2.1.5. </span><em>Script</em></a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>Esta página</h3>
    <ul class="this-page-menu">
      <li><a href="../../../../../../_sources/98.apendice/05.virtual/02.software/01.completa/02.kvm/01.qemu/05.misc.rst.txt"
            rel="nofollow">Mostrar el código</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Búsqueda rápida</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Ir a" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navegación</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../../../../genindex.html" title="Índice General"
             >índice</a></li>
        <li class="right" >
          <a href="06.script.html" title="9.2.2.1.2.1.5. Script"
             >siguiente</a> |</li>
        <li class="right" >
          <a href="03.red.html" title="9.2.2.1.2.1.3. Red"
             >anterior</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../../../../index.html">documentación de Linuxnomicón - rolling</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../../../../index.html" ><span class="section-number">9. </span>Apéndices</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="../../../../index.html" ><span class="section-number">9.2. </span>Virtualización</a> &#187;</li>
          <li class="nav-item nav-item-3"><a href="../../../../02.software.html" ><span class="section-number">9.2.2. </span>Software de virtualización</a> &#187;</li>
          <li class="nav-item nav-item-4"><a href="../../02.kvm.html" ><span class="section-number">9.2.2.1.2. </span><abbr title="Kernel-based Virtual Machine">KVM</abbr></a> &#187;</li>
        <li class="nav-item nav-item-this"><a href=""><span class="section-number">9.2.2.1.2.1.4. </span>Otros aspectos</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Derechos de autor CC BY 4.0, 2016-2023, José Miguel Sánchez Alés.
      Creado usando <a href="https://www.sphinx-doc.org/">Sphinx</a> 5.3.0.
    </div>
  </body>
</html>