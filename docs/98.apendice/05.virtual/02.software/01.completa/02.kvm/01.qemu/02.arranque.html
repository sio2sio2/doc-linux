

<!DOCTYPE html>

<html lang="es" data-content_root="../../../../../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>9.2.2.1.2.1.2. Ejecución de máquinas &#8212; documentación de Linuxnomicón - rolling</title>
    <link rel="stylesheet" type="text/css" href="../../../../../../_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="../../../../../../_static/classic.css?v=def86cc0" />
    <link rel="stylesheet" href="../../../../../../_static/custom.css" type="text/css" />
    
    <script src="../../../../../../_static/documentation_options.js?v=a621b78a"></script>
    <script src="../../../../../../_static/doctools.js?v=9a2dae69"></script>
    <script src="../../../../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../../../../_static/translations.js?v=d190bf04"></script>
    
    <link rel="index" title="Índice" href="../../../../../../genindex.html" />
    <link rel="search" title="Búsqueda" href="../../../../../../search.html" />
    <link rel="next" title="9.2.2.1.2.1.3. Red" href="03.red.html" />
    <link rel="prev" title="9.2.2.1.2.1.1. Gestión de discos" href="01.discos.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="Related">
      <h3>Navegación</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../../../../genindex.html" title="Índice General"
             accesskey="I">índice</a></li>
        <li class="right" >
          <a href="03.red.html" title="9.2.2.1.2.1.3. Red"
             accesskey="N">siguiente</a> |</li>
        <li class="right" >
          <a href="01.discos.html" title="9.2.2.1.2.1.1. Gestión de discos"
             accesskey="P">anterior</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../../../../index.html">documentación de Linuxnomicón - rolling</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../../../../index.html" ><span class="section-number">9. </span>Apéndices</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="../../../../index.html" ><span class="section-number">9.2. </span>Virtualización</a> &#187;</li>
          <li class="nav-item nav-item-3"><a href="../../../../02.software.html" ><span class="section-number">9.2.2. </span>Software de virtualización</a> &#187;</li>
          <li class="nav-item nav-item-4"><a href="../../02.kvm.html" accesskey="U"><span class="section-number">9.2.2.1.2. </span><abbr title="Kernel-based Virtual Machine">KVM</abbr></a> &#187;</li>
        <li class="nav-item nav-item-this"><a href=""><span class="section-number">9.2.2.1.2.1.2. </span>Ejecución de máquinas</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="ejecucion-de-maquinas">
<span id="qemu-uso"></span><h1><span class="section-number">9.2.2.1.2.1.2. </span>Ejecución de máquinas<a class="headerlink" href="#ejecucion-de-maquinas" title="Link to this heading">¶</a></h1>
<p><strong class="program">QEmu</strong> no es un programa especialmente amigable para la ejecución de
máquinas. No hay más que leer la presentación <a class="reference external" href="https://archive.fosdem.org/2018/schedule/event/vai_qemu_jungle/attachments/slides/2539/export/events/attachments/vai_qemu_jungle/slides/2539/qemu_cli_jungle.pdf">La jungla de los parámetros de
QEmu</a>.
De hecho, no está pensado para el uso habitual de un usuario normal y ni
siquiera pueden <em>crearse</em> máquinas virtuales, sino que al utilizar uno o varios
discos se declaran cuáles son las características de la máquina virtual que los
usará.</p>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p><strong class="program">QEmu</strong> no distingue el guión del doble guión. Por tanto,
<kbd class="kbd docutils literal notranslate">-hda</kbd> equivale a <kbd class="kbd compound docutils literal notranslate"><kbd class="kbd docutils literal notranslate">-</kbd>-<kbd class="kbd docutils literal notranslate">hda</kbd></kbd>.</p>
</div>
<section id="basica">
<span id="qemu-arranque-basico"></span><h2><span class="section-number">9.2.2.1.2.1.2.1. </span>Básica<a class="headerlink" href="#basica" title="Link to this heading">¶</a></h2>
<p>La ejecución más básica que podemos hacer es la siguiente:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>qemu-system-x86_64<span class="w"> </span>-machine<span class="w"> </span><span class="nv">accel</span><span class="o">=</span>kvm<span class="w"> </span>-m<span class="w"> </span><span class="m">512</span><span class="w"> </span>-hda<span class="w"> </span>disco.qcw
</pre></div>
</div>
<p>que, habilitando la aceleración por <em>hardware</em><a class="footnote-reference brackets" href="#id7" id="id1" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a>, levantará
una máquina:</p>
<ul class="simple">
<li><p>Con 512MiB de memoria <abbr title="Random Access Memory">RAM</abbr> gracias a la opción <kbd class="kbd docutils literal notranslate">-m</kbd>. Es necesario
incluirla, porque la memoria predeterminada son <em>128</em> MiB, muy escasa para
practicamente cualquier sistema operativo moderno. Puede incluirse
<kbd class="kbd docutils literal notranslate">G</kbd> para significar GiB. Por ejemplo, <code class="code docutils literal notranslate"><span class="pre">-m</span> <span class="pre">1G</span></code>.</p></li>
<li><p>Con firmware <abbr title="Basic I/O System">BIOS</abbr>.</p></li>
<li><p>Con un procesador.</p></li>
<li><p>Dispone de un disco duro representado por el archivo <code class="file docutils literal notranslate"><span class="pre">disco.qcw</span></code>.</p></li>
<li><p>Con una tarjeta de red configurada como <abbr title="Network Address Translation">NAT</abbr> (según <a class="reference internal" href="../../01.virtualbox.html#virtualbox-red"><span class="std std-ref">la terminología de Virtualbox</span></a>)<a class="footnote-reference brackets" href="#id8" id="id2" role="doc-noteref"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></a>.</p></li>
<li><p>Con una salida de vídeo compatible con <abbr title="Video Graphics Array">VGA</abbr>.</p></li>
<li><p>Muestra el huésped (una opción <kbd class="kbd compound docutils literal notranslate"><kbd class="kbd docutils literal notranslate">-display</kbd> <kbd class="kbd docutils literal notranslate">gtk</kbd></kbd> implícita) en una ventana
del anfitrión.</p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>En cualquier caso, esta forma de lanzar es un poco peligrosa, puesto
que la ventana se cerrará sin confirmación (y con ello la máquina virtual
se abortará) con tan sólo pulsar el aspa que proporciona el gestor de ventanas.
Es recomendable evitarlo añadiendo:</p>
<p><code class="code docutils literal notranslate"><span class="pre">-display</span> <span class="pre">gtk,window-close=off</span></code>.</p>
</div>
<p>Sin embargo, si el disco está vacío, de poco servirá porque la máquina no
encontrará sistema operativo que arrancar. Así que podemos añadir un cedé y arrancar por él:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>qemu-system-x86_64<span class="w"> </span>-machine<span class="w"> </span><span class="nv">accel</span><span class="o">=</span>kvm<span class="w"> </span>-m<span class="w"> </span><span class="m">512</span><span class="w"> </span>-hda<span class="w"> </span>disco.qcw<span class="w"> </span>-cdrom<span class="w"> </span>gparted.iso<span class="w"> </span>-boot<span class="w"> </span>d
</pre></div>
</div>
<p>donde hemos tenido que añadir la opción <kbd class="kbd docutils literal notranslate">-boot</kbd> para poder arrancar desde
el cedé en vez de el disco duro, que es el comportamiento predeterminado, ya que
«d» significa CDRom, como «c» disco duro, y «n» red. En realidad es una
simplificación (obsoleta, según su página de manual
<em class="manpage"><a class="manpage reference external" href="https://manpages.debian.org/qemu-system-x86_64">qemu-system-x86_64</a></em>) de:</p>
<p><code class="code docutils literal notranslate"><span class="pre">-boot</span> <span class="pre">order=d</span></code></p>
<p>Pueden indicarse varias letras para definir una secuencia de arranque. Por
ejemplo:</p>
<p><code class="code docutils literal notranslate"><span class="pre">-boot</span> <span class="pre">order=ndc</span></code></p>
<p>intenta primero un arranque por red, si éste falla, un arranque por la unidad
óptica y, por último, un arranque por el disco duro. También podemos optar por
presentar un menú de selección:</p>
<p><code class="code docutils literal notranslate"><span class="pre">-boot</span> <span class="pre">menu=on</span></code></p>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p><kbd class="kbd docutils literal notranslate">-boot</kbd> sólo tiene efecto con <em>firmware</em> <abbr title="Basic I/O System">BIOS</abbr>.</p>
</div>
<p id="qemu-nodefaults">En cualquier caso, y antes de empezar a profundizar en la virtualización de
algunos dispositivos, es recomendable introducir los siguientes alias:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span><span class="nb">alias</span><span class="w"> </span>qemu-system<span class="o">=</span><span class="s1">&#39;qemu-system-x86_64 -nodefaults -display none -m 512 -machine accel=kvm&#39;</span>
<span class="gp">$ </span><span class="nb">alias</span><span class="w"> </span>qemu-system-vga<span class="o">=</span><span class="s1">&#39;qemu-system -device virtio-vga -display gtk -monitor vc&#39;</span>
</pre></div>
</div>
<p>El primero elimina cualquier dispositivo predeterminado (p.e. ya no habrá
ninguna interfaz de red ni ninguna salida de vídeo) gracias a la opción
<kbd class="kbd docutils literal notranslate">-nodefaults</kbd>, mientras que el segundo añadirá una salida de vídeo <abbr title="Video Graphics Array">VGA</abbr>.
Este segundo <em>alias</em> hace algo más: hace accesible el monitor de <strong class="program">QEmu</strong>
para manipular la máquina virtual en la ventana gráfica en que se ve el huésped.
Si nos resulta un problema  crear máquinas sin interfaz de red (el estudio de
ellas lo posponemos al siguiente epígrafe), podemos redefinir el primer <em>alias</em>
para que añada una <a class="reference internal" href="../../01.virtualbox.html#virtualbox-red"><span class="std std-ref">interfaz dispuesta en NAT</span></a>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span><span class="nb">alias</span><span class="w"> </span>qemu-system<span class="o">=</span><span class="s1">&#39;qemu-system-x86_64 -nodefaults -display none -m 512 -machine accel=kvm -netdev user,id=nic -device virtio-net,netdev=nic&#39;</span>
</pre></div>
</div>
<p>Sobre esta base podremos probar las opciones que se proponen a continuación.</p>
</section>
<section id="discos">
<h2><span class="section-number">9.2.2.1.2.1.2.2. </span>Discos<a class="headerlink" href="#discos" title="Link to this heading">¶</a></h2>
<p><strong class="program">QEmu</strong> provee un mecanismo simplificado para indicar qué discos duros
(o unidad óptica) pretenden incorporarse a la máquina virtual, y que es el que
hemos utilizado bajo el epígrafe anterior: las opciones <kbd class="kbd docutils literal notranslate">-hda</kbd>,
<kbd class="kbd docutils literal notranslate">-hdb</kbd>, <kbd class="kbd docutils literal notranslate">-hdc</kbd> <kbd class="kbd docutils literal notranslate">-hdd</kbd>, y <kbd class="kbd docutils literal notranslate">-cdrom</kbd>, la cual convierte el
disco situado en <em>hdc</em> en un medio óptico, por lo que es incompatible con la
opción <kbd class="kbd docutils literal notranslate">-hdc</kbd>. Para estos cinco argumentos el parámetro es un archivo
regular: una imagen de disco (p.e. en formato <abbr title="Qemu Copy On Write">QCOW</abbr>2) para los cuatro
primeros, y una imagen <em>ISO</em> para el último.</p>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>Como estará sospechando por estar reducido a la declaración de cuatro
discos, <strong class="program">QEmu</strong> emula, mediante esta forma simplificada, una
controladora <abbr title="Integrated Device Electronic">IDE</abbr>.</p>
</div>
<p>Normalmente, bastará con expresar mediante estas opciones los medios de
almacenamiento, pero podemos encontrarnos casos en que tengamos que conocer con
mayor profundidad cómo se refieren éstos. Hay dos opciones que deberemos usar
conjuntamente:</p>
<dl>
<dt><kbd class="kbd docutils literal notranslate">-blockdev</kbd></dt><dd><p>que define en sí el dispositivo de bloques que se utilizará como <em>backend</em>.
Por ejemplo, lo siguiente define un dispositivo que es un archivo de nombre
<code class="file docutils literal notranslate"><span class="pre">disco.qcw</span></code> en formato <abbr title="Qemu Copy On Write">QCOW</abbr>2.</p>
<p><code class="code docutils literal notranslate"><span class="pre">-blockdev</span> <span class="pre">&quot;driver=file,node-name=f1,filename=disco.qcw&quot;</span> <span class="pre">-blockdev</span> <span class="pre">&quot;driver=qcow2,node-name=hdd,file=f1&quot;</span></code></p>
<p>Y, esto esto, un archivo en formato crudo:</p>
<p><code class="code docutils literal notranslate"><span class="pre">-blockdev</span> <span class="pre">&quot;driver=file,node-name=iso,filename=gparted.iso&quot;</span> <span class="pre">-blockdev</span> <span class="pre">&quot;driver=raw,node-name=cdrom,file=iso&quot;</span></code></p>
<p>que, obviamente, es la imagen de un cedé. Ahora bien, como <em>raw</em> es el
formato predeterminado podríamos habernos ahorrado el segundo
<kbd class="kbd docutils literal notranslate">-blockdev</kbd>:</p>
<p><code class="code docutils literal notranslate"><span class="pre">-blockdev</span> <span class="pre">&quot;driver=file,node-name=cdrom,filename=gparted.iso&quot;</span></code></p>
<p>Si, en cambio, quisiéramos usar directamente el lector óptico
(<code class="file docutils literal notranslate"><span class="pre">/dev/sr0</span></code>):</p>
<p><code class="code docutils literal notranslate"><span class="pre">-blockdev</span> <span class="pre">&quot;drive=host_device,node-name=cdrom,filename=/dev/sr0&quot;</span></code></p>
<p>Sea como sea, esta opción solamente declara dispositivos de bloques sin
especificar qué se quiere hacer con ellos. Para que una máquina virtual los
use, es necesario añadir una opción más.</p>
</dd>
<dt><kbd class="kbd docutils literal notranslate">-device</kbd></dt><dd><p>que define cómo se usara el dispositivo. Por ejemplo, esto nos conectaría el
disco definido anteriormente (recordemos <kbd class="kbd compound docutils literal notranslate"><kbd class="kbd docutils literal notranslate">node</kbd>-<kbd class="kbd docutils literal notranslate">name=hdd</kbd></kbd>) a la controladora <abbr title="Integrated Device Electronic">IDE</abbr>:</p>
<p><code class="code docutils literal notranslate"><span class="pre">-device</span> <span class="pre">&quot;ide-hd,drive=hdd,bootindex=1&quot;</span></code></p>
<p>y, si queremos conectar también el cedé (al que nombramos con
<kbd class="kbd compound docutils literal notranslate"><kbd class="kbd docutils literal notranslate">node</kbd>-<kbd class="kbd docutils literal notranslate">name=cdrom</kbd></kbd>):</p>
<p><code class="code docutils literal notranslate"><span class="pre">-device</span> <span class="pre">&quot;ide-cd,drive=cdrom,bootindex=0&quot;</span></code></p>
<p>Obsérvese que hemos referido el orden de arranque para que arranque primero
el cedé. Sin embargo, por rendimiento es mejor usar <a class="reference external" href="https://www.qemu.org/2021/01/19/virtio-blk-scsi-configuration/">virtio-blk</a> para los
discos duros en vez de emular la controladora <abbr title="Integrated Device Electronic">IDE</abbr>. En consecuencia:</p>
<p><code class="code docutils literal notranslate"><span class="pre">-device</span> <span class="pre">&quot;virtio-blk,drive=hdd,bootindex=1&quot;</span> <span class="pre">-device</span> <span class="pre">&quot;ide-cd,drive=cdrom,bootindex=0&quot;</span></code></p>
</dd>
</dl>
<p>Poniendo todo junto podríamos arrancar una máquina con un disco del siguiente
modo:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>qemu-system-vga<span class="w"> </span>-blockdev<span class="w"> </span><span class="s2">&quot;driver=file,node-name=f1,filename=disco.qcw&quot;</span><span class="w"> </span><span class="se">\</span>
<span class="w">   </span>-blockdev<span class="w"> </span><span class="s2">&quot;driver=qcow2,node-name=hdd,file=f1&quot;</span><span class="w"> </span>-device<span class="w"> </span><span class="s2">&quot;ide-hd,drive=hdd&quot;</span>
</pre></div>
</div>
<p>y si queremos añadir un lector óptico con una imagen de disco incluida y que
arranque primero:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>qemu-system-vga<span class="w"> </span>-blockdev<span class="w"> </span><span class="s2">&quot;driver=file,node-name=f1,filename=disco.qcw&quot;</span><span class="w"> </span><span class="se">\</span>
<span class="w">   </span>-blockdev<span class="w"> </span><span class="s2">&quot;driver=qcow2,node-name=hdd,file=f1&quot;</span><span class="w"> </span>-device<span class="w"> </span><span class="s2">&quot;virtio-blk,drive=hdd,bootindex=1&quot;</span><span class="w"> </span><span class="se">\</span>
<span class="w">   </span>-blockdev<span class="w"> </span><span class="s2">&quot;driver=file,node-name=cdrom,filename=gparted.iso&quot;</span><span class="w"> </span>-device<span class="w"> </span><span class="s2">&quot;ide-cd,drive=cdrom,bootindex=0&quot;</span>
</pre></div>
</div>
<p>Evidentemente las formas simplificadas con que comenzamos el epígrafe son
bastante más sencillas.</p>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p><em>virtio-blk</em> tiene el inconveniente de que en un huésped <em>Linux</em> los
discos no serán los dispositivos de bloques <code class="file docutils literal notranslate"><span class="pre">/dev/sdX</span></code>, sino
<code class="file docutils literal notranslate"><span class="pre">/dev/vdX</span></code>. Una buenaalternativa que mantiene los nombres habituales y
que permite también emular dispositivos ópticos, aunque con algo menos de
rendimiento, es <a class="reference internal" href="05.misc.html#qemu-virtio-scsi"><span class="std std-ref">virtio-scsi</span></a>.</p>
</div>
</section>
<section id="salida-de-video">
<h2><span class="section-number">9.2.2.1.2.1.2.3. </span>Salida de vídeo<a class="headerlink" href="#salida-de-video" title="Link to this heading">¶</a></h2>
<p>Por defecto, o sea, en ausencia de la opción <kbd class="kbd docutils literal notranslate">-nodefaults</kbd>, <strong class="program">QEmu</strong>
la define así<a class="footnote-reference brackets" href="#id9" id="id3" role="doc-noteref"><span class="fn-bracket">[</span>3<span class="fn-bracket">]</span></a>:</p>
<p><code class="code docutils literal notranslate"><span class="pre">-device</span> <span class="pre">VGA</span> <span class="pre">-display</span> <span class="pre">gtk</span></code></p>
<p>en que hay dos opciones: <kbd class="kbd docutils literal notranslate">-device</kbd>, que hace referencia a un <em>hardware</em>
virtualizado por la aplicación (ya vimos que también se usaba para virtualizar
discos) y <kbd class="kbd docutils literal notranslate">-display</kbd> que refiere la forma en que el vídeo se presentará al
anfitrión. En este caso, para el huésped se virtualiza una tarjeta de vídeo con
compatibilidad absoluta con el estándar <abbr title="Video Graphics Array">VGA</abbr> y en el anfitrión se muestra éste
mediante una ventana que que presenta un menú superior con algunas opciones de
manipulación de la máquina. En principio, podemos sustituir <kbd class="kbd docutils literal notranslate">VGA</kbd> por
<kbd class="kbd compound docutils literal notranslate"><kbd class="kbd docutils literal notranslate">virtio</kbd>-<kbd class="kbd docutils literal notranslate">vga</kbd></kbd>, que debería ser más  eficiente y, de hecho, es lo que se ha
hecho al crear el alias <em>qemu-system-vga</em>.</p>
<div class="admonition seealso">
<p class="admonition-title">Ver también</p>
<p>Puede echarle un ojo a <a class="reference external" href="https://www.kraxel.org/blog/2019/09/display-devices-in-qemu/">otras virtualizaciones del hardware de
vídeo</a>.</p>
</div>
<dl id="qemu-video-grafica">
<dt><strong>Ventana gráfica</strong></dt><dd><p>Si no manipulamos <kbd class="kbd docutils literal notranslate">-display</kbd>, el anfitrión se muestra dentro de la
ventana gráfica y hay algunas combinaciones de teclas que nos conviene saber:</p>
<ul class="simple">
<li><p><kbd class="kbd compound docutils literal notranslate"><kbd class="kbd docutils literal notranslate">Ctrl</kbd>+<kbd class="kbd docutils literal notranslate">Alt</kbd>+<kbd class="kbd docutils literal notranslate">q</kbd></kbd>, que cancela inmediatamente la ejecución de la máquina.</p></li>
<li><p><kbd class="kbd compound docutils literal notranslate"><kbd class="kbd docutils literal notranslate">Ctrl</kbd>+<kbd class="kbd docutils literal notranslate">Alt</kbd>+<kbd class="kbd docutils literal notranslate">f</kbd></kbd>, que pone la ventana gráfica a pantalla completa (y revierte
el efecto si vuelve a pulsarse).</p></li>
<li><p><kbd class="kbd compound docutils literal notranslate"><kbd class="kbd docutils literal notranslate">Ctrl</kbd>+<kbd class="kbd docutils literal notranslate">Alt</kbd>+<kbd class="kbd docutils literal notranslate">g</kbd></kbd>, que recupera para el anfitrión el ratón si el huésped lo
capturó.</p></li>
<li><p><kbd class="kbd compound docutils literal notranslate"><kbd class="kbd docutils literal notranslate">Ctrl</kbd>+<kbd class="kbd docutils literal notranslate">Alt</kbd>+<kbd class="kbd docutils literal notranslate">1</kbd></kbd>, <kbd class="kbd compound docutils literal notranslate"><kbd class="kbd docutils literal notranslate">Ctrl</kbd>+<kbd class="kbd docutils literal notranslate">Alt</kbd>+<kbd class="kbd docutils literal notranslate">2</kbd></kbd>, <kbd class="kbd compound docutils literal notranslate"><kbd class="kbd docutils literal notranslate">Ctrl</kbd>+<kbd class="kbd docutils literal notranslate">Alt</kbd>+<kbd class="kbd docutils literal notranslate">3</kbd></kbd>, que cambian de
consola virtual. En la <strong>1</strong> está el anfitrión; el la <strong>2</strong>, el monitor (si
definimos la salida del monitor como <em>vc</em>); y en <strong>3</strong>, el puerto serie.</p></li>
</ul>
<p>Además, dado que el anfitrión aparece en una ventana aparte, la terminal
donde estemos ejecutado <strong class="program">QEmu</strong> quedará inútilmente ocupada hasta que
apaguemos la máquina. Por tanto, nos convendrá normalmente añadir la opción
<code class="code docutils literal notranslate"><span class="pre">-daemonize</span></code>, que la liberará para que podamos utilizarla entretanto:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>qemu-system-vga<span class="w"> </span>-hda<span class="w"> </span>caca.qcw<span class="w"> </span>-daemonize
</pre></div>
</div>
</dd>
<dt><abbr title="Virtual Network Computing">VNC</abbr></dt><dd><p>Una posibilidad es sustituir la ventana por un servidor <abbr title="Virtual Network Computing">VNC</abbr>, de modo que
para observar e interactuar con el huéspedes utilicemos un <a class="reference internal" href="../../../../../../guias/0227.ser/01.remoto.html#ser-vnc-cliente"><span class="std std-ref">cliente VNC</span></a> en el anfitrión:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>qemu-system-vga<span class="w"> </span>-hda<span class="w"> </span>disco.qcw<span class="w"> </span>-display<span class="w"> </span><span class="s2">&quot;vnc=localhost:0&quot;</span><span class="w"> </span>-daemonize
</pre></div>
</div>
<p>lo cual creará un servidor <abbr title="Virtual Network Computing">VNC</abbr> que escuchará en el puerto 5900/<abbr title="Transmission Control Protocol">TCP</abbr> de la
interfaz de <em>loopback</em>. Podemos ir sustituyendo el número (<strong>0</strong>, <strong>1</strong>, etc.)
si arrancamos varias máquinas a la vez, para que cada una se ponga a eschar
en un puerto distinto (<strong>5900</strong>, <strong>5901</strong>, etc.). Como en el caso de la
ventana gráfica, hemos añadido <kbd class="kbd docutils literal notranslate">-daemonize</kbd> para liberar la terminal del
anfitrión.</p>
<p>Aunque lo anterior basta, es conveniente añadir estos parámetros:</p>
<p><code class="code docutils literal notranslate"><span class="pre">-device</span> <span class="pre">qemu-xhci</span> <span class="pre">-device</span> <span class="pre">usb-tablet</span> <span class="pre">-k</span> <span class="pre">es</span></code></p>
<p>que habilitan el <abbr title="Universal Serial Bus">USB</abbr> y definen la configuración del teclado (es
recomendación de la propia página de manual).</p>
<div class="admonition warning">
<p class="admonition-title">Advertencia</p>
<p>Ejecutado así, la comunicación con la máquina virtual no será
cifrada ni tendrá contraseña, aunque hemos paliado el problema permitiendo
la conexión únicamente desde el propio cliente. Pueden usarse contraseñas
o certificados para cifrar la conexión. Échele un vistazo a:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>qemu-system-x86_64<span class="w"> </span>-display<span class="w"> </span><span class="nv">vnc</span><span class="o">=</span><span class="nb">help</span>
</pre></div>
</div>
</div>
</dd>
</dl>
<dl id="qemu-video-texto">
<dt><strong>Texto</strong></dt><dd><p>Si nuestro huésped es un servidor sin entorno gráfico, no necesitamos en
realidad una ventana gráfica en la que ni siquiera podemos copiar y pegar
(y esto incluye el acceso <abbr title="Virtual Network Computing">VNC</abbr> que acabamos de ver)<a class="footnote-reference brackets" href="#id10" id="id4" role="doc-noteref"><span class="fn-bracket">[</span>4<span class="fn-bracket">]</span></a>. Una buena
alternativa es sustituir dicha ventana por la salida y entrada estándares de
la propia terminal del anfitrión. Tendremos, no obstante, dos desventajas:</p>
<ul>
<li><p>Sólo podremos tener una sesión abierta (a menos que habilitemos accesos
adicionales por <abbr title="Security SHell">SSH</abbr>) a diferencia de la ventana gráfica o <abbr title="Virtual Network Computing">VNC</abbr>, en los
que podemos abrir las seudoterminales típicas a través de <kbd class="kbd compound docutils literal notranslate"><kbd class="kbd docutils literal notranslate">Alt</kbd>+<kbd class="kbd docutils literal notranslate">F1</kbd></kbd>,
<kbd class="kbd compound docutils literal notranslate"><kbd class="kbd docutils literal notranslate">Alt</kbd>+<kbd class="kbd docutils literal notranslate">F2</kbd></kbd>, etc.</p></li>
<li><p>Tendremos que modificar el huésped para que se muestre a través del
puerto serie. En un huésped <em>Linux</em> que arranque con <abbr title="GNU GRand Unified Bootloader">GRUB</abbr> esto se logra
editando <code class="file docutils literal notranslate"><span class="pre">/etc/default/grub</span></code> de modo que incluya estas tres líneas:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="c1">#GRUB_CMDLINE_LINUX_DEFAULT=&quot;quiet&quot;</span>
<span class="nv">GRUB_CMDLINE_LINUX</span><span class="o">=</span><span class="s2">&quot;console=ttyS0&quot;</span>

<span class="nv">GRUB_TERMINAL</span><span class="o">=</span><span class="s2">&quot;console serial&quot;</span>
<span class="nv">GRUB_SERIAL_COMMAND</span><span class="o">=</span><span class="s2">&quot;serial --speed=115200 --unit=0 --word=8 --parity=no --stop=1&quot;</span>

<span class="nv">GRUB_GFXPAYLOAD_LINUX</span><span class="o">=</span><span class="s2">&quot;text&quot;</span>
</pre></div>
</div>
<p>La primera línea suele encontrarse descomentada y, simplemente, evita que
el núcleo informe demasiado durante el arranque. Como yo prefiero verlos,
he comentado la línea. La segunda añade un parámetro al arranque del núcleo
y puede ya encontrarse en el archivo con algún otro valor. Si es así, no
habrá más que añadir el nuevo (<kbd class="kbd docutils literal notranslate">console=ttyS0</kbd>).  Las dos siguientes
líneas provocan que el propio <abbr title="GNU GRand Unified Bootloader">GRUB</abbr> también se muestre por el puerto
serie. La última línea le indica al núcleo que arranque en modo texto.
Finalmente, habrá que regenerar la configuración:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp"># </span>update-grub
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>Como alternativa a añadir <kbd class="kbd docutils literal notranslate">console=ttyS0</kbd> a
<em>GRUB_CMDLINE_LINUX</em>, puede habilitarse el siguiente servicio:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp"># </span>systemctl<span class="w"> </span><span class="nb">enable</span><span class="w"> </span>--now<span class="w"> </span>serial-getty@ttyS0.service
</pre></div>
</div>
<p>Sin embargo, esto no permitirá ver los mensajes del núcleo durante el
arranque, por lo que, dado que de todos modos hay que editar
<code class="file docutils literal notranslate"><span class="pre">/etc/default/grub</span></code> para lograr que <strong class="program">grub</strong> se vea por el
puerto serie, es preferible la primera opción</p>
</div>
</li>
</ul>
<p>Una primera forma es usar la opción <code class="code docutils literal notranslate"><span class="pre">-nographic</span></code>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>qemu-system-x86_64<span class="w"> </span>-machine<span class="w"> </span><span class="nv">accel</span><span class="o">=</span>kvm<span class="w"> </span>-m<span class="w"> </span><span class="m">512</span><span class="w"> </span>-hda<span class="w"> </span>disco.qcw<span class="w"> </span>-nographic
</pre></div>
</div>
<p>que requiere los dispositivos predeterminados por lo que no usamos los alias
creados anteriormente, que hacen uso de <kbd class="kbd docutils literal notranslate">-nodefaults</kbd>.</p>
<p>Una alternativa mejor es, simplemente, redirigir el puerto serie del huésped
a la salida y entrada estándares del anfitrión:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>qemu-system<span class="w"> </span>-hda<span class="w"> </span>disco.qcw<span class="w"> </span>-serial<span class="w"> </span>stdio
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>Obsérvese que no hemos usado el alias <em>qemu-system-vga</em>. En este
caso, no queremos ninguna salida de vídeo.</p>
</div>
<p>El problema de esta comunicación con el anfitrión es que habremos perdido
el monitor. Para paliarlo, <strong class="program">QEmu</strong> permite multiplexar con el
monitor simplemente añadiendo el prefijo <kbd class="kbd docutils literal notranslate">mon:</kbd> al valor de
<kbd class="kbd docutils literal notranslate">-serial</kbd>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>qemu-system<span class="w"> </span>-hda<span class="w"> </span>disco.qcw<span class="w"> </span>-serial<span class="w"> </span>mon:stdio
</pre></div>
</div>
<p>Hay alternativas a mostrar directamente una terminal del huésped en la
terminal del anfitrión. Por ejemplo, redirigir a un servidor telnet
situado en un determinado puerto (p.e. el <strong>12345</strong>):</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>qemu-system<span class="w"> </span>-hda<span class="w"> </span>disco.qcw<span class="w"> </span>-serial<span class="w"> </span>mon:telnet:localhost:12345,server<span class="o">=</span>on,wait<span class="o">=</span>off<span class="w"> </span>-daemonize<span class="sb">`</span>
</pre></div>
</div>
<p>al cual podremos conectarnos desde el anfitrión con <strong class="command">telnet</strong>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>telnet<span class="w"> </span>localhost<span class="w"> </span><span class="m">12345</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>Si añadimos a la línea el dispositivo gráfico <code class="code docutils literal notranslate"><span class="pre">-device</span> <span class="pre">sga</span></code>,
que es precisamente lo que hace la opción <kbd class="kbd docutils literal notranslate">-nographic</kbd>, veremos
también los mensajes de arranque de la <abbr title="Basic I/O System">BIOS</abbr>, pero no es recomendable
porque afecta a toda la salida posterior.</p>
</div>
</dd>
<dt><strong>Tubería</strong></dt><dd><p>Una variante para la interfaz <abbr title="Command Line Interface">CLI</abbr> anterior, es manipular la salida para
poder manipular la máquina de forma no interactiva. Exige también que el
huésped presente una consola en el puerto serie, pero en este caso tal puerto
se redirige a una tubería del anfitrión:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>mkfifo<span class="w"> </span>/tmp/huesped.<span class="o">{</span><span class="k">in</span>,out<span class="o">}</span>
</pre></div>
</div>
<p>arrancando la máquina con la opción:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>qemu-system<span class="w"> </span>-hda<span class="w"> </span>disco.qcw<span class="w"> </span>-serial<span class="w"> </span>pipe:/tmp/huesped
</pre></div>
</div>
<p>En estas condiciones, <code class="file docutils literal notranslate"><span class="pre">huesped.out</span></code> mostrará la salida de la máquina:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>cat<span class="w"> </span>/tmp/huesped.out
</pre></div>
</div>
<p>y a través de <code class="file docutils literal notranslate"><span class="pre">huesped.in</span></code> podremos introducir datos. Por tanto, cuando
aparezca el login, podremos ingresar del siguiente modo:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>cat<span class="w"> </span>&gt;<span class="w"> </span>/tmp/huesped.in
<span class="go">root</span>
<span class="go">contraseñaderoot</span>
<span class="go">whoami</span>
</pre></div>
</div>
<div class="admonition warning">
<p class="admonition-title">Advertencia</p>
<p>Cada instrucción puede requerir un tiempo de procesamiento,
por lo que en ocasiones será necesario que exista una pausa entre
instrucciones. El caso de justamente arriba funciona porque se supone que
se está escribiendo interactivamente la orden  y entre la primera línea
(<em>root</em>) y la segunda (<em>su contraseña</em>) pasará un tiempo. En cambio, si
las tres líneas estuvieran previamente escritas en un archivo y se
redirigiera éste a la tubería, no lograríamos ingresar.</p>
</div>
</dd>
</dl>
<dl id="qemu-video-spice">
<dt><strong>Spice</strong></dt><dd><p>Cuando el huésped dispone de entorno gráfico esta salida es la más adecuada,
ya que ofrece varias ventajas y, entre ellas, la posibilidad de copiar y
pegar con el ratón entre anfitrión y huésped.</p>
<p>La máquina debe arrancarse del siguiente modo:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>qemu-system<span class="w"> </span>-spice<span class="w"> </span><span class="nv">unix</span><span class="o">=</span>on,addr<span class="o">=</span>/var/run/vm_spice.socket,disable-ticketing<span class="o">=</span>on<span class="w"> </span>-device<span class="w"> </span>qxl-vga<span class="w"> </span>-display<span class="w"> </span>spice-app<span class="w"> </span><span class="se">\</span>
<span class="w">   </span>-device<span class="w"> </span>virtio-serial<span class="w"> </span>-chardev<span class="w"> </span>spicevmc,id<span class="o">=</span>vdagent,debug<span class="o">=</span><span class="m">0</span>,name<span class="o">=</span>vdagent<span class="w"> </span><span class="se">\</span>
<span class="w">   </span>-device<span class="w"> </span>virtserialport,chardev<span class="o">=</span>vdagent,name<span class="o">=</span>com.redhat.spice.0
</pre></div>
</div>
<p>donde la primera línea es la estrictamente necesaria para usar spice utilizando
como comunicación con el anfitrión un <em>socket</em>, y las dos siguientes permiten
que funcione el cortapega entre anfitrión y huesped.</p>
<p>Lo necesario, no obstante, no acaba aquí. En el <strong>anfitrión</strong> necesitamos un
cliente <em>spice</em> (p.e. <a class="extlink-deb reference external" href="https://packages.debian.org/stable/spice-client-gtk">spice-client-gtk</a> o <a class="extlink-deb reference external" href="https://packages.debian.org/stable/virt-viewer">virt-viewer</a>) para
acceder al huésped. <code class="code docutils literal notranslate"><span class="pre">-display</span> <span class="pre">spice-app</span></code> intenta lanzar automáticamente
uno al arrancar la máquina, pero requiere que tal cliente esté asociado al tipo
<abbr title="Multipurpose Internet Mail Extensions">MIME</abbr> <kbd class="kbd compound docutils literal notranslate"><kbd class="kbd docutils literal notranslate">x</kbd>-<kbd class="kbd docutils literal notranslate">scheme</kbd>-<kbd class="kbd docutils literal notranslate">handler/spice</kbd>+<kbd class="kbd docutils literal notranslate">unix</kbd></kbd>. <strong class="command">spicy</strong> (el cliente que
incluye el paquete <a class="extlink-deb reference external" href="https://packages.debian.org/stable/spice-client-gtk">spice-client-gtk</a>) tiene la ventaja de que no incluye
ninguna dependencia de <a class="reference internal" href="../../02.kvm.html#libvirt"><span class="std std-ref">libvirt</span></a>, pero al menos hasta
<em>Bullseye</em>  no tiene ningún archivo <kbd class="kbd docutils literal notranslate">.desktop</kbd> que permita establecer la
asociación<a class="footnote-reference brackets" href="#id11" id="id5" role="doc-noteref"><span class="fn-bracket">[</span>5<span class="fn-bracket">]</span></a>. La solución  es sencilla si se repasa el epígrafe sobre
<a class="reference internal" href="../../../../../../02.conbas/99.misc/06.mimetypes.html#mimetypes-gui"><span class="std std-ref">aplicaciones predeterminadas en entorno GUI</span></a> y se siguen
sus instrucciones, para la cual necesitaremos crear primero un archivo
<code class="file docutils literal notranslate"><span class="pre">spicy.desktop</span></code> en <code class="file docutils literal notranslate"><span class="pre">~/.local/share/applications</span></code> con este
contenido:</p>
<div class="highlight-ini notranslate"><div class="highlight"><pre><span></span><span class="k">[Desktop Entry]</span>
<span class="na">Comment</span><span class="o">=</span><span class="s">Cliente spice</span>
<span class="na">Type</span><span class="o">=</span><span class="s">Application</span>
<span class="na">Exec</span><span class="o">=</span><span class="s">spicy --uri=%u</span>
<span class="na">Name</span><span class="o">=</span><span class="s">spicy</span>
<span class="na">MimeType</span><span class="o">=</span><span class="s">x-scheme-handler/spice+unix</span>
</pre></div>
</div>
<p>En el <strong>huésped</strong>, por su parte, hay también tareas que hacer:</p>
<ol class="arabic">
<li><p>El entorno gráfico del cliente debe usar el driver <abbr title="Qemu X Library">QXL</abbr>
(si el cliente es un sistema <em>Debian</em>, tendrá que estár instalado el
paquete <a class="extlink-deb reference external" href="https://packages.debian.org/stable/xserver-xorg-video-qxl">xserver-xorg-video-qxl</a>)<a class="footnote-reference brackets" href="#id12" id="id6" role="doc-noteref"><span class="fn-bracket">[</span>6<span class="fn-bracket">]</span></a>.</p></li>
<li><p>Para compartir el portapapeles es necesario instalar:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp"># </span>apt<span class="w"> </span>install<span class="w"> </span>spice-vdagent
</pre></div>
</div>
<p>y comprobar que el servicio homónimo se encuentra en funcionamiento:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>systemctl<span class="w"> </span>status<span class="w"> </span>spice-vdagent
</pre></div>
</div>
</li>
</ol>
</dd>
</dl>
<p class="rubric">Notas al pie</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id7" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id1">1</a><span class="fn-bracket">]</span></span>
<p>También puede usarse la forma <code class="code docutils literal notranslate"><span class="pre">-enable-kvm</span></code></p>
</aside>
<aside class="footnote brackets" id="id8" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id2">2</a><span class="fn-bracket">]</span></span>
<p>Esta disposición de la interfaz permite tráfico <abbr title="Transmission Control Protocol">TCP</abbr> y <abbr title="User Datagram Protocol">UDP</abbr>, pero no
<abbr title="Internet Control Message Protocol">ICMP</abbr>, así que no podremos usar la orden <strong class="command">ping</strong> para comprobar
conectividades.</p>
</aside>
<aside class="footnote brackets" id="id9" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id3">3</a><span class="fn-bracket">]</span></span>
<p>Hasta hace no tanto tiempo el <em>display</em> era «sdl».</p>
</aside>
<aside class="footnote brackets" id="id10" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id4">4</a><span class="fn-bracket">]</span></span>
<p>De hecho, es muy recomendable haber instalado el <a class="reference internal" href="../../../../../../04.servidor/10.ssh/01.basico.html#ssh-inst"><span class="std std-ref">servicio SSH</span></a> y acceder de este modo a él.</p>
</aside>
<aside class="footnote brackets" id="id11" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id5">5</a><span class="fn-bracket">]</span></span>
<p><strong class="command">remove-viewer</strong>, el cliente incluido en <a class="extlink-deb reference external" href="https://packages.debian.org/stable/virt-viewer">virt-viewer</a> sí lo
tiene por lo que su mera instalación dejará convenientemente preparado el
anfitrión.</p>
</aside>
<aside class="footnote brackets" id="id12" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id6">6</a><span class="fn-bracket">]</span></span>
<p>Esto debería ocurrir con que estuviera disponible el paquete, pero si no
es así, puede forzarse <a class="reference external" href="https://www.admin-magazine.com/Archive/2013/13/Controlling-virtual-machines-with-VNC-and-Spice/(offset)/6">manipulando la configuración del servidor X</a>.
Es ese mismo enlace hay información sobre cómo instalarlo en sistemas
<em>Windows</em>.</p>
</aside>
</aside>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
  <div>
    <h3><a href="../../../../../../index.html">Tabla de contenido</a></h3>
    <ul>
<li><a class="reference internal" href="#">9.2.2.1.2.1.2. Ejecución de máquinas</a><ul>
<li><a class="reference internal" href="#basica">9.2.2.1.2.1.2.1. Básica</a></li>
<li><a class="reference internal" href="#discos">9.2.2.1.2.1.2.2. Discos</a></li>
<li><a class="reference internal" href="#salida-de-video">9.2.2.1.2.1.2.3. Salida de vídeo</a></li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>Tema anterior</h4>
    <p class="topless"><a href="01.discos.html"
                          title="capítulo anterior"><span class="section-number">9.2.2.1.2.1.1. </span>Gestión de discos</a></p>
  </div>
  <div>
    <h4>Próximo tema</h4>
    <p class="topless"><a href="03.red.html"
                          title="próximo capítulo"><span class="section-number">9.2.2.1.2.1.3. </span>Red</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>Esta página</h3>
    <ul class="this-page-menu">
      <li><a href="../../../../../../_sources/98.apendice/05.virtual/02.software/01.completa/02.kvm/01.qemu/02.arranque.rst.txt"
            rel="nofollow">Mostrar el código</a></li>
    </ul>
   </div>
<search id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Búsqueda rápida</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Ir a" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="Related">
      <h3>Navegación</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../../../../genindex.html" title="Índice General"
             >índice</a></li>
        <li class="right" >
          <a href="03.red.html" title="9.2.2.1.2.1.3. Red"
             >siguiente</a> |</li>
        <li class="right" >
          <a href="01.discos.html" title="9.2.2.1.2.1.1. Gestión de discos"
             >anterior</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../../../../index.html">documentación de Linuxnomicón - rolling</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../../../../index.html" ><span class="section-number">9. </span>Apéndices</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="../../../../index.html" ><span class="section-number">9.2. </span>Virtualización</a> &#187;</li>
          <li class="nav-item nav-item-3"><a href="../../../../02.software.html" ><span class="section-number">9.2.2. </span>Software de virtualización</a> &#187;</li>
          <li class="nav-item nav-item-4"><a href="../../02.kvm.html" ><span class="section-number">9.2.2.1.2. </span><abbr title="Kernel-based Virtual Machine">KVM</abbr></a> &#187;</li>
        <li class="nav-item nav-item-this"><a href=""><span class="section-number">9.2.2.1.2.1.2. </span>Ejecución de máquinas</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
    &#169; Copyright CC BY 4.0, 2016-2024, José Miguel Sánchez Alés.
      Creado usando <a href="https://www.sphinx-doc.org/">Sphinx</a> 7.4.7.
    </div>
  </body>
</html>