


<!DOCTYPE html>

<html lang="es">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>2.2.2. Ficheros y directorios &#8212; documentación de Linuxnomicón - rolling</title>
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
    
    <script id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/translations.js"></script>
    
    <link rel="index" title="Índice" href="../../genindex.html" />
    <link rel="search" title="Búsqueda" href="../../search.html" />
    <link rel="next" title="2.2.3. Dispositivos" href="04.devices.html" />
    <link rel="prev" title="2.2.1. El sistema de archivos" href="01.filesystem.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navegación</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="Índice General"
             accesskey="I">índice</a></li>
        <li class="right" >
          <a href="04.devices.html" title="2.2.3. Dispositivos"
             accesskey="N">siguiente</a> |</li>
        <li class="right" >
          <a href="01.filesystem.html" title="2.2.1. El sistema de archivos"
             accesskey="P">anterior</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">documentación de Linuxnomicón - rolling</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" ><span class="section-number">2. </span>Conceptos básicos</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="index.html" accesskey="U"><span class="section-number">2.2. </span>Acceso a la información</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href=""><span class="section-number">2.2.2. </span>Ficheros y directorios</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="ficheros-y-directorios">
<span id="fic-dir"></span><h1><span class="section-number">2.2.2. </span>Ficheros y directorios<a class="headerlink" href="#ficheros-y-directorios" title="Enlazar permanentemente con este título">¶</a></h1>
<div class="section" id="bicheando">
<h2><span class="section-number">2.2.2.1. </span>Bicheando<a class="headerlink" href="#bicheando" title="Enlazar permanentemente con este título">¶</a></h2>
<div class="section" id="dentro-de-directorios">
<h3><span class="section-number">2.2.2.1.1. </span>… dentro de directorios<a class="headerlink" href="#dentro-de-directorios" title="Enlazar permanentemente con este título">¶</a></h3>
<p>Nuestra intención ahora es echarle un vistazo a los comandos que nos permiten
tanto comprobar cuál es el contenido de un fichero como comprobar cuál es el
contenido de un directorio.</p>
<p>Por supuesto, para hacer referencia a ficheros y directorios es indispensable
conocer <a class="reference external" href="rutas">cómo referirse a ellos</a>.</p>
<span class="target" id="pwd"></span><dl id="index-0">
<dt><em class="manpage"><a class="manpage reference external" href="https://manpages.debian.org/pwd">pwd</a></em></dt><dd><p>Nos permite conocer en qué directorio estamos:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> <span class="nb">pwd</span>
<span class="go">/home/usuario</span>
</pre></div>
</div>
</dd>
</dl>
<span class="target" id="ls"></span><dl id="index-1">
<dt><em class="manpage"><a class="manpage reference external" href="https://manpages.debian.org/ls">ls</a></em></dt><dd><p>El comando fundamental para ver el contenido de un directorio es <strong class="command">ls</strong>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">ls [opciones] [&lt;nombre1&gt; [&lt;nombre2&gt; ...]]</span>
</pre></div>
</div>
<p>Su sintaxis permite añadir opciones (muchísimas) y el directorio (también
fichero que queremos consultar). Pueden incluirse varios y en ese caso se
mostrarán todos ellos. Por ejemplo:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> ls /sbin
</pre></div>
</div>
<p>Mostrará el contenido del directorio <code class="file docutils literal notranslate"><span class="pre">/sbin</span></code>. Al ser un directorio es
posible también acabar el nombre con la barra:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> ls /sbin/
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>Dependiendo del contexto (o sea, del programa que estemos ejecutando) será
o no indiferente rematar el nombre del directorio con la barra. En el caso
de <strong class="command">ls</strong>, sólo hay diferencia cuando el fichero es un <a class="reference internal" href="#symlink"><span class="std std-ref">enlace
simbólico</span></a> que apunta a un directorio: si se añade la barra,
se mostrará el contenido del directorio apuntado; y si no se añade, el
propio enlace simbólico.</p>
</div>
<p>También se puede usar <strong class="command">ls</strong> con un fichero:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> ls /bin/cp
<span class="go">/bin/cp</span>
</pre></div>
</div>
<p>En este caso, se muestra el nombre del fichero con lo que, usado así y si no se
usan comodines o expandibles, no tiene más utilidad que saber si el fichero
existe. Una opción que le da sentido a <em>mirar</em> un fichero con <strong class="command">ls</strong> es
<code class="docutils literal notranslate"><span class="pre">-l</span></code>, que permite obtener cierta información del fichero o directorio que se
consulte:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> ls -l /bin/cp
<span class="go">-rwxr-xr-x 1 root root 124932 ene 14  2015 /bin/cp</span>
</pre></div>
</div>
<p>Para cada fichero que consultemos, <strong class="command">ls</strong> nos devuelve:</p>
<ul>
<li><p>El <strong>tipo</strong> de fichero, representado por el primer carácter:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 15%" />
<col style="width: 85%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Carácter</p></th>
<th class="head"><p>Tipo de fichero</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>-</p></td>
<td><p>Fichero regular</p></td>
</tr>
<tr class="row-odd"><td><p>d</p></td>
<td><p>Directorio</p></td>
</tr>
<tr class="row-even"><td><p>l</p></td>
<td><p><a class="reference internal" href="#symlink"><span class="std std-ref">Enlace simbólico</span></a></p></td>
</tr>
<tr class="row-odd"><td><p>p</p></td>
<td><p><a class="reference internal" href="../08.redirecciones/01basica.html#pipeline"><span class="std std-ref">Tubería</span></a></p></td>
</tr>
<tr class="row-even"><td><p>b</p></td>
<td><p><a class="reference internal" href="04.devices.html#blockdevice"><span class="std std-ref">Dispositivo de bloques</span></a></p></td>
</tr>
<tr class="row-odd"><td><p>c</p></td>
<td><p><a class="reference internal" href="04.devices.html#chardevice"><span class="std std-ref">Dispositivo de caracteres</span></a></p></td>
</tr>
<tr class="row-even"><td><p>s</p></td>
<td><p>Socket</p></td>
</tr>
</tbody>
</table>
</li>
<li><p>Los nueve siguientes caracteres representan los <a class="reference internal" href="../05.seguridad/05b.permisos.html#ugo"><span class="std std-ref">permisos</span></a>,
que se tratarán más adelante.</p></li>
<li><p>El siguiente campo, que es un número, representa el número de
<strong>referencias</strong> al fichero en el sistema de ficheros. Para entender esto,
tomemos primero un fichero vacío (que podemos crear con <a class="reference internal" href="#touch">touch</a>):</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> touch vacio
<span class="gp">$</span> ls -l vacio
<span class="go">-rw-rw-r-- 1 usuario usuario 0 oct 14 10:02 vacio</span>
</pre></div>
</div>
<p>Este fichero recién creado ocupará un espacio físico en disco y sólo tiene
una referencia en el sistema de ficheros: a través del nombre <em>vacío</em>.
Consecuentemente el número de enlaces es <em>1</em>. Sin embargo, en los sistemas
unix existen los llamados <a class="reference internal" href="#hardlink"><span class="std std-ref">enlaces duros</span></a>, que permiten
asociar ese mismo espacio de disco a otro nombre (véanse <a class="reference internal" href="#ln"><span class="std std-ref">ln</span></a> o
<a class="reference internal" href="#cp">cp</a> más adelante):</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> ln vacio mismo.vacio
<span class="gp">$</span> ls *vacio -l
<span class="go">-rw-rw-r-- 2 profesor profesor 0 oct 14 10:02 mismo.vacio</span>
<span class="go">-rw-rw-r-- 2 profesor profesor 0 oct 14 10:02 vacio</span>
</pre></div>
</div>
<p>Ahora hay dos nombres refiriéndose al mismo espacio. Por tanto, aparece un
<em>2</em>.</p>
<p>En el caso de los directorios, el concepto es el mismo (referencias al
propio directorio), aunque no está asociado al concepto de enlaces duros.
En principio, al crear un directorio:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> mkdir directorio
</pre></div>
</div>
<p>hay dos referencias a él: la referencia a él que se hace en el directorio
raíz:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> ls -d directorio
<span class="go">directorio</span>
</pre></div>
</div>
<p>y la referencia a él que hace él mismo (el punto <strong>.</strong>):</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> ls -a directorio
<span class="go">. ..</span>
</pre></div>
</div>
<p>Consecuentemente, al crearse un directorio habrá dos referencias a él:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> ls -ld directorio
<span class="go">drwxrwxr-x 2 usuario usuario 4096 oct 14 12:38 directorio</span>
</pre></div>
</div>
<p>Y cada vez que creemos un subdirectorio, se generará otra referencia:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> mkdir directorio/subdirectorio
<span class="gp">$</span> ls directorio/subdirectorio
<span class="go">. ..</span>
</pre></div>
</div>
<p>En este caso, los dos puntos (<strong>..</strong>) de <code class="file docutils literal notranslate"><span class="pre">directorio/subdirectorio</span></code>,
al referirse a su directorio padre, se refieren a <code class="file docutils literal notranslate"><span class="pre">directorio</span></code>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> ls -d directorio
<span class="go">drwxrwxr-x 3 usuario usuario 4096 oct 14 12:38 directorio</span>
</pre></div>
</div>
<p>En cambio, crear un nuevo fichero dentro del directorio no provoca ninguna
referencia:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> touch directorio/otro.vacio.mas
<span class="gp">$</span> ls -d directorio
<span class="go">drwxrwxr-x 3 usuario usuario 4096 oct 14 12:38 directorio</span>
</pre></div>
</div>
<p>En conclusión, el número representa:</p>
<ul class="simple">
<li><p>Para <em>ficheros</em>, representa el número de enlaces (duros) al propio
fichero.</p></li>
<li><p>Para <em>directorios</em>, el número de subdirectorios que contiene más 2.</p></li>
</ul>
</li>
<li><p>Los dos siguientes campos son el <strong>usuario propietario</strong> y el <strong>grupo
propietario</strong>, cuya explicación diferiremos hasta explicar los <a class="reference external" href="Permisos">permisos</a></p></li>
<li><p>El número que se muestra a continuación es el <strong>tamaño</strong>.</p></li>
<li><p>El siguiente dato es la <strong>fecha</strong> de modificación.</p></li>
<li><p>El último campo el <strong>nombre</strong> del fichero.</p></li>
</ul>
<p>Otra opción útil es <code class="docutils literal notranslate"><span class="pre">-d</span></code>. El comportamiento de <strong class="command">ls</strong> es mostrar el
propio fichero, si es un fichero; o el contenido del directorio, si es un
directorio. Esta opción permite ver el propio directorio, y no su contenido y
puede ser útil si lo que buscamos es conocer información sobre él (permisos o
propietarios, por ejemplo):</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> ls -ld /
<span class="go">drwxr-xr-x 22 root root 4096 jul 21  2015 /</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">-l</span></code> muestra el tamaño en <em>bytes</em>, lo cual es engorroso cuando el tamaño es
grande. Para paliar esto, existe la opción <code class="docutils literal notranslate"><span class="pre">-h</span></code>, que representa el tamaño en
las unidades más adecuadas:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> ls -lh Documentos
<span class="go">-rw-rw-r-- 1 usuario usuario  473K jun 24 09:11 BOJA1.pdf</span>
<span class="go">-rw-rw-r-- 1 usuario usuario  2,6M oct  6 12:50 CuadranteFotos.pdf</span>
<span class="go">-rw-rw-r-- 1 usuario usuario   30K oct  5 17:53 Distribucion.pdf</span>
</pre></div>
</div>
<p>Por defecto, <strong class="command">ls</strong> ordena los ficheros alfabéticamente, pero en
ocasiones puede resultarnos útil otro tipo de ordenación:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">-r</span></code> invierte el orden.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">-t</span></code> ordena de más reciente a más antiguo. Es obvio, que si se quieren
ver los más recientes al final del listado, puede usarse <kbd class="kbd docutils literal notranslate">-tr</kbd>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">-X</span></code> ordena alfabéticamente según la extensión.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">-S</span></code> ordena por tamaño de mayor a menor.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">group-directories-first</span></code> muestra antes los directorios que los ficheros.</p></li>
</ul>
</dd>
</dl>
<span class="target" id="stat"></span><dl id="index-2">
<dt><em class="manpage"><a class="manpage reference external" href="https://manpages.debian.org/stat(1)">stat(1)</a></em></dt><dd><p>Además de <kbd class="kbd compound docutils literal notranslate"><kbd class="kbd docutils literal notranslate">ls</kbd> <kbd class="kbd docutils literal notranslate"></kbd>-<kbd class="kbd docutils literal notranslate">l</kbd></kbd> otro modo de obtener información sobre ficheros es el
comando <strong class="command">stat</strong>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> stat .
<span class="go">Fichero: «.»</span>
<span class="go">   Tamaño: 4096       Bloques: 8          Bloque E/S: 4096   directorio</span>
<span class="go">   Dispositivo: 801h/2049d Nodo-i: 524290      Enlaces: 36</span>
<span class="go">Acceso: (0755/drwxr-xr-x)  Uid: ( 1000/ usuario)   Gid: ( 1000/ usuario)</span>
<span class="go">Acceso: 2016-10-14 13:32:41.571887432 +0200</span>
<span class="go">Modificación: 2016-10-14 13:36:51.769082058 +0200</span>
<span class="go">      Cambio: 2016-10-14 13:36:51.769082058 +0200</span>
<span class="go">    Creación: -</span>
</pre></div>
</div>
<p>Este comando es más prolijo que la opción <code class="docutils literal notranslate"><span class="pre">-l</span></code> de <strong class="command">ls</strong> y entre otras
cosas ofrece cuatro fechas distintas:</p>
<ul class="simple">
<li><p>La fecha de <em>modificación</em> que indica el último momento en que se modificó
el contenido de un fichero.</p></li>
<li><p>La fecha de <em>acceso</em> que indica el último momento en que se accedió (leyó)
el fichero. Esta es la teoría, porque en la práctica hacer registro en el
disco duro cada vez que se accedió a un fichero o directorio provoca que
baje mucho el rendimiento del sistema, así que lo habitual es que linux
monte los sistemas de ficheros con la opción <em>noatime</em>, para que la fecha
de acceso sólo se actualice o una vez al día o cuando se modifica el
fichero.</p></li>
<li><p>La fecha de <em>cambio</em> que indica el último momento en que se cambiaron los
atributos de un fichero (propietarios, permisos, etc.).</p></li>
<li><p>La fecha de <em>creación</em> que indica el momento en que se creó el fichero. En
este caso, el sistema de ficheros es capaz de almacenarlo, pero los
sistemas unix no hacen uso de esta fecha, de modo que siempre la veremos
vacía.</p></li>
</ul>
<p>Una opción interesante de <strong class="command">stat</strong> es <code class="docutils literal notranslate"><span class="pre">-c</span></code> que permite indicar el
formato de salida del resultado de la consulta. Para expresar este formato cada
propiedad se representa de la forma <code class="docutils literal notranslate"><span class="pre">%&lt;letra&gt;</span></code>. Por ejemplo, <code class="docutils literal notranslate"><span class="pre">%U</span></code>
representa el nombre del propietario y <code class="docutils literal notranslate"><span class="pre">%u</span></code>, uid del propietario. Así pues:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> stat -c <span class="s2">&quot;%U/%u&quot;</span> fichero
<span class="go">usuario/1000</span>
</pre></div>
</div>
<p>En la página del manual se desglosan las letras que corresponden a cada
propiedad.</p>
</dd>
</dl>
<span class="target" id="tree"></span><dl id="index-3">
<dt><em class="manpage"><a class="manpage reference external" href="https://manpages.debian.org/tree">tree</a></em></dt><dd><p>Muestra los contenidos de un directorio en forma arborescente:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">tree [&lt;opciones&gt;] [&lt;directorio&gt;]</span>
</pre></div>
</div>
<p>El directorio que se indica como argumento es aquel del que se desean mostrar
los contenidos. Si no se indica se sobrentiende el directorio actual. Dispone
de muchas opciones. Algunas interesantes son:</p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">-d</span></code></dt><dd><p>Sólo muestra directorios y no ficheros.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">-L</span></code></dt><dd><p>Nivel de profundidad. <strong class="command">tree</strong> es recursivo, así que muestra los
directorios y los directorios de los directorios y así sucesivamente hasta
que ya no quedan directorios que mostrar. Con esta opción podemos indicar
en qué nivel parar. Por ejemplo:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> tree -dL <span class="m">1</span> /
</pre></div>
</div>
<p>Sólo nos mostrará los subdirectorios del directorio raíz, sin profundizar
más.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">-a</span></code></dt><dd><p>Como la opción de <a class="reference internal" href="#ls"><span class="std std-ref">ls</span></a>, muestra también los ficheros ocultos.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>Requiere la instalación del paquete homónimo.</p>
</div>
</dd>
</dl>
<span class="target" id="file"></span><dl id="index-4">
<dt><em class="manpage"><a class="manpage reference external" href="https://manpages.debian.org/file">file</a></em></dt><dd><p>Por lo general, las extensiones se usan para saber de qué tipo es un fichero,
pero no tienen por qué haber sido bien elegidas. <strong class="command">file</strong> es un comando
que intenta averiguar de qué tipo es, basándose en su contenido:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> file primera_carlista.mp4
<span class="go">primera_carlista.mp4: ISO Media, MP4 Base Media v1 [IS0 14496-12:2003]</span>
</pre></div>
</div>
<p>Si se usa la opción <kbd class="kbd docutils literal notranslate">-i</kbd>, devuelve el tipo <em>mime</em>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> file primera_carlista.mp4
<span class="go">primera_carlista.mp4: video/mp4; charset=binary</span>
</pre></div>
</div>
</dd>
</dl>
<span class="target" id="which"></span><dl id="index-5">
<dt><em class="manpage"><a class="manpage reference external" href="https://manpages.debian.org/which">which</a></em></dt><dd><p>Dentro de los comandos que nos permiten gulismear en el árbol de directorios
está <strong class="command">which</strong>. Básicamente, busca dónde se encuentran los programas
que podemos ejecutar a través de la línea de comandos<a class="footnote-reference brackets" href="#id3" id="id1">1</a>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> which ls
<span class="go">/bin/ls</span>
</pre></div>
</div>
<p id="index-6">Una alternativa (que es muy útil al programar porque cumple con el estándar
<em>POSIX</em>) es:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> <span class="nb">command</span> -v ls
<span class="go">/bin/ls</span>
</pre></div>
</div>
</dd>
</dl>
<span class="target" id="whereis"></span><dl id="index-7">
<dt><em class="manpage"><a class="manpage reference external" href="https://manpages.debian.org/whereis">whereis</a></em></dt><dd><p><strong class="command">ls</strong> puede usarse para comprobar si un fichero se encuentra o no en un
directorio. Sin embargo, si no sabemos a ciencia cierta en qué directorio se
encuentra, el comando puede resultar o tedioso o, directamente, bastante inútil.
Ya se ha citado <a class="reference internal" href="#which"><span class="std std-ref">which</span></a>, pero está limitado a ejecutables. Un comando más
exhaustivo es <strong class="command">whereis</strong>, que es capaz de encontrar ejecutables, códigos
fuente y páginas del manual en los directorios en los que suelen encontrarse:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> whereis ls
<span class="go">ls: /bin/ls /usr/share/man/man1/ls.1.gz</span>
</pre></div>
</div>
</dd>
</dl>
<span class="target" id="find"></span><dl id="index-8">
<dt><em class="manpage"><a class="manpage reference external" href="https://manpages.debian.org/find">find</a></em></dt><dd><p>Sin embargo, <strong class="command">whereis</strong> no es suficiente si lo que queremos es buscar un
fichero cualquiera. Para ello puede usarse el comando <strong class="command">find</strong> que
permite hacer una búsqueda bastante exhaustiva y, por tanto, tiene una ingente
cantidad de opciones.</p>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>Los argumentos de <strong class="command">find</strong> no siguen el estándar POSIX.</p>
</div>
<p>En general, la sintaxis del comando es la siguiente:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">find [-P|-H|-L] [&lt;directorio&gt;] [opciones]</span>
</pre></div>
</div>
<p>Las tras primeras opciones hacen referencia a cómo <strong class="command">find</strong> tratará los
<a class="reference internal" href="#symlink"><span class="std std-ref">enlaces simbólicos</span></a>. la predeterminada es <code class="docutils literal notranslate"><span class="pre">-P</span></code> que implica no
seguirlos.</p>
<p>El <em>directorio</em> es aquel bajo el cual <strong class="command">find</strong> buscará lo que se le
exprese con las opciones que se pasen a continuación. La búsqueda es recursiva,
de modo que <strong class="command">find</strong> buscará dentro de los subdirectorios. El orden es
importante y, de hecho, el directorio debe expresarse antes que las opciones. Si
no se indica, se sobrentiende que es el directorio actual (o sea, <kbd class="kbd docutils literal notranslate">.</kbd>).</p>
<p>Las opciones son muy variadas: algunas permiten modificar el comportamiento del
comando; otras seleccionar ficheros casi según cualquier criterio imaginable; y
otras realizar una operación (como imprimir por pantalla o borrar). El orden no
es indistinto y deben colocarse según se han enunciado: primero las de
modificación, luego las de selección y, por último, la de operación. Si no se
especifica ninguna acción, se sobreentiende que se desea imprimir (<code class="docutils literal notranslate"><span class="pre">-print</span></code>).
En este documento sólo se describirán las opciones más relevantes:</p>
<p>Opciones de <strong>modificación</strong>:</p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">-maxdepth</span> <span class="pre">&lt;N&gt;</span></code>:</dt><dd><p>Realiza la búsqueda sólo profundizando hasta el nivel <em>N</em>. Por ejemplo, un
nivel <em>1</em> buscará dentro del directorio que se haya usado como punto de
partido, pero no dentro de los subdirectorios. Esta opción debe colocarse
antes de</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">-mount</span></code>:</dt><dd><p>No busca en subdirectorios que pertenezcan a sistemas de ficheros
distintos al del directorio de punto de partida.</p>
</dd>
<dt>Opciones de <strong>selección</strong>:</dt><dd><p>Estas opciones se evalúan a verdadero o falso. Si la evaluación sobre un
fichero resulta verdadera, el fichero se seleccionará.</p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">-name</span> <span class="pre">&lt;expresion&gt;</span></code>:</dt><dd><p>permite buscar ficheros por su nombre según la expresión que se indique. Esta
expresión sigue las mismas reglas que las indicadas <a class="reference internal" href="../07.avanzada/08.interpretaciones.html#comodines"><span class="std std-ref">aquí</span></a>.
La variante <kbd class="kbd docutils literal notranslate">-iname</kbd> obra del mismo modo, pero sin tener en cuenta
mayúsculas o minúsculas.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">-path</span> <span class="pre">&lt;expresion&gt;</span></code>:</dt><dd><p>busca ficheros atendiendo a toda su ruta y no sólo al nombre. Existe
también la variante <kbd class="kbd docutils literal notranslate">ipath</kbd> para no distinguir mayúsculas de
minúsculas. En cuanto a la ruta, debe considerarse que esta se expresa
como ruta relativa al directorio que se tome como punto de partida. Por
ejemplo, si el directorio es <kbd class="kbd docutils literal notranslate">.</kbd> las rutas de todos los ficheros
encontrados empezarán por <code class="docutils literal notranslate"><span class="pre">./</span></code>; si <kbd class="kbd docutils literal notranslate">dir</kbd>, todas empezarán por
<code class="docutils literal notranslate"><span class="pre">dir/</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">-regex</span> <span class="pre">&lt;expresion_regular&gt;</span></code>:</dt><dd><p>Como <kbd class="kbd docutils literal notranslate">-path</kbd> pero la expresión se evaluará como una <a class="reference internal" href="../10.texto/01.regex.html#regex"><span class="std std-ref">expresión regular</span></a>. <kbd class="kbd docutils literal notranslate">iregex</kbd> cumple la misma función pero sin distinguir
mayúsculas de minúsculas. Relacionada con estas dos expresiones existe la
opción <kbd class="kbd docutils literal notranslate">-regexptype</kbd>, que permite indicar qué tipo de expresiones
regulares se usarán. Para saber qué tipos estan soportados puede hacerse lo
siguiente:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> find -regextype <span class="nb">help</span>
</pre></div>
</div>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">-type</span> <span class="pre">f|d|l|p|b|c|s</span></code>:</dt><dd><p>restringe la búsqueda al tipo de fichero indicado. El carácter es el mismo
que el que muestra la opción <code class="docutils literal notranslate"><span class="pre">-l</span></code> de <a class="reference internal" href="#ls">ls</a>, excepto en el caso de los
ficheros regulares que se usa la <kbd class="kbd docutils literal notranslate">f</kbd> en vez del guión.`</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">-samefile</span> <span class="pre">&lt;fichero&gt;</span></code>:</dt><dd><p>busca los otros <a class="reference internal" href="#hardlink"><span class="std std-ref">enlaces duros</span></a> del fichero indicado.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">-empty</span></code>:</dt><dd><p>el fichero (o directorio) está vacío.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">-mtime</span> <span class="pre">&lt;n&gt;</span></code>:</dt><dd><p>el fichero se modificó hace <em>n</em> días. Si se hace negativo el número,
significa hace menos de <em>n</em> días; y, si incluye un signo <em>+</em> explícito,
hace más de <em>n</em> días. Las opciones <code class="docutils literal notranslate"><span class="pre">-atime</span></code> y <code class="docutils literal notranslate"><span class="pre">-ctime</span></code> sirven para lo
mismo pero usando las fechas de acceso y cambio.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">-newer</span> <span class="pre">&lt;fichero&gt;</span></code>:</dt><dd><p>busca los ficheros modificados después del fichero de referencia
proporcionado como argumento. <code class="docutils literal notranslate"><span class="pre">anewer</span></code> y <code class="docutils literal notranslate"><span class="pre">cnewer</span></code> sirven para lo
mismo, pero usando las fechas de acceso y cambio.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">-group</span> <span class="pre">&lt;grupo&gt;</span></code>:</dt><dd><p>busca ficheros cuyo grupo propietario sea el indicado (puede usarse el
nombre o el <em>gid</em>).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">-user</span> <span class="pre">&lt;usuario&gt;</span></code>:</dt><dd><p>busca ficheros propiedad del usuario indicado (puede usarse el usuario o
el <em>uid</em>).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">-links</span> <span class="pre">&lt;n&gt;</span></code>:</dt><dd><p>busca ficheros que tengan <em>n</em> enlaces. Pueden usarse los signos <em>-</em> y <em>+</em>
con el mismo significado que para <kbd class="kbd docutils literal notranslate">mtime</kbd>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">-size</span> <span class="pre">&lt;n&gt;&lt;unidad&gt;</span></code>:</dt><dd><p>busca ficheros de un tamaño determinado. En cuanto a la cantidad pueden
usarse los signos <em>-</em> y <em>+</em> para indicar menor y mayor como en otros
casos. En cuanto a la unidad se pueden indicar:</p>
<ul class="simple">
<li><p><strong>b</strong>, bloques de 512 <em>bytes</em>.</p></li>
<li><p><strong>c</strong>, <em>bytes</em>.</p></li>
<li><p><strong>k</strong>, <em>kilobytes</em>.</p></li>
<li><p><strong>M</strong>, <em>megabytes</em>.</p></li>
<li><p><strong>G</strong>, <em>gigabytes</em>.</p></li>
</ul>
</dd>
</dl>
</dd>
<dt>Opciones de <strong>operación</strong>:</dt><dd><p>Pueden indicarse varias operaciones que se ejecutarán una detrás de otra.</p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">-print</span></code>:</dt><dd><p>imprime en pantalla los ficheros seleccionados, uno por línea. Hay
variantes de esta opción, pero hay una indispensable en ciertos casos que
es <kbd class="kbd docutils literal notranslate">print0</kbd> que imprime de modo que el carácter que separa un fichero
de otro es el carácter nulo.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">-delete</span></code>:</dt><dd><p>borra el fichero indicado. Si el fichero es un directorio, debe estar
vacío.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">-exec</span> <span class="pre">&lt;comando&gt;</span> <span class="pre">'{}'</span> <span class="pre">+</span></code>:</dt><dd><p>ejecuta el comando indicado sobre los ficheros seleccionados. El “{}” representa
tales ficheros que se usaran como argumentos para comando.  Al incluir
el signo <code class="docutils literal notranslate"><span class="pre">+</span></code>, no se ejecuta un comando por cada fichero, sino que se
procura ejecutar el comando incluyendo el mayor número de ficheros
posibles en cada invocación. Por ejemplo:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> print . -type f -exec file -i <span class="s1">&#39;{}&#39;</span> +
<span class="go">./hola2:         inode/x-empty; charset=binary</span>
<span class="go">./a 1:           inode/x-empty; charset=binary</span>
<span class="go">./tmux.txt:      text/x-fortran; charset=utf-8</span>
<span class="go">./hola:          inode/x-empty; charset=binary</span>
</pre></div>
</div>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">-ok</span> <span class="pre">&lt;command&gt;</span> <span class="pre">'{}'</span> <span class="pre">\;</span></code>:</dt><dd><p>ejecuta el comando para cada uno de los ficheros seleccionados, pero
pregunta antes si se quiere efectuar cada operación o no. Existe también
una versión de <code class="docutils literal notranslate"><span class="pre">-exec</span></code> que remata en punto y coma, pero por ser menos
eficiente que la referida, se ha callado.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">-prune</span></code>:</dt><dd><p>no hace nada en especial más que impedir que <strong class="command">find</strong> descienda si
el fichero seleccionado es un directorio. Puede usarse para evitar revisar
los contenidos de un fichero.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">-quit</span></code>:</dt><dd><p>sale inmediatamente de <strong class="command">find</strong></p>
</dd>
</dl>
</dd>
</dl>
<p>Faltan opciones, pero con las indicadas hay materia para entretenerse. Aún queda
por explicar los operadores, pero antes es útil ilustrar con algunos ejemplos el
uso:</p>
<ol class="arabic">
<li><p>Buscar todos los ficheros <code class="docutils literal notranslate"><span class="pre">.pdf</span></code> bajo el directorio de trabajo:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> find -iname <span class="s1">&#39;*.pdf&#39;</span>
</pre></div>
</div>
<p>Como no se especifica acción alguna, se sobreentiende <code class="docutils literal notranslate"><span class="pre">-print</span></code>.</p>
</li>
<li><p>Lo mismo, pero especificando que se buscan ficheros regulares y no
cualquier otra cosa (enlaces simbólicos, por ejemplo):</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> find -type f -iname <span class="s1">&#39;*.pdf&#39;</span>
</pre></div>
</div>
</li>
<li><p>Buscar un fichero llamado <code class="file docutils literal notranslate"><span class="pre">deseable.txt</span></code> bajo el directorio de
trabajo y para la búsqueda nada más encontrarlo:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> find -type f -name <span class="s1">&#39;deseable.txt&#39;</span> -print -quit
</pre></div>
</div>
<p>En este caso, para cada fichero encontrado, primero se imprime y luego se
acaba la ejecución. Por tanto, nada más encontrar e imprimir el primer
fichero, se dejará de buscar. Puede ser útil si sabemos de antemano que el
fichero es único.</p>
</li>
<li><p>Muestra el tipo de los ficheros del directorio actual:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> find -maxdepth <span class="m">1</span> -type f -exec file <span class="s1">&#39;{}&#39;</span> +
</pre></div>
</div>
</li>
<li><p>Borra los ficheros vacíos que se encuentran bajo el directorio actual:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> find -type f -empty -delete
</pre></div>
</div>
</li>
<li><p>Como en el caso anterior, pero preguntando primero:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> find -type f -empty -ok rm -f <span class="s1">&#39;{}&#39;</span> <span class="se">\;</span>
</pre></div>
</div>
</li>
<li><p>Busca bajo el directorio <code class="file docutils literal notranslate"><span class="pre">/home/store/video</span></code> los ficheros mayores a
500MB:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> find /home/store/video -type f -size +500M
</pre></div>
</div>
</li>
<li><p>Busca bajo el directorio actual los ficheros con más de un enlace:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> find -type f -links +1
</pre></div>
</div>
</li>
</ol>
<p>Estas pueden ser búsquedas útiles con <strong class="command">find</strong>, pero… <em>no se vayan
todavía, que aún hay más</em>. Si se analizan algunos ejemplos, se observará que
se han dado dos o más condiciones o incluso dos o más acciones y estas siempre
eran acumulativas:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> find -type f -empty -delete
</pre></div>
</div>
<p>En este ejemplo se buscan ficheros que sean regulares (<kbd class="kbd compound docutils literal notranslate"><kbd class="kbd docutils literal notranslate">-type</kbd> <kbd class="kbd docutils literal notranslate">f</kbd></kbd>) <strong>y</strong>
que, además, estén vacios. Es decir, que si hablamos en términos lógicos hay un
opèrador <em>and</em> implícito entre una y otra condición. También lo hay entre las
condiciones y la acción <code class="docutils literal notranslate"><span class="pre">-delete</span></code> (<em>y me lo imprimes</em>), porque las acciones,
además de hacer algo, devuelven un valor siempre verdadero.</p>
<p>Pues bien, en <strong class="command">find</strong> podemos usar los operadores <code class="docutils literal notranslate"><span class="pre">-a</span></code> (<em>and</em>), <code class="docutils literal notranslate"><span class="pre">-o</span></code>
(<em>or</em>) o <code class="docutils literal notranslate"><span class="pre">!</span></code> (<em>not</em>) y los paréntesis para agrupar. Esto convierte a
<strong class="command">find</strong> en infinitamente más poderoso. Por ejemplo:</p>
<ol class="arabic">
<li><p>Busca todos los ficheros que no estén vacíos:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> find -empty -o -print
</pre></div>
</div>
<p>La razón de que este funcione es que <strong class="command">find</strong> evalúa como
habitualmente se hace en programación cuando hay un <em>or</em>: sólo se evalua
la segunda expresión si la primera era falsa. Por tanto, si el fichero
está vacío no se hace nada, pues no hay ninguna acción indicada y ahi se
para de evaluar para el fichero en cuestión; pero si no está vacío, se
evalúa la segunda expresión y, consecuentemente, se imprime el nombre del
fichero.</p>
<p>Por supuesto esto mismo se podría haber logrado así:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> find <span class="se">\!</span> -empty -print
</pre></div>
</div>
<p>que es más immediato. pero hacerlo de otro modo ilustra mejor cómo
evalúa <strong class="command">find</strong>. En este último caso, ademäs, podemos ahorrarnos
<code class="docutils literal notranslate"><span class="pre">-print</span></code>.</p>
</li>
<li><p>Busca ficheros <code class="docutils literal notranslate"><span class="pre">.pdf</span></code> bajo el directorio actual, pero desecha los
subdirectorios que se llaman <em>backup</em>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> find -type d -name backup -prune -o -name <span class="s1">&#39;*.pdf&#39;</span> -print
</pre></div>
</div>
<p>El razonamiento es análogo al del anterior ejemplo, pero en este caso ha
sido necesario añadir <code class="docutils literal notranslate"><span class="pre">-prune</span></code>. La razón es que el hecho de que no se
imprima un directorio, no implica que no se entre en él y se revisen sus
contenidos, por lo que es necesaria la acción <code class="docutils literal notranslate"><span class="pre">-prune</span></code> para descartarlo
por completo. Antes se omitió este <code class="docutils literal notranslate"><span class="pre">-prune</span></code>, porque al concordar la
expresión con directorios vacíos, esto implica que no tengan nada dentro.</p>
</li>
<li><p>Busca ficheros regulares y enlaces simbólicos:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> find <span class="se">\(</span> -type f -o -type l <span class="se">\)</span> -print
</pre></div>
</div>
<p>Es necesario agrupar para que ambas condiciones se apliquen a la misma
acción <code class="docutils literal notranslate"><span class="pre">-print</span></code>. No incluir los paréntesis implicaría no hacer nada para
los ficheros regulares y, en caso contrario, comprobar que es un enlace
simbólico e imprimir, o sea, imprimir sólo enlaces simbólicos.</p>
</li>
</ol>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p><strong class="command">find</strong> puede ser muy útil a la hora de seleccionar ficheros de los
que se desea realizar copia de seguridad al ser mucho más versátil que las
opciones que <a class="reference internal" href="../11.backup/02.empaquetado.html#tar"><span class="std std-ref">tar</span></a> da para ello.</p>
</div>
</dd>
</dl>
<span class="target" id="du"></span><dl id="index-9">
<dt><em class="manpage"><a class="manpage reference external" href="https://manpages.debian.org/du">du</a></em></dt><dd><p>Sirve para estimar el espacio de disco que ocupan los directorios (o ficheros)
que se le pasan como argumento. Entiéndase que el espacio de ocupación que
proporciona para los directorios es el espacio que ocupan todos sus
contenidos. Por defecto, desglosa el espacio de cada uno de los
subdirectorios que se encuentra, así que por lo general es usarlo con la
opción <code class="docutils literal notranslate"><span class="pre">-s</span></code> que devuelve solamente el espacio ocupado por el fichero que se
le ha dado como argumento. Además dispone de una opción <code class="docutils literal notranslate"><span class="pre">-h</span></code> que se
comporta como la de <code class="docutils literal notranslate"><span class="pre">ls</span></code>. Por tanto:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> du -hs ~
<span class="go">3,4G  /home/josem</span>
</pre></div>
</div>
<p>Nos devolverá el espacio total ocupado por nuestro directorio personal. Es
útil añadir la opción <code class="docutils literal notranslate"><span class="pre">-x</span></code> que no tiene en cuenta los subdirectorios que
monten otros sistemas de ficheros.</p>
</dd>
</dl>
</div>
<div class="section" id="y-dentro-de-ficheros">
<h3><span class="section-number">2.2.2.1.2. </span>… y dentro de ficheros<a class="headerlink" href="#y-dentro-de-ficheros" title="Enlazar permanentemente con este título">¶</a></h3>
<span class="target" id="cat"></span><dl id="index-10">
<dt><em class="manpage"><a class="manpage reference external" href="https://manpages.debian.org/cat">cat</a></em></dt><dd><p>El comando más simple que permite consultar el contenido de un fichero es
<strong class="command">cat</strong>: simplemente escupe por pantalla, carácter a carácter, el
contenido. Si el fichero es <em>texto plano</em> podremos leerlo, si es un fichero
binario veremos caracteres ininteligibles y, si nuestra intención era echar un
vistazo, habrá servidor de poco:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> cat saludo.txt
<span class="go">Hola</span>
</pre></div>
</div>
<p>Suponiendo que hubiéramos escrito previamente un fichero que contuviera
únicamente la palabra <em>Hola</em>. Si se escriben dos o más ficheros como argumento,
<strong class="command">cat</strong> los concatena:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> cat saludo.txt despedida.txt
<span class="go">Hola</span>
<span class="go">Adiós</span>
</pre></div>
</div>
<p>Es posible también usarlo sin indicar fichero alguno: en este caso recibirá los
datos a través de la entrada estándar (véase <a class="reference internal" href="../08.redirecciones/index.html#ioredirect"><span class="std std-ref">redirecciones</span></a>).</p>
<p>De entre sus opciones, es útil a veces <code class="docutils literal notranslate"><span class="pre">-n</span></code>, que numera las líneas al
mostrarlas.</p>
</dd>
</dl>
<span class="target" id="more"></span><dl id="index-11">
<dt><em class="manpage"><a class="manpage reference external" href="https://manpages.debian.org/more">more</a></em></dt><dd><p>Sin embargo, <strong class="command">cat</strong> tiene el inconveniente de mostrar el fichero de una
sola tacada, por lo que si el fichero es largo se escapará por la parte superior
de la pantalla. Para remediarlo, puede usarse <strong class="command">more</strong> que es un
paginador que al llenarse la pantalla hará una pausa:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> more fichero_larguisimo
</pre></div>
</div>
<p>Al llenar la pantalla, el programa quedará esperando a que pulsemos <kbd class="kbd docutils literal notranslate">Enter</kbd>
(avancar una línea) o <kbd class="kbd docutils literal notranslate">Espacio</kbd> (avanzar una pantalla). También puede
escribirse una barra (<kbd class="kbd docutils literal notranslate">/</kbd>) seguida de una <a class="reference internal" href="../10.texto/01.regex.html#regex"><span class="std std-ref">expresión regular</span></a>
para buscar la primera ocurrencia que concuerde con dicha expresión,</p>
<p>Se saldrá del programa al acabarse el fichero o al pulsarse <kbd class="kbd docutils literal notranslate">q</kbd>.</p>
</dd>
</dl>
<span class="target" id="less"></span><dl id="index-12">
<dt><em class="manpage"><a class="manpage reference external" href="https://manpages.debian.org/less">less</a></em></dt><dd><p>Como con <strong class="command">more</strong> sólo podemos avanzar, pero no retroceder, existe
<cite>less</cite>. Tiene un uso semejante, con la diferencia de que hay teclas para ir
hacia atrás. Consúltese la página del manual.</p>
<p>Tanto <strong class="command">cat</strong>, como <strong class="command">more</strong>, como <strong class="command">less</strong> suelen tener
ejecutables equivalentes para mostrar ficheros que hayan sido comprimidos sin
necesidad de descomprimirlos previamente:</p>
<span class="target" id="index-13"></span><span class="target" id="index-14"></span><ul class="simple" id="index-15">
<li><p><strong class="command">zcat</strong>, <strong class="command">zmore</strong> y <strong class="command">zless</strong> para comprimidos con
<strong class="program">gzip</strong> (extensión <code class="docutils literal notranslate"><span class="pre">.gz</span></code>).</p></li>
</ul>
<span class="target" id="index-16"></span><span class="target" id="index-17"></span><ul class="simple" id="index-18">
<li><p><strong class="command">bzcat</strong>, <strong class="command">bzmore</strong> y <strong class="command">bzless</strong> para comprimidos con
<strong class="program">bzip2</strong> (extensión <code class="docutils literal notranslate"><span class="pre">.bz</span></code> o <code class="docutils literal notranslate"><span class="pre">.bzip2</span></code>).</p></li>
</ul>
<span class="target" id="index-19"></span><span class="target" id="index-20"></span><ul class="simple" id="index-21">
<li><p><strong class="command">xzcat</strong>, <strong class="command">xzmore</strong> y <strong class="command">xzless</strong> para comprimidos con
<strong class="program">xz</strong> (extensión <code class="docutils literal notranslate"><span class="pre">.xz</span></code>).</p></li>
</ul>
</dd>
</dl>
<span class="target" id="head"></span><dl id="index-22">
<dt><em class="manpage"><a class="manpage reference external" href="https://manpages.debian.org/head">head</a></em></dt><dd><p>Cuando no se quiere inspeccionar todo el fichero sino sólo su comienzo, es útil
el comando <strong class="command">head</strong>, que permite indicar cuáles de las primeras líneas de
un texto se desean mostrar:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> head /etc/passwd
</pre></div>
</div>
<p>Si no se especifica nada, se muestran 10 líneas. Si se quiere mostrar un número
distinto es posible hacerlo con la opción <code class="docutils literal notranslate"><span class="pre">-n</span></code>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> head -n20 /etc/passwd
</pre></div>
</div>
<p>El ejemplo, mostrará 20 líneas. Es posible también mostrar todas las líneas
menos las <em>n</em> últimas, haciendo negativo el argumento de <code class="docutils literal notranslate"><span class="pre">-n</span></code>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> head -n-1 /etc/passwd
</pre></div>
</div>
<p>Esto mostraría todas las líneas menos la última.</p>
<p>Como con los comandos anteriores, si no se indica nombre alguno de fichero, se
intenta tomar datos de la entrada estándar.</p>
</dd>
</dl>
<span class="target" id="tail"></span><dl id="index-23">
<dt><em class="manpage"><a class="manpage reference external" href="https://manpages.debian.org/tail">tail</a></em></dt><dd><p>Como contrapartida a este último comand, <strong class="command">tail</strong> permite mostrar las
últimas líneas del fichero. Si no se especifica cuántas:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> tail /etc/passwd
</pre></div>
</div>
<p>mostrará las diez últimas, pero puede variarse este número usando la opción
<code class="docutils literal notranslate"><span class="pre">-n</span></code>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> tail -n15 /etc/passwd
</pre></div>
</div>
<p>Si se incluye antes del número el signo <em>+</em>, se motrará a partir de dicha
línea:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> tail -n+15 /etc/passwd
</pre></div>
</div>
<p>De nuevo, no indicar fichero implica que se quiere leer de la entrda estándar.</p>
<p><strong class="command">tail</strong>, además, admite la opción <code class="docutils literal notranslate"><span class="pre">-f</span></code>, que es muy útil cuando se
quiere monitorizar porque muestra las últimas 10 líneas del fichero (o cualquier
otro número si se usa además <code class="docutils literal notranslate"><span class="pre">-n</span></code>) y queda esperando a que el fichero se
actualice con nuevas líneas:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> tail -f /var/log/syslog
</pre></div>
</div>
</dd>
</dl>
<span class="target" id="watch"></span><dl id="index-24">
<dt><em class="manpage"><a class="manpage reference external" href="https://manpages.debian.org/watch">watch</a></em></dt><dd><p>No es un comando propiamente para ver el contenido de un fichero, sino para
refrescar cada cierto tiempo (por defecto cada dos segundos) la salida por
pantalla de una orden. Así si hacemos:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> watch -n1 <span class="s2">&quot;cat /proc/mdstat&quot;</span>
</pre></div>
</div>
<p>nos mostrará el contenido del fichero <code class="file docutils literal notranslate"><span class="pre">/proc/mdstat</span></code> (ya que eso es lo
que hace <a class="reference internal" href="#cat"><span class="std std-ref">cat</span></a>) e ira refrescando ese contenido cada segundo. Por
la misma razón:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> watch <span class="s2">&quot;ls -l /var/log&quot;</span>
</pre></div>
</div>
<p>mostrará el contenido del directorio <code class="file docutils literal notranslate"><span class="pre">/var/log</span></code> e irá refrescado cada
dos segundos la salida.</p>
</dd>
</dl>
</div>
</div>
<div class="section" id="creando-contenidos">
<h2><span class="section-number">2.2.2.2. </span>Creando contenidos<a class="headerlink" href="#creando-contenidos" title="Enlazar permanentemente con este título">¶</a></h2>
<span class="target" id="mkdir"></span><dl id="index-25">
<dt><em class="manpage"><a class="manpage reference external" href="https://manpages.debian.org/mkdir">mkdir</a></em></dt><dd><p>La acción más sencilla para alterar nuestro sistema de ficheros es crear un
nuevo directorio:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> mkdir nuevo
</pre></div>
</div>
<p>Se pueden indicar varios directorios en una misma línea:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> mkdir nuevo nuevo/dentro otro.nuevo
</pre></div>
</div>
<p>Obsérvese que para crear <code class="file docutils literal notranslate"><span class="pre">nuevo/dentro</span></code> es necesario que exista
previamente file:<cite>nuevo</cite>, de ahí el orden. Sin embargo, <strong class="command">mkdir</strong> tiene
la opción <code class="docutils literal notranslate"><span class="pre">-p</span></code> que crear un directorio, creando previamente todos los directorios
necesarios:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> mkdir -p  nuevo/dentro
</pre></div>
</div>
</dd>
</dl>
<span class="target" id="rmdir"></span><dl id="index-26">
<dt><em class="manpage"><a class="manpage reference external" href="https://manpages.debian.org/rmdir">rmdir</a></em></dt><dd><p>En contraposición, <strong class="command">rmdir</strong> elimina directorios, pero sólo si están
vacíos:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> rmdir nuevo/dentro
</pre></div>
</div>
<p>SI se usa la opción <code class="docutils literal notranslate"><span class="pre">-p</span></code> borra directorios padre, si estos se quedan vacíos:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> rmdir -p nuevo/dentro
</pre></div>
</div>
</dd>
</dl>
<span class="target" id="touch"></span><dl id="index-27">
<dt><em class="manpage"><a class="manpage reference external" href="https://manpages.debian.org/touch">touch</a></em></dt><dd><p>En general, para crear un fichero de un determinado tipo lo que debe hacerse es usar una
aplicación adecuada. Ahora bien, cuando se quiere crear un fichero vacío, muy
comúnmente se usa <strong class="command">touch</strong>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> touch estoy.vacio
<span class="gp">$</span> ls -l estoy.vacio
<span class="go">-rw-r--r-- 1 usuario usuario 0 oct 15 20:08 estoy.vacio</span>
</pre></div>
</div>
<p>En realidad, esta no es la función principal de <strong class="command">touch</strong>, sino un efecto
secundario, consecuencia de que el archivo no existe. Su tarea principal es
cambiar las fechas de un archivo: o la de modificación (<code class="docutils literal notranslate"><span class="pre">-m</span></code>) o la de acceso
(<code class="docutils literal notranslate"><span class="pre">-a</span></code>) o ambas a la vez (no incluir ninguna de las anteriores opciones).</p>
<p>Las fechas se fijan al momento en que se ejecuta el comando, a menos que se
indique una fecha distinta a través de <code class="docutils literal notranslate"><span class="pre">-t</span></code>. En todo caso, La de cambio
siempre será la del momento de la acción:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> touch -t <span class="m">200109110915</span> estoy.vacio
<span class="gp">$</span> stat estoy.vacio
<span class="go">  Fichero: «estoy.vacio»</span>
<span class="go">    Tamaño: 0             Bloques: 0          Bloque E/S: 1024   fichero</span>
<span class="go">    regular vacío</span>
<span class="go">  Dispositivo: fd02h/64770d       Nodo-i: 28          Enlaces: 1</span>
<span class="go">  Acceso: (0644/-rw-r--r--)  Uid: ( 1000/ usuario)   Gid: ( 1000/ usuario)</span>
<span class="go">        Acceso: 2001-09-11 09:15:00.000000000 +0200</span>
<span class="go">  Modificación: 2001-09-11 09:15:00.000000000 +0200</span>
<span class="go">        Cambio: 2016-10-15 20:31:07.000000000 +0200</span>
<span class="go">      Creación: -</span>
</pre></div>
</div>
</dd>
</dl>
<span class="target" id="rm"></span><dl id="index-28">
<dt><em class="manpage"><a class="manpage reference external" href="https://manpages.debian.org/rm">rm</a></em></dt><dd><p>Si, en vez de crear un fichero, queremos borrarlo, podemos usar el comando
<strong class="command">rm</strong>. Su forma más elemental de uso es indicar como argumento el
nombre del fichero a borrar:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> rm fichero_a_borrar
</pre></div>
</div>
<p>aunque pueden incluirse varios nombres en una misma orden.</p>
<p>Como por error podemos borrar un fichero sin querer, <strong class="command">rm</strong> proporciona
la opción <code class="docutils literal notranslate"><span class="pre">-i</span></code>, que pide confirmación antes de hacerlo. En oposición está <code class="docutils literal notranslate"><span class="pre">-f</span></code>,
que no lo hace. Cuando se usan ambas prevalece la última que se indicó.</p>
<p>Además, el comando sirve en principio para borrar ficheros, por lo que si se
intenta borrar un directorio, fallará. Para evitar esto, puede usarse el
comando <code class="docutils literal notranslate"><span class="pre">-r</span></code> que borrará directorios con todo su contenido:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> rm -r directorio
</pre></div>
</div>
<p>Es habitual usar <code class="docutils literal notranslate"><span class="pre">-r</span></code> junto a <code class="docutils literal notranslate"><span class="pre">-f</span></code> para evitar preguntas continuas de
confirmación, ya que la orden recursiva puede implicar muchísimos borrados.</p>
<div class="admonition warning">
<p class="admonition-title">Advertencia</p>
<p>Es sumamente aconsejable colocar <kbd class="kbd docutils literal notranslate">-rf</kbd> al final de la orden después
de haber incluido las rutas de borrado, y no antes. Eso evita que
accidentalmente pulsemos <kbd class="kbd docutils literal notranslate">Enter</kbd> antes de acabar de terminar de
escribir la ruta y borremos accidentalmente más de la cuenta.</p>
</div>
</dd>
</dl>
<span class="target" id="mv"></span><dl id="index-29">
<dt><em class="manpage"><a class="manpage reference external" href="https://manpages.debian.org/mv">mv</a></em></dt><dd><p>Otra operación habitual con ficheros (o directorios) es moverlos de lugar, para
lo cual existe el comando <strong class="command">mv</strong>. La sintaxis general es la siguiente:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> mv <span class="o">[</span>opciones<span class="o">]</span> &lt;origen&gt; &lt;destino&gt;
</pre></div>
</div>
<p>Es decir, el fichero se mueve desde un origen a un destino. El origen es el
propio fichero, mientras que el destino puede existir o no. Para entender cómo
se comporta <strong class="command">mv</strong> es mejor usar el siguiente ejemplo:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> touch fic1 fic2
<span class="gp">$</span> mkdir dir1 dir2
</pre></div>
</div>
<p>Es decir, creamos dos ficheros y dos directorios. En este caso:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> mv fic1 dir1
<span class="gp">$</span> ls dir1
<span class="go">fic1</span>
</pre></div>
</div>
<p>el destino existe y es un directorio, por lo que el efecto que movemos
<code class="file docutils literal notranslate"><span class="pre">fic1</span></code> dentro del directorio de destino <code class="file docutils literal notranslate"><span class="pre">dir1</span></code>. En cambio, si el
destino no existe:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> mv dir1/fic1 dir2/fic.renombrado
<span class="gp">$</span> ls dir2
<span class="go">fic.renombrado</span>
</pre></div>
</div>
<p>Lo que hacemos es cambiar el nombre. Por último, si el destino existe, pero
es un fichero, sobrescribimos:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> mv dir2/fic.renombrado fic2
<span class="go">ls dir1 dir2 fic2</span>
</pre></div>
</div>
<p>Si tomáramos como origen un directorio en vez de un fichero las consecuencias
son las mismas, excepto que no tiene sentido el caso en que el destino es un
fichero, porque un directorio no puede sobrescribir un fichero, así que la orden
fallará.</p>
<p>También es posible indicar más de dos argumentos. En ese caso el último
argumento se considerará el destino y todos los anteriores ficheros de origen.
Para que la orden funcione el destino debe ser un directorio y existir; así lo
que haremos será mover todos los orígenes dentro de tal directorio de destino.</p>
<p>Resumidamente, podemos verlo así:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 12%" />
<col style="width: 14%" />
<col style="width: 74%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Origen</p></th>
<th class="head"><p>Destino</p></th>
<th class="head"><p>Acción</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>F</p></td>
<td><p>F</p></td>
<td><p>El fichero se mueve al destino. Si este existe,
sobreescribe; si no, cambia de nombre.</p></td>
</tr>
<tr class="row-odd"><td><p>F</p></td>
<td><p>D</p></td>
<td><p>El fichero se mueve dentro del directorio.</p></td>
</tr>
<tr class="row-even"><td><p>D</p></td>
<td><p>F</p></td>
<td><p><strong>Error</strong>.</p></td>
</tr>
<tr class="row-odd"><td><p>D</p></td>
<td><p>D</p></td>
<td><p>El origen se mueve dentro del directorio de destino. Si
no existe, cambia el nombre, a menos que al destino le
incluyamos la barra final, en cuyo caso se producirá un
error.</p></td>
</tr>
</tbody>
</table>
<p>Al igual que <strong class="command">rm</strong>, <strong class="command">mv</strong> tiene también las opciones <code class="docutils literal notranslate"><span class="pre">-i</span></code> y
<code class="docutils literal notranslate"><span class="pre">-f</span></code>.</p>
<div class="admonition note" id="diff-bsd-gnu-mv">
<p class="admonition-title">Nota</p>
<p>En los sistemas <abbr title="Berkeley Software Distribution">BSD</abbr>, cuando el origen es un directorio y acaba en
barra, el comportamiento de <strong class="command">mv</strong> (y de <strong class="command">cp</strong>), cambia.
Cuando el directorio de destino existe, no se mueve el propio directorio
origen dentro del de destino, sino su contenido.</p>
</div>
</dd>
</dl>
<span class="target" id="cp"></span><dl id="index-30">
<dt><em class="manpage"><a class="manpage reference external" href="https://manpages.debian.org/cp">cp</a></em></dt><dd><p>Si lo que se pretende es hacer una copia, de manera que al acabar tengamos el
original y una copia, existe el comando <strong class="command">cp</strong>. SU funcionamiento es
similar al de <strong class="command">mv</strong> excepto por hecho de que no perdemos el archivo
original. Por tanto, es válido todo lo ya indicado, pero, además, dispone de
algunas otras opciones útiles.</p>
<p>Cuando movemos un fichero, no cambia sus propiedades (fechas, permisos,
propietarios, etc.), excepto la fecha de cambio. Por contra, cuando se copia un
fichero, muchas propiedades si pueden cambiar: por ejemplo, las fechas de acceso
y modificación pasan a reflejar el momento de la copia o el propietario em la
copia es aquel que la realiza. La opción <code class="docutils literal notranslate"><span class="pre">-p</span></code> (de <em>preservar</em>) intenta que las
propiedades cambien lo menos posible. De este modo, se conservaran las fechas
(excepto la de cambio) y, si la copia la hace el administrador, se preservará
incluso el propietario:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> touch -t <span class="m">201109301130</span> f1
<span class="gp">$</span> ls -l f1
<span class="go">-rw-r--r-- 1 usuario usuario 0 sep 30  2011 f1</span>
<span class="gp">$</span> cp f1 fc.normal
<span class="gp">$</span> cp -p f1 fc.preservado
<span class="gp">$</span> ls -l f*
<span class="go">-rw-r--r-- 1 usuario usuario 0 sep 30  2011 f1</span>
<span class="go">-rw-r--r-- 1 usuario usuario 0 oct 16 10:00 fc.normal</span>
<span class="go">-rw-r--r-- 1 usuario usuario 0 sep 30  2011 fc.preservado</span>
</pre></div>
</div>
<p>En principio, <code class="file docutils literal notranslate"><span class="pre">cp</span></code> copia ficheros, pero es posible copiar también
directorios añadiendo la opción <code class="docutils literal notranslate"><span class="pre">-r</span></code>.</p>
<p>En particular, cuando se quiere hacer una copia exacta de un directorio con todo
lo que contiene, preservando sus propiedades, es conveniente usar la opción
<code class="docutils literal notranslate"><span class="pre">-a</span></code>, que incluye <code class="docutils literal notranslate"><span class="pre">-p</span></code><a class="footnote-reference brackets" href="#id4" id="id2">2</a> y <code class="docutils literal notranslate"><span class="pre">-r</span></code>.</p>
<p id="hardlink">Hay una última opción muy interesante: <code class="docutils literal notranslate"><span class="pre">-l</span></code>, que en vez de crear una copia
crea un <strong>enlace duro</strong>. De este modo, no hacemos una copia de la información,
sino que creamos un nueva referencia (un nuevo nombre) para la misma
información:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> cp -l f1 f1.alternativo
<span class="gp">$</span> ls -l f1*
<span class="go">-rw-r--r-- 2 usuario usuario 0 sep 30  2011 f1</span>
<span class="go">-rw-r--r-- 2 usuario usuario 0 sep 30  2011 f1.alternativo</span>
</pre></div>
</div>
<p>Para entender el concepto de <em class="dfn">enlace duro</em> obsérve el siguiente gráfico:</p>
<img alt="Concepto de enlace duro y simbólico" src="../../_images/enlaces.png" />
<p>Supongamos que el recuadro grande representa todo el espacio físico de un
sistema de ficheros. Dentro de este sistema de ficheros, se encuentra un
fichero que está referenciado a través de dos nombres (<em>nombre1</em> y
<em>nombre2</em>). Al crear un enlace duro lo que estamos haciendo es crear una
nueva referencia a partir de una que ya existía. En el sistema de ficheros,
no hay dos ficheros, sino un único fichero con dos nombres. La limitación es
que ambas referencias sólo pueden existir dentro del mismo sistema de
ficheros. Por ese motivo, si intentamos crear un enlace duro en otro sistema
de ficheros, obtendremos un error. Supongamos que <code class="file docutils literal notranslate"><span class="pre">/home</span></code> y
<code class="file docutils literal notranslate"><span class="pre">/tmp</span></code> están en distinto sistema de ficheros:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> <span class="nb">cd</span>
<span class="gp">$</span> touch f1
<span class="gp">$</span> <span class="nb">cd</span> /tmp
<span class="gp">$</span> cp -l ~/f1 .
<span class="go">cp: crea el enlace duro &#39;./f1&#39; a &#39;/home/josem/f1&#39;: Enlace cruzado entre dispositivos no permitido</span>
</pre></div>
</div>
<p>No pueden hacerse enlaces duros de directorios. Obsérvese, además, que ningún
nombre es <em>más importante que otro</em>: el fichero se borrará definitivamente,
mientras exista alguna referencia a él. Dicho de otro modo, no hay ningún
nombre (referencia)  <em>original</em> al que estén subordinados el resto de nombres.</p>
</dd>
</dl>
<span class="target" id="ln"></span><dl id="index-31">
<dt><em class="manpage"><a class="manpage reference external" href="https://manpages.debian.org/ln">ln</a></em></dt><dd><p>Una alternativa para crear enlaces es <strong class="command">ln</strong>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> touch nombre1
<span class="gp">$</span> ln nombre1 nombre2
<span class="gp">$</span> ls -l nombre*
<span class="go">-rw-r--r-- 2 usuario usuario 0 oct 16 13:13 nombre1</span>
<span class="go">-rw-r--r-- 2 usuario usuario 0 oct 16 13:13 nombre2</span>
</pre></div>
</div>
<p id="symlink">Ahora bien, existe otro tipo de enlace, el <em class="dfn">enlace simbólico</em>. En este
caso, el nombre no referencia directamente al fichero, sino al nombre de un
fichero. En el dibujo se expresa esta idea haciendo que <em>simbólico</em> señale a
<em>nombre1</em>. Para crearlos puede usarse la opción <code class="docutils literal notranslate"><span class="pre">-s</span></code>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> ln -s nombre1 simbolico
<span class="gp">$</span> ls -l simbolico
<span class="go">lrwxrwxrwx 1 usuario usuario 7 oct 16 13:21 simbolico -&gt; nombre1</span>
</pre></div>
</div>
<p>Hay varias diferencias con el otro tipo de enlace:</p>
<blockquote>
<div><ol class="arabic">
<li><p>Existen dos ficheros distintos: el fichero original y el enlace simbólico.</p></li>
<li><p>Los enlaces simbólicos se pueden hacer entre distintos sistemas de
ficheros.</p></li>
<li><p>Pueden enlazarse directorios.</p></li>
<li><p>Si se borra el fichero original, el enlace simbólico permanecerá, pero
apuntando a algo que ya no existe y, por tanto, deja de tener sentido:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> rm nombre1
<span class="gp">$</span> ls -l
<span class="go">lrwxrwxrwx 1 usuario usuario 7 oct 16 13:21 simbolico -&gt; nombre1</span>
<span class="gp">$</span> cat simbolico
<span class="go">cat: simbolico: No existe el fichero o el directorio</span>
</pre></div>
</div>
</li>
</ol>
</div></blockquote>
<div class="admonition warning">
<p class="admonition-title">Advertencia</p>
<p>Ha de tenerse cuidado al crear enlaces simbólicos cuando se usa una
ruta relativa para expresar el fichero apuntado. Esta ruta relativa no se
expresa respecto al directorio de trabajo, sino respecto al propio enlace
simbólico. Retomando el ejemplo anterior:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> <span class="nb">cd</span>
<span class="gp">$</span> touch nombre1
<span class="gp">$</span> <span class="nb">cd</span> /tmp
<span class="gp">$</span> ln -s nombre1 ~/simbolico
</pre></div>
</div>
<p>Como se quiere usar una ruta relativa, <code class="file docutils literal notranslate"><span class="pre">nombre1</span></code> debe extresarse
respecto al directorio donde se desea crear <code class="file docutils literal notranslate"><span class="pre">simbólico</span></code>. Por tanto la
ruta relativa consiste en escribir simplemente el nombre, aunque nuestro
dikrectorio de trabajo sea <code class="file docutils literal notranslate"><span class="pre">/tmp</span></code> y no el directorio personal.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>Aunque sólo se pueden crear enlaces duros con ficheros, es lícito con
<strong class="command">cp</strong> copiar directorios con todo su contenido, usar la opción
<code class="docutils literal notranslate"><span class="pre">-l</span></code>. En ese caso, <strong class="command">cp</strong> creara un nuevo directorio al copiar
el directorio y enlaces duros al copiar los ficheros.</p>
</div>
</dd>
</dl>
<span class="target" id="realpath"></span><dl id="index-32">
<dt><em class="manpage"><a class="manpage reference external" href="https://manpages.debian.org/realpath">realpath</a></em></dt><dd><p>Devuelve la ruta absoluta (resolviendo enlaces simbólicos si los hubiera)
del archivo dado como argumento (que no tiene por qué):</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> <span class="nb">pwd</span>
<span class="go">/home/usuario</span>
<span class="gp">$</span> realpath no.existe
<span class="go">/home/usuario/no.existe</span>
</pre></div>
</div>
<p>Puede requerirse que el archivo exista incluyendo la opción <kbd class="kbd docutils literal notranslate">-e</kbd>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> realpath -e no.existe
<span class="go">realpath: «no.existe»: No existe el fichero o el directorio</span>
</pre></div>
</div>
</dd>
</dl>
<span class="target" id="readlink"></span><dl id="index-33">
<dt><em class="manpage"><a class="manpage reference external" href="https://manpages.debian.org/readlink">readlink</a></em></dt><dd><p>Resuelve el enlace simbólico devolviendo el fichero al que apunta:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> touch soy.un.fichero
<span class="gp">$</span> ln -s soy.un.fichero soy.un.enlace.simbolico
<span class="gp">$</span> readlink soy.un.enlace.simbolico
<span class="go">soy.un.fichero</span>
</pre></div>
</div>
<p>Si se usa como argumento un fichero que no es un enlace simbólico, no
imprimirá nada y devolverá un error a la <em>shell</em>.</p>
<p>Si el enlace simbólico apunta a otro enlace simbólico se devolverá este
segundo enlace, con lo que no se sabrá a ciencia cierta cuál es el
fichero al que se está apuntando en realidad. Para ello existe la opción
<code class="docutils literal notranslate"><span class="pre">-f</span></code> que, además, siempre muestra la ruta absoluta:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> ln -s soy.un.enlace.simbolico soy.otro.enlace
<span class="gp">$</span> readlink soy.otro.enlace
<span class="go">soy.un.enlace.simbolico</span>
<span class="gp">$</span> readlink -f soy.otro.enlace
<span class="go">/home/usuario/soy.un.fichero</span>
</pre></div>
</div>
<p>En este caso, tiene sentido usar como argumento cualquier fichero: no se
generará un error, sino que se mostrará su ruta absoluta:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> readlink -f soy.un.fichero
<span class="go">/home/usuario/soy.un.fichero</span>
</pre></div>
</div>
</dd>
</dl>
<span class="target" id="index-34"></span><span class="target" id="index-35"></span><p id="index-36">Cuando se usa una interfaz de texto, gran parte de los ficheros que se manejan
son de texto, así que una de las herramientas más socorridas son los <em>editores de
texto</em>. En cualquier sistema <em>unix</em> suele venir de serie <strong class="program">vi</strong> o su
<em>primo de Zumosol</em> <a class="reference external" href="http://www.vim.org">vim</a>, pero los neófitos suelen
preferir <strong class="program">nano</strong>, un clónico mejorado del antiguo editor
<strong class="program">pico</strong>. También es muy usado <a class="reference external" href="https://www.gnu.org/software/emacs/">emacs</a>.</p>
</div>
<div class="section" id="ejercicios-sobre-manipulacion-de-archivos">
<span id="ej-fic"></span><h2><span class="section-number">2.2.2.3. </span>Ejercicios sobre manipulación de archivos<a class="headerlink" href="#ejercicios-sobre-manipulacion-de-archivos" title="Enlazar permanentemente con este título">¶</a></h2>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>Especifique convenientemente si usa el administrador o no.</p>
</div>
<ol class="loweralpha">
<li><p>Lleve a cabo las siguienes tareas:</p>
<ol class="arabic">
<li><p>Crear un fichero vacío llamado <code class="file docutils literal notranslate"><span class="pre">estoy.en.blanco</span></code> dentro del directorio
personal del usuario.</p></li>
<li><p>Hacer una copia de este fichero en el directorio temporal con nombre
<code class="file docutils literal notranslate"><span class="pre">sigo.en.blanco</span></code>. Use rutas relativas tanto para el origen como para
el destino.</p></li>
<li><p>Hacer un enlace duro en el directorio temporal conservando el nombre.
¿Es posible en el sistema en que está trabajando? ¿Por qué?</p></li>
<li><p>Crear la siguiente estructura de directorios:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>/tmp
  +---- DIR1
  |      +------ DIR11
  |      +------ DIR12
  +---- DIR2
  +---- DIR3
    +------ DIR31
    +------ DIR32
    +------ DIR33
</pre></div>
</div>
</li>
<li><p>Cambiar al directorio temporal usando ruta absoluta.</p></li>
<li><p>Mover <code class="file docutils literal notranslate"><span class="pre">sigo.en.blanco</span></code> al directorio <code class="file docutils literal notranslate"><span class="pre">DIR33</span></code>.</p></li>
<li><p>Manteniendo el mismo nombre, hacer un enlace simbólico a
<code class="file docutils literal notranslate"><span class="pre">sigo.en.blanco</span></code> en el directorio personal</p></li>
<li><p>Mover el directorio <code class="file docutils literal notranslate"><span class="pre">DIR33</span></code> dentro de <code class="file docutils literal notranslate"><span class="pre">DIR12</span></code>.</p></li>
<li><p>Copiar todo el árbol que cuelga de <code class="file docutils literal notranslate"><span class="pre">DIR1</span></code> dentro de <code class="file docutils literal notranslate"><span class="pre">DIR32</span></code>.</p></li>
<li><p>Borrar todo lo que se ha hecho.</p></li>
</ol>
</li>
<li><p>Haga esta otra tanda de ejercicios, sabiendo que comienza a hacerlos estando
en su directorio personal:</p>
<ol class="arabic">
<li><p>Consulte el contenido de <code class="file docutils literal notranslate"><span class="pre">/usr/sbin</span></code> usando ruta relativa.</p></li>
<li><p>Encuentre los ficheros de extensión <code class="file docutils literal notranslate"><span class="pre">.txt.gz</span></code> contenidos dentro
de la parte del árbol de directorios que cualga de <code class="file docutils literal notranslate"><span class="pre">/usr/share/doc</span></code>.</p></li>
<li><p>Entre en el directorio temporal usando ruta relativa.</p></li>
<li><p>Consulte cuáles son los permisos del directorio raíz. Utilice ruta
relativa y dos órdenes distintas.</p></li>
<li><p>Cree la siguiente estructura de archivos (vacíos) y directorios:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>+ /tmp
    +--- dirA
    |     +-- fichero1.txt
    |     +-- dirAA
    |     |     +-- fichero2.txt
    |     |     +-- fichero3.txt
    |     |
    |     +-- dirAB
    |     +-- dirAC
    |           +-- fichero4.txt
    +--- dirB
</pre></div>
</div>
</li>
<li><p>Mueva <code class="file docutils literal notranslate"><span class="pre">dirAA</span></code> dentro de <code class="file docutils literal notranslate"><span class="pre">dirB</span></code>.</p></li>
<li><p>Buscar todos los ficheros de texto plano (extensión <code class="file docutils literal notranslate"><span class="pre">.txt</span></code>)
contenidos en el directorio temporal.</p></li>
<li><p>Hacer en enlace duro dentro de <code class="file docutils literal notranslate"><span class="pre">dirAB</span></code> del archivo
<code class="file docutils literal notranslate"><span class="pre">fichero3.txt</span></code>.</p></li>
<li><p>Hacer un enlace simbólico en <code class="file docutils literal notranslate"><span class="pre">dirB</span></code> de <code class="file docutils literal notranslate"><span class="pre">fichero1.txt</span></code> y llamar
a dicho enlace <code class="file docutils literal notranslate"><span class="pre">unfichero.txt</span></code>.</p></li>
<li><p>Borrar todo lo creado.</p></li>
</ol>
</li>
</ol>
<p class="rubric">Notas al pie</p>
<dl class="footnote brackets">
<dt class="label" id="id3"><span class="brackets"><a class="fn-backref" href="#id1">1</a></span></dt>
<dd><p>En realidad,  <code class="docutils literal notranslate"><span class="pre">-p</span></code> no preserva algunas propiedades como los atributos
extendidos. Usar <code class="docutils literal notranslate"><span class="pre">-a</span></code> implica, más bien, <kbd class="kbd compound docutils literal notranslate"><kbd class="kbd docutils literal notranslate">-</kbd>-<kbd class="kbd docutils literal notranslate">preserve=all</kbd></kbd>.</p>
</dd>
<dt class="label" id="id4"><span class="brackets"><a class="fn-backref" href="#id2">2</a></span></dt>
<dd><p><strong class="command">which</strong> no busca todos los programas que hay en nuestro árbol de
directorios, ya que estos pueden encontrarse en cualquier lugar
arbitrario. Véase la variable <a class="reference internal" href="../07.avanzada/08.interpretaciones.html#path"><span class="std std-ref">PATH</span></a>, para saber más al
respecto.</p>
</dd>
</dl>
</div>
</div>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../../index.html">Tabla de contenido</a></h3>
  <ul>
<li><a class="reference internal" href="#">2.2.2. Ficheros y directorios</a><ul>
<li><a class="reference internal" href="#bicheando">2.2.2.1. Bicheando</a><ul>
<li><a class="reference internal" href="#dentro-de-directorios">2.2.2.1.1. … dentro de directorios</a></li>
<li><a class="reference internal" href="#y-dentro-de-ficheros">2.2.2.1.2. … y dentro de ficheros</a></li>
</ul>
</li>
<li><a class="reference internal" href="#creando-contenidos">2.2.2.2. Creando contenidos</a></li>
<li><a class="reference internal" href="#ejercicios-sobre-manipulacion-de-archivos">2.2.2.3. Ejercicios sobre manipulación de archivos</a></li>
</ul>
</li>
</ul>

  <h4>Tema anterior</h4>
  <p class="topless"><a href="01.filesystem.html"
                        title="capítulo anterior"><span class="section-number">2.2.1. </span>El sistema de archivos</a></p>
  <h4>Próximo tema</h4>
  <p class="topless"><a href="04.devices.html"
                        title="próximo capítulo"><span class="section-number">2.2.3. </span>Dispositivos</a></p>
  <div role="note" aria-label="source link">
    <h3>Esta página</h3>
    <ul class="this-page-menu">
      <li><a href="../../_sources/02.conbas/02.informacion/03.ficheros.rst.txt"
            rel="nofollow">Mostrar el código</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Búsqueda rápida</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Ir a" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navegación</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="Índice General"
             >índice</a></li>
        <li class="right" >
          <a href="04.devices.html" title="2.2.3. Dispositivos"
             >siguiente</a> |</li>
        <li class="right" >
          <a href="01.filesystem.html" title="2.2.1. El sistema de archivos"
             >anterior</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">documentación de Linuxnomicón - rolling</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" ><span class="section-number">2. </span>Conceptos básicos</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="index.html" ><span class="section-number">2.2. </span>Acceso a la información</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href=""><span class="section-number">2.2.2. </span>Ficheros y directorios</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Derechos de autor CC BY 4.0, 2016-2021, José Miguel Sánchez Alés.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 3.5.4.
    </div>
  </body>
</html>