


<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" lang="es">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>2.2.3. Dispositivos &#8212; documentación de ServidorLinux - 0.1.0</title>
    <link rel="stylesheet" href="../../_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../_static/custom.css" />
    
    <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../_static/language_data.js"></script>
    <script type="text/javascript" src="../../_static/translations.js"></script>
    
    <link rel="index" title="Índice" href="../../genindex.html" />
    <link rel="search" title="Búsqueda" href="../../search.html" />
    <link rel="next" title="2.3. Seguridad en el sistema de ficheros" href="../05.seguridad/index.html" />
    <link rel="prev" title="2.2.2. Ficheros y directorios" href="03.ficheros.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navegación</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="Índice General"
             accesskey="I">índice</a></li>
        <li class="right" >
          <a href="../05.seguridad/index.html" title="2.3. Seguridad en el sistema de ficheros"
             accesskey="N">siguiente</a> |</li>
        <li class="right" >
          <a href="03.ficheros.html" title="2.2.2. Ficheros y directorios"
             accesskey="P">anterior</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">documentación de ServidorLinux - 0.1.0</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" >2. Conceptos básicos</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="index.html" accesskey="U">2.2. Acceso a la información</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="dispositivos">
<span id="id1"></span><h1>2.2.3. Dispositivos<a class="headerlink" href="#dispositivos" title="Enlazar permanentemente con este título">¶</a></h1>
<div class="section" id="lo-que-esconde-dev">
<h2>2.2.3.1. Lo que esconde <code class="file docutils literal notranslate"><span class="pre">/dev</span></code><a class="headerlink" href="#lo-que-esconde-dev" title="Enlazar permanentemente con este título">¶</a></h2>
<p>En los sistemas <em>unix</em> todo se representa a través de ficheros<a class="footnote-reference" href="#id16" id="id2">[1]</a>. Para
realizar esta abstracción existen una serie de ficheros especiales al margen de
los ya vistos (regulares, directorios y enlaces simbólicos), que se encuentran
bajo <code class="file docutils literal notranslate"><span class="pre">/dev</span></code>. No son, pues, ficheros propiamente dichos, sino la
abstracción de una comunicación que se hace ver al usuario como un fichero. Hay
de dos tipos<a class="footnote-reference" href="#id17" id="id3">[2]</a>:</p>
<dl class="docutils" id="chardevice">
<dt>Dispositivos orientados a <strong>caracteres</strong></dt>
<dd><p class="first">Sirven para la transmisión de datos byte a byte. Algunos ficheros
representan dispositivos de <em>hardware</em>:</p>
<ul class="simple">
<li><code class="file docutils literal notranslate"><span class="pre">/dev/psaux</span></code>, el ratón conectado al puerto <a class="reference external" href="https://es.wikipedia.org/wiki/PS/2">PS/2</a>.</li>
<li><code class="file docutils literal notranslate"><span class="pre">/dev/ttyS0</span></code>, el puerto serie.</li>
<li><code class="file docutils literal notranslate"><span class="pre">/dev/ttyN</span></code>, las <a class="reference internal" href="../01.preliminares/index.html#terminal"><span class="std std-ref">terminales</span></a> <a class="footnote-reference" href="#id18" id="id4">[3]</a>.</li>
<li><code class="file docutils literal notranslate"><span class="pre">/dev/pts/N</span></code>, las pseudoterminales.</li>
<li>etc.</li>
</ul>
<p>Otros, en cambio, representan dispositivos especiales que no se
corresponden con <em>hardware</em>. Algunos tocará usarlos de vez en cuando
como:</p>
<ul class="last simple">
<li><code class="file docutils literal notranslate"><span class="pre">/dev/null</span></code>, dispositivo que acepta cualquier flujo de
caracteres sin generar ninguna respuesta<a class="footnote-reference" href="#id19" id="id5">[4]</a>.</li>
<li><code class="file docutils literal notranslate"><span class="pre">/dev/zero</span></code>, dispositivo que devuelve ceros.</li>
<li><code class="file docutils literal notranslate"><span class="pre">/dev/random</span></code> o <code class="file docutils literal notranslate"><span class="pre">/dev/urandom</span></code>, que generan secuencias
de bytes (pseudoaleatorios). A menos que sea crítica la aletoriedad,
es más conveniente usar <code class="file docutils literal notranslate"><span class="pre">/dev/urandom</span></code>.</li>
</ul>
</dd>
</dl>
<dl class="docutils" id="blockdevice">
<dt>Dispositivos orientados a <strong>bloques</strong></dt>
<dd><p class="first">Sirven para la trasmisión de datos en bloques y se usa con ellos el
<em>buffer</em> de datos del sistema. Típicamente se usan para representar los
dispositivos de almacenamiento:</p>
<ul class="last simple">
<li><code class="file docutils literal notranslate"><span class="pre">/dev/fd0</span></code>, representaba el disco flexible.</li>
<li><code class="file docutils literal notranslate"><span class="pre">/dev/hd[a-z]</span></code>, representaba los discos duros conectados al bus
<a class="reference external" href="https://es.wikipedia.org/wiki/Integrated_Drive_Electronics">IDE</a>.</li>
<li><code class="file docutils literal notranslate"><span class="pre">/dev/sd[a-z]</span></code>, representa los discos <abbr title="Small Computer System Interface">SCSI</abbr> y también los discos <abbr title="Serial Advanced Technology Attachment">SATA</abbr> o <cite>USB (Universal Serial Bus)</cite><a class="footnote-reference" href="#id20" id="id6">[5]</a>.</li>
<li><code class="file docutils literal notranslate"><span class="pre">/dev/sr0</span></code>, representa al lector de cd-rom SATA.</li>
</ul>
</dd>
</dl>
</div>
<div class="section" id="dispositivos-de-almacenamiento">
<h2>2.2.3.2. Dispositivos de almacenamiento<a class="headerlink" href="#dispositivos-de-almacenamiento" title="Enlazar permanentemente con este título">¶</a></h2>
<p>En la administración de un sistema es muy común tener que acceder a los
dispositivos de almacenamiento ya para saber de cuáles se dispone, ya para
leerlos, ya para particionarlos, ya para montarlos si es que disponen de un
sistema de ficheros. Bajo este epígrafe se verá cómo hacer todas estas
operaciones.</p>
<div class="section" id="de-cuales-dispongo">
<h3>2.2.3.2.1. ¿De cuáles dispongo?<a class="headerlink" href="#de-cuales-dispongo" title="Enlazar permanentemente con este título">¶</a></h3>
<p>Dado que ya hemos avanzado que nombre tienen en el sistema, bastaría en
principio con hacer:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> ls /dev/sd<span class="o">[</span>a-z<span class="o">]</span>
</pre></div>
</div>
<p>Y ver qué nos devuelve la orden. Es ciertamente una posibilidad, pero bastante
precaria, porque no habrá forma de saber, por ejemplo, qué tamaño tienen. En
cualquier caso, si en vez de usar el comando anterior, se hizo lo siguiente:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> ls /dev/sd*
</pre></div>
</div>
<p>Nos habremos dado cuenta que aparecen otros dispositivos con números al final
como <code class="file docutils literal notranslate"><span class="pre">/dev/sda1</span></code>. Haciendo la prueba en mi sistema virtualizado:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> ls /dev/sd<span class="o">[</span>a-z<span class="o">]</span>
<span class="go">/dev/sda</span>
<span class="gp">$</span>ls /dev/sd*
<span class="go">/dev/sda   /dev/sda1</span>
</pre></div>
</div>
<p>Hay un sólo disco (y un cd-rom en <code class="file docutils literal notranslate"><span class="pre">/dev/sr0</span></code>, que no viene al caso). Pero
¿qué es <code class="file docutils literal notranslate"><span class="pre">/dev/sda1</span></code>? Fácil: una partición del disco <em>sda</em>, la única que
tiene<a class="footnote-reference" href="#id21" id="id7">[6]</a>.</p>
<p>Por tanto, escudriñando en <code class="file docutils literal notranslate"><span class="pre">/dev</span></code> sólo somos capaces de saber que tenemos
un disco y que este tiene una sola partición: no hay tamaños, ni naturaleza de
las particiones. Ni siquiera sabemos si esa partición contiene un sistema de
ficheros o, por el contrario, algo más complejo.</p>
<p>Es cierto que usando <strong class="command">ls</strong> y <strong class="command">cat</strong> dentro de <code class="file docutils literal notranslate"><span class="pre">/sys</span></code> o
<code class="file docutils literal notranslate"><span class="pre">/proc</span></code>, podríamos obtener más información, pero lo mejor es cambiar de
estrategia.</p>
<p>La forma más simple, aunque aún algo precaria, de hacernos una idea de cómo está
organizado nuestro disco duros es la siguiente:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> cat /proc/partitions
<span class="go">major   minor    #blocks name</span>

<span class="go">   8        0    4194304 sda</span>
<span class="go">   8        1    4192256 sda1</span>
<span class="go">  11        0    1048575 sr0</span>
<span class="go">   9        0    4190208 md0</span>
<span class="go"> 253        0    1949696 dm-0</span>
<span class="go"> 253        1     249856 dm-1</span>
<span class="go"> 253        2     241664 dm-2</span>
<span class="go"> 253        3     241664 dm-3</span>
</pre></div>
</div>
<p>Mirar el contenido del fichero <code class="file docutils literal notranslate"><span class="pre">/proc/partitions</span></code> nos dice cuáles son los
dispositivos y <em>particiones</em> de nuestro disco duro susceptibles de contener un
sistema de ficheros. Por el número de la primera columna sabemos que hay cuatro
dispositivos diferentes: <em>8</em>, <em>11</em>, <em>9</em>, y <em>253</em>. El primero es el disco
duro; y el segundo, el cdrom. Hay otros dos <em>raros</em> y efectivamente lo son
porque el particinado de este disco no es el más sencilla En cualquier caso:</p>
<dl class="docutils">
<dt>Disco duro:</dt>
<dd><p class="first">tenemos dos dispositivos asociados al disco duro: <em>sda</em> y <em>sda1</em>. El
primero representa al disco en su totalidad y el segundo a una única partición
que ocupa todo el disco (los tamañós son prácticamente iguales). El tamaño
de disco es de 4194304 bloques. Como cada bloque es de 2KB, resulta
que el disco es exactamente de <em>8</em>GB. De todos modos, el tamaño de
bloque no está expresado, así que es sólo una suposición. Realmente no
podemos conocer con absoluta seguridad cuál es el tamaño.</p>
<p class="last">Si nuestro sistema tuviera un particinado básico, simplemente tendríamos
varias particiones más <em>sda2</em>, <em>sda3</em> y <em>sda1</em> no ocuparía todo el
espacio.</p>
</dd>
<dt><em>CDROM</em></dt>
<dd>Está representado por <em>sr0</em>. No hay mucho que decir.</dd>
<dt><em>md0</em></dt>
<dd>Este es uno de esos raros dispositivos. Por el tamaño se ve que tiene
prácticamente el tamaño de <em>sda1</em>. No es extraño. En linux, los RAID por
software están asociados a los dispositivos <code class="file docutils literal notranslate"><span class="pre">/dev/mdN</span></code>, así que esto
es un RAID que ocupa la partición <em>sda1</em>. Pero ¿cómo puede existir un RAID
asociado a un único soporte físico? El más simple, el <em>RAID 1</em> necesita
dos soportes, puesto que consiste en sincronizar ambos de manera que en
ambos se escriba lo mismo. De ese modo, si uno se estropea, el otro
contiene toda la información. Lo cierto es que esto es un RAID 1. La
anomalía de que sólo esté asociada a un soporte es que, como esto es una
máquina virtual, lo mismo nos da un soporte que treinta. Los dispositivos
son en realidad ficheros y si se estropea el disco de la máquina real, se
van al garete todos los ficheros juntos. Así que se ha creado un falso
RAID en el que no hay redundancia. Pero funciona como RAID, así que se
puede observar cómo funciona y en cualquier momento se puede ampliar para
crear un RAID real.</dd>
<dt><em>dm-N</em></dt>
<dd>Son <em>particiones</em> que están asociadas a un mismo dispositivo.
<em>Particiones</em>, porque cumplen su función, ya no lo son realmente. Vemos
que hay cuatro.</dd>
</dl>
<p>En definitiva, que algo hemos visto, mejor que con <strong class="command">ls</strong>, pero tampoco
es muy ilustrativo.</p>
<span class="target" id="lsblk"></span><dl class="docutils" id="index-0">
<dt><strong class="command">lsblk</strong></dt>
<dd><p class="first">Un comando más elocuente y que nos muestra más a las claras cómo esan
organizados nuestros dispositivos es <strong class="command">lsblk</strong>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> lsblk
<span class="go">NAME                 MAJ:MIN RM  SIZE RO TYPE  MOUNTPOINT</span>
<span class="go">sda                    8:0    0    4G  0 disk</span>
<span class="go">└─sda1                 8:1    0    4G  0 part</span>
<span class="go">  └─md0                9:0    0    4G  0 raid1</span>
<span class="go">     ├─vgserver-root  253:0    0  1,9G  0 lvm   /</span>
<span class="go">     ├─vgserver-swap  253:1    0  244M  0 lvm   [SWAP]</span>
<span class="go">     ├─vgserver-home  253:2    0  236M  0 lvm   /home</span>
<span class="go">     └─vgserver-mysql 253:3    0  236M  0 lvm   /var/lib/mysql</span>
<span class="go">sr0                    11:0    1 1024M  0 rom</span>
</pre></div>
</div>
<p>Esto ya es otra cosa. Se ve claramente el cdrom y el disco con su partición, que
dentro de la partición hay un dispositivo de raiz y que este raid tiene cuatro
particiones que en realidad son <em>volúmenes lógicos</em> (se sabe porque su tipo es
<em>lvm</em>) y cuya naturaleza no explicaremos, porque nos basta con creernos que son
particiones.</p>
<p>Además cada <em>partición</em> tiene expresado qué sistema de ficheros soporta. Y se
ven claramento los tamaños.</p>
<p>Si probamos a ver si esos dispositivos existen bajo <code class="file docutils literal notranslate"><span class="pre">/dev</span></code>, veremos que
sí:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> ls -l /dev/vgserver
<span class="go">total 0</span>
<span class="go">lrwxrwxrwx 1 root root 7 oct 17 18:53 home -&gt; ../dm-2</span>
<span class="go">lrwxrwxrwx 1 root root 7 oct 17 18:53 mysql -&gt; ../dm-3</span>
<span class="go">lrwxrwxrwx 1 root root 7 oct 17 18:53 root -&gt; ../dm-0</span>
<span class="go">lrwxrwxrwx 1 root root 7 oct 17 18:53 swap -&gt; ../dm-1</span>
</pre></div>
</div>
<p class="last">y, como era de prever, están relacionados con los dispositivos <em>dm-N</em>, que vimos
en <code class="file docutils literal notranslate"><span class="pre">/proc/partitions</span></code>.</p>
</dd>
</dl>
<span class="target" id="blkid"></span><dl class="docutils" id="index-1">
<dt><strong class="command">blkid</strong></dt>
<dd><p class="first">Otra orden interesante para bichear en nuestros dispositivos de almacenamiento
es <strong class="command">blkid</strong>, que hay que usar como administrador. Su salida no es tan
elocuente:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> blkid
<span class="go">/dev/sda1: UUID=&quot;c74e4d2d-848b-0c73-3fe6-acff0992a4ed&quot;</span>
<span class="go">           UUID_SUB=&quot;5a22044a-c1ce-ec62-c653-6572e0dfc9e0&quot; LABEL=&quot;debian:0&quot;</span>
<span class="go">           TYPE=&quot;linux_raid_member&quot; PARTUUID=&quot;b3847d39-01&quot;</span>
<span class="go">/dev/md0: UUID=&quot;2lGqII-SHAM-i9S6-Cm17-pt57-sHyo-4LDLdn&quot; TYPE=&quot;LVM2_member&quot;</span>
<span class="go">/dev/mapper/vgserver-root: LABEL=&quot;root&quot; UUID=&quot;dcbb187a-360a-4091-bc2a-ea18acf5e5fe&quot; TYPE=&quot;ext4&quot;</span>
<span class="go">/dev/mapper/vgserver-swap: UUID=&quot;fa3d001a-40bb-4ee1-a9ef-635a110e0b89&quot; TYPE=&quot;swap&quot;</span>
<span class="go">/dev/mapper/vgserver-home: LABEL=&quot;home&quot; UUID=&quot;c447a88c-fb88-492b-b79e-818d687f2c37&quot; TYPE=&quot;ext4&quot;</span>
<span class="go">/dev/mapper/vgserver-mysql: LABEL=&quot;mysql&quot; UUID=&quot;844ec999-d6a1-4175-970f-7b98060a6c1f&quot; TYPE=&quot;ext4&quot;</span>
</pre></div>
</div>
<p>pero añade información adicional, sobre todo en la referente a las particiones
que contienen sistemas de ficheros. Por un lado nos enteramos de que hay otro
enlace simbólico a los dispositivos <em>dm-N</em>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> ls /dev/mapper/vgserver-*
<span class="go">lrwxrwxrwx 1 root root 7 oct 17 18:53 /dev/mapper/vgserver-home -&gt; ../dm-2</span>
<span class="go">lrwxrwxrwx 1 root root 7 oct 17 18:53 /dev/mapper/vgserver-mysql -&gt; ../dm-3</span>
<span class="go">lrwxrwxrwx 1 root root 7 oct 17 18:53 /dev/mapper/vgserver-root -&gt; ../dm-0</span>
<span class="go">lrwxrwxrwx 1 root root 7 oct 17 18:53 /dev/mapper/vgserver-swap -&gt; ../dm-1</span>
</pre></div>
</div>
<p>Por otro, vemos en qué sistema de ficheros están formateados (<em>ext4</em>) y,
finalmente, conocemos también que etiqueta tienen estos sistemas de ficheros y
que identificador único. Veremos qué importancia tienen estos dos datos más
adelante.</p>
<p><strong class="command">blkid</strong> también puede usarse de modo más restringido para obtener
alguna característica particular de un dispositivo. Por ejemplo:</p>
<div class="last highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> blkid -s UUID -o value /dev/mapper/vgserver-swap
<span class="go">fa3d001a-40bb-4ee1-a9ef-635a110e0b89</span>
</pre></div>
</div>
</dd>
</dl>
</div>
<div class="section" id="preparacion-de-dispositivos">
<h3>2.2.3.2.2. Preparación de dispositivos<a class="headerlink" href="#preparacion-de-dispositivos" title="Enlazar permanentemente con este título">¶</a></h3>
<p>Bajo este epígrafe se discute, muy brevemente, cómo preparar los dispositivos
que contendrán los sistemas de ficheros. Esto, en principio, tiene dos fases:</p>
<ol class="arabic simple">
<li>Particionar el dispositivo.</li>
<li>Conferir un sistema de fichero a las particiones creadas.</li>
</ol>
<p>La primera tarea tiene mucha miga y merece una explicación prolija, que no se
dará aquí<a class="footnote-reference" href="#id22" id="id8">[7]</a>. Baste con decir que pueden crearse particiones <em>msdos</em> o las
más modernas particiones <em>GPT</em>. Si el disco es mayor de 2TB, es necesario hacer
estas últimas.</p>
<p>La herramienta fundamental y más simple para crear particiones <em>msdos</em> es el
<span class="target" id="index-2"></span>programa <strong class="program">fdisk</strong>, mientras que para crear particiones
<em>gpt</em> es el <span class="target" id="index-3"></span>programa <strong class="command">gdisk</strong>. Para estas últimas
particiones también es muy recomendable el <span class="target" id="index-4"></span>comando
<strong class="command">sgdisk</strong> que permite hacerlas a través de opciones en vez de con un
menú interactivo.</p>
<p>Supuesto que seamos capaces de <a class="reference internal" href="../../05.discos/01.particionado/index.html#particionado"><span class="std std-ref">hacer el particionado</span></a>, la
segunda tarea consiste en formatear las particiones resultantes. Para ello, el
comando apropiado es</p>
<span class="target" id="mkfs"></span><dl class="docutils" id="index-5">
<dt><strong class="command">mkfs</strong></dt>
<dd><p class="first">En realidad, <strong class="command">mkfs</strong> no es un comando sino un <em>front-end</em> de una
familia de programas llamados <strong>mkfs.&lt;tipo&gt;</strong> (<strong class="command">mkfs.ext4</strong>,
<strong class="command">mkfs.xfs</strong>, <strong class="command">mkfs.btrfs</strong>, <strong class="command">mkfs.ntfs</strong>, etc.) que
se instalan por separado. Por ello hay dos formas para dar formato:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">mkfs -t &lt;tipo&gt; [&lt;opciones&gt;] &lt;dispositivo&gt;</span>
<span class="go">mkfs.&lt;tipo&gt; [&lt;opciones&gt;] &lt;dispositivo&gt;</span>
</pre></div>
</div>
<p>Las opciones de formateo dependen del tipo de sistema de ficheros que vayamos
a usar, pero hay una serie de opciones que habitualmente se incluyen al hacer
el formateo:</p>
<ul class="simple">
<li>Para agilizar el formateo, no comprobar la integridad del dispositivo ni
llenarlo con ceros a fin de eliminar toda información anterior. Suele
ser el comportamiento predeterminado excepto para <strong class="command">mkfs.ntfs</strong>
que requiere la opción <code class="docutils literal notranslate"><span class="pre">-f</span></code>.</li>
<li>Poner una etiqueta (<em>LABEL</em>) al sistema de ficheros a través de <code class="docutils literal notranslate"><span class="pre">-L</span></code>,
excepto para <code class="docutils literal notranslate"><span class="pre">mkfs.vfat</span></code> que usa la opción <code class="docutils literal notranslate"><span class="pre">-n</span></code></li>
<li>Muy circunstancialmente, se puede desear dar al sistema de ficheros un
identificador (<em>UUID</em>) determinado. Por ejemplo, cuando la partición ya
formaba parte del sistema y, simplemente, se desea reformatear. Como es
posible que el antiguo <strong>UUID</strong> ya estuviera expresado en algún fichero
de configuración (por ejemplo, en el <a class="reference internal" href="#fstab"><span class="std std-ref">fstab</span></a>, es bastante
aconsejable que no cambie. La opción suele ser <code class="docutils literal notranslate"><span class="pre">-U</span></code>, aunque
<strong class="command">mkfs.vfat</strong> utiliza <code class="docutils literal notranslate"><span class="pre">-i</span></code>.</li>
</ul>
<div class="admonition warning">
<p class="first admonition-title">Advertencia</p>
<p class="last">Consúltese antes la página de manual del comando de formateado, porque las
opciones pueden variar.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Nota</p>
<p class="last">Tanto el particionado como el formateo sólo lo puede realizar el
administrador o un usuario que pertenezca al grupo <em>disk</em>.</p>
</div>
<p>Por lo general, tocará formatear dispositivos para memoria de intercambio
(<strong class="command">mkfs.swap</strong>) y sistemas de ficheros <em>ext4</em> (<strong class="command">mkfs.ext4</strong>),
<em>ntfs</em> (<strong class="command">mkfs.ntfs</strong>), <em>vfat</em> (<strong class="command">mkfs.vfat</strong>), <em>xfs</em>
(<strong class="command">mkfs.xfs</strong>) y <em>btrfs</em> (<strong class="command">mkfs.btrfs</strong>); el primero porque es
el sistema de ficheros habitual en linux; y el segundo y tercero porque con
ellos se suelen formatear los pinchos <em>USB</em> para poder leerlos en ordenadores
que no utilicen <em>linux</em>. El formateo es sencillo:</p>
<ol class="last arabic">
<li><p class="first">Formatear la partición <code class="file docutils literal notranslate"><span class="pre">/dev/sda6</span></code> con <em>ext4</em> proporcionando un
nombre para la etiqueta:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> mkfs.ext4 -L HOME /dev/sda6
</pre></div>
</div>
</li>
<li><p class="first">Formatear la partición <code class="file docutils literal notranslate"><span class="pre">dev/sdc1</span></code> en <em>ntfs</em>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> mkfs.ntfs -f -L PINCHO /dev/sdc1
</pre></div>
</div>
</li>
<li><p class="first">Formatear la partición <code class="file docutils literal notranslate"><span class="pre">dev/sdc1</span></code> en <em>vfat</em>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> mkfs.vfat -n PINCHO /dev/sdc1
</pre></div>
</div>
</li>
<li><p class="first">Reformatear la partición <code class="file docutils literal notranslate"><span class="pre">/dev/sdb1</span></code> manteniendo el mismo
<em>UUID</em>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> mkfs.ext4 -L STORE -U <span class="k">$(</span>blkid -s UUID -o value /dev/sdb1<span class="k">)</span> /dev/sdb1
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Nota</p>
<p class="last">En vez de consultar el <em>UUID</em> y trascribir el resultado de la
consulta en la línea de comandos, se ha preferido hacer uso de las
<a class="reference internal" href="../07.avanzada/08.interpretaciones.html#subshell"><span class="std std-ref">subshells</span></a>, como se mostrará más adelante, como se
mostrará más adelante.</p>
</div>
</li>
</ol>
</dd>
</dl>
<span class="target" id="mkswap"></span><dl class="docutils" id="index-6">
<dt><strong class="command">mkswap</strong></dt>
<dd><p class="first">Prepara un dispositivo para que pueda ser usado como memoria de intercambio.
Es el equivalente a <strong class="command">mkfs.&lt;tipo&gt;</strong> y su uso es semejante:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> mkswap <span class="o">[</span>&lt;opciones&gt;<span class="o">]</span> &lt;dispositivo&gt;
</pre></div>
</div>
<p class="last">Dispone también de las opciones <code class="docutils literal notranslate"><span class="pre">-L</span></code> y <code class="docutils literal notranslate"><span class="pre">-U</span></code>.</p>
</dd>
</dl>
</div>
<div class="section" id="montaje-de-dispositivos">
<h3>2.2.3.2.3. Montaje de dispositivos<a class="headerlink" href="#montaje-de-dispositivos" title="Enlazar permanentemente con este título">¶</a></h3>
<p>Ya se ha explicado que en <em>unix</em> existe un único árbol de directorios sobre el
cual se montan, sobre distintos directorios, los distintos sistemas de ficheros.
Se llama <em class="dfn">punto de montaje</em> a cada uno de los directorios sobre los que se
monta un sistema de ficheros.</p>
<p>Un modo de saber cuáles son estos <em>puntos de montaje</em> se ha expuesto ya y,
además, es bastante ilustrativo: a través de <a class="reference internal" href="#lsblk">lsblk</a>.</p>
<span class="target" id="df"></span><dl class="docutils" id="index-7">
<dt><strong class="command">df</strong></dt>
<dd><p class="first">Otro modo de extraer la información sobre los puntos de montaje y sus
particiones asociadas y, de paso, conocer cuál es el grado de ocupación
es el comando <strong class="command">df</strong>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> df -h
<span class="go">S.ficheros                 Tamaño Usados  Disp Uso% Montado en</span>
<span class="go">/dev/dm-0                    1,8G   892M  840M  52% /</span>
<span class="go">udev                          10M      0   10M   0% /dev</span>
<span class="go">tmpfs                         24M   4,4M   19M  19% /run</span>
<span class="go">tmpfs                         59M      0   59M   0% /dev/shm</span>
<span class="go">tmpfs                        5,0M      0  5,0M   0% /run/lock</span>
<span class="go">tmpfs                         59M      0   59M   0% /sys/fs/cgroup</span>
<span class="go">/dev/mapper/vgserver-mysql   225M   2,1M  207M   1% /var/lib/mysql</span>
<span class="go">/dev/mapper/vgserver-home    225M   2,1M  207M   1% /home</span>
</pre></div>
</div>
<p class="last">Con la opción <code class="docutils literal notranslate"><span class="pre">-h</span></code> muestra los tamaños en la unidad de medida más apropiada
(como <strong class="command">ls</strong>) y así es como se ha usado. Aparecen en el listado
algunos sistemas de ficheros virtuales y tres de los cuatro volúmenes lógicos
que ya habíamos detectado con otras herramientas. El cuarto volumen lógico se
usó para memoria de intercambio, así que es lógico que no aparezca.</p>
</dd>
</dl>
<span class="target" id="findmnt"></span><dl class="docutils" id="index-8">
<dt><strong class="command">findmnt</strong></dt>
<dd><p class="first">Es un comando cuya salida es bastante más versátil que la de <strong class="command">df</strong>,
ya que permite indicar qué campos desean obtenerse y de qué sistemas de
ficheros. Por ejemplo:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> findmnt -T /var/lib/mysql -nlo TARGET,USE%
<span class="go">/var/lib/mysql       1%</span>
</pre></div>
</div>
<p class="last">Esta capacidad de seleccionar qué datos queremos mostrar, puede resultarnos
de mucha utilidad en la <a class="reference internal" href="../../03.scripts/index.html#scripts"><span class="std std-ref">programación de scripts</span></a>. Por otro
lado, sin la opción <code class="docutils literal notranslate"><span class="pre">-l</span></code> muestra una salida semejante a <a class="reference internal" href="#lsblk"><span class="std std-ref">lsblk</span></a>, así que podremos ver cómo se organizan los puntos de montaje.</p>
</dd>
</dl>
<span class="target" id="mount"></span><dl class="docutils" id="index-9">
<dt><strong class="command">mount</strong></dt>
<dd><p class="first">No obstante, la herramienta básica para tratar los montajes de dispositivos es
el comando <strong class="command">mount</strong>. Su sintaxis básica es:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">mount [opciones] [&lt;dispositivo&gt;] [&lt;punto_montaje&gt;]</span>
</pre></div>
</div>
<p>En su forma más simple de uso puede ejecutarse sin más<a class="footnote-reference" href="#id23" id="id9">[8]</a>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> mount
<span class="go">sysfs on /sys type sysfs (rw,nosuid,nodev,noexec,relatime)</span>
<span class="go">proc on /proc type proc (rw,nosuid,nodev,noexec,relatime)</span>
<span class="go">udev on /dev type devtmpfs (rw,relatime,size=10240k,nr_inodes=61012,mode=755)</span>
<span class="go">devpts on /dev/pts type devpts (rw,nosuid,noexec,relatime,gid=5,mode=620,ptmxmode=000)</span>
<span class="go">tmpfs on /run type tmpfs (rw,nosuid,relatime,size=101240k,mode=755)</span>
<span class="go">/dev/mapper/vgserver-root on / type ext4 (rw,relatime,errors=remount-ro,data=ordered)</span>
<span class="go">[...]</span>
<span class="go">/dev/mapper/vgserver-home on /home type ext4 (rw,relatime,data=ordered)</span>
<span class="go">/dev/mapper/vgserver-mysql on /var/lib/mysql type ext4 (rw,relatime,data=ordered)</span>
<span class="go">rpc_pipefs on /run/rpc_pipefs type rpc_pipefs (rw,relatime)</span>
</pre></div>
</div>
<p>y mostrará todos los sistemas montados con expresión de en qué dispositivo se
montan y con qué opciones de montaje. Últimamente no es un método muy elocuente
para descubrir cuáles son los sistemas de ficheros que montamos en nuestro
linux, ya que linux, cada vez más, monta sistemas de ficheros virtuales
(<em>devtmpfs</em>, <em>proc</em>, <em>sysfs</em>, <em>tmpfs</em>, etc.), con lo que los sistemas de
ficheros que corresponden a <em>particiones</em> (en el sentido más amplio) quedan algo
escondidos en la maraña de montajes.</p>
<p><strong class="command">mount</strong>, empero, no sólo sirve para ver los sistemas ya montados, sino
también para la acción de montar. Al hilo de esto, es importante tener claras
varias ideas:</p>
<ul class="simple">
<li>Con <strong class="command">mount</strong> realizamos montajes manuales lo cual para un sistema
de escritorio puede resultar engorroso. Para estos sistemas se usan
herramientas de autodetección y automontado como las que proporcionan los
grandes escritorios (<em>gnome</em>, <em>kde</em>, etc…) u otras independientes como
<a class="reference external" href="https://wiki.archlinux.org/index.php?title=Udisks">udiskie</a>. Dado que
nuestra intención es llegar a administrar servidores, prescindiremos de esta
cómoda vía.</li>
<li>Para montar un sistema de ficheros, obviamente, es necesario indicar el
sistema de ficheros y el punto de montaje.</li>
<li>Hay sistemas de ficheros que se montan automáticamente en el arranque
(los montajes sobre <code class="file docutils literal notranslate"><span class="pre">/</span></code> o sobre <code class="file docutils literal notranslate"><span class="pre">/home</span></code>, por ejemplo), así que
tiene que haber algún sitio donde se asocien sistemas de ficheros a puntos
de montaje.</li>
</ul>
<p>Comencemos obviando la existencia de este <em>sitio</em> y montemos un sistema de
ficheros. Para ello, imaginemos que pinchamos una memoria <em>usb</em><a class="footnote-reference" href="#id24" id="id10">[9]</a>, lo que
provocará que aparezca un nuevo un nuevo disco (y una nueva partición si suponemos
que esta existe):</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> ls /dev/sd*
<span class="go">/dev/sda    /dev/sda1    /dev/sdb    /dev/sdb1</span>
</pre></div>
</div>
<p>Si existe esa primera partición y está formateada con un sistema de ficheros
entendible por nuestro linux, montarlo es tan fácil cómo:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> mount /dev/sdb1 /mnt
</pre></div>
</div>
<p>Se ha escogido como punto de montaje <code class="file docutils literal notranslate"><span class="pre">/mnt</span></code>, porque este es el indicado
cuando se hacen montajes manuales (véase <a class="reference internal" href="01.filesystem.html#filesystem"><span class="std std-ref">el apartado correspondiente</span></a>). <strong class="command">mount</strong> es medianamente inteligente, así
que no hace falta decirle en qué sistema de ficheros está formateado <em>sdb1</em>:
él sólo lo descubre. Además, hay definidas unas opciones de montaje
predeterminadas para el sistema de ficheros en cuestión (<em>ext4</em>, por ejemplo) y
esas serán las que se apliquen. Sin embargo, si queremos especificar otras, es
posible hacerlo a través de la opción <code class="docutils literal notranslate"><span class="pre">-o</span></code>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> mount -o ro /dev/sdb1 /mnt
</pre></div>
</div>
<p>En este caso montamos el sistema de ficheros como de sólo lectura, por lo que no
podremos escribir en él. Una opción muy socorrida es volver a montar el sistema,
sin llegar a desmontarlo, para cambiar las opciones. Por ejemplo, si decidimos
en algún momento que queremos escribir en <code class="file docutils literal notranslate"><span class="pre">/mnt</span></code>, podemos hacer lo
siguiente:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> mount -o remount,rw /mnt
</pre></div>
</div>
<p><em>linux</em> permite montar un directorio sobre otro. Esto supone que el contenido
de un directorio aparecerá como contenido del otro<a class="footnote-reference" href="#id25" id="id11">[10]</a>. Por ejemplo:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> mount -o <span class="nb">bind</span> /home /mnt
</pre></div>
</div>
<p>provocará que el contenido de <code class="file docutils literal notranslate"><span class="pre">/home</span></code> aparezca también dentro de
<code class="file docutils literal notranslate"><span class="pre">/mnt</span></code>.</p>
<p>Hay ciertas ocasiones en las que deseamos especificar el sistema de ficheros en
que queremos montar la partición. Por ejemplo, en el caso de particiones <em>ntfs</em>
puede hacerse necesario:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> mount -t ntfs-3g /dev/sdb1 /mnt
</pre></div>
</div>
<div class="last admonition note">
<p class="first admonition-title">Nota</p>
<p class="last"><strong class="command">mount</strong> también permite montar ficheros que contienen sistemas de
ficheros (como, por ejemplo, la imagen <em>iso</em> de un cdrom). Si tiene
interés en ello, consulte el apartado sobre <a class="reference internal" href="../99.misc/04.loop.html#loop"><span class="std std-ref">montaje de imágenes</span></a>.</p>
</div>
</dd>
</dl>
<span class="target" id="umount"></span><dl class="docutils" id="index-10">
<dt><strong class="command">umount</strong></dt>
<dd><p class="first">El proceso inverso de montar, o sea, desmontar, se hace con el comando
<strong class="command">umount</strong>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> umount /mnt
</pre></div>
</div>
<p class="last">En este caso, basta con indicar el punto de montaje. Esta acción, no obstante,
puede fallar como consecuencia de que el dispositivo esté aún ocupado. Por
ejemplo, porque en alguna terminal nos hayamos quedado dentro de algún
directorio dentro de <code class="file docutils literal notranslate"><span class="pre">/mnt</span></code>.</p>
</dd>
</dl>
<span class="target" id="lsof"></span><dl class="docutils" id="index-11">
<dt><strong class="command">lsof</strong></dt>
<dd><p class="first">En ocasiones saber por qué está ocupado el dispositivo es sumamente sencillo:
puede deberse simplemente a que hayamos estado trabajando dentro de él y
hayamos intentado desmontar sin salirnos a un directorio externo. Pero en
otras cosas no es tan evidente, ya que el estar ocupado puede deberse a que
haya un programa en segundo plazo que esté trabajando sobre él. La mejor
forma de saber quién o quiénes son los culpables de la ocupación es usar el
comando <strong class="command">lsof</strong>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> lsof /mnt
</pre></div>
</div>
<p>que nos dirá quién esta usando qué y sobre qué fichero. Conocido el caso,
podremos tomar la determinación de solucionar el problema o, si es un proceso
que requiere terminarse, decirle a <strong class="command">umount</strong> que desmonte el
dispositivo cuando quede libre:</p>
<div class="last highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> umount -l /mnt
</pre></div>
</div>
</dd>
</dl>
<span class="target" id="swapon"></span><dl class="docutils" id="index-12">
<dt><strong class="command">swapon</strong></dt>
<dd><p class="first">Sirve para <em>montar</em> (o sea, para activar) dispositivos como memoria de
intercambio que fuera formateados con <a class="reference internal" href="#mkswap"><span class="std std-ref">mkswap</span></a>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> swapon /dev/sdb2
</pre></div>
</div>
<p class="last">Suponiendo que <code class="file docutils literal notranslate"><span class="pre">/dev/sdb2</span></code> sea la partición que se quiere usar para
intercambio.</p>
</dd>
</dl>
<span class="target" id="swapoff"></span><dl class="docutils" id="index-13">
<dt><strong class="command">swapoff</strong></dt>
<dd><p class="first">Desactiva una partición como memoria de intercambio:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> swapoff /dev/sdb2
</pre></div>
</div>
<p class="last">Para que la operación tenga éxito, la memoria de intercambio no debe estarse
usando. Esto puede consultarse con el comando <a class="reference internal" href="../99.misc/01.anahw.html#free"><span class="std std-ref">free</span></a>.</p>
</dd>
</dl>
<p id="fstab">Para rematar este epígrafe sobre montaje de dispositivos queda describir cómo
linux sabe de antemano qué sistemas de ficheros debe montar y sobre qué puntos
de montaje. Esto lo logra gracias al fichero <code class="file docutils literal notranslate"><span class="pre">/etc/fstab</span></code><a class="footnote-reference" href="#id26" id="id12">[11]</a>, que tiene
líneas con el siguiente aspecto:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> <span class="m">1</span>.                                      <span class="m">2</span>.        <span class="m">3</span>.    <span class="m">4</span>.               <span class="m">5</span>.       <span class="m">6</span>.
<span class="gp">#</span> --------------------------------------- --------- ----  ----------------- ------  ----
<span class="go">UUID=31f3c189-8786-4dd6-a826-91bbf8777a74 /         ext4  errors=remount-ro 0       1</span>
<span class="go">UUID=2bee799a-740b-4106-90ad-d9a155d85afe /home     ext4  defaults          0       2</span>
</pre></div>
</div>
<p>Este fichero desglosa, línea a línea, los sistemas de ficheros definidos en el
servidor y define las reglas para su montaje. Cada línea consta de seis campos:</p>
<table border="1" class="docutils">
<colgroup>
<col width="22%" />
<col width="78%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Campo</th>
<th class="head">Descripción</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><ol class="first last arabic simple">
<li>Dispositivo</li>
</ol>
</td>
<td>El dispositivo cuyas reglas define la línea</td>
</tr>
<tr class="row-odd"><td><ol class="first last arabic simple" start="2">
<li>Punto de montaje</li>
</ol>
</td>
<td>El directorio sobre el que se montará el dispositivo</td>
</tr>
<tr class="row-even"><td><ol class="first last arabic simple" start="3">
<li>Tipo de sistema</li>
</ol>
</td>
<td>El sistema de ficheros en el que está formateado el dispositivo</td>
</tr>
<tr class="row-odd"><td><ol class="first last arabic simple" start="4">
<li>Opciones</li>
</ol>
</td>
<td>Las opciones de montaje con las que se monta el sistema de ficheros</td>
</tr>
<tr class="row-even"><td><ol class="first last arabic simple" start="5">
<li>Volcado</li>
</ol>
</td>
<td>Si el sistema necesita ser volcado o no.</td>
</tr>
<tr class="row-odd"><td><ol class="first last arabic simple" start="6">
<li>Chequeo</li>
</ol>
</td>
<td>Orden en que se comprueban los sistemas de ficheros.</td>
</tr>
</tbody>
</table>
<p>Para separar un campo de otro basta con usar uno o más caracteres de espaciado
(espacios o tabulaciones). Lo habitual es que se escriban de modo que los campos
queden alineados en vertical formando columnas.</p>
<dl class="docutils">
<dt><strong>Dispositivo</strong></dt>
<dd><p class="first">Define el dispositivo (partición, volumen lógico, etc.) que se desea montar.</p>
<p>La manera más directa de hacer referencia a él es a través del nombre que
recibe dentro de <code class="file docutils literal notranslate"><span class="pre">/dev/</span></code>. Por ejemplo, si deseáramos montar la segunda
partición del primer disco, nos referiríamos a <code class="file docutils literal notranslate"><span class="pre">/dev/sda2</span></code>. Sin
embargo, esto modo de referirnos a los dispositivos no es muy adecuado. La
razón es que si hay cambios en el hardware o el disco se traslada a otro
ordenador, puede ocurrir que tal disco deje de ser <em>sda</em> y pase a ser <em>sdc</em>.
En tal caso, el dispositivo sería <code class="file docutils literal notranslate"><span class="pre">/dev/sdc2</span></code> y, consecuentemente, el
mentaje dejaría de funcionar. Si, además, estamos hablando de partes
esenciales del sistema que se deben montar en el arranque como <code class="file docutils literal notranslate"><span class="pre">/</span></code> o
<code class="file docutils literal notranslate"><span class="pre">/home</span></code> el resultado es que el sistema ni siquiera será capaz de
iniciarse.</p>
<p>Para evitar estos inconvenientes, existen dos modos alternativos para
referirnos en <code class="file docutils literal notranslate"><span class="pre">/etc/fstab</span></code> al dispositivo: a través de</p>
<ol class="arabic simple">
<li>Una etiqueta (<em>LABEL</em>)</li>
<li>Un identificador (<abbr title="universally unique identifier">UUID</abbr>).</li>
</ol>
<p>Tanto la etiqueta como el identificador se adjudican al sistema de ficheros
contenido en el dispositivo en el momento en que se <a class="reference internal" href="#mkfs"><span class="std std-ref">formatea</span></a>,
la diferencia es que la etiqueta la fija el usuario, mientras que el
identificador es un número de <em>128</em> bits, que se crea aleatoriamente<a class="footnote-reference" href="#id27" id="id13">[12]</a>.</p>
<p>Para usar etiqueta o identificador basta con escribir:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">LABEL=RAIZ</span>
</pre></div>
</div>
<p>si se trata de una etiqueta y le pusimos <em>RAIZ</em> al formatearlo, o:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">UUID==63491fd0-3abd-4c27-ab8e-6dec89fd7c4a</span>
</pre></div>
</div>
<p class="last">si se trata de un identificador. Dada la longitud del identificador es casi
imposible que en dos dispositivos se haya generado el mismo <em>UUID</em> con lo que
podemos estar seguros de que este es único. No podemos decir lo mismo de las
etiquetas, así que es más conveniente usar el <em>UUID</em>, para expresar el
dispositivo.</p>
</dd>
<dt><strong>Punto de montaje</strong></dt>
<dd>No hay mucho que explicar: símplemente consiste en indicar el directorio que
servirá como punto de montaje. Por ejemplo, <code class="file docutils literal notranslate"><span class="pre">/home</span></code>.</dd>
<dt><strong>Tipo de sistema</strong></dt>
<dd><p class="first">Debe especificarse el sistema de ficheros en que está formateado el
dipositivo o partición (<em>ext3</em>, <em>xfs</em>, <em>ntfs</em>, <em>nfs</em>, etc). Puede ser <em>none</em>
en algunos casos (p.e. cuando se monta un directorio sobre otro, véase la
opción <code class="docutils literal notranslate"><span class="pre">bind</span></code> de <a class="reference internal" href="#mount"><span class="std std-ref">mount</span></a>.</p>
<p>También puede indicarse <em>auto</em> para que el sistema se encargue de adivinar
cuál es el tipo del sistema de ficheros.</p>
<div class="last admonition note">
<p class="first admonition-title">Nota</p>
<p class="last">Cuando el dispositivo se usa como memoria de intercambio, se indica son
<em>swap</em>.</p>
</div>
</dd>
<dt><strong>Opciones</strong></dt>
<dd><p class="first">Son las opciones con las que se montará el sistema de ficheros. En la página
de manual de <a class="reference internal" href="#mount"><span class="std std-ref">mount</span></a> se enumeran las opciones generales para
cualquier sistema de ficheros y las que son particulares para cada uno. Para
expresarlas basta escribirlas separadas por comas: <kbd class="kbd docutils literal notranslate">ro,nofail</kbd>.</p>
<p>El <em>kernel</em> de linux monta cada sistema con una opciones predeterminadas que
no hace falta especificar, por lo que sólo hace falta indicar las opciones
adicionales o las opciones que contradigan a las predeterminadas. Existe la
palabra <code class="docutils literal notranslate"><span class="pre">defaults</span></code> para expresar las opciones predeterminadas. Sin embargo,
<kbd class="kbd docutils literal notranslate">defaults,ro</kbd> es equivalente a <kbd class="kbd docutils literal notranslate">ro</kbd>, pues las predeterminadas
siempre se usan, por lo que esta palabra sólo es necesaria cuando no se va a
expresar ninguna opción adicional<a class="footnote-reference" href="#id28" id="id14">[13]</a>.</p>
<p>Dentro de las opciones universales para cualquier sistema de ficheros hay
unas cuantas interesantes:</p>
<dl class="docutils">
<dt><strong>noauto</strong></dt>
<dd>No monta durante el arranque el dispositivo: lo predeterminado es que sí
se haga.</dd>
<dt><strong>nofail</strong></dt>
<dd>No provoca fallo que el dispositivo no exista y, por tanto, no se pueda
montar.</dd>
<dt><strong>user</strong></dt>
<dd>Permite montar manualmente el dispositivo a cualquier usuario. Sólo este
mismo usuario podrá desmontarlo.</dd>
<dt><strong>users</strong></dt>
<dd>Como el anterior, pero cualquier usuario podrá desmontarlo.</dd>
</dl>
<div class="last admonition note">
<p class="first admonition-title">Nota</p>
<p class="last">Para los dispositivos que se usan como memoria de intercambio se usa la
opción <em>sw</em>.</p>
</div>
</dd>
<dt><strong>Volcado</strong></dt>
<dd>Indica si se quieren hacer copias de seguridad con <strong class="command">dump</strong>. No suele
usarse, de modo que lo habitual es que se indique <em>0</em> (no hacer copia), y no
<em>1</em>, que significa sí hacerla.</dd>
<dt><strong>Chequeo</strong></dt>
<dd>Indica cómo se llevara a efecto la comprobación del sistema de ficheros al
montarse. Puede tener valores 0, 1 ó 2. <em>0</em> es para aquellos sistemas que no
se desea comprobar; <em>1</em> para el sistema que se monta sobre la raíz del
sistema; y <em>2</em> para el resto de sistemas de ficheros.</dd>
</dl>
<p>Sabido todo esto, ya es posible interpretar una línea de fstab:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">UUID=63491fd0-3abd-4c27-ab8e-6dec89fd7c4a  /  ext4  errors=remount-ro  0  1</span>
</pre></div>
</div>
<p>Esta línea hace que se monte el sistema de ficheros con el <em>UUID</em> indicado como
raíz del sistema, es <em>ext4</em>, se monta con las opciones
predeterminadas, pero si se produce un error, se vuelve a montar cómo sólo
lectura, no se hace copia con <em>dump</em> y se realiza el chequeo del sistema antes
de ningún otro.</p>
<p>Por otro lado, cuando un sistema aparece en <code class="file docutils literal notranslate"><span class="pre">/etc/fstab</span></code>, al hacer un
montaje manual no es necesario más que indicar el punto de montaje, ya que el
las opciones y el dispositivo las toma el comando de tal fichero. Por ejemplo,
si existe una entrada para <code class="file docutils literal notranslate"><span class="pre">/home/store</span></code>, bastará con montarla del
siguiente modo:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> mount /home/store
</pre></div>
</div>
</div>
<div class="section" id="lectura">
<h3>2.2.3.2.4. Lectura<a class="headerlink" href="#lectura" title="Enlazar permanentemente con este título">¶</a></h3>
<p>La forma más natural de leer un dispostivo es la más obvia: se monta ésta y se
accede a sus ficheros y directorios. Sin embargo, en ocasiones, es interesante
recurrir a una lectura (o una escritura) de <em>bajo nivel</em>, es decir, una lectura
<em>byte</em> a <em>byte</em> del dispositivo.</p>
<div class="admonition note">
<p class="first admonition-title">Nota</p>
<p class="last">Para el pleno entendimiento de este apartado es necesario saber qué son y
cómo funcionan las <a class="reference internal" href="../08.redirecciones/index.html#ioredirect"><span class="std std-ref">redirecciones</span></a>.</p>
</div>
<p>Un caso muy habitual es el de querer hacer una copia de seguridad exacta del
dispostivo. Esto implica leer <em>byte</em> a <em>byte</em> el dispotivo y almacenar la
lectura en un fichero, O sea, si queremos hacer una copia de la primera
partición del disco:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> cat /dev/sda1 &gt; particion1.img
</pre></div>
</div>
<p>Esto, no obstante, genera unos ficheros muy grandes, tan grandes como grande es
la partición, por lo que, comúnmente, lo que se hace es almacenar la imagen
comprimida:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> xz -9c &lt; /dev/sda1 &gt; particion1.img.xz
</pre></div>
</div>
<p>La recuperación de estas imágenes consiste simplemente en hacer la lectura y la
escritura en sentido inverso:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> cat particion1.img &gt; /dev/sda1
</pre></div>
</div>
<p>o bien, si la imagen estaba comprimida:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> xzcat particion1.img.xz &gt; /dev/sda1
</pre></div>
</div>
<p>Cuando se realiza esta recuperación, basta con que la partición en que se
vuelque la imagen sea, como mínimo, del mismo tamaño que la partición original
<a class="footnote-reference" href="#id29" id="id15">[14]</a>.</p>
<span class="target" id="dd"></span><dl class="docutils" id="index-14">
<dt><strong class="command">dd</strong></dt>
<dd><p class="first"><strong class="command">cat</strong> permite hacer lecturas o escrituras, pero la operación acaba
bien cuando se acaba el soporte de lectura o bien cuando se acaba el soporte
de almacenamiento. Si lo que pretendemos en controlar cuántos <em>bytes</em> se leen
o escriben, la herramienta adecuada es <strong class="command">dd</strong>.</p>
<p>En principio, podemos usar <strong class="command">dd</strong> del mismo modo que <strong class="command">cat</strong>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> dd &lt; /dev/sda &gt; copia.img
</pre></div>
</div>
<p>de modo que haremos una copia exacta del dispositivo. Sin embargo, la
utilidad de <strong class="command">dd</strong> radica en escoger cúanto queremos copiar. Para ello
tiene dos argumentos fundamentales, <code class="docutils literal notranslate"><span class="pre">bs</span></code> y <code class="docutils literal notranslate"><span class="pre">count</span></code>, que nos permiten
indicar respectivamente qué cantidad de <em>bytes</em> queremos leer y escribir de
una tacada y cuántas veces. Por ejemplo, la orden:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> dd <span class="nv">bs</span><span class="o">=</span><span class="m">512</span> <span class="nv">count</span><span class="o">=</span><span class="m">1</span> &lt; /dev/sda &gt; mbr.img
</pre></div>
</div>
<p>hace una copia del <abbr title="Master Boot Record">MBR</abbr> del disco <em>sda</em>, ya que
este es el primer sector ( 512 <em>bytes</em>) del disco duro. Cuando no se quiere
empezar a leer desde el principio se puede usar el argumento <code class="docutils literal notranslate"><span class="pre">skip</span></code>, que
permite indicar el número de bloques que se desean saltar antes de empezar a
leer del dispositivo de entrada. El tamaño de estos bloques es el indicado
por <code class="docutils literal notranslate"><span class="pre">bs</span></code>. Por ejemplo:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> dd <span class="nv">bs</span><span class="o">=</span>2M <span class="nv">count</span><span class="o">=</span><span class="m">1</span> <span class="nv">skip</span><span class="o">=</span><span class="m">3</span> &lt; /dev/sda &gt; backup.img
</pre></div>
</div>
<p class="last">copiará 2MB de datos del disco saltándose el primeros 6MB.</p>
</dd>
</dl>
</div>
</div>
<div class="section" id="ejercicios-sobre-dispositivos">
<h2>2.2.3.3. Ejercicios sobre dispositivos<a class="headerlink" href="#ejercicios-sobre-dispositivos" title="Enlazar permanentemente con este título">¶</a></h2>
<ol class="arabic simple">
<li>Enchufar un disco de 4G a la máquina virtual.</li>
<li>Crear tres particiones primarias en el disco duro de:<ol class="arabic">
<li>1G</li>
<li>2G</li>
<li>1G</li>
</ol>
</li>
<li>Formatear las particiones con las siguientes características:<ol class="arabic">
<li>ext4, etiqueta=PRIMERA</li>
<li>xfs, etiqueta=SEGUNDA</li>
<li>ntfs, etiqueta=WINDOWS</li>
</ol>
</li>
<li>Mountar la partición (1) como sólo lectura.</li>
<li>Crear una entrada en <code class="file docutils literal notranslate"><span class="pre">fstab</span></code> para montar automáticamente la partición
<em>WINDOWS</em> en <code class="file docutils literal notranslate"><span class="pre">/home/windows-data</span></code>.</li>
<li>Investíguese si hay alguna forma de sólo los usuarios pertenecientes
al grupo <em>windoseros</em> puedan escribir en la partición anterior.</li>
<li>Compruebe si puede desmontar o no el sistema de ficheros montado
sobre <code class="file docutils literal notranslate"><span class="pre">/home</span></code>.</li>
<li>Hacer una copia byte a byte de <em>WINDOWS</em> en <code class="file docutils literal notranslate"><span class="pre">/dev/null</span></code>.</li>
<li>¿Cuánto espacio hay ocupado en <code class="file docutils literal notranslate"><span class="pre">/home</span></code>?</li>
<li>Remontar <em>WINDOWS</em> como sólo lectura.</li>
</ol>
<p class="rubric">Notas al pie</p>
<table class="docutils footnote" frame="void" id="id16" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[1]</a></td><td>Excepto las tarjetas de red.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id17" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3">[2]</a></td><td>En realidad, los ficheros de dipositivo son tres: los dos referidos y los
dispositivos orientados a <strong>sockets</strong> que sirven para comunicar procesos
entre sí. No se refieren bajo este epígrafo porque suelen encontrarse bajo
<code class="file docutils literal notranslate"><span class="pre">/var/run</span></code>.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id18" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id4">[3]</a></td><td><p class="first"><code class="file docutils literal notranslate"><span class="pre">/dev/tty</span></code>, sin número, representa la terminal activa, sea terminal
o pseudo terminal. De hecho si probamos a hacer:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> <span class="nb">echo</span> <span class="s2">&quot;Estoy aqui&quot;</span> &gt; /dev/tty
</pre></div>
</div>
<p class="last">Veremos como se escribe la frase en la terminal que estamos usando.</p>
</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id19" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id5">[4]</a></td><td>Es socorridísimo. Cuando queremos desechar la salida de alguna orden, basta
con que lo redirigamos a él.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id20" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id6">[5]</a></td><td>En la transición entre discos IDE y SATA, se solían mapear los discos IDE
como SATA, de modo que también se representaban mediante ficheros
<code class="file docutils literal notranslate"><span class="pre">/dev/sdN</span></code>.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id21" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id7">[6]</a></td><td>Tratar sobre las particiones, los tipos de particiones y el particiado en
sí requeriría un epígrafe amplio.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id22" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id8">[7]</a></td><td>Puede encontrarse una explicación detallada <a class="reference external" href="http://docs.iescdl.es/~josem/discos.html">aquí</a>.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id23" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id9">[8]</a></td><td><p class="first">Como alternativa a usar <strong class="command">mount</strong> como consulta puede inspeccionarse
el contenido del fichero <code class="file docutils literal notranslate"><span class="pre">/proc/mounts</span></code>:</p>
<div class="last highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> cat /proc/mounts
</pre></div>
</div>
</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id24" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id10">[9]</a></td><td>Si se trabaja con una máquina virtual, puede ser algo engorroso hacer que esta
vea una unidad externa; por lo que es bastante más simple enchufar un nuevo disco
virtual. Eso sí, deberá tener al menos una partición y estar esta formateada.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id25" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id11">[10]</a></td><td>Tiene utilidad en algunos casos. Por ejemplo, en un servidor FTP
enjaulado, permite mostrar un directorio que esté fuera de la jaula.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id26" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id12">[11]</a></td><td>En realidad, con <strong>systemd</strong> han cambiado un poco las cosas. <strong>systemd</strong>
tiene su propia forma de determinar los sistemas que se montan y dónde,
pero tiene un traductor que nos permite seguir usando <code class="file docutils literal notranslate"><span class="pre">/etc/fstab</span></code>
como desde hace treinta años.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id27" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id13">[12]</a></td><td>Algunos sistemas (p.e. <em>ext4</em>) permiten fijar también el identificador,
aunque no es lo habitual y rara vez se tiene necesidad de ello.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id28" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id14">[13]</a></td><td>Y es que necesariamente hay que escribir algo en cada campo, por lo que
si no se necesitan modificar las opciones predeterminadas, habrá que
escribir <kbd class="kbd docutils literal notranslate">defaults</kbd>.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id29" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id15">[14]</a></td><td>Si es más grande, no obstante, es necesario redimensionar el sistema de
ficheros después de hacer la restauración para poder aprovechar el espacio
extra.</td></tr>
</tbody>
</table>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../../index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">2.2.3. Dispositivos</a><ul>
<li><a class="reference internal" href="#lo-que-esconde-dev">2.2.3.1. Lo que esconde <code class="file docutils literal notranslate"><span class="pre">/dev</span></code></a></li>
<li><a class="reference internal" href="#dispositivos-de-almacenamiento">2.2.3.2. Dispositivos de almacenamiento</a><ul>
<li><a class="reference internal" href="#de-cuales-dispongo">2.2.3.2.1. ¿De cuáles dispongo?</a></li>
<li><a class="reference internal" href="#preparacion-de-dispositivos">2.2.3.2.2. Preparación de dispositivos</a></li>
<li><a class="reference internal" href="#montaje-de-dispositivos">2.2.3.2.3. Montaje de dispositivos</a></li>
<li><a class="reference internal" href="#lectura">2.2.3.2.4. Lectura</a></li>
</ul>
</li>
<li><a class="reference internal" href="#ejercicios-sobre-dispositivos">2.2.3.3. Ejercicios sobre dispositivos</a></li>
</ul>
</li>
</ul>

  <h4>Tema anterior</h4>
  <p class="topless"><a href="03.ficheros.html"
                        title="capítulo anterior">2.2.2. Ficheros y directorios</a></p>
  <h4>Próximo tema</h4>
  <p class="topless"><a href="../05.seguridad/index.html"
                        title="próximo capítulo">2.3. Seguridad en el sistema de ficheros</a></p>
  <div role="note" aria-label="source link">
    <h3>Esta página</h3>
    <ul class="this-page-menu">
      <li><a href="../../_sources/02.conbas/02.informacion/04.devices.rst.txt"
            rel="nofollow">Mostrar el código</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Búsqueda rápida</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Ir a" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navegación</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="Índice General"
             >índice</a></li>
        <li class="right" >
          <a href="../05.seguridad/index.html" title="2.3. Seguridad en el sistema de ficheros"
             >siguiente</a> |</li>
        <li class="right" >
          <a href="03.ficheros.html" title="2.2.2. Ficheros y directorios"
             >anterior</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">documentación de ServidorLinux - 0.1.0</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" >2. Conceptos básicos</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="index.html" >2.2. Acceso a la información</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Derechos de autor 2016, José Miguel Sánchez Alés.
      Creado con <a href="http://sphinx-doc.org/">Sphinx</a> 1.8.5.
    </div>
  </body>
</html>