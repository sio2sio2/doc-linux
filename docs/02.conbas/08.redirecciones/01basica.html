


<!DOCTYPE html>

<html lang="es">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>2.5.1. Redirección básica &#8212; documentación de Linuxnomicón - rolling</title>
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
    
    <script id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/translations.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <link rel="index" title="Índice" href="../../genindex.html" />
    <link rel="search" title="Búsqueda" href="../../search.html" />
    <link rel="next" title="2.5.2. Redirección avanzada" href="02avanzada.html" />
    <link rel="prev" title="2.5. Redirección de E/S" href="index.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navegación</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="Índice General"
             accesskey="I">índice</a></li>
        <li class="right" >
          <a href="02avanzada.html" title="2.5.2. Redirección avanzada"
             accesskey="N">siguiente</a> |</li>
        <li class="right" >
          <a href="index.html" title="2.5. Redirección de E/S"
             accesskey="P">anterior</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">documentación de Linuxnomicón - rolling</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" ><span class="section-number">2. </span>Conceptos básicos</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="index.html" accesskey="U"><span class="section-number">2.5. </span>Redirección de E/S</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href=""><span class="section-number">2.5.1. </span>Redirección básica</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="redireccion-basica">
<span id="ioredirect-bas"></span><h1><span class="section-number">2.5.1. </span>Redirección básica<a class="headerlink" href="#redireccion-basica" title="Enlazar permanentemente con este título">¶</a></h1>
<p>Para este caso trataremos sólo los tres ficheros antes indicados:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 32%" />
<col style="width: 35%" />
<col style="width: 33%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Nombre</p></th>
<th class="head"><p>Dipositivo</p></th>
<th class="head"><p>Descriptor asociado</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Entrada estándar</p></td>
<td><p><code class="file docutils literal notranslate"><span class="pre">/dev/stdin</span></code></p></td>
<td><p>0</p></td>
</tr>
<tr class="row-odd"><td><p>Salida estándar</p></td>
<td><p><code class="file docutils literal notranslate"><span class="pre">/dev/stdout</span></code></p></td>
<td><p>1</p></td>
</tr>
<tr class="row-even"><td><p>Salida de errores</p></td>
<td><p><code class="file docutils literal notranslate"><span class="pre">/dev/stderr</span></code></p></td>
<td><p>2</p></td>
</tr>
</tbody>
</table>
<p>y no haremos redirecciones permanentes.</p>
<p>La tercera columna, intitulada <em>Descriptor asociado</em>, hace referencia al
descriptor de fichero, o sea, al número entero, con el que es posible hacer
referencia al fichero en cuestión.</p>
<div class="section" id="salida">
<h2><span class="section-number">2.5.1.1. </span>Salida<a class="headerlink" href="#salida" title="Enlazar permanentemente con este título">¶</a></h2>
<p>La redirección de salida consiste en redirigir la salida estándar o la salida
de errores hacia otro fichero que puede ser la otra salida o un fichero
regular.</p>
<p>Consideremos la siguiente orden:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> cat
</pre></div>
</div>
<p>Sabemos ya que el comando leerá de teclado (la entrada estándar) y escribirá en
la pantalla (la salida estándar). Si queremos redirigir la salida hacia un
fichero regular, basta con lo siguiente:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> cat &gt; contenedor_de_tonterias
<span class="go">Esto que escribo, ya no aparece por la pantalla,</span>
<span class="go">puesto que se redirige la salida estándar</span>
<span class="go">hacia un fichero llamado &#39;contenedor_de_tonterias&#39;.</span>
</pre></div>
</div>
<p>Tal fichero puede o no existir: si no existe, se creará; si existe, se
sustituirá su anterior contenido por lo que escribamos ahora. Es posible también
redirigir al fichero añadiendo en vez de sustituyendo:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> cat &gt;&gt; contenedor_de_tonterías
<span class="go">Añadimos un par de líneas adicionales</span>
<span class="go">a las que escribimos antes</span>
</pre></div>
</div>
<p>El resultado es que el fichero contendrá 5 líneas: ls tres anteriores y estas
dos nuevas, en vez de contener sólo estas dos últimas, lo cual habría ocurrido
si hubiéramos usado una redirección simple.</p>
<p>Hay ocasiones en que redirigimos la salida no porque deseemos guardar
resultados, sino porque deseamos no verlos. En este caso, es sumamente útil
el fichero especial <code class="file docutils literal notranslate"><span class="pre">/dev/null</span></code>, que se traga todo lo que le echemos sin
dejar rastro:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> ls /usr/bin/ &gt; /dev/null
</pre></div>
</div>
<p>Ahora bien, ¿por qué hemos redirigido la salida estándar y no la salida de
errores? La razón está en que cuando no se indica cuál, se sobreentiende que nos
referimos al descriptor <em>1</em>, esto es, a la salida estándar. La sintaxis general
de la redirección es:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">N&gt; destino</span>
</pre></div>
</div>
<p>donde <code class="docutils literal notranslate"><span class="pre">N</span></code> es el número del descriptor. La ausencia de <code class="docutils literal notranslate"><span class="pre">N</span></code> implica 1. Para la
redirección doble es exactamente igual.</p>
<p>Probemos ahora lo siguiente:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> sadhgaskjhsa &gt; /dev/null
<span class="go">sadhgaskjhsa: no se encontró la orden</span>
</pre></div>
</div>
<p>Como vemos, a pesar de la redirección, hemos visto el mensaje. Esto es debido a
que lo que hemos redirigido es la salida estándar, no la salida de errores, por
lo que esta última sigue saliendo por la pantalla. Para haber evitado ver el
mensaje de error deberíamos haber hecho:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> sadhgaskjhsa <span class="m">2</span>&gt; /dev/null
</pre></div>
</div>
<p>También es posible redirigir una fichero de salida hacia el otro. Por ejemplo,
esto redirige la salida de errores hacia la salida estándar:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> sadhgaskjhsa <span class="m">2</span>&gt;<span class="p">&amp;</span><span class="m">1</span>
<span class="go">sadhgaskjhsa: no se encontró la orden</span>
</pre></div>
</div>
<p>Volvemos a ver por pantalla el error, pero en esta ocasión se escribe el mensaje
en la salida de errores no en la estándar. De hecho:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> sadhgaskjhsa &gt;contenedor_del_error <span class="m">2</span>&gt;<span class="p">&amp;</span><span class="m">1</span>
</pre></div>
</div>
<p>Escribe el mensaje de error en el fichero. En realidad, se redirigen tanto la
salida estándar como la de errores<a class="footnote-reference brackets" href="#id5" id="id1">1</a>. No obstante, para esto último, es más
sencillo redirigir ambas salidas a la vez, para lo cual hay un símbolo propio:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> ls /y* <span class="p">&amp;</span>&gt; /dev/listado.txt
</pre></div>
</div>
<p>Téngase en cuenta que esta última notación es propia de <strong class="program">bash</strong> y no
funciona en <strong class="program">dash</strong>.</p>
</div>
<div class="section" id="entrada">
<h2><span class="section-number">2.5.1.2. </span>Entrada<a class="headerlink" href="#entrada" title="Enlazar permanentemente con este título">¶</a></h2>
<p>Por su parte, redirigir la entrada consiste en alimentar con una fuente
alternativa a un programa que espera recibir datos desde la entrada estándar,
que en un principio es el teclado. El caso más sencillo es:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> cat &lt; fichero
<span class="go">[ ...Se muestra el contenido del fichero... ]</span>
</pre></div>
</div>
<p>Como <strong class="command">cat</strong> no tiene argumentos espera recibir datos a través de la
entrada estándar; pero, como con secuencia de la redirección, esta pasa de ser el
teclado a ser el fichero. Consecuentemente, lo que muestra <strong class="command">cat</strong> es el
contenido del fichero. En realidad, esto es equivalente a:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> cat <span class="m">0</span>&lt; fichero
</pre></div>
</div>
<p>Ya que <strong>0</strong> es el descriptor que representa la entrada estándar. Esta es la base de la redirección de entrada.</p>
<p id="sh-here-document">Otra redirección de entrada que también forma parte del estándar es la llamada
<strong>Here Document</strong> que permite redirigir hacia la entrada estándar un texto largo
de varias líneas. Para ello se define una palabra delimitadora, de manera que
cuando se vuelva a encontrar esta misma palabra delimitadora sola al principio
de línea, se considerará acabado el texto. Por ejemplo, si hacemos que nuestro
delimitador sea <kbd class="kbd docutils literal notranslate">EOF</kbd>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> cat <span class="s">&lt;&lt;EOF</span>
<span class="gp">&gt;</span><span class="s"> En un país multicolor</span>
<span class="gp">&gt;</span><span class="s"> había una abeja bajo el sol</span>
<span class="gp">&gt;</span><span class="s"> EOF</span>
<span class="go">En un país multicolor</span>
<span class="go">había una abeja bajo el sol.</span>
</pre></div>
</div>
<p>En el texto, la <em>shell</em> intentará llevar a cabo sustituciones por lo que:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> cat <span class="s">&lt;&lt;EOF</span>
<span class="gp">&gt;</span><span class="s"> 4 * 2 = $((4*2))</span>
<span class="gp">&gt;</span><span class="s"> EOF</span>
<span class="go">4 * 2 = 8</span>
</pre></div>
</div>
<p>Ahora bien, si se rodea el delimitador de inicio con comillas dobles o simples,
no se interpretará nada:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> cat &lt;&lt;<span class="s2">&quot;EOF&quot;</span>
<span class="gp">&gt;</span> <span class="m">4</span> * <span class="nv">2</span> <span class="o">=</span> <span class="k">$((</span><span class="m">4</span><span class="o">*</span><span class="m">2</span><span class="k">))</span>
<span class="gp">&gt;</span> EOF
<span class="go">4 * 2 = $((4*2))</span>
</pre></div>
</div>
<p>Es posible anteponer al primer delimitador un guión para que pueda sangrarse
(exclusivamente con tabulaciones) el texto del <em>documento</em> en línea que se
escribe. Es útil cuando se programa y se quiere mantener el código
correctamente sangrado:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> cat &lt;&lt;-EOF
<span class="go">   Mi hogar es $HOME</span>
<span class="go">   EOF</span>
<span class="go">Mi hogar es /home/usuario</span>
</pre></div>
</div>
<p class="rubric" id="bash-here-string">Here String</p>
<p><strong class="command">bash</strong>, además, ofrece esta redirección adicional, que
permite redirigir hacia la entrada estándar una cadena:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> cat <span class="o">&lt;&lt;&lt;</span>Hola,<span class="se">\ </span>don<span class="se">\ </span>Pepito.
<span class="go">Hola, don Pepito.</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>Obsérvese que <em>Here String</em> no es más que el caso particular de un
<em>Here Document</em> de una sola línea:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> cat <span class="s">&lt;&lt;EOF</span>
<span class="gp">&gt;</span><span class="s"> Hola, don Pepito.</span>
<span class="gp">&gt;</span><span class="s"> EOF</span>
<span class="go">Hola, don Pepito</span>
</pre></div>
</div>
<p>por lo que si al escribir un <em>script</em> en que deseamos evitar las extensiones
de <strong class="program">bash</strong> tenemos necesidad de usar un <em>Here String</em><a class="footnote-reference brackets" href="#id6" id="id2">2</a>, podemos
usar un <em>Here Document</em>.</p>
</div>
</div>
<div class="section" id="tuberias">
<span id="pipeline"></span><h2><span class="section-number">2.5.1.3. </span>Tuberías<a class="headerlink" href="#tuberias" title="Enlazar permanentemente con este título">¶</a></h2>
<p>Las tuberías (<em>pipelines</em> en inglés) son un caso particular de una redirección
de salida junto a una redirección de entrada. Para entender su utilidad
supongamos que, con las herramientas vistas, se nos propone mostrar únicamente
la penúltima línea de <code class="file docutils literal notranslate"><span class="pre">/etc/group</span></code>.</p>
<p>Echando mano de la memoria, parece útil <a class="reference internal" href="../02.informacion/03.ficheros.html#tail"><span class="std std-ref">tail</span></a>, capaz de extraer la
parte final de un documento. En concreto:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> tail -n2 /etc/group
<span class="go">libvirt-qemu:x:116:libvirt-qemu</span>
<span class="go">qemusers:x:117:josem</span>
</pre></div>
</div>
<p>muestra las dos últimas líneas. Pero resulta que sólo queremos la penúltima, o
lo que es lo mismo, la primera línea de la salida producida por <strong class="command">tail</strong>.
Pero resulta que <a class="reference internal" href="../02.informacion/03.ficheros.html#head"><span class="std std-ref">head</span></a> permite extraer los comienzos de fichero, de
modo que si aplicamos un <kbd class="kbd docutils literal notranslate"><kbd class="kbd docutils literal notranslate">head</kbd> <kbd class="kbd docutils literal notranslate"></kbd>-<kbd class="kbd docutils literal notranslate">n1</kbd></kbd> a esa salida conseguiremos nuestro
objetivo. Por supuesto es posible hacer:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> tail -n2 /etc/group &gt; /tmp/fichero.intermedio
<span class="gp">$</span> head -n1 &lt; /tmp/fichero.intermedio
<span class="go">libvirt-qemu:x:116:libvirt-qemu</span>
<span class="gp">$</span> rm -f /tmp/fichero.intermedio
</pre></div>
</div>
<p>Pero nos obliga a crear un absurdo fichero intermedio que hay que borrar al
terminar. La solución fetén a nuestro problema son las tuberías (<code class="docutils literal notranslate"><span class="pre">|</span></code>) que
permite redirigir la salida estándar de un programa hacia la entrada estándar
del siguiente:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> tail -n2 /etc/group <span class="p">|</span> head -n1
<span class="go">libvirt-qemu:x:116:libvirt-qemu</span>
</pre></div>
</div>
<p>Esta es básicamente la idea de las tuberías: sencilla, pero que abre muchísimas
posibilidades al permitir construir una herramienta más compleja mediante la
cooperación de herramientas más simples.</p>
<p>La tubería, así escrita, sólo redirige la salida estándar. Si se quieren
redirigir tanto la salida estándar como la de errores puede hacerse:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> ls /g* <span class="m">2</span>&gt;<span class="p">&amp;</span><span class="m">1</span> <span class="p">|</span> tail -n2
</pre></div>
</div>
<p>O bien, usar una sintaxis que sólo es admitida por <strong class="command">bash</strong>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> ls /g* <span class="p">|&amp;</span> tail -n2
</pre></div>
</div>
<p>En lo relativo a redirecciones son muy útiles dos órdenes que las usan:</p>
<span class="target" id="tee"></span><dl id="index-0">
<dt><strong class="command">tee</strong></dt><dd><p>Desdobla su entrada hacia dos salidas: la estándar y el fichero que se
indique:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> ls / <span class="p">|</span> tee /tmp/listado.txt
</pre></div>
</div>
<p>Hecho esto, veremos que el listado aparece en la pantalla, pero también se
habrá almacenado en <code class="file docutils literal notranslate"><span class="pre">/tmp/listado.txt</span></code>.</p>
</dd>
</dl>
<span class="target" id="pv"></span><dl id="index-1">
<dt><strong class="command">pv</strong></dt><dd><p>Este comando, simplemente, cuenta los <em>bytes</em> que recibe por la entrada
estándar y los redirige hacia la salida estándar. Es bastante útil cuando el
flujo de datos es grande y no sabemos muy bien cuándo acabará. Por ejemplo,
supongamos que tenemos en el fichero <code class="file docutils literal notranslate"><span class="pre">disco.img.xz</span></code> la imagen cruda
comprimida de un disco y queremos volcarla sobre el disco físico
<code class="file docutils literal notranslate"><span class="pre">/dev/sdb</span></code>. La solución es trivial:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> xzcat disco.img.xz &gt; /dev/sdb
</pre></div>
</div>
<p>Ahora bien, la descompresión es un proceso lento y la escritura de tantos
datos en el disco, también. Como consecuencia, no sabemos muy bien ni cuánto
tardará ni la velocidad ia la que se van escribiendo datos, con lo que nos
resulta imposible hacernos una idea de cómo va el proceso hasta que
finalmente acaba. La solución es usar <strong class="command">pv</strong><a class="footnote-reference brackets" href="#id7" id="id3">3</a> como
intermediario:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> xzcat disco.img.xz <span class="p">|</span> pv &gt; /dev/sdb
</pre></div>
</div>
<p>De este modo, el proceso de volcado se llevará a cabo igualemente, ya que
<strong class="command">pv</strong> no altera los <em>bytes</em>, pero mostrará información de a qué
velocidad se lleva a cabo el proceso y cuántos <em>bytes</em> han pasado por el
momento a través de él. No, puede, sin embargo, pronosticarnos cuánto tiempo
tardará ni decirnos cuál es el porcentaje ya volcado porque ignora el tamaño
final de aquello que se le pasa. No obstante, si nosotros sabemos cuál es el
tamaño descomprimido de la imagen, porque recordamos de cuánto era el disco
del que la hicimos, entonces es posible indicarle a <strong class="command">pv</strong> cuál es la
cantidad total de bytes que pasará a través de él (<code class="docutils literal notranslate"><span class="pre">-s</span></code>) y pedirle que nos
muestre una barra de progreso con el porcentaje completado (<code class="docutils literal notranslate"><span class="pre">-p</span></code>):</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> xzcat disco.img.xz <span class="p">|</span> pv -ps 250G &gt; /dev/sdb
</pre></div>
</div>
<p>No obstante, para este caso particular, <strong class="command">pv</strong> permite también indicar
en sus argumentos un fichero del que leer, en vez de usar la entrada
estándar. En este caso, <strong class="command">pv</strong> si es capaz de saber cuántos <em>bytes</em>
leerá, puesto que toma el dato del tamaño del fichero, y esto hace que sea
innecesario pasar con <code class="docutils literal notranslate"><span class="pre">-s</span></code> la cantidad. Así pues, lo anterior, habría sido
más inteligente haberlo hecho del siguiente modo:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> pv -p disco.img.xz <span class="p">|</span> xzcat &gt; /dev/sdb
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>Nótese que en este último caso la cantidad de <em>bytes</em> que pasan por
<strong class="command">pv</strong> es significativamente menor, ya que no pasa la imagen
descomprida, sino la comprimida. Por tanto, el total no serán 250GB sino
solamente quizás 5GB, por decir algo. Sin embargo, como los tres comandos
tienen que sincronizarse puesto que unos alimentan a otros, el dato del
tiempo restante y el porcentaje completado es absolutamente verídico. De
hecho, no están sujetos a la arbitrariedad de nuestra memoria ni que a
que, posiblemente, el tamaño de disco no sean exactamente 250GB<a class="footnote-reference brackets" href="#id8" id="id4">4</a>.</p>
</div>
</dd>
</dl>
<p>Por último, debe tener presente que para que se pueda usar una tubería la salida
de una orden (la «A») sea la entrada de la siguiente («B»):</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> ordenA <span class="p">|</span> ordenB
</pre></div>
</div>
<p>exige que la <strong class="program">ordenA</strong> sea capaz de escribir su resultado en la salida
estándar y la <strong class="program">ordenB</strong> sea capaz de leer de la entrada estándar. Sin
embargo, puede ocurrir que la sintaxis de la <strong class="program">ordenA</strong> sólo nos permita
escribir su resultado en un fichero, no en la salida estándar, o que la sintaxis
de la <strong class="program">ordenB</strong> sólo nos permita leer de un fichero y no de la entrada
estándar. En esas condiciones nos es imposible utilizar la tubería y tendremos
que:</p>
<ul>
<li><p>Utilizar el fichero intermedio, que es la estrategia más grosera. Por ejemplo,
si la <strong class="program">ordenB</strong> sólo puede leer de un fichero que se le pasa como
argumento:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> ordenA &gt; /tmp/entrada.txt
<span class="gp">$</span> ordenB /tmp/entrada.txt
<span class="gp">$</span> rm /tmp/entrada.txt
</pre></div>
</div>
<p>La estrategia funciona pero supone que esperemos a que la <strong class="program">ordenA</strong>
acabe de escribir el resultado y, además, que el resultado tengamos que
almacenarlo temporalmente en disco.</p>
</li>
<li><p>Utilizar tuberías con nombre.</p></li>
<li><p>Usar la sintaxis que brinda <strong class="program">bash</strong> llamada en su manual <em>process
substitution</em>.</p></li>
</ul>
<span class="target" id="mkfifo"></span><dl id="index-2">
<dt><strong>Tuberias con nombre</strong></dt><dd><p>Las <em class="dfn">tuberías con nombre</em> consisten en crear un fichero especial que
representa una tubería con la orden <em class="manpage"><a class="manpage reference external" href="https://manpages.debian.org/mkfifo">mkfifo</a></em> y hacer que los dos
programas involucrados lean y escriban en él, como si se tratara de un
fichero regular. La ventaja es que la transferencia de datos se lleva a cabo
del mismo que cuando se usan tuberías anónimas nrmales y por tanto, ambos
procesos se sincronizan la producción y el consumo, por lo que no se
almacenan datos en disco. De estemodo si es la <strong class="program">ordenB</strong> la que tiene
que leer de fichero, podemos hacer:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> mkfifo /tmp/tuberia
<span class="gp">$</span> ordenA &gt; /tmp/tuberia <span class="p">&amp;</span> ordenB /tmp/tuberia
<span class="gp">$</span> rmdir /tmp/tuberia
</pre></div>
</div>
<p>y si es la <strong class="program">ordenA</strong> la que solo puede escribir en un fichero:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> mkfifo /tmp/tuberia
<span class="gp">$</span> ordenA /tmp/tuberia <span class="p">&amp;</span> ordenB &lt;/tmp/tuberia
</pre></div>
</div>
</dd>
</dl>
<dl id="bash-process-substitution">
<dt><strong>Process substitution</strong> (extensión de <strong class="program">bash</strong>, incompatible con <em>POSIX</em>)</dt><dd><p>El primer caso de limitación es que <strong class="program">ordenB</strong> sólo sea capaz de leer de
fichero, esto es, la sintaxis posible es <kbd class="kbd docutils literal notranslate"><kbd class="kbd docutils literal notranslate">ordenB</kbd> <kbd class="kbd docutils literal notranslate">fichero</kbd>-<kbd class="kbd docutils literal notranslate">entrada</kbd></kbd>. Si es
así, la forma imposible:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> ordenA <span class="p">|</span> ordenB
</pre></div>
</div>
<p>se puede resolver con:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> ordenB &lt;<span class="o">(</span>ordenA<span class="o">)</span>
</pre></div>
</div>
<p>mientras que el segundo caso de limitación, que consiste en que
<strong class="program">ordenA</strong> sólo es capaz de escribir su resultado en un fichero, esto
es, que la sintaxis posibles es <kbd class="kbd docutils literal notranslate"><kbd class="kbd docutils literal notranslate">ordenA</kbd> <kbd class="kbd docutils literal notranslate">fichero</kbd>-<kbd class="kbd docutils literal notranslate">salida</kbd></kbd>, como no puede
resolverse:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> ordenA <span class="p">|</span> ordenB
</pre></div>
</div>
<p>se resuelve:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> ordenA &gt;<span class="o">(</span><span class="nv">$ordenB</span><span class="o">)</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>Con <em>POSIX</em> puede subsanarse la carencia, aunque utilizando <a class="reference internal" href="index.html#ioredirect"><span class="std std-ref">técnicas
de redirección</span></a> algo avanzada. Así la expresión:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> ordenB &lt;<span class="o">(</span>ordenB<span class="o">)</span>
</pre></div>
</div>
<p>puede lograrse de este modo:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> ordenA <span class="p">|</span> ordenB /dev/fd/0
</pre></div>
</div>
<p>o de forma más general usando otro descriptor:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> ordenA <span class="m">3</span>&lt;<span class="p">&amp;</span>- <span class="p">|</span> ordenB /dev/fd/3 <span class="m">3</span>&lt;<span class="p">&amp;</span><span class="m">0</span>
</pre></div>
</div>
<p>Por su parte:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> ordenA &gt;<span class="o">(</span>ordenB<span class="o">)</span>
</pre></div>
</div>
<p>puede emularse con:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> ordenA /dev/fd/1 <span class="p">|</span> ordenB
</pre></div>
</div>
<p>o de forma más general usando otro descriptor:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> ordenA /dev/fd/3 <span class="m">3</span>&gt;<span class="p">&amp;</span><span class="m">1</span> <span class="p">|</span> ordenB <span class="m">3</span>&gt;<span class="p">&amp;</span>-
</pre></div>
</div>
</div>
<p>Para que no quede expresado de forma tan general este apartado supongamos que
queremos en una misma orden guardar el contenido del directorio raíz y a la
vez contar cuántos ficheros contiene. La solución es la siguiente:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> ls / <span class="p">|</span> tee &gt;<span class="o">(</span>wc -l<span class="o">)</span> &gt;/tmp/listado.txt
</pre></div>
</div>
</dd>
</dl>
<p class="rubric">Notas al pie</p>
<dl class="footnote brackets">
<dt class="label" id="id5"><span class="brackets"><a class="fn-backref" href="#id1">1</a></span></dt>
<dd><p>¡Téngase cuidado! No vale cambiar de orden las redirecciones:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> sadhgaskjhsa <span class="m">2</span>&gt;<span class="p">&amp;</span><span class="m">1</span> &gt;contenedor_del_error
<span class="go">sadhgaskjhsa: no se encontró la orden</span>
</pre></div>
</div>
<p>ya que en este caso se redirige la salida del descriptor 2 hacia la
salida del descriptor 1, que en el momento de la redirección sigue
siendo aún la pantalla.</p>
</dd>
<dt class="label" id="id6"><span class="brackets"><a class="fn-backref" href="#id2">2</a></span></dt>
<dd><p>EN principio, podemos usar una tubería para emular un <em>Here String</em>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> <span class="nb">echo</span> <span class="s2">&quot;Hola, don Pepito&quot;</span> <span class="p">|</span> cat
<span class="go">Hola, don Pepito</span>
</pre></div>
</div>
<p>pero en ese caso la parte derecha de la tubería se ejecuta dentro de una
<em>subshell</em>, cuyo inconveniente principal es que impide definir o redefinir
el valor de una variable, ya que lo que se haga en la <em>subshell</em>, en la
<em>subshell</em> queda. Por ejemplo, si hiciéramos uso de <a class="reference internal" href="02avanzada.html#read"><span class="std std-ref">read</span></a>, que
veremos a continuación:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> <span class="nb">echo</span> <span class="s2">&quot;valor&quot;</span> <span class="p">|</span> <span class="nb">read</span> -r VAR
<span class="gp">$</span> <span class="nb">echo</span> <span class="nv">$VAR</span>
</pre></div>
</div>
<p>no habría conseguido dar valor a VAR, porque al salir de la <em>subshell</em> queda
sin ehecto la asignación de valor.</p>
</dd>
<dt class="label" id="id7"><span class="brackets"><a class="fn-backref" href="#id3">3</a></span></dt>
<dd><p>No viene instalado de serie en el sistema, por lo que hay que instalar
el paquete del mismo nombre.</p>
</dd>
<dt class="label" id="id8"><span class="brackets"><a class="fn-backref" href="#id4">4</a></span></dt>
<dd><p>Recordemos que los fabricantes de discos utilizan los múltiplos del bytes
suponiendo que la relación entre ellos es 1000, cuando las unidades que
maneja el sistema operativo siempre son en múltiplos de 1024.</p>
</dd>
</dl>
</div>
</div>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../../index.html">Tabla de contenido</a></h3>
  <ul>
<li><a class="reference internal" href="#">2.5.1. Redirección básica</a><ul>
<li><a class="reference internal" href="#salida">2.5.1.1. Salida</a></li>
<li><a class="reference internal" href="#entrada">2.5.1.2. Entrada</a></li>
<li><a class="reference internal" href="#tuberias">2.5.1.3. Tuberías</a></li>
</ul>
</li>
</ul>

  <h4>Tema anterior</h4>
  <p class="topless"><a href="index.html"
                        title="capítulo anterior"><span class="section-number">2.5. </span>Redirección de E/S</a></p>
  <h4>Próximo tema</h4>
  <p class="topless"><a href="02avanzada.html"
                        title="próximo capítulo"><span class="section-number">2.5.2. </span>Redirección avanzada</a></p>
  <div role="note" aria-label="source link">
    <h3>Esta página</h3>
    <ul class="this-page-menu">
      <li><a href="../../_sources/02.conbas/08.redirecciones/01basica.rst.txt"
            rel="nofollow">Mostrar el código</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Búsqueda rápida</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Ir a" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navegación</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="Índice General"
             >índice</a></li>
        <li class="right" >
          <a href="02avanzada.html" title="2.5.2. Redirección avanzada"
             >siguiente</a> |</li>
        <li class="right" >
          <a href="index.html" title="2.5. Redirección de E/S"
             >anterior</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">documentación de Linuxnomicón - rolling</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" ><span class="section-number">2. </span>Conceptos básicos</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="index.html" ><span class="section-number">2.5. </span>Redirección de E/S</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href=""><span class="section-number">2.5.1. </span>Redirección básica</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Derechos de autor CC BY 4.0, 2016-2021, José Miguel Sánchez Alés.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 3.4.3.
    </div>
  </body>
</html>