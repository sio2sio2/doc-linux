


<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" lang="es">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>2.5.1. Redirección básica &#8212; documentación de Linuxnomicón - rolling</title>
    <link rel="stylesheet" href="../../_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../_static/custom.css" />
    
    <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../_static/language_data.js"></script>
    <script type="text/javascript" src="../../_static/translations.js"></script>
    <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <link rel="index" title="Índice" href="../../genindex.html" />
    <link rel="search" title="Búsqueda" href="../../search.html" />
    <link rel="next" title="2.5.2. Redirección avanzada" href="02avanzada.html" />
    <link rel="prev" title="2.5. Redirección de E/S" href="index.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navegación</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="Índice General"
             accesskey="I">índice</a></li>
        <li class="right" >
          <a href="02avanzada.html" title="2.5.2. Redirección avanzada"
             accesskey="N">siguiente</a> |</li>
        <li class="right" >
          <a href="index.html" title="2.5. Redirección de E/S"
             accesskey="P">anterior</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">documentación de Linuxnomicón - rolling</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" >2. Conceptos básicos</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="index.html" accesskey="U">2.5. Redirección de E/S</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="redireccion-basica">
<h1>2.5.1. Redirección básica<a class="headerlink" href="#redireccion-basica" title="Enlazar permanentemente con este título">¶</a></h1>
<p>Para este caso trataremos sólo los tres ficheros antes indicados:</p>
<table border="1" class="docutils">
<colgroup>
<col width="32%" />
<col width="35%" />
<col width="33%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Nombre</th>
<th class="head">Dipositivo</th>
<th class="head">Descriptor asociado</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Entrada estándar</td>
<td><code class="file docutils literal notranslate"><span class="pre">/dev/stdin</span></code></td>
<td>0</td>
</tr>
<tr class="row-odd"><td>Salida estándar</td>
<td><code class="file docutils literal notranslate"><span class="pre">/dev/stdout</span></code></td>
<td>1</td>
</tr>
<tr class="row-even"><td>Salida de errores</td>
<td><code class="file docutils literal notranslate"><span class="pre">/dev/stdrerr</span></code></td>
<td>2</td>
</tr>
</tbody>
</table>
<p>y no haremos redirecciones permanentes.</p>
<p>La tercera columna, intitulada <em>Descriptor asociado</em>, hace referencia al
descriptor de fichero, o sea, al número entero, con el que es posible hacer
referencia al fichero en cuestión.</p>
<div class="section" id="salida">
<h2>2.5.1.1. Salida<a class="headerlink" href="#salida" title="Enlazar permanentemente con este título">¶</a></h2>
<p>La redirección de salida consiste en redirigir la salida estándar o la salida
de errores hacia otro fichero que puede ser la otra salida o un fichero
regular.</p>
<p>Consideremos la siguiente orden:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> cat
</pre></div>
</div>
<p>Sabemos ya que el comando leerá de teclado (la entrada estándar) y escribirá en
la pantalla (la salida estándar). Si queremos redirigir la salida hacia un
fichero regular, basta con lo siguiente:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> cat &gt; contenedor_de_tonterias
<span class="go">Esto que escribo, ya no aparece por la pantalla,</span>
<span class="go">puesto que se redirige la salida estándar</span>
<span class="go">hacia un fichero llamado &#39;contenedor_de_tonterias&#39;.</span>
</pre></div>
</div>
<p>Tal fichero puede o no existir: si no existe, se creará; si existe, se
sustituirá su anterior contenido por lo que escribamos ahora. Es posible también
redirigir al fichero añadiendo en vez de sustituyendo:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> cat &gt;&gt; contenedor_de_tonterías
<span class="go">Añadimos un par de líneas adicionales</span>
<span class="go">a las que escribimos antes</span>
</pre></div>
</div>
<p>El resultado es que el fichero contendrá 5 líneas: ls tres anteriores y estas
dos nuevas, en vez de contener sólo estas dos últimas, lo cual habría ocurrido
si hubiéramos usado una redirección simple.</p>
<p>Hay ocasiones en que redirigimos la salida no porque deseemos guardar
resultados, sino porque deseamos no verlos. En este caso, es sumamente útil
el fichero especial <code class="file docutils literal notranslate"><span class="pre">/dev/null</span></code>, que se traga todo lo que le echemos sin
dejar rastro:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> ls /usr/bin/ &gt; /dev/null
</pre></div>
</div>
<p>Ahora bien, ¿por qué hemos redirigido la salida estándar y no la salida de
errores? La razón está en que cuando no se indica cuál, se sobreentiende que nos
referimos al descriptor <em>1</em>, esto es, a la salida estándar. La sintaxis general
de la redirección es:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">N&gt; destino</span>
</pre></div>
</div>
<p>donde <code class="docutils literal notranslate"><span class="pre">N</span></code> es el número del descriptor. La ausencia de <code class="docutils literal notranslate"><span class="pre">N</span></code> implica 1. Para la
redirección doble es exactamente igual.</p>
<p>Probemos ahora lo siguiente:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> sadhgaskjhsa &gt; /dev/null
<span class="go">sadhgaskjhsa: no se encontró la orden</span>
</pre></div>
</div>
<p>Como vemos, a pesar de la redirección, hemos visto el mensaje. Esto es debido a
que lo que hemos redirigido es la salida estándar, no la salida de errores, por
lo que esta última sigue saliendo por la pantalla. Para haber evitado ver el
mensaje de error deberíamos haber hecho:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> sadhgaskjhsa <span class="m">2</span>&gt; /dev/null
</pre></div>
</div>
<p>También es posible redirigir una fichero de salida hacia el otro. Por ejemplo,
esto redirige la salida de errores hacia la salida estándar:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> sadhgaskjhsa <span class="m">2</span>&gt;<span class="p">&amp;</span><span class="m">1</span>
<span class="go">sadhgaskjhsa: no se encontró la orden</span>
</pre></div>
</div>
<p>Volvemos a ver por pantalla el error, pero en esta ocasión se escribe el mensaje
en la salida de errores no en la estándar. De hecho:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> sadhgaskjhsa &gt;contenedor_del_error <span class="m">2</span>&gt;<span class="p">&amp;</span><span class="m">1</span>
</pre></div>
</div>
<p>Escribe el mensaje de error en el fichero. En realidad, se redirigen tanto la
salida estándar como la de errores<a class="footnote-reference" href="#id5" id="id1">[1]</a>. No obstante, para esto último, es más
sencillo redirigir ambas salidas a la vez, para lo cual hay un símbolo propio:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> ls /y* <span class="p">&amp;</span>&gt; /dev/listado.txt
</pre></div>
</div>
<p>Téngase en cuenta que esta última notación es propia de <strong class="program">bash</strong> y no
funciona en <strong class="program">dash</strong>.</p>
</div>
<div class="section" id="entrada">
<h2>2.5.1.2. Entrada<a class="headerlink" href="#entrada" title="Enlazar permanentemente con este título">¶</a></h2>
<p>Por su parte, redirigir la entrada consiste en alimentar con una fuente
alternativa a un programa que espera recibir datos desde la entrada estándar,
que en un principio es el teclado. El caso más sencillo es:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> cat &lt; fichero
<span class="go">[ ...Se muestra el contenido del fichero... ]</span>
</pre></div>
</div>
<p>Como <strong class="command">cat</strong> no tiene argumentos espera recibir datos a través de la
entrada estándar; pero, como con secuencia de la redirección, esta pasa de ser el
teclado a ser el fichero. Consecuentemente, lo que muestra <strong class="command">cat</strong> es el
contenido del fichero. En realidad, esto es equivalente a:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> cat <span class="m">0</span>&lt; fichero
</pre></div>
</div>
<p>Ya que <strong>0</strong> es el descriptor que representa la entrada estándar. Esta es la base de la redirección de entrada.</p>
<p id="sh-here-document">Otra redirección de entrada que también forma parte del estándar es la llamada
<strong>Here Document</strong> que permite redirigir hacia la entrada estándar un texto largo
de varias líneas. Para ello se define una palabra delimitadora, de manera que
cuando se vuelva a encontrar esta misma palabra delimitadora sola al principio
de línea, se considerará acabado el texto. Por ejemplo, si hacemos que nuestro
delimitador sea <kbd class="kbd docutils literal notranslate">EOF</kbd>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> cat <span class="s">&lt;&lt;EOF</span>
<span class="gp">&gt;</span><span class="s"> En un país multicolor</span>
<span class="gp">&gt;</span><span class="s"> había una abeja bajo el sol</span>
<span class="gp">&gt;</span><span class="s"> EOF</span>
<span class="go">En un país multicolor</span>
<span class="go">había una abeja bajo el sol.</span>
</pre></div>
</div>
<p>En el texto, la <em>shell</em> intentará llevar a cabo sustituiciones por lo que:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> cat <span class="s">&lt;&lt;EOF</span>
<span class="gp">&gt;</span><span class="s"> 4 * 2 = $((4*2))</span>
<span class="gp">&gt;</span><span class="s"> EOF</span>
<span class="go">4 * 2 = 8</span>
</pre></div>
</div>
<p>Ahora bien, si se rodea el delimitador de inicio con comillas dobles o simples,
no se interpretará nada:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> cat &lt;&lt;<span class="s2">&quot;EOF&quot;</span>
<span class="gp">&gt;</span> <span class="m">4</span> * <span class="nv">2</span> <span class="o">=</span> <span class="k">$((</span><span class="m">4</span><span class="o">*</span><span class="m">2</span><span class="k">))</span>
<span class="gp">&gt;</span> EOF
<span class="go">4 * 2 = $((4*2))</span>
</pre></div>
</div>
<p>Es posible anteponer al primer delimitador un guión para que pueda sangrarse
(exclusivamente con tabulaciones) el texto del <em>documento</em> en línea que se
escribe. Es útil cuando se programa y se quiere mantener el código
correctamente sangrado:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> cat &lt;&lt;-EOF
<span class="go">   Mi hogar es $HOME</span>
<span class="go">   EOF</span>
<span class="go">Mi hogar es /home/usuario</span>
</pre></div>
</div>
<p class="rubric" id="bash-here-string">Here String</p>
<p><strong class="command">bash</strong>, además, ofrece esta redirección adicional, que
permite permite redirigir hacia la entrada estándar una cadena:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> cat <span class="o">&lt;&lt;&lt;</span>Hola,<span class="se">\ </span>don<span class="se">\ </span>Pepito.
<span class="go">Hola, don Pepito.</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Nota</p>
<p>Obsérvese que <em>Here String</em> no es más que el caso particular de un
<em>Here Document</em> de una sola línea:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> cat <span class="s">&lt;&lt;EOF</span>
<span class="gp">&gt;</span><span class="s"> Hola, don Pepito.</span>
<span class="gp">&gt;</span><span class="s"> EOF</span>
<span class="go">Hola, don Pepito</span>
</pre></div>
</div>
<p class="last">por lo que si al escribir un <em>script</em> en que deseamos evitar las extensiones
de <strong class="program">bash</strong> tenemos necesidad de usar un <em>Here String</em><a class="footnote-reference" href="#id6" id="id2">[2]</a>, podemos
usar un <em>Here Document</em>.</p>
</div>
</div>
<div class="section" id="tuberias">
<span id="pipeline"></span><h2>2.5.1.3. Tuberías<a class="headerlink" href="#tuberias" title="Enlazar permanentemente con este título">¶</a></h2>
<p>Las tuberías (<em>pipelines</em> en inglés) son un caso particular de una redirección
de salida junto a una redirección de entrada. Para entender su utilidad
supongamos que, con las herramientas vistas, se nos propone mostrar únicamente
la penúltima línea de <code class="file docutils literal notranslate"><span class="pre">/etc/group</span></code>.</p>
<p>Echando mano de la memoria, parece útil <a class="reference internal" href="../02.informacion/03.ficheros.html#tail"><span class="std std-ref">tail</span></a>, capaz de extraer la
parte final de un documento. En concreto:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> tail -n2 /etc/group
<span class="go">libvirt-qemu:x:116:libvirt-qemu</span>
<span class="go">qemusers:x:117:josem</span>
</pre></div>
</div>
<p>muestra las dos últimas líneas. Pero resulta que sólo queremos la penúltima, o
lo que es lo mismo, la primera línea de la salida producida por <strong class="command">tail</strong>.
Pero resulta que <a class="reference internal" href="../02.informacion/03.ficheros.html#head"><span class="std std-ref">head</span></a> permite extraer los comienzos de fichero, de
modo que si aplicamos un <kbd class="kbd docutils literal notranslate">head -n1</kbd> a esa salida conseguiremos nuestro
objetivo. Por supuesto es posible hacer:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> tail -n2 /etc/group &gt; /tmp/fichero.intermedio
<span class="gp">$</span> head -n1 &lt; /tmp/fichero.intermedio
<span class="go">libvirt-qemu:x:116:libvirt-qemu</span>
<span class="gp">$</span> rm -f /tmp/fichero.intermedio
</pre></div>
</div>
<p>Pero nos obliga a crear un absurdo fichero intermedio que hay que borrar al
terminar. La solución fetén a nuestro problema son las tuberías (<code class="docutils literal notranslate"><span class="pre">|</span></code>) que
permite redirigir la salida estándar de un programa hacia la entrada estándar
del siguiente:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> tail -n2 /etc/group <span class="p">|</span> head -n1
<span class="go">libvirt-qemu:x:116:libvirt-qemu</span>
</pre></div>
</div>
<p>Esta es básicamente la idea de las tuberías: sencilla, pero que abre muchísimas
posibilidades al permitir construir una herramienta más compleja mediante la
cooperación de herramientas más simples.</p>
<p>La tubería, así escrita, sólo redirige la salida estándar. Si se quieren
redirigir tanto la salida estándar como la de errores puede hacerse:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> ls /g* <span class="m">2</span>&gt;<span class="p">&amp;</span><span class="m">1</span> <span class="p">|</span> tail -n2
</pre></div>
</div>
<p>O bien, usar una sintaxis que sólo es admitida por <strong class="command">bash</strong>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> ls /g* <span class="p">|&amp;</span> tail -n2
</pre></div>
</div>
<p>Para acabar, en lo relativo a redirecciones son muy útiles dos órdenes:</p>
<span class="target" id="tee"></span><dl class="docutils" id="index-0">
<dt><strong class="command">tee</strong></dt>
<dd><p class="first">Desdobla su entrada hacia dos salidas: la estándar y el fichero que se
indique:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> ls / <span class="p">|</span> tee /tmp/listado.txt
</pre></div>
</div>
<p class="last">Hecho esto, veremos que el listado aparece en la pantalla, pero también se
habrá almacenado en <code class="file docutils literal notranslate"><span class="pre">/tmp/listado.txt</span></code>.</p>
</dd>
</dl>
<span class="target" id="pv"></span><dl class="docutils" id="index-1">
<dt><strong class="command">pv</strong></dt>
<dd><p class="first">Este comando, simplemente, cuenta los <em>bytes</em> que recibe por la entrada
estándar y los redirige hacia la salida estándar. Es bastante útil cuando el
flujo de datos es grande y no sabemos muy bien cuándo acabará. Por ejemplo,
supongamos que tenemos en el fichero <code class="file docutils literal notranslate"><span class="pre">disco.img.xz</span></code> la imagen cruda
comprimida de un disco y queremos volcarla sobre el disco físico
<code class="file docutils literal notranslate"><span class="pre">/dev/sdb</span></code>. La solución es trivial:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> xzcat disco.img.xz &gt; /dev/sdb
</pre></div>
</div>
<p>Ahora bien, la descompresión es un proceso lento y la escritura de tantos
datos en el disco, también. Como consecuencia, no sabemos muy bien ni cuánto
tardará ni la velocidad ia la que se van escribiendo datos, con lo que nos
resulta imposible hacernos una idea de cómo va el proceso hasta que
finalmente acaba. La solución es usar <strong class="command">pv</strong><a class="footnote-reference" href="#id7" id="id3">[3]</a> como
intermediario:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> xzcat disco.img.xz <span class="p">|</span> pv &gt; /dev/sdb
</pre></div>
</div>
<p>De este modo, el proceso de volcado se llevará a cabo igualemente, ya que
<strong class="command">pv</strong> no altera los <em>bytes</em>, pero mostrará información de a qué
velocidad se lleva a cabo el proceso y cuántos <em>bytes</em> han pasado por el
momento a través de él. No, puede, sin embargo, pronosticarnos cuánto tiempo
tardará ni decirnos cuál es el porcentaje ya volcado porque ignora el tamaño
final de aquello que se le pasa. No obstante, si nosotros sabemos cuál es el
tamaño descomprimido de la imagen, porque recordamos de cuánto era el disco
del que la hicimos, entonces es posible indicarle a <strong class="command">pv</strong> cuál es la
cantidad total de bytes que pasará a través de él (<code class="docutils literal notranslate"><span class="pre">-s</span></code>) y pedirle que nos
muestre una barra de progreso con el porcentaje completado (<code class="docutils literal notranslate"><span class="pre">-p</span></code>):</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> xzcat disco.img.xz <span class="p">|</span> pv -ps 250G &gt; /dev/sdb
</pre></div>
</div>
<p>No obstante, para este caso particular, <strong class="command">pv</strong> permite también indicar
en sus argumentos un fichero del que leer, en vez de usar la entrada
estándar. En este caso, <strong class="command">pv</strong> si es capaz de saber cuántos <em>bytes</em>
leerá, puesto que toma el dato del tamaño del fichero, y esto hace que sea
innecesario pasar con <code class="docutils literal notranslate"><span class="pre">-s</span></code> la cantidad. Así pues, lo anterior, habría sido
más inteligente haberlo hecho del siguiente modo:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> pv -p disco.img.xz <span class="p">|</span> xzcat &gt; /dev/sdb
</pre></div>
</div>
<div class="last admonition note">
<p class="first admonition-title">Nota</p>
<p class="last">Nótese que en este último caso la cantidad de <em>bytes</em> que pasan por
<strong class="command">pv</strong> es significativamente menor, ya que no pasa la imagen
descomprida, sino la comprimida. Por tanto, el total no serán 250GB sino
solamente quizás 5GB, por decir algo. Sin embargo, como los tres comandos
tienen que sincronizarse puesto que unos alimentan a otros, el dato del
tiempo restante y el porcentaje completado es absolutamente verídico. De
hecho, no están sujetos a la arbitrariedad de nuestra memoria ni que a
que, posiblemente, el tamaño de disco no sean exactamente 250GB<a class="footnote-reference" href="#id8" id="id4">[4]</a>.</p>
</div>
</dd>
</dl>
</div>
<div class="section" id="process-substitution">
<span id="bash-process-substitution"></span><h2>2.5.1.4. Process substitution<a class="headerlink" href="#process-substitution" title="Enlazar permanentemente con este título">¶</a></h2>
<div class="admonition warning">
<p class="first admonition-title">Advertencia</p>
<p class="last">Esta substitución no es <em>POSIX</em>, sino una extensión de
<strong class="program">bash</strong>.</p>
</div>
<div class="admonition-todo admonition" id="index-2">
<p class="first admonition-title">Por hacer</p>
<p class="last">Reescribir esto para empezar diciendo para lo que sirve (el final)
y no este efecto de ver el nombre del fichero.</p>
</div>
<p>Esta construcción, como la anterior, ejecuta una subshell con las órdenes que
contiene, pero en vez de sustituirse por la salida estándar de éstas, se
sustituye por el nombre de un fichero descriptor cuyo contenido es la salida
estándar de las órdenes.</p>
<p>Analicemos un ejemplo, bastante inútil desde un punto de vista práctico, pero
que sirve para entender el párrafo anterior. Esta orden:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> <span class="nb">echo</span> <span class="s2">&quot;Hola Adiós&quot;</span>
<span class="go">Hola Adiós</span>
</pre></div>
</div>
<p>es obvia la salida que produce. Si metemos la orden dentro de una <em>subshell</em>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> <span class="nb">echo</span> <span class="k">$(</span><span class="nb">echo</span> <span class="s2">&quot;Hola Adiós&quot;</span><span class="k">)</span>
<span class="go">Hola Adiós</span>
</pre></div>
</div>
<p>el intérprete se limita a sustituir en la línea de órdenes la subshell por lo
que imprime (el propio «Hola Adiós»), por lo que acaba ejecutando el
<strong class="command">echo</strong> de la salida del <strong class="command">echo</strong> de la <em>subshell</em> y el resultado
es el mismo.</p>
<p>En cambio la <em>substitución del proceso</em> lo que hace es mandar la salida a un
fichero descriptor y sustituir la expresión por el nombre de ese fichero:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> <span class="nb">echo</span> &lt;<span class="o">(</span><span class="nb">echo</span> <span class="s2">&quot;Hola Adiós&quot;</span><span class="o">)</span>
<span class="go">/dev/fd/63</span>
</pre></div>
</div>
<p>En este caso, lo que ha ocurrido es que la salida del echo de la <em>subshell</em> (o
sea, la frase «Hola Adiós»), se manda al fichero descriptor <code class="file docutils literal notranslate"><span class="pre">/dev/fd/63</span></code> y
se sustituye la expresión por ese nombre de fichero. En este caso, si hubiéramos
querido obtener el mismo efecto que con la expresión anterior (o sea ver «Hola
Adiós»), deberíamos haber usado <a class="reference internal" href="../02.informacion/03.ficheros.html#cat"><span class="std std-ref">cat</span></a> que es la orden apropiada para
ver contenidos de ficheros:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> cat &lt;<span class="o">(</span><span class="nb">echo</span> <span class="s2">&quot;Hola Adiós&quot;</span><span class="o">)</span>
<span class="go">Hola Adiós</span>
</pre></div>
</div>
<p>Pero ¿qué utilidad tiene esto si para obtener el efecto del ejemplo basta con
hacer simplemente?:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> <span class="nb">echo</span> <span class="s2">&quot;Hola Adiós&quot;</span>
<span class="go">Hola Adiós</span>
</pre></div>
</div>
<p>Esta <em>process substitución</em>, en realidad, se usa cuando un programa
<strong class="program">ordenB</strong> necesita como entrada la salida de otro programa
<strong class="program">ordenA</strong>, pero el programa <strong class="program">ordenB</strong> sólo admite que se le
pasen los datos a través de un fichero y no mediante la entrada estándar, en
cuyo caso bastaría con <a class="reference internal" href="#pipeline"><span class="std std-ref">una tubería</span></a>. O sea, nuestra intención
sería hacer:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> ordenA <span class="p">|</span> ordenB
</pre></div>
</div>
<p>pero como <strong class="program">ordenB</strong> no es capaz de recibir datos de la entrada estándar,
porque porque su sintaxis es <kbd class="kbd docutils literal notranslate">ordenB fichero-entrada</kbd>, entonces se puede hacer:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> ordenB &lt;<span class="o">(</span>ordenA<span class="o">)</span>
</pre></div>
</div>
<p>También existe la <em>substitución de proceso</em> para la salida que se utiliza cuando
una <strong class="program">ordenA</strong> que sólo es capaz de almacenar su salida en un fichero,
debe pasarle esta salida a otro programa <strong class="program">ordenB</strong> que podría recibirla
por la entrada estándar. O sea que nuestra intención sería hacer:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> ordenA <span class="p">|</span> ordenB
</pre></div>
</div>
<p>pero la sintaxis de <strong class="program">ordenA</strong> solo nos deja hacer <kbd class="kbd docutils literal notranslate">ordenA
fichero-salida</kbd>, por lo que tenemos que recurrir a:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> ordenA &gt;<span class="o">(</span>ordenB<span class="o">)</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Nota</p>
<p>Con <em>POSIX</em> puede subsanarse la carencia, aunque utilizando <a class="reference internal" href="index.html#ioredirect"><span class="std std-ref">técnicas
de redirección</span></a> algo avanzada. Así la expresión:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> ordenB &lt;<span class="o">(</span>ordenB<span class="o">)</span>
</pre></div>
</div>
<p>puede lograrse de este modo:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> ordenA <span class="p">|</span> ordenB /dev/fd/0
</pre></div>
</div>
<p>o de forma más general usando otro descriptor:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> ordenA <span class="m">3</span>&lt;<span class="p">&amp;</span>- <span class="p">|</span> ordenB /dev/fd/3 <span class="m">3</span>&lt;<span class="p">&amp;</span><span class="m">0</span>
</pre></div>
</div>
<p>Por su parte:;</p>
<blockquote>
<div>$ ordenA &gt;(ordenB)</div></blockquote>
<p>podría emularse con:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> ordenA /dev/fd/1 <span class="p">|</span> ordenB
</pre></div>
</div>
<p>o de forma más general usando otro descriptor:</p>
<div class="last highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> ordenA /dev/fd/3 <span class="m">3</span>&gt;<span class="p">&amp;</span><span class="m">1</span> <span class="p">|</span> ordenB
</pre></div>
</div>
</div>
<p class="rubric">Notas al pie</p>
<table class="docutils footnote" frame="void" id="id5" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td><p class="first">¡Téngase cuidado! No vale cambiar de orden las redirecciones:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> sadhgaskjhsa <span class="m">2</span>&gt;<span class="p">&amp;</span><span class="m">1</span> &gt;contenedor_del_error
<span class="go">sadhgaskjhsa: no se encontró la orden</span>
</pre></div>
</div>
<p class="last">ya que en este caso se redirige la salida del descriptor 2 hacia la
salida del descriptor 1, que en el momento de la redirección sigue
siendo aún la pantalla.</p>
</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id6" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[2]</a></td><td><p class="first">EN principio, podemos usar una tubería para emular un <em>Here String</em>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> <span class="nb">echo</span> <span class="s2">&quot;Hola, don Pepito&quot;</span> <span class="p">|</span> cat
<span class="go">Hola, don Pepito</span>
</pre></div>
</div>
<p>pero en ese caso la parte derecha de la tubería se ejecuta dentro de una
<em>subshell</em>, cuyo inconveniente principal es que impide definir o redefinir
el valor de una variable, ya que lo que se haga en la <em>subshell</em>, en la
<em>subshell</em> queda. Por ejemplo, si hiciéramos uso de <a class="reference internal" href="02avanzada.html#read"><span class="std std-ref">read</span></a>, que
veremos a continuación:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> <span class="nb">echo</span> <span class="s2">&quot;valor&quot;</span> <span class="p">|</span> <span class="nb">read</span> -r VAR
<span class="gp">$</span> <span class="nb">echo</span> <span class="nv">$VAR</span>
</pre></div>
</div>
<p class="last">no habría conseguido dar valor a VAR, porque al salir de la <em>subshell</em> queda
sin ehecto la asignación de valor.</p>
</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id7" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3">[3]</a></td><td>No viene instalado de serie en el sistema, por lo que hay que instalar
el paquete del mismo nombre.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id8" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id4">[4]</a></td><td>Recordemos que los fabricantes de discos utilizan los múltiplos del bytes
suponiendo que la relación entre ellos es 1000, cuando las unidades que
maneja el sistema operativo siempre son en múltiplos de 1024.</td></tr>
</tbody>
</table>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../../index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">2.5.1. Redirección básica</a><ul>
<li><a class="reference internal" href="#salida">2.5.1.1. Salida</a></li>
<li><a class="reference internal" href="#entrada">2.5.1.2. Entrada</a></li>
<li><a class="reference internal" href="#tuberias">2.5.1.3. Tuberías</a></li>
<li><a class="reference internal" href="#process-substitution">2.5.1.4. Process substitution</a></li>
</ul>
</li>
</ul>

  <h4>Tema anterior</h4>
  <p class="topless"><a href="index.html"
                        title="capítulo anterior">2.5. Redirección de E/S</a></p>
  <h4>Próximo tema</h4>
  <p class="topless"><a href="02avanzada.html"
                        title="próximo capítulo">2.5.2. Redirección avanzada</a></p>
  <div role="note" aria-label="source link">
    <h3>Esta página</h3>
    <ul class="this-page-menu">
      <li><a href="../../_sources/02.conbas/08.redirecciones/01basica.rst.txt"
            rel="nofollow">Mostrar el código</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Búsqueda rápida</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Ir a" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navegación</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="Índice General"
             >índice</a></li>
        <li class="right" >
          <a href="02avanzada.html" title="2.5.2. Redirección avanzada"
             >siguiente</a> |</li>
        <li class="right" >
          <a href="index.html" title="2.5. Redirección de E/S"
             >anterior</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">documentación de Linuxnomicón - rolling</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" >2. Conceptos básicos</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="index.html" >2.5. Redirección de E/S</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Derechos de autor CC BY 4.0, 2016-2020, José Miguel Sánchez Alés.
      Creado con <a href="http://sphinx-doc.org/">Sphinx</a> 1.8.5.
    </div>
  </body>
</html>