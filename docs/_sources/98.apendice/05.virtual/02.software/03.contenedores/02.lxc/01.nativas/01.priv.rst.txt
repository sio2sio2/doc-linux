Contenedores privilegiados
**************************
Dedicaremos este epígrafe a la gestión de contenedores privilegiados creados y
gestionados por el propio administrador\ [#]_ y, conocidos estos, introduciremos
en el próximo la dificultad de crear contenedores no privilegiados con un
usuario normal.

Preliminares
============
Comencemos aclarando algunas particularidades que nos ayudarán a entender el
desarrollo posterior:

#. El demonio :program:`lxc-net` gestiona la creación de interfaces puentes (que
   se estudiarán bajo el :ref:`epígrafe dedicado a la red <lxc-red>`) y,
   :ref:`como hace libvirtd <virsh-red>`, proporciona direcciones |IP| dinámicas
   valiéndose de :ref:`dnsmasq <dnsmasq-dhcp>`.

#. Los contenedores contienen un conjunto de archivos y directorios que
   constituyen el sistema de archivos del sistema huésped. Por tanto, cada
   contenedor recreará una estructura típica de directorios (:file:`/bin`,
   :file:`/etc`, :file:`/usr`, etc) que variará según sea la distribución que el
   huésped imita.

#. Para construir este árbol de directorios, |LXC| proporciona `una serie
   de plantillas predefinidas <https://uk.lxd.images.canonical.com/>`_.

#. Al crear un contenedor con una de ellas, la plantilla se descargará y se
   ejecutará un *script* que preparará el contenedor utilizando la configuración
   local y la información de la plantilla. Las plantillas se almacenan en
   principio en :file:`/var/cache/lxc`, aunque pueden borrarse posteriormente
   sin escrúpulo.

#. A diferencia de :ref:`QEmu <qemu>` o :ref:`Virtualbox <virtualbox>`, no existe
   un archivo de disco (|QCOW|\ 2, |VDI|) que contenga un sistema de archivos
   totalmente ajeno al anfitrión, sino que el contenido del contenedor son
   archivos y directorios incluidos en una parte del árbol de directorios del
   anfitrión (por defecto, :file:`/var/lib/lxc/nombre_contenedor`). Esto supone
   que |LXC| actúe dependiendo de cuál sea el sistema de archivos sobre el que se
   encuentra esa parte del árbol, esto es, dependiendo de cuál sea el formato de
   su almacenamiento (*backing store* en su terminología):

   "*none*" (o también "*dir*")
      este formato es el que se presenta cuando los archivos del contenedor los
      trata como archivos sin más consideración. Por ejemplo, si el sistema de
      archivos del anfitrión es *ext4* y :file:`/var/lib/lxc` forma parte de
      este sistema de archivos, no habrá más remedio que usar este formato. No
      es lo más apropiado, desde luego:

      * Las instantáneas consisten en hacer una copia completa de todos los
        archivos.
      * No hay forma de limitar el tamaño del contenedor y, si
        :file:`/var/lib/lxc` no constituye un sistema de archivos aparte, los
        contenedores pueden crecer hasta ocupar todo el espacio disponible de
        :file:`/`.

   "*btrfs*"\ /\ "*zfs*"
      Si :file:`/var/lib/lxc` se encuentra en un sistema de archivos |BTRFS| o
      |ZFS| (p.e. porque hayamos dispuesto esa ruta en partición aparte y le
      hayamos dado formato con alguno de estos dos sistemas), entonces podremos
      informar a |LXC| de que puede hacer uso de sus características especiales
      (p.e. soporte nativo para instantáneas, subvolúmenes). 

   "*lvm*"
      Podemos optar por incluir cada contenedor en un :ref:`volumen lógico de
      LVM <lvm>`. |LVM| soporta instantáneas y, si utilizamos
      :ref:`aprovisionamiento fino <lvm-snapshots>`, las ventajas se
      multiplican.

   "*loop*"
      Este es el formato más cercano al estilo de las dos virtualizaciones
      completas que hemos citados anteriormente: los archivos del contenedor se
      guardaran dentro de un archivo regular del anfitrión
      (:file:`/var/lib/lxc/nombre_contenedor/rootdev`).

.. _lxc-create:

Creación
========
Para la creación de un contenedor tenemos que tener presente de inicio dos
aspectos: qué sistema *Linux* queremos incluir y cuál será el formato de
almacenamiento. Existe otro más (la limitación de recursos), pero lo trataremos
:ref:`más adelante <lxc-limit>`. Comencemos, pues, por lo más sencillo::

   # lxc-create -n test -t download -- -d alpine -r 3.17 -a amd64

donde hay que notar:

* Somos el administrador.
* Nuestro contenedor se llamará "*test*".
* Hacemos la instalación a través de una plantilla llamada *download* que facilita
  la operación y nos permite seleccionar de forma sencilla una de `las imágenes disponibles en
  los servidores <https://uk.lxd.images.canonical.com/>`_. Sin añadir más, la
  imagen ejecuta un *script* que nos muestra y, a continuación, nos permite
  seleccionar cuál es la plantilla que deseamos utilizar, pero...
* Tras :kbd:`--` se pueden incluir las opciones que permita la plantilla (en
  este caso, *download*). Pues bien, si observamos la lista de plantillas
  veremos que cada una se define por cuatro características: *distribución*
  (:kbd:`-d`), *versión* (:kbd:`-r`), *arquitectura* (:kbd:`-a`) y variante
  (:kbd:`-v`), que son precisamente las opciones que permite añadir *download*
  para restringir la lista de selección que nos muestra. Así, si
  incluyéramos únicamente :code:`-a amd64` aparecerían sólo las plantillas para
  esta arquitectura. Si añadimos las opciones suficientes como para restringir
  la lista a una sola plantilla, entonces la instalación se realizará
  inmediatamente sin más preguntas. Esto es precisamente lo que logra la orden
  de arriba, porque aunque falta especificar la variante, cuando esta no se
  indica, se entiende que es "*default*".

Por tanto, hemos instalado una distribución la variante *default* de la versión
3.17 de Alpine_ para arquitectura `x64_64
<https://es.wikipedia.org/wiki/X86-64>`_\ [#]_.

.. _lxc-create-none:

Ahora bien, ¿qué pasa con el segundo aspecto, esto es, el formato de
almacenamiento? El formato se introduce con la opción :kbd:`-B` antes de
:kbd:`--`, puesto que es algo que nada tiene que ver con la plantilla que se
use. Cuando no se especifica nada, :program:`lxc-create` entiende :code:`-B
none` (o :code:`-B dir`, que es lo mismo) y, por tanto, |LXC| entenderá que
nuestro contenedor es una mera colección de archivos y directorios sin nada
especial de lo que pueda aprovecharse. La traducción de esto es que se habrá
creado lo siguiente:

.. code-block:: none

   /var/lib/lxc
        +-- test
              +---- config
              +---- rootfs/
                       +-- ...
                       +-- Estructura de directorios de Alpine
                       +-- ...

O sea, un directorio dentro de :file:`/var/lib/lxc` cuyo nombre coincide con el
nombre del contenedor que, a su vez, contiene:

* Un directorio que incluye la estructura de archivos del contenedor
  (:file:`rootfs`). Cuando entremos en el huésped, nos encontraremos
  enjaulados dentro de él.
* Un archivo (:file:`config`) con la configuración del contenedor para la que se
  toma como referencia la que se encuentra en :file:`/etc/lxc/default.conf`.

.. _lxc-create-loop:

Probemos crear con otro formato::

   # lxc-destroy -n test  # Primero borramos el anterior
   # lxc-create -n test -t download -B loop --fssize=50M -- -d alpine -r 3.17 -a amd64

La orden es idéntica a la anterior, pero hemos añadido las opciones para que el
almacenamiento sea un único archivo (:code:`-B loop`). |LXC| crea un archivo,
pero ¿de qué tamaño y con qué sistema de archivos lo formatea? Para el tamaño
existe la opción :kbd:`--fssize`, que sí se ha indicado porque lo predeterminado
es 1GiB y nosotros no necesitamos tanto para una minidistribución. El sistema de
archivos se especifica con :kbd:`--fstype` y su valor predeterminado es *ext4*.
Si gulismeamos nos encontraremos lo siguiente:

.. code-block:: none

   /var/lib/lxc
        +-- test
              +---- config
              +---- rootdev  [Aquí dentro está nuestra Alpine]
              +---- rootfs/

La estructura es semejante, pero ahora :file:`rootfs` está vacío, puesto que es
el archivo :file:`rootdev` el que contiene dentro de sí toda la estructura de
directorios. En este caso, cuando arranquemos el contenedor, |LXC| montará el
contenido de :file:`rootdev` sobre :file:`rootfs`. También es preciso notar que,
si el sistema de archivos lo soporta, el archivo :file:`rootdev` es :ref:`un
archivo disperso como el que podemos crear nosotros con truncate <truncate>`,
por lo que inicialmente no ocupará todo el tamaño que le asignamos, e irá
creciendo según añadamos contenido.

.. _lxc-create-btrfs:
.. _lxc-create-zfs:

Si :file:`/var/lib/lxc` se encuentra en un sistema de archivos |BTRFS|, podremos
indicarle a |LXC| que lo tenga en cuenta. Sin embargo, para ello deberemos
tener antes instalado::

   # apt install btrfs-progs

Ahora sí, procedamos::

   # lxc-destroy -n test
   # lxc-create -n test -t download -B btrfs -- -d alpine -r 3.17 -a amd64

En principio, no observaremos diferencias respecto a :ref:`no especificar
formato <lxc-create-none>` (la estructura de archivos es idéntica), pero
existen. De hecho::

   # btrfs subvolume list /var/lib/lxc
   ID 258 gen 102 top level 5 path test/rootfs

|LXC| ha definido un subvolumen para la estructura de directorios del
contenedor. Esta es la clave que permite luego crear instantáneas o limitar el
espacio de disco del contenedor.

.. note:: Con |ZFS| ocurre algo similar.

.. _lxc-create-lvm:

Por último, podemos escoger como formato de almacenamiento |LVM|. Para ello es
obvio que necesitamos disponer de un grupo de volúmenes (al que llamaremos
*VGtest*) y, aunque no es extrictamente necesario, supondremos que dentro de él
también tenemos un pool llamado *lxc* para aprovisionamiento fino\ [#]_. En
estas circunstancias, podemos crear un contenedor así::

   # lxc-destroy -n test
   # lxc-create -n test -t download -B lvm --vgname VGtest --thinpool lxc --fssize=50M -- -d alpine -r 3.17 -a amd64

Esto supone que dentro del *pool* :file:`VGtest/lxc` se cree un volumen lógico
de 50 MiB (:kbd:`--fssize`) para albergar el contenedor. El nombre del volumen
lógico se toma del nombre del contenedor. Por tanto, si consultamos los
volúmenes existentes:

.. code-block:: bash
   :emphasize-lines: 10

   # lvs
     LV        VG     Attr       LSize   Pool Origin Data%  Meta%  Move Log Cpy%Sync Convert
     home      VGraid Vwi-aotz-- 500,00m lxc         6,45
     log       VGraid -wi-ao----  64,00m
     lxc       VGraid twi-aotz-- 768,00m             12,59  12,40
     mysql     VGraid Vwi-aotz-- 500,00m lxc         6,41
     raiz      VGraid -wi-ao----   1,75g
     srv       VGraid Vwi-aotz-- 500,00m lxc         6,41
     swap      VGraid -wc-ao----  32,00m
     test      VGraid Vwi-aotz--  50,00m lxc         3,14

Como no hemos especificado sistema de archivos (:kbd:`--fstype`), el volumen
lógico se formatea en *ext4*. La orden crea un estructura como la anterior:

.. code-block:: none

   /var/lib/lxc
        +-- test
              +---- config
              +---- rootfs/

pero :file:`rootfs` se encontrará vacío puesto los archivos del contenedor se
encuentran en el volumen lógico.

.. _lxc-manage:

Gestión
=======
Una vez usado :ref:`lxc-create <lxc-create>`, se creará el contenedor::

   # lxc-ls
   test

pero se encontrará parado, lo cual puede comprobarse añadiendo la opción
:kbd:`-f`::

   # lxc-ls -f
   NAME STATE   AUTOSTART GROUPS IPV4 IPV6 UNPRIVILEGED 
   test STOPPED 0         -      -    -    false

o bien, :command:`lxc-info`::

   # lxc-info -n test
   Name:           test
   State:          STOPPED

Para **arrancar** el contenedor es preciso::

   # lxc-start -n test

lo cual cambia el estado del contenedor::

   # lxc-ls -f
   NAME STATE   AUTOSTART GROUPS IPV4          IPV6 UNPRIVILEGED 
   test RUNNING 0         -      10.0.3.108    -    false
   # lxc-info -n test
   Name:           test
   State:          RUNNING
   PID:            3156
   IP:             10.0.3.108
   Link:           vethL6i8cY
    TX bytes:      2.09 KiB
    RX bytes:      2.56 KiB
    Total bytes:   4.65 KiB

Esta orden lo arranca, pero por defecto lo deja en segundo plano\ [#]_, por lo
que tendremos que conectarnos al contenedor. La manera fetén de hacerlo es
utilizando la orden :manpage:`lxc-console` que nos presentará un *login* de
acceso. Sin embargo, ¿cuál es la contraseña? Lo primero, pues, es preparar el
acceso para que nos sea posible. Para ello disponemos de :manpage:`lxc-attach`,
que permite ejecutar directamente órdenes dentro del contenedor, así que podemos
empezar por ponerle una contraseña al administrador::

   # lxc-attach -n test -- passwd

.. warning:: En otras distribuciones bastará con esto, pero en el caso
   particular de *Alpine*, seguiremos teniendo problemas de acceso, porque en
   ella, cuando se accede como administrador, se consulta :manpage:`securetty`
   para comprobar si la consola de acceso es considerada segura y las que usamos
   con :command:`lxc-console` (:file:`/dev/lxc/tty1`, :file:`/dev/lxc/tty2`,
   etc.) no están. Podemos optar por crear un usuario sin privilegios (y ya en
   el contenedor convertirnos en administrador con :ref:`su <su>`)::

      # lxc-attach -n test -- adduser -s /bin/ash -g "" usuario

   o eliminar el archivo :file:`/etc/securetty` para evitar la comprobación::

      # lxc-attach -n test -- mv /etc/securetty /etc/securetty.move

Hecho lo cual, podremos ingresar en el contenedor::

   # lxc-console -n test

   Connected to tty 1
   Type <Ctrl+a q> to exit the console, <Ctrl+a Ctrl+a> to enter Ctrl+a itself

   Welcome to Alpine Linux 3.17
   Kernel 5.10.0-19-amd64 on an x86_64 (/dev/tty1)

   test login: root
   Password:

   [...]

   test:~# _

Obsérvese, cómo se nos advierte de que para salir de la consola (que es la
**1**) podemos teclear :kbd:`Ctrl-A+q`. Esto se debe a que si cerramos la sesión
(por ejemplo, con :ref:`exit <exit>`), se nos volverá a pedir el *login* como
ocurre en un sistema habitualmente; y. si optamos por apagar (:ref:`poweroff
<poweroff>`). lo que lograremos es apagar el sistema huésped, o sea, parar el
contenedor. La combinación de teclas  nos permite desconectarnos del huésped
para volver al sistema anfitrión. Posteriormente, podremos volver a conectarnos
con::

   # lxc-console -n test -t1

donde especificamos el número de consola a la que queremos conectar para evitar
que :command:`lxc-consola` pueda escoger una distinta\ [#]_. También es útil
tener presente que es posible cambiar la tecla de control por si :kbd:`Ctrl+A`,
ya la usamos para algo especial en el anfitrión (p.e. porque usemos `screen
<https://www.gnu.org/software/screen/>`_)::

   # lxc-console -e '^k' -n test

.. note:: El *gorrito* (:kbd:`^`) se ha escrito literalmente.

Ya sólo nos queda saber cómo parar y eliminar el contenedor. Lo primero se logra
bien apagando el contenedor desde el propio huésped (p.e. con :ref:`poweroff
<poweroff>`) como ya hemos visto, o bien desde el anfitrión utilizando la
orden::

   # lxc-stop -n test

Una vez que hayamos parado el contenedor, podremos eliminarlo con::

   # lxc-destroy -n test

.. _lxc-limit:

Limitación
==========
Al tratar de limitar recursos tenemos que distinguir entre limitar el espacio de
disco, que es algo que dependerá del formato de almacenamiento, y limitar el
resto de recursos (|RAM|, |CPU|, etc) que depende de *cgroups*.

.. rubric:: Espacio de disco

Dos de los formatos que hemos revisado (:ref:`loop <lxc-create-loop>` y
:ref:`lvm <lxc-create-lvm>`) ya limitan *per se* el tamaño del contenedor por
vía de la opción :file:`--fssize`. :ref:`none <lxc-create-none>`, por su parte,
es incapaz de fijar una limitación, puesto que los archivos irán creciendo
mientras haya espacio disponible dentro del sistema de archivos en el que se
encuentre :file:`/var/lib/lxc`. Por tanto, esta exposición se reduce a conocer
cómo limitarlo con :ref:`brtfs <lxc-create-btrfs>` y (:ref:`zfs
<lxc-create-zfs>`).  En ambos casos, la limitación  se fija haciendo uso de las
herramientas propias del sistema de archivos y no del propio |LXC|, así que es
más un problema de conocer tal sistema de archivos que de conocer esta
tecnología de contenedores. Estudiemos cómo hacerlo con |BTRFS|.

Ya se adelantó que al crear un contenedor sobre un sistema |BTRFS| (e indicarle
con :code:`:B btrfs` que así es), se crea automáticamente un subvolumen para el
contenido del contenedor::

   # btrfs subvolume list /var/lib/lxc
   ID 258 gen 102 top level 5 path test/rootfs

Pues bien, para poder limitar el espacio que ocupará este subvolumen,
necesitamos habilitar las cuotas en el sistema de archivos::

   # btrfs quota enable /var/lib/lxc

y establecer una cuota para el subvolumen::

   # btrfs qgroup limit 50m /var/lib/lxc/test/rootfs

con lo cual:

.. code-block:: console
   :emphasize-lines: 5

   # btrfs qgroup show -r /var/lib/lxc
   qgroupid         rfer         excl     max_rfer 
   --------         ----         ----     -------- 
   0/5          16.00KiB     16.00KiB         none 
   0/258         9.65MiB      9.65MiB     50.00MiB

Y, efectivamente, si intentamos dentro del huésped escribir 50MiB::

   test:~$  dd < /dev/zero > ceros bs=1M count=50
   dd: error writing 'standard output': Quota exceeded
   41+0 records in
   40+0 records out

seeremos incapaces de completar la operación, porque  ya había más de 9MiB
ocupados por la propia *Alpine*.

Podemos redefinir cualquier otro valor para la cuota y, si decidimos eliminarla,
basta con usar la palabra *none*::

   # btrfs qgroup limit none /var/lib/lxc/test/rootfs

.. rubric:: Otros recursos

El resto de recursos (p.e. la memoria |RAM|) se limitan haciendo uso de
*cgroups*. Las modernas versiones de *Debian* (a partir de *Bullseye*) usan
*v2*, así que sobre esta segunda versión es sobre la que trabajaremos. En
principio, no hay definida ninguna limitación, así que si sobre mi sistema de
512MiB, entro al contenedor y consulto la memoria disponible::

   test:~$  grep ^MemT /proc/meminfo 
   MemTotal:         484704 kB

obtendremos más o menos esa cantidad de memoria disponible. ¿Cómo establecer las
limitaciones? Para ello debemos hacer uso de :command:`lxc-cgroups` (con la
contenedor arrancado) y saber `qué controlador
<https://facebookmicrosites.github.io/cgroup2/docs/memory-controller.html>`_
debemos tocar::

   # lxc-groups -n test memory.max 100m
   # lxc-groups -n test memory.swap.max 25m
   # lxc-cgroup -n test cpuset.cpus 0,2

Estos, por ejemplo, limitan la |RAM|, la *swap* y el uso de la |CPU| a solamente
al primero y tercero de los núcleos. Podemos comprobar estos límites
consultando::

   # cat /sys/fs/cgroup/lxc.payload.test/memory.max
   104857600

o sea, 10MiB expresados en *bytes*. Los límites, sin embargo, son efímeros y se
perderán al apagar la máquina. Para hacerlos permanentes, pueden añadirse al
archivo de configuración del contenedor (en este caso,
:file:`/var/lib/lxc/test/config`):

.. code-block:: bash

   lxc.cgroup2.memory.max = 100m
   lxc.cgroup2.memory.swap.max = 25m
   lxc.cgroup2.cpuset.cpus = 0,2

.. todo:: :ref:`free <free>`, sin embargo, devuelve datos del anfitrión. Debe
   ser algo relacionado con el servicio *lxcfs*. Debe comprobarse si se mantiene
   este problema con |LXD|.

.. _lxc-snapshot:

Instantáneas
============


.. _lxc-conf:

Configuración
=============
.. _lxc-red:

.. LXC:
   https://wiki.calculate-linux.org/lxc
   https://www.josedomingo.org/pledin/2021/12/introduccion-lxc/

.. LXC y LVM:
   https://edoput.it/lxc/lvm/2016/11/13/working-with-lxc-and-lvm.html
   https://manuelfrancoblog.wordpress.com/2018/01/12/lxc-lvm-containers-y-clonado/

.. rubric:: Notas al pie

.. [#] Si un contenedor privilegiado no lo gestiona un administrador, no
   podremos actuar dentro de él como tal y, en consecuencia, es imposible que
   gestione un sistema completo.

.. [#] *Alpine* es una distribución mínima con lo cual es ideal para hacer
   crear nuestros contenedores de prueba.

.. [#] Se supone que estamos :ref:`familiarizados con estos conceptos <lvm>`.

.. [#] En versiones antiguas, el comportamiento predeterminado era justamente el
   contrario y para no conectarse al contenedor había que añadir la opción
   :kbd:`-d`.

.. [#] Circunstancia que en este caso particular no ocurrirá, pero que podría
   ocurrir cuando la situación fuera distinta.

.. |LXC| replace:: :abbr:`LXC (LinuX Containers)`
.. |QCOW| replace:: :abbr:`QCOW (Qemu Copy-On-Write)`
.. |VDI| replace:: :abbr:`VDI (Virtual Disk Image)`
.. |LVM| replace:: :abbr:`LVM (Logical Volume Management)`
.. |BTRFS| replace:: :abbr:`BTRFS (B-TRee File System)`
.. |ZFS| replace:: :abbr:`ZFS (Zettabyte File System)`
.. |RAM| replace:: :abbr:`RAM (Random Access Memory)`
.. |CPU| replace:: :abbr:`CPU (Central Processing Unit)`
.. |LXD| replace:: :abbr:`LXD (LinuX containers Daemon)`

.. _Alpine: https://www.alpinelinux.org/
