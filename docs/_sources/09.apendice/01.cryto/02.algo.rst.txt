.. _tecnicas-crypto:

***********************
Técnicas criptográficas
***********************
Estudiaremos bajo este epígrafe tres actividades propies de la criptografía:

- Resumen criptográfico, gracias a las funciones *hash*.
- El cifrado y cuáles son los algoritmos que se usan para ello.
- La firma digital.

Remataremos con un apéndice práctico que indique cómo llevar a cabo estas tareas
en un sistema *Linux*.

.. _hash:

Resumen critográfico
********************
Las :dfn:`funciones hash` o :dfn:`funciones digest` o :dfn:`funciones resumen`
son funciones que dada una entrada generan siempre una salida de la misma
longitud (el llamado :dfn:`resumen`). Se caracterizan por:

+ ser *deterministas*, esto es, para una misma entrada siempre generar la
  misma salida.

+ minimizar las *colisiones*, esto es, minimizar la posibilidad de obtener
  una misma salida para dos entradas distintas.

+ generar, sea cual sea la entrada, resúmenes del mismo tamaño. cuya
  consecuencia inmediata es que operan en un solo sentido, esto es, a partir del
  original obtenemos su resumen, pero a partir del resumen es imposible
  averiguar cuál era la información de partida.

La actividad de resumir criptográficamente la información está relacionada con
el :ref:`objetivo de la integridad <crypto-objetivos>`, ya que dadas las
propiedades de las funciones *hash*, es extremadamente improbable que un
contenido que no ha cambiado su resumen, haya cambiado.

Entre las funciones de *hash* más conocidas se encuentran:

|MD5|
   Genera un resumen de 128 *bits* representado habitualmente por 32 dígitos
   hexadecimales. Es muy común usarlo como comprobación de la integridad de
   ficheros. Su seguridad está en entredicho, ya que presenta problemas de
   colisiones.

|SHA|
   Es una familia de funciones *hash*  que ha ido sufriendo diversas revisiones:
   |SHA|\ -0, |SHA|\ -1, |SHA|\ -2 y |SHA|\ -3. Tanto |SHA|\ -0 como |SHA|\ -1
   generan resúmenes de 160 *bits*. Ambas se consideran inseguras y se
   desaconseja su uso para paliar esto, se desarrolló |SHA|\ -2, que implementa
   funciones *hash* de 224, 256, 364 y 512 *bits*. Se las conoce habitualmente
   como |SHA|\ -224, |SHA|\ -256, |SHA|\ -364 y |SHA|\ -512. |SHA|\ -3, por su
   parte, cambia internamente los algoritmos, pero está pensada para generar
   resúmenes de la misma longitud que |SHA|\ -2.

.. seealso:: Más adelante, puede consultar :ref:`cómo hacer resúmenes
   criptográficos en Linux <md5sum>`.

Cifrado
*******
Por :dfn:`cifrado` nos referimos particularmente a la acción de ofuscar cierta
información con el objeto de que pueda ser posteriormente desofuscada.
Si deshacer la ofuscación no puede hacerla un tercero no autorizado, entonces
el cifrado se encamina a la *privacidad* y tenemos propiamente aquello que se
refiere como *cifrado*. En cambio, si cualquier tercero puede desofuscar, el
propósito no es la privacidad, sino la *autenticidad*, y entraríamos en el
terreno de la :ref:`firma digital <firma-digital>`, que trataremos más adelante.

Ya se ha comentado que los algoritmos modernos de cifrado se basan en el
secreto de la clave y no en el secreto del propio algoritmo, por lo que nos
centraremos en los algoritmos basados en clave. Atendiendo a ella hay dos tipos
de algoritmos.

**De clave simétrica**
   También conocidos como :dfn:`de clave privada` o de :dfn:`clave única`. Son
   aquellos en que se usa la misma clave para cifrar y descifrar.

**De clave asimétrica**
   También conocidos como :dfn:`de clave pública` o :dfn:`de doble clave`. Son
   aquellos que emplean una pareja de claves, de manera que si una se usa para
   cifrar la otra sirve para descifrar los mensajes cifrados con la primera.

Es común, además, que las técnicas de cifrado usen una combinación de un
algoritmo de clave simétrica y otro de clave asimétrica, lo cual se conoce como
:ref:`cifrado híbrido <híbrido>`.

Cifrado simétrico
=================
En este tipo de cifrado se usa la misma clave tanto para cifrar como para
descifrar. Cuando las dos partes se encuentran alejadas, ese, precisamente, es
su punto débil, ya que exige que la clave se encuentre en ambos extremos con
anterioridad a la comunicación, lo cual sólo puede lograrse:

- Encontrándose físicamente las ambas partes para intercambiar en mano la clave.
- Transmitiendo la clave en claro, lo cual puede provocar que se intercepte y
  sea inútil el cifrado posterior.

Obviando lo anterior, el factor decisivo en la robustez de la clave es su
longitud: cuanto más larga sea, más difícil es averiguarla por fuerza bruta.
Por ejemplo, una clave de **8** *bits* sólo puede tener 2\ :sup:`8`, o sea,
**256** valores distintos, lo que implica que podría adivinarse con un máximo
de **256** intentos.

Algunos algoritmos de cifrado simétrico muy conocidos son:

|DES|
   Considerado actualmente inseguro para la capacidad computacional de los
   ordenadores modernos, ya que tiene una longitud de sólo **56** *bits*.
   Su sucesor directo es el 3\ |DES| (Triple |DES|) que usa el triple de
   longitud para la clave (**168** bits), aunque también se ha ido desplazando
   en favor de otros algoritmos.

|AES|
   Sustituyó al algoritmo anterior y tiene una longitud de **256** *bits*. Es
   más rápido y, además, no se le conocen vulnerabilidades. Es uno de los
   algoritmos más ampliamente utilizados.
   
Existen otros algoritmos como `Twofish <https://es.wikipedia.org/wiki/Twofish>`_
o `Blowfish <https://es.wikipedia.org/wiki/Blowfish>`_.

.. _asimetrico:

Cifrado asimétrico
==================
Se basa en el uso de una pareja de claves relacionadas entre sí, de modo que lo
que se haya cifrado con una es posible descifrarlo con la otra, pero no con
ella misma. Los algoritmos están diseñados para que el interesado genere una de
estas parejas de claves, de manera que cada una de ellas realice un papel
diferente:

+ Una es la clave **privada** que debe mantenerla en secreto su propietario.
+ Otra es la clave **pública**, pensada para que el propietario la comunique
  a los demás.

De este modo, cuando se desea enviar un mensaje secreto a un destinatario, lo
que se hace es usar la clave *pública* de éste, ya que tal mensaje sólo podrá
ser descifrado usando su clave *privada* correspondiente, que sólo está en
posesión del destinatario. El cifrado con la clave *pública*, pues garantiza
la privacidad.

Por otra parte, si un emisor usa su clave **privada** para cifrar, el mensaje
podrá descifrase con su clave *pública* correspondiente. Como la clave
*pública* es, eso, pública, no sirve para salvaguardar ninguna privacidad,
pero sí para asegurar que el emisor del mensaje es el dueño de las claves.
Afinaremos esto más adelante.

Los algoritmos más conocidos de cifrado asimétrico son:

|RSA|
   Es el primer sistema criptográfico de clave asimétrica y aún se considera
   válido (esto es, suficientemente seguro) tanto para cifrar y como firmar
   digitalmente. Por lo general, utiliza claves con una longitud entre 1024 y
   4096 *bits*.

|DSA|
   Es otro sistema criptográfico de clave asimétrica que en la actualidad se
   considera débil, por lo que se desaconseja su uso para cifrar información\
   [#]_. Sus claves tienen una longitud entre 512 y 1024 *bits*.

   Variantes de este sistema que mejoran la fortaleza de las claves y, por
   tanto permiten su uso para cifrado, son:

   * |ECDSA|, que usa `criptografía de curva elíptica
     <https://es.wikipedia.org/wiki/Criptograf%C3%ADa_de_curva_el%C3%ADptica>`_.

   * |EdDSA|, que usa también criptografía de curva elíptica. y se desarrolló
     para mejorar la velocidad de cifrado sin sacrificar velocidad. Un tipo
     particular de este sistema es *Ed22519*, que permiten usar las últimas
     versiones de :program:`openssh`.

La desventaja fundamental del cifrado asimétrico frente al simétrico es su costo
computacional: para un mismo nivel de seguridad requiere claves más largas y,
además, para una misma longitud de clave es más costoso en tiempo.

.. _híbrido:

Cifrado híbrido
===============
El :dfn:`cifrado híbrido` consiste en el uso de técnicas de cifrado simétrico y
asimétrico para sortear:

+ La debilidad intrínseca de tener que la clave simétrica en ambos extremos de
  la comunicación.

+ El mayor costo computacional del cifrado asimétrico.

Para ello realiza una primera fase de la comunicación utilizando cifrado
asimétrico que sirve estrictamente para intercambiar una clave simétrica de
forma segura, que se denomina :dfn:`clave de sesión`. Una vez que la clave se
encuentra en ambos extremos se pasa a realizar un cifrado simétrico usando esta
clave de sesión.

Conclusiones
============
Lo adecuado al cifrar es usar:

a. Cifrado **simétrico** sobre:

   + Información que no se requiere transmitir (p.e. cifrado de disco).
   + Información que se transmite siempre que la clave simétrica se transmita
     cifrada asimétricamente, lo cual ya hemos definido como cifrado **híbrido**.

b. Cifrado **asimétrico** sobre:

   + Una clave simétrica que se desea transmitir, que es el complemento del
     cifrado *híbrido* que se acaba de citar. Para cifrar la clave simétrica
     se utiliza la clave pública de aquel a quien se desea transmitirla, puesto
     que sólo él será capaz de descifrarla.
   + Un resumen generado con una función *hash*. Este acción de cifrado, sin
     embargo, es parte de la *firma digital*.

.. _firma-digital:

Firma digital
*************
Una :dfn:`firma digital` es al mundo digital lo que la firma manuscrita al
papel, esto es, algo que certifica que los términos expresados en un texto
son ratificados por la persona firmante.

La *firma digital* no es un acción atómica como las dos anteriores (resumir y
cifrar), sino un conjunto de acciones de resumen y cifrado que permiten
asegurar la identidad del emisor y la integridad del mensaje. Esquemáticamente,
firmar consiste en:

+ Obtener :ref:`un resumen <hash>` de los datos mediante una función *hash*.
+ Cifrar tal resumen con la clave privada del firmante.
+ Transmitir los datos (o almacenarlos) junto al resumen cifrado (la firma).

Ante esto, un tercero (por ejemplo, el destinatario de un mensaje de correo
firmado), es capaz de certificar que el origen es quien dice ser, ya que
descifrará el resumen con la clave pública de éste y, por otra parte, podrá
comprobar si los datos conservan su integridad gracias al propio resumen
descifrado.

.. note:: Aunque conceptualmente una firma no es más que un resumen cifrado con
   clave privada, en la práctica es necesario añadir metainformación sobre quién
   firmó o cuándo lo hizo.

Apéndice práctico
*****************
Trataremos bajo este epúgrafe algunas herramientas criptográficas muy
habituales en sistemas *Linux* que implementan los conceptos tratados hasta
ahora: |GnuPG|, más enfocado a implementar el estándar `OpenPGP
<https://www.openpgp.org/>`_\ [#]_, y Open\ |SSL|. La segunda herramienta
(incluida en el paquete homónimo) es más que probable que ya se encuentre
instalada en el sistema. Para la primera, en cambio, sí conviene hacer
precisiones.

.. note:: En caso de que hagamos pruebas en una máquina virtual es conveniente
   aumentar la entropía del sistema para mejorar y acelerar la creación de
   claves asimétricas. Para lograrlo puede obrarse del siguiente\ [#]_ modo::

      $ cat /proc/sys/kernel/random/entropy_avail  # Entropía inicial
      234
      # apt install rng-tools
      # echo 'HRNGDEVICE=/dev/urandom' >> /etc/default/rng-tools
      # echo 'RNGDOPTIONS="--fill-watermark=90%"' >> /etc/default/rng-tools
      # invoke-rc.d rng-tools start
      # cat /proc/sys/kernel/random/entropy_avail
      2159

.. _gnupg.1:

.. rubric:: Instaslación de |GnuPG|

La instalación es sumamente sencilla::

   # apt install gnupg

Como configuración podemos usar la siguiente::

   $ mkdir -m 700 ~/.gnupg
   $ cat > ~/.gnupg/gpg.conf
   #keyserver hkps://sks-keyservers.net:443
   keyserver hkp://pool.sks-keyservers.net
   no-greeting
   armor

   personal-digest-preferences SHA512
   cert-digest-algo SHA512
   default-preference-list SHA512 SHA384 SHA256 SHA224 AES256 AES192 AES CAST5 ZLIB BZIP2 ZIP Uncompressed
   personal-cipher-preferences AES256 TWOFISH CAMELLIA256 3DES

Con la que seleccionamos cuáles son nuestros algoritmos de cifrado y *hash*
preferidos. Además, con :kbd:`armor` guardamos el texto cifrado como caracteres
imprimibles.

Si ejecutamos la orden::

   $ gpg --version

podremos consultar cuáles son los algoritmos de cifrado, *hash* y compresión que
usa el programa.

.. index:: md5sum
.. index:: shasum, sha256sum, sha384sum, sha512sum

.. _md5sum:
.. _shasum:

Resúmenes
=========
Para la generación de resúmenes *hash* de ficheros y flujos de texto, existen
dos órdenes fundamentales: :command:`md5sum` y la familia de comandos
:program:`shasum` (:command:`sha256sum`, :command:`sha384sum`,
:command:`sha512sum`), que comparten una misma interfaz, con lo que es
indiferente ilustrar el uso de una u otra orden. Suelen encontrarse todas
instaldas en el sistema.

La generación del resumen puede hacerse del siguiente modo::

   $ echo "Hola, caracola" > saludo1.txt
   $ md5sum saludo1.txt
   b18a245aba5384920d7f6a488d725181  saludo1.txt

.. note:: Si se incluyen varios ficheros como argumento, se calculará el resumen
   de cada uno de ellos.

También es posible calcular el resumen de un flujo de datos::

   $ echo "Hola, caracola" | sha256sum
   d261be2aa264d38cad717fa8493dacc0b3f33f949869d39ecf7611689fb617ad  -

Habitualmente, los resúmenes generados se almacenan, a fin de que puedan servir
más adelante para comprobar la integridad de los ficheros::

   $ md5sum saludo1.txt saludo2.txt > saludos.md5

Con posterioridad, podrá comprobarse la integridad del siguiente modo\ [#]_::

   $ LC_ALL=C md5sum -c saludos.md5
   saludo1.txt: OK
   saludo2.txt: OK

.. note:: Si se almacenó el resumen de un flujo de datos (obsérvese que aparece
   un "-", en vez de el nombre del fichero), puede comprobarse que otro flujo es
   el mismo pasándolo a través de la entrada estándar::

      $ echo "Hola, caracola" | md5sum >  flujo.md5
      $ echo "Hola, caracola" | LC_ALL=C md5sum -c flujo.md5
      -: OK

También es posible utilizar para este fin (aunque no es lo habitual) las
herramientas que usaremos después para ilustrar el cifrado y la firma digital:

* :ref:`GnuPG <gnupg.1>`::

      $ gpg --print-md sha512 fichero.txt

  e incluso hay una opción que calcula los resúmenes según todos los algoritmos
  disponibles::

      $ gpg --print-mds fichero.txt

* :ref:`OpenSSL <openssl>`::

      $ openssl dgst -sha512 fichero.txt

.. _openssl:

Open\ |SSL|
===========
Open\ |SSL| es la herramienta de cifrado por antonomasia en sistemas *Linux*.

.. note:: Volveremos sobre esta herramienta al introducir los :ref:`certificados
   digitales <cert-digital>`.

Cifrado simétrico
-----------------
Una forma de llevarlo a cabo es esta::

   # openssl enc -aes256 -pbkdf2 -a -in fichero.txt -out fichero.txt.enc

que utiliza |AES|\ -256 para el proceso y genera un cifrado en `base64
<https://es.wikipedia.org/wiki/Base64>`_ gracias a la opción `-a`. Para
descifrar basta con añadir la opción :kbd:`-d` y, obviamente, utilizar como
entrada el texto cifrado::

   # openssl enc -aes256 -a -d -in fichero.txt.enc -out fichero-recuperado.txt

.. note:: Tanto :kbd:`-in` como :kbd:`-out` son opcionales y, si no se
   especifican, se entenderá que la entrada es la entrada estándar y la salida
   la salida estándar.

.. note:: La clave simétrica para el cifrado/descifrado se pide de forma
   interactiva. Puede proporcionarse en la propia orden incluyendo la opción
   :kbd:`-pass`::

      # openssl enc -aes256 -pbkdf2 -a -pass pass:clave-secreta -in fichero.txt -out fichero.txt.enc
      
Cifrado asimétrico
------------------
Llevarlo a cabo requiere generar un par de claves (|RSA| en concreto)::

   # openssl genrsa -aes128 -out privkey.pem 4096
   # openssl rsa -in privkey.pem -pubout -out pubkey.pem

Las órdenes generan un par de claves |RSA| (:file:`privkey.pem` y
:file:`pubkey.pem`) de 4096 *bits*. Para proteger la clave privada con una
contraseña (esto es, con una clave simétrica) hemos usado la opción
:kbd:`-aes128`. Esto último es un simple mecanismo de seguridad para que sea
imposible usar la clave privada sin conocer esta contraseña. Así, en caso de
robo, el ladrón aún deberá averiguar la contraseña.

.. note:: Las claves que se piden interactivamente pueden pasarse a través de
   las opciones :kbd:`-passin` o :kbd:`-passout` (vease :manpage:`openssl(1ssl)`
   para más información)

Con ellas podemos cifrar y descifrar pequeños ficheros. Usando la clave pública
para cifrar y la privada para descifrar::

   # echo "Hola" > saludo.txt
   # openssl rsautl -encrypt -inkey pubkey.pem -pubin -in saludo.txt -out saludo.enc
   # openssl rsautl -decrypt -inkey privkey.pem -in saludo.enc
   Hola

¿Podemos cifrar con la privada y descifrar con la pública? Teóricamente sí,
aunque tal como lo hacemos ahora no tenga mucho sentido (porque obrar así es
propio del acto de firmar)::

   # openssl rsautl -sign -inkey privkey.pem -in saludo.txt -out saludo.enc
   # openssl rsautl -verify -inkey pubkey.pem -pubin -in saludo.enc
   Hola

.. note:: Si en vez de un un simple par de claves, tenemos un :ref:`certificado
   digital <cert-digital>`, aún podremos realizar estas operaciones sustituyendo
   :kbd:`-pubin` por :kbd:`-certin`

Firma digital
-------------
Partiendo de las claves |RSA| ya generadas en el apartado anterior
(:file:`privkey.pem`, :file:`pubkey.pem`), podemos hacer una primera
aproximación tomando la :ref:`descripción de lo que es la firma digital
<firma-digital>`::

   $ echo "Este es el contenido del fichero que firmo" > fichero.txt
   $ sha256sum fichero.txt | tee /dev/tty | openssl rsautl -sign -inkey privkey.pem -out fichero.sign
   47ebcc00b179c0f1fc8f45fec4a3e6a55fbb1aeddd8a5bb6ee52c5d7f57d1d3a  fichero.txt

Ya tenemos el archivo original (:file:`fichero.txt`) y la firma
(:file:`fichero.sign`) generada con la clave privada. Con ellos dos y la clave
publica correspondiente, podemos comprobar integridad e identidad::

   $ sha256sum fichero.txt
   47ebcc00b179c0f1fc8f45fec4a3e6a55fbb1aeddd8a5bb6ee52c5d7f57d1d3a  fichero.txt
   $ openssl rsautl -verify -inkey pubkey.pem -pubin -in fichero.sign
   47ebcc00b179c0f1fc8f45fec4a3e6a55fbb1aeddd8a5bb6ee52c5d7f57d1d3a  fichero.txt

Dado que coincide el resumen del archivo con la firma descifrada con la clave
pública, podemos concluir que el archivo no ha cambiado y que lo certificó el
propietario de la clave.

En realidad, para firmar con más comodidad aunque nos abstraigamos del
concepto::

   $ openssl dgst -sha256 -sign privkey.pem -out fichero.sign fichero.txt

Y para verificar la firma::

   $ openssl dgst -sha256 -verify pubkey.pem -signature fichero.sign fichero.txt 
   Verified OK

.. note:: Cuando lo que se tiene no es un simple par de claves, sino un
   :ref:`certificado digital <cert-digital>` aún puede hacerse este proceso
   extrayendo previamente la clave pública del certificaddo::

      $ openssl x509 -in micert.pem -pubkey -nooout > pubkey.pem

|GnuPG|
=======
Aunque el próposito final del programa es la implementación del estándar
Open\ |PGP|, podemos utilizarlo para ilustrar los conceptos anteriores.

Cifrado simétrico
-----------------
Podemos utilizarlos para cifrar un archivo determinado::

   $ echo 'Hola, caracola!!!' > /tmp/saludo.txt
   $ gpg -c /tmp/saludo.txt

La orden genera el fichero cifrado :file:`/tmp/saludo.txt.asc` con esta pinta\
[#]_::

   -----BEGIN PGP MESSAGE-----

   jA0ECQMCgmqtVcUnh0H80lAB2H6YjrKdXR2P2I9a0JRDKpoQhEJc//dnzA550ged
   Q2DYgVpYgaL3Se26CAwii54xhZfUijWnGg7pPSKc7Zd81TLvQm75MA6IbsDPGHEN
   eQ==
   =5YjK
   -----END PGP MESSAGE-----

El fichero podría haberse enviado a otro fichero usando la opción ``--output``::

   $ gpg -c -o /tmp/otrofichero.asc /tmp/saludo.txt

.. note:: Si se usa como nombre de fichero :kbd:`-`, la salida será la estándar.

.. note:: El formato del fichero cifrado, sigue el estándar marcado por
   *OpenPGP*, pero también podríamos haber generado un fichero cifrado que use
   caracteres no imprimibles habiendo añadido ``--no-armor``. En este caso, la
   extensión añadida es ``.gpg`` en vez de ``.asc``.

Si hemos ejecutado las ordenes anteriores, habremos comprobado que se pide de
forma interactiva la clave simétrica de cifrado. Si queremos ejecutar la orden
de forma no interactiva podemos hacer lo siguiente::

   $ gpg --batch --passphrase 'contraseñadificil' -c /tmp/saludo.txt

o bien::

   $ printf 'contraseñadificil' | gpg --batch --passphrase-fd 0 -c /tmp/saludo.txt

.. warning:: Aunque recordemos que eso guardará en el historial la contraseña y
   es muy discutible su seguridad, por lo que al menos deberíamos asegurarnos de
   que tal cosa no sucede.

Para descifrar, podemos no usar la opción :kbd:`-d`::

   $ gpg -qd /tmp/saludo.txt.asc
   Hola, caracola!!!

.. note:: La opción ``-q`` ejecuta la orden en modo silencioso.

Hay algo, sin embargo, extraño: ¿por qué no se nos pide la clave anteriormente
suministrada durante la operación de cifrado para descifrar?  La razón es que
:command:`gpg` levanta automáticamente un demonio que se encarga de recordar
claves. Si por alguna razón se desea pararlo, puede hacerse::

   $ gpgconf --kill gpg-agent

.. note:: Si nuestra intención es consultar cuáles es el cifrado sin descifrar
   en absoluto, podemos hacer::

      $ gpg --list-only -d saludo.txt.asc

.. _gpg-pgp:

Cifrado asimétrico
------------------
La implementación de este tipo de cifrado está determinado por el propósito de
la orden (el estádar Open\ |PGP|), por lo que hay muchos aspectos que vienen
determinados por ello. Sea como sea, cifrar asimétricamente requiere previamente
generar una pareja de claves::

   $ gpg --gen-key --default-new-key-algo rsa3072

que nos pedirá el nombre de su propietario y la dirección de correo electrónico,
que se usará como identificador para las claves generadas. Además, se nos pedirá
una clave simétrica con la que cifrar la clave privada. Esta contraseña deberá
consignarse cada vez que la clave privada tenga que usarse y es una simple
medida de seguridad para evitar que, si la clave privada cae en manos ajenas, el
ladrón tenga fácil usurpar la identidad del legítimo propietario. Se han
añadido, además, dos datos relevantes: el tiempo de vigencia de la clave (un
año), que de forma predeterminada es eterno, y el tipo de algoritmo\ [#]_. La
orden no sólo genera las claves, sino que las almacena en el anillo de claves
(todo dentro de :file:`~/.gnupg`), con lo que podremos consultar su existencia
listando cuáles son las claves públicas almacenadas::

   $ gpg --list-keys --keyid-format short
   /home/usuario/.gnupg/pubring.kbx
   --------------------------------
   pub   rsa3072/B0B83042 2019-11-08 [SC] [caduca: 2021-11-07]
         F08A6107385FE48775100943E3DCBB0AB0B83042
   uid      [  absoluta ] Licenciado Cebadilla (cuenta de pruebas) <xxxx@gmail.com>

.. note:: Obsérvese que la clave, tal como se ha generado, sólo sirve para
   firmar y no para cifrar (no aparece :kbd:`E` dentro de los corchetes). Si
   nuestra intención es usarla :ref:`también para cifrar <gnupg-cif-asi>`
   entonces deberemos añadir una subclave para cifrado::

      $ gpg  --quick-add-key F08A6107385FE48775100943E3DCBB0AB0B83042
   
También podemos comprobar las claves privadas::

   $ gpg --list-secret-keys

Por ahora sólo veremos una y una respectivamente. Lo habitual es que
dispongamos de una única clave privada y muchas públicas, ya que podemos importar
a nuestro repositorio claves públicas ajenas.

En versiones modernas  de :command:`gpg` existe la opción :kbd:`--full-gen-key` que
pregunta interactivamente otras opciones como el propio algoritmo o el tiempo de
vigencia. En cualquier caso, si se quiere alterar algún parámetro, como el
tiempo de vigencia, puede usarse la opción :kbd:`--edit-key`::

   $ gpg --edit-key xxxx@gmail.com

.. rubric:: Importación/exportación local de claves

Como debemos compartir nuestra clave pública con el resto de usuarios y, a su
vez, recibir de éstos sendas claves públicas, GnuPG_ provee de mecanismos para
la importación y exportación de claves.

Para exportar una clave pública del repositorio, podemos hacer::

   $ gpg --export xxxx@gmail.com > clave.asc

.. note:: La selección de la clave puede hacerse con cualquier parte
   de la identificación que se usó al crear la clave (el correo electrónico
   es una de ellas). Si no especificamos ninguna clave en concreto, se
   exportarán todas.

Si, además, queremos exportar la clave privada, podemos añadirla al fichero
anterior::

   $ gpg --export-secret-keys xxxx@gmail.com >> clave.asc
   
El proceso inverso de importar claves es también sencillo::

   $ gpg --import clave.asc

orden que importará todas las claves contenidas en el fichero\ [#]_.

.. note:: Si la importación se hace del siguiente modo::

      $ gpg --import --import-options import-show --dry-run clave.asc

   se muestran los datos de la clave o claves que se importarán, pero
   al incluir también ``-dry-run`` no se hará efectiva la importación,
   con lo que el resultado es que tenemos un método para consultar las
   claves contenidas en un fichero.

.. rubric:: Importación/Exportación remota de claves

Hasta ahora, hemos importado y exportado claves a o desde ficheros. Ahora bien,
existen **servidores** |PGP| que almacenan claves públicas y que permiten
importarlas lo que facilita el intercambio de claves. Dependiendo de cuál sea
el servidor Puede accederse a través de distintos protocolos. El fichero de
configuración de configuración define un servidor que soporta un protocolo
seguro por el puerto **443** (lo que puede ayudarnos si estamos dentro de una
red que restringe el acceso a internet)::

   $ gpg --send-keys B0B83042

.. warning:: En versiones modernas, para poder hacer esta exportación remota es
   necesario que se encuentre instalado el paquete *dirmngr*.

La importación de claves, por su parte, puede hacerse así::

   $ gpg --recv-keys 00188366

si se conoce el **ID** y, si no es así. es posible buscar la clave usando alguna
porción de la cadena de identificación (p.e. el correo electrónico)::

   $ gpg --search-keys xxxx@gmail.com

.. rubric:: Revocación

Es posible que deseemos anular una clave antes de que esta expire por algún
motivo. Para ello debemos generar una revocación e importarla a nuestro
anillo de claves::

   $ gpg --gen-revoke xxxx@gmail.com | gpg --import
   
   [...]

Para revocar también esta clave en el servidor público al que exportamos esta
clave con anterioridad, basta con exportar la clave ahora revocada de nuevo::

   $ gpg --send-keys B0B83042

.. _gnupg-cif-asi:

.. rubric:: Cifrado

Para cifrar un mensaje con la clave pública de alguien a fin de que sólo éste
sea capaz de descifrarlo puede hacerse::

   $ gpg -er su_correo@dominio.com -o - fichero.txt > fichero.txt.asc

o bien, si se desea codificar lo remitido por la entrada estándar::

   $ echo "Esto es un secreto" | gpg -er su_correo@dominio.com > secreto.asc

.. note:: :code:`-o -` permite que la salida cifrada vaya a la salida estándar,
   ya que de lo contrario se escribirá en un fichero que se llamará igual que el
   original adjuntando el prefijo ``.asc`` (o ``.gpg`` si se usa la opción
   ``--no-armor``). Si el mensaje original procedía de la entrada estándar, se
   dirige directamente a la salida estándar y, en consecuencia, no es necesario.

Para descifrar la clave en un sistema que tenga disponible la clave privada
correspondiente a la pública con la que se firmó, basta con::

   $ gpg -qd secreto.asc
   Esto es un secreto

Firma digital
-------------
|GnuPG| lleva a cabo la firma de archivos mediante el estándar Open\ |PGP|::

   $ echo "Este es el contenido del fichero que firmo" > fichero.txt
   $ gpg --detach-sign --default-key mi_cuenta@example.com -o fichero.sig fichero.txt

De esta manera tenemos un fichero original (:file:`fichero.txt`) y su resumen
cifrado digitalmente con nuestra clave privada en :file:`fichero.sign`. Si
analizamos el fichero de firma::

   $ gpg --list-packets fichero.sign
   :signature packet: algo 1, keyid 53175AA29C972B7B
           version 4, created 1543050622, md5len 0, sigclass 0x00
           digest algo 10, begin of digest 04 9e
           hashed subpkt 33 len 21 (issuer fpr v4 040968BBC05C39A4DD2A43BD53175AA29C972B7B)                                                  
           hashed subpkt 2 len 4 (sig created 2018-11-24)
           hashed subpkt 28 len 23 (signer's user ID)
           subpkt 16 len 8 (issuer key ID 53175AA29C972B7B)
           data: [3071 bits]

veremos algunas características de la firma, como:

* qué algoritmo de clave asimétrica se usó, el **1**, que se corresponde con una
  clave asimétrica |RSA|, válida tanto para firma como para cifrado. El
  significado de los códigos puede encontrarse en el :rfc:`4880`, y en concreto
  en la `sección 9.1 <https://tools.ietf.org/html/rfc4880#section-9.1>`_.

* qué clave se usó: la *53175AA29C972B7B*, que efectivamente es la nuestra:

  .. code-block:: console
     :emphasize-lines: 4

     $ gpg --keyid-format long -list-keys
     /home/usuario/.gnupg/pubring.kbx
     --------------------------------
     pub   rsa3072/53175AA29C972B7B 2018-11-21 [SC] [expires: 2020-11-20]
           040968BBC05C39A4DD2A43BD53175AA29C972B7B
     uid                 [ unknown] Soy el que soy <mi_cuenta@example.com>
           sub   rsa3072/4B1F09C9B84F038E 2018-11-21 [E] [expires: 2020-11-20]

* con qué algoritmo se resumió el fichero, el **10**, que es *SHA512* según 
  `la sección 9.4 <https://tools.ietf.org/html/rfc4880#section-9.4>`_ del
  :rfc:`4880`.

Si hacemos llegar **ambos** archivos a un tercero, y éste posee nuestra clave
pública, podrá verificar nuestra identidad gracias a descifrar la firma y la
integridad del fichero gracias al resumen que contiene esta::

   $ gpg --verify fichero.sign fichero.txt
   [...]
   Primary key fingerprint: 0409 68BB C05C 39A4 DD2A  43BD 5317 5AA2 9C97 2B7B
   $ echo $?
   0

.. seealso:: Hay un extenso tutorial del uso de GnuPG_ en la `wiki de Archlinux
   <https://wiki.archlinux.org/index.php/GnuPG_(Espa%C3%B1ol)>`_.

.. rubric:: Notas al pie

.. [#] De hecho, `OpenSSH <https://www.openssh.com/>`_, para su versión 7,
   `deshabilitó el uso de DSA
   <https://www.gentoo.org/support/news-items/2015-08-13-openssh-weak-keys.html>`_.
.. [#] Se fuerza a que la orden se ejecute en inglés, para que el resultado se
   exprese como *OK* o *FAILED*. En castellano, la leyenda se expresa de forma
   muy farragosa.
.. [#] Trataremos este estándar al hablar sobre :ref:`correo electronico <email-seguro>`.
.. [#] Usar, sin embargo, el propio kernel para la generación de la
   entropía no es muy recomendable. Debería usarse el dispositivo
   hardware (/dev/hwrng), pero en la máquina virtual es posible que
   no esté. Para :program:`qemu` véase
   `su wiki <https://wiki.qemu.org/Features/VirtIORNG>`_.
.. [#] El archivo cifrado es imprimible gracias a que incluimos :kbd:`armor` en
   el archivo de configuración.
.. [#] El algoritmo elegido utiliza una clave |RSA| de 2048 *bits* tanto para
   cifrado como para firmado. Otro posible algoritmo es *ed25519*.
.. [#] En nuestro caso, sería una clave pública y su correspondiente privada.

.. |DES| replace:: :abbr:`DES (Data Encryption Standard)`
.. |AES| replace:: :abbr:`AES (Advanced Encryption Standard)`
.. |RSA| replace:: :abbr:`RSA (Rivest, Shamir y Adleman)`
.. |DSA| replace:: :abbr:`DSA (Digital Signature Algorithm)`
.. |ECDSA| replace:: :abbr:`ECDSA (Elliptic Curve Digital Signature Algorithm)`
.. |EdDSA| replace:: :abbr:`EdDSA (Edwards-curve Curve Digital Signature Algorithm)`
.. |GnuPG| replace:: :abbr:`GnuPG (GNU Provacy Guard)`
.. |MD5| replace:: :abbr:`MD5 (Message Digest Algorithm 5)`
.. |SHA| replace:: :abbr:`SHA (sechure Hash Algorithm)`
.. |PGP| replace:: :abbr:`PGP (Pretty Good Privacy)`
.. |SSL| replace:: :abbr:`SSL (Secure Socket Layer)`
.. |FNMT| replace:: :abbr:`FNMT (Fabrica Nacional de Moneda y Timbre)`
.. |PKCS| replace:: :abbr:`PKCS (Public-Key Cryptography Standards)`

.. _GnuPG: https://www.gnupg.org/
.. _keyservers: http://www.keyserver.net/
