.. _nftables-bridge:

Bridges
*******
El tratamiento de las :ref:`interfaces bridge <bridge>` se hace también con
:command:`nft`. Ahora bien, si se observa el :ref:`diagrama de flujo
<netfilter-hooks>` (eliminando el flujo para tráfico |ARP|):

.. image:: files/ebtables.png

se comprobará que el tráfico que circula entre dos puertos de un mismo *bridge*
no se ve afectado por las reglas que se escriban para los puntos de enganche del
resto de las familias (excepto *netdev*, claro está). Podemos ratificarlo si
para una máquina con dos interfaces en puente definimos estar reglas:

.. code-block:: bash

   table ip filter {
      chain FORWARD {
         type filter hook forward priority filter;
         
         ip protocol icmp counter
      }
   }

   table bridge filter {
      chain FORWARD {
         type filter hook forward priority filter;
         
         ip protocol icmp counter
         iif eth0 ip protocol icmp counter
      }
   }

Al enviar un paquete |ICMP| desde una máquina conectada en un extremo a otra
colocada en el otro extremo, el contador de la tabla de la familia *ip* no
detectará ningún paquete, mientras que los contadores de la familia *bridge*,
sí.

Otro aspecto a tener en cuenta es que en las reglas que se encuentren en cadenas
de la familia *bridge* las interfaces serán los puertos del puente, es decir, si
se pretende establecer una condición con :kbd:`iif` la interfaz que deberá
proporcionarse será aquel puerto físico del puente por el que entró el paquete
(p.e. *eth0*). Sin embargo, si ese mismo paquete, estaba destinado para la propia
máquina que hace de puente y, en consecuencia, atraviesa enganches de la familia
*ip* (en concreto *prerouting* e *înput*) en las cadenas asociadas a tales
enganches, la interfaz de entrada no será el puerto físico, sino la interfaz
virtual *bridge*. Por tanto, la condición con :kbd:`iif` deberá hacerse con
*br0* (o comoquiera que se llame la interfaz).

Finalmente, si nuestra intención es forzar a que los paquetes sean encaminados,
no conmutados, la estrategia con :command:`nftables` es alterar en el paquete la
|MAC| de destino para que coincida con la de la interfaz *bridge*, obviamente
antes de que :program:`netfilter` lleve a cabo la comprobación para dirigir el
paquete hacia en enganche *forward* de la familia *bridge*. Así pues, si nuestra
intención fuera encaminar siempre el tráfico |ICMP| que entra por el puerto
*eth0*, podríamos hacer:

.. code-block:: bash

   table bridge filter {
      chain PREROUTING {
         type filter hook prerouting priority dstnat

         iif eth0 icmp type echo-request ether daddr set de:ad:be:ef:27:d4 \
                                         meta pkttype set unicast \
                                         meta mark set 0x1
      }
   }

suponiendo que *de:ad:be:ef:27:d4* sea la |MAC| de nuestra interfaz puente.
Hemos aprovechado, además, para marcar tales paquetes por si más adelante
necesitamos hacer referencia a tales paquetes. 

Sí, además, tuviéramos intención de apropiarnos del paquete podríamos
redirigirlo:

.. code-block:: bash

   table ip nat {
      chain PREROUTING {
         type nat hook prerouting priority dstnat
         meta mark 1 redirect
      }
   }

.. _nftables-arp:

Tráfico |ARP|
*************


.. |ARP| replace:: :abbr:`ARP (Address Resolution Protocol)`
.. |MAC| replace:: :abbr:`MAC (Media Access Control)`
.. |ICMP| replace:: :abbr:`ICMP (Internet Control Message Protocol)`
