Uso avanzado
************

.. _nftables-sets:

Conjuntos
=========
En :program:`nftables` hay dos tipos de conjuntos:

* **Anónimos** que son aquellos invariables que se añaden directamente a las
  reglas y, sin ponerles nombre, ya se han introducidos en algunos ejemplos::

   # nft add rule filter INPUT tcp dport {http, https} accept

  este, por ejemplo, es un conjunto anónimimo que almacena dos puertos: el
  **80** y el **443**. El conjunto se ha creado así y así permanecerá mientras
  exista la regla.

* **Nominados**, que se asocian a tablas y pueden usarse en las reglas. Estos
  conjuntos implementan las posibilidades de :ref:`ipset <ipset>` en
  :command:`iptables`. A ellos dedicaremos el epígrafe.

Los *conjuntos nominados* se crean asociándole una tabla, dotándolos de un
nombre y declarando qué tipo de dato contendrán. Por ejemplo::

   # nft add table filter
   # nft add set filter www {type inet_service\;}

Por ahora nos hemos limitado a crear un conjunto llamado "www" que puede
contener puertos. Podría haber contenido también:

.. table::
   :class: nftables-set-type

   =============== =====================================
    Tipo            Descripción
   =============== =====================================
    ipv4_address     Direcciones |IP|\ v4
    ipv6_address     Direcciones |IP|\ v6
    ether_address    Direcciones |MAC|.
    inet_proto       Protocolos 
    inet_service     Puertos de conexión.
    mark             Marcas.
    ifname           Nombres de interfaces.
   =============== =====================================

Para usarlo basta anteponer una arroba al nombre::

   # nft add chain filter INPUT "{type filter hook input priority 0;}"
   # nft add rule filter INPUT tcp dport @www counter

aunque aún no contiene ningún puerto. Además del tipo, pueden añadirse otras
características al crear el conjunto:

.. table::
   :class: nftables-set-caract

   +----------------+----------+--------------------------------------------------------------------------------------+
   | Característica | Opción   | Descripción                                                                          |
   +================+==========+======================================================================================+
   | type           | Tipo de los elementos que constituyen el conjunto.                                              |
   +----------------+-------------------------------------------------------------------------------------------------+
   | timeout        | Tiempo de vida de los elementos que se añaden. Pasado éste, desaparecen automáticamente.        |
   |                | Implica que se puedan indicar tiempo de vida al añadir elementos.                               |
   +----------------+-------------------------------------------------------------------------------------------------+
   | elements       | Añade los elementos de la lista al conjunto                                                     |
   |                +-------------------------------------------------------------------------------------------------+
   |                | nft add set filter hosts \\"{type ipv4_addr; elements={1.1.1.1, 1.0.0.1};}\\"                   |
   +----------------+----------+--------------------------------------------------------------------------------------+
   | flags          | constant | El contenido del conjunto no puede cambiar mientras esté vinculado a alguna regla.   |
   |                +----------+--------------------------------------------------------------------------------------+
   |                | dynamic  | Crea conjuntos dinámicos, que añaden elementos directamente desde las reglas. Lo     |
   |                |          | trataremos en el :ref:`epígrafe dedicado a meters <nftables-meters>`.                |
   |                +----------+--------------------------------------------------------------------------------------+
   |                | interval | El conjunto contiene intervalos, no elementos individuales.                          |
   |                +----------+--------------------------------------------------------------------------------------+
   |                | timeout  | Al añadir elementos, se puede indicar el tiempo de vida de cada elemento             |
   |                +----------+--------------------------------------------------------------------------------------+
   |                | | nft add set filter hosts \\"{type ipv4_addr; flags constant, timeout;}\\"                     |
   |                | | nft add element filter hosts {1.1.1.1 timeout 1m}                                             |
   +----------------+----------+--------------------------------------------------------------------------------------+
   | size           | Cantidad máxima de elementos que puede contener el conjunto.                                    |
   +----------------+----------+--------------------------------------------------------------------------------------+

Podemos añadir elementos::

   # nft add element filter www {http, https}
   # nft list set filter www
   table ip filter {
      set www {
         type inet_service
         elements = { http, https }
      }
   }

aunque también pueden añadirse automáticamente a través de las reglas. Por
ejemplo, así controlaríamos las máquinas que nos ha hecho :program:`ping` en la
última hora::

   # nft add set filter pines {type ipv4_addr; timeout 1h; size 65535}
   # nft add rule filter INPUT icmp type echo-request add @pines {ip saddr}

.. warning:: Cuando se añaden elementos de este modo, es más que conveniente
   fijar un tamaño máximo y un tiempo de vida del elemento en el conjunto.

Los conjuntos con nombre puede eliminarse::

   # nft delete set filter www

siempre y cuando no estén vinculados a ninguna regla.
   
.. ¿"add rule ... delete @set" en los normales o en los dinámicos?
   https://lwn.net/Articles/806177/

.. _nftables-concat:

Concatenaciones
===============
Las :dfn:`concatenaciones` permiten agrupar selectores (o sea, condiciones) para
tratarlas de modo conjunto. Como operador se usa el punto ("."). Por ejemplo::

   # nft add filter FORWARD ip saddr . ip daddr {10.0.0.4 . 10.0.0.8, 10.0.0.5 . 10.0.0.10} counter

En este caso, el selector vandŕa tanto para si la conexión es entre *10.0.0.4* y
*10.0.0.8* como si es entre *10.0.0.5* y *10.0.0.10*.

Esta es una expresión literal, pero podría haberse construido también un
conjunto nomimal concatenado los dos valores necesarios::

   # nft add set filter orig-dest {type ipv4_addr . ipv4_addr\;}
   # nft add element filter orig-dest {10.0.0.4 . 10.0.0.8, 10.0.0.5 . 10.0.0.10}
   # nft add filter FORWARD ip saddr . ip daddr @orig-dest counter

También es posible concatenar las claves en los mapas y disccionarios.

.. seealso:: Échele un vistazo al `epigrafe de concatenaciones de la wiki de
   nftables
   <https://wiki.nftables.org/wiki-nftables/index.php/Concatenations>`_.


.. _nftables-maps:

Mapas
=====
Los :dfn:`mapas` son conjuntos de valores a los que se accede a través de una clave.
Como en el caso de los conjuntos:

- Pueden ser **anónimos** o **nominados**.
- Pueden utilizarse en las sentencias de las reglas.
- Puede modificarse su contenido manualmente.

Y a diferencia de ellos, no pueden añadirse elementos a través de reglas. Para
utilizarlos debe hacerse lo siguiente::

   dnat to tcp dport map {80: 192.168.1.100, 8888: 192.168.1.101}
   counter name tcp dport map @conn

es decir, debe colocarse primero la expresión que define el valor y después la
expresión que define la clave. El primero es un ejemplo de mapa anónimo y el
segundo de mapa con nombre don se requiere hacer algunas definiciones previas::

   # nft add counter filter c22
   # nft add counter filter c28
   # nft add map filter conn {type inet_service: counter}
   # nft add element filter conn {ssh: c22, http: c80}

Y ahora sí, podria usarse el mapa::

   # nft add rule filter INPUT ct state new counter name tcp dport map @conn

.. _nftables-vmap:

Diccionarios
============
Los :dfn:`diccionarios` son mapas en que los valores son acciones terminalesi (excepto
*reject*). Por ejemplo, esta regla salta dependiendo del tipo de tráfico a una u
otra cadena de usuario::

   # nft add rule filter ct state new tcp port vmap {ssh: jump SSH, ftp: jump FTP}

También es posible hacer diccionarios nominados.

.. _nftables-meters:

Conjuntos dinámicos
===================

.. todo:: Repasar este apartado para aclarar el concepto y usar también
   ejemplos con quota.

Los :dfn:`conjuntos dinámicos` permiten incluir elementos atendiendo al estado
de la conexión. La diferencia con un conjunto a secas es que éstos últimos
incluyen, por ejemplo, una dirección |IP| a secas, mientras que los dinámicos
incluyen una dirección |IP| que cumple una determinada condición; y si no la
cumple, la |IP| no es añadida y, además, la acción fracasa. Tienen dos formas de
expresarse:

* Hasta la versión *0.9.0* (que es precisamente la que trae *Buster*) a través
  de la palabra clave :kbd:`meter`.
* A partir de la *0.9.1* a través del *flag* :kbd:`dynamic` al crear conjuntos.

Aunque :kbd:`meter` sigue existiendo, esta marcada como obsoleta por lo que
podría ocurrir que en el futuro desapareciera. En consecuencia, trataremos ambas
sintaxis. Para ilustrarlas consideremos en caso de que queramos aceptar
peticiones |ICMP| pero limitadas a una cada segundo por cliente como máximo.

.. rubric:: meter

Con *lista blanca*, deberíamos hacer::

   # nft add filter INPUT icmp type echo-request \
      meter pines size 65535 {ip saddr timeout 5s limit rate 1/second burst 1 packets} accept

En este caso, se añaden al *meter* (el conjunto) "pines" todas las direcciones
de origen cuyo ratio no sobrepase el de 1 por segundo. La sentencia resulta verdadera en ese caso y,
en consecuencia se acepta el paquete. En cambio, si el ratio es mayor, no se cumple la regla y,
consecuentemente por la política predeterminada, el paquete se desecha.

Con *lista negra*, el equivalente será::

   # nft add filter INPUT icmp type echo-request \
      meter pines size 1000 {ip saddr timeout 5s limit rate over 1/second burst 1 packets} drop

En que sólo se añadirán a "pines" las direccions de origen que sobrepasen la
cuota, de lo que resultará una evaluación verdadera y se acabará desechando el
paquete.

Em ambos casos, podremos consultar el contenido de "pines" con::

   # nft list meter filter pines

.. rubric:: dynamic

El equivalente usando el tipo *dinámico* consiste en definir primero el conjunto::

   # nft add set filter pines {type ipv4_addr; timeout 5s; flags dynamic; size 65535}

y añadir los elementos en la regla correspondiente. Con una política de *lista
blanca*, la regla quedaría así::

   # nft add filter INPUT icmp type echo-request \
      add @pines {ip saddr limit rate 1/second burst 1 packets} accept

Para aclarar el concepto, podemos hacernos la siguiente pregunta: ¿cuál es la
diferencia entre la sentencia anterior, y esta otra suponiendo que "pines" sea
un conjunto normal?

::

   # nft add filter INPUT icmp type echo-request \
       limit rate 1/second burst 1 packets add @pines {ip saddr} accept
   
La diferencia radica en que en este segundo caso, siempre que una máquina envíe
una peticion |ICMP| se comprueba el ratio de peticiones que incluirá todas las
peticiones de todas las máquinas; y, si ese ratio global no supera el límite, se
aceptará la petición. Por ese motivo, una máquina que individualmente no haga
más de una petición, puede ser rechazada, si otras máquinas contribuyeron a
alcanzar el límite. En cambio, con los conjuntos dinámicos, se analiza cada
ratio individual.

En conjunción con las concatenaciones los *conjuntos dinámicos* permiten la
implementación de las funcionalidades que ofrecen los módulos :ref:`hashlimit y
connlimit <iptables-limit>` de :program:`iptables`.

.. ¿Se puede usar en conjuntos dinámicos?
   # nft add rule filter OUTPUT tcp sport 22 add @sshquota {ip daddr timeout 20m quota over 10 mbytes} drop
   Según esto, parece que sí:
   https://netdevconf.info/2.1/slides/apr8/ayuso-netdev-netfilter-updates-canada-2017.pdf

.. _nftables-connlimit:

connlimit
---------
Dependiendo de cuáles sean las conexiones que queremos limitar, así tendremos
que obrar. Consideraremos una política de *lista blanca* en nuestro servidor:

**Conexiones totales de un servicio**
   Para limitar el número máximo de conexiones simultáneas a un servicio (p.e.
   un máximo de 5 conexiones a |SSH|)::

      # nft add rule filter INPUT ct state new tcp dport ssh \
         meter sshconn size 65535 {tcp dport ct count 5} accept

**Conexiones totales de un cliente**
   Para limitar el número máximo de conexiones que un cliente puede hacer
   a cualquier servicio::

      # nft add rule filter INPUT ct state new tcp dport ssh \
         meter sshconn size 65535 {ip saddr ct count 5} accept

**Conexiones totales desde un cliente a un servicio**
   Para limitar el número máximo de conexiones que un mismo cliente puede
   hacer a un servicio::

      # nft add rule filter INPUT ct state new tcp dport ssh \
         meter sshconn size 65535 {ip saddr . tcp dport ct count 2} accept

.. note:: Se usa :kbd:`meter` por compacidad. A partir de los ejemplos, la
   implementación con *dynamic* es trivial.

.. _nftables-hashlimit:

hashlimit
---------
El módulo *hashlimit* de :program:`iptables` permite limitar el flujo de paquete
según cual sea el origen o destino de las conexión. A diferencia de *limit*, que
limita el flujo de paquetes global. Para implementar esta funcionalidad en
:program:`nftables` basta con utilizar *limit* en conjunción con los conjuntos
dinámicos y la concatenación. Por ejemplo, para limitar la descarga a través de
|SSH| con cada cliente podemos hacer::

   # nft add rule filter OUTPUT tcp sport ssh \
      meter sshlimit size 65535 {tcp sport . ip daddr timeout 10s limit rate over 100kbytes/second} drop

que limitará a 100 KiB/s el tráfico de descarga para cada uno de los clientes.

.. _nftables-flowtables:

flowtables
===========
Las :dfn:`flowtables` son un mecanismo para acelerar el paso de los paquetes
por la máquina haciendo que fluyan directamente entre la entrada (el enganche
*ingress*) y la interfaz de salida sin tener que atravesar todo los enganches
intermedios:

.. image:: files/netfilter-flowtable.png

Para lograrlo, el paquete que abre conexión sí debe realizar el camino habitual,
especificar que los paquetes utilizarán el atajo y, obviamente lograr alcanzar
su destino.

.. warning:: Hasta la versión 0.8.0, los :ref:`conjuntos dinámicos
   <nftables-meters>` se denominaron *flowtables* y se usaba la palabra
   :kbd:`flowtable` en vez de :kbd:`meter`. Pese a ello, son dos conceptos
   absolutamente distintos: téngalo en cuenta si ve en internet algún ejemplo de
   uso antiguo.

Para ilustrarlo supongamos que a través del cortafuegos deseamos alcanzar un
servidor |SSH| que se encuentra en el otro extremo::

   table ip filter {
      flowtable sshpass {
         hook ingress priority 0
         devices = {eth0, eth1}
      }

      chain FORWARD {
         type filter hook forward priority 0
         policy drop

         tcp dport ssh flow add @sshpass 
         tcp dport ssh counter accept
         
      }
   }

donde se ha supuesto que *eth0* y *eth1* son las interfaces del router. En la
cadena *FORWARD*, declaramos que queremos que el tráfico |SSH| use "sshpass" y,
además, aceptamos el paquete para que llegue a su destino. Incluímos un contador
para comprobar que los siguientes paquetes de la conexión no lo aumentan, ya que
jamás pasan por la cadena. Si incluyeremas un contador para el tráfico de
réplica, veríamos que ocurre otro tanto.

La técnica también soporta |NAT|, de modo que si el servidor se encontrara en
una red interna que el cortafuegos oculta haciendo enmascaramiento a la salida
de *eth0*, seguiríamos pudiendo acelerar la intermediación de los paquetes::

   table ip filter {
      flowtable sshpass {
         hook ingress priority 0
         devices = { eth0, eth1 }
      }

      chain POSTROUTING {
         type nat hook postrouting priority 100

         oif "eth0" masquerade comment "Ocultamos la red 192.168.255.0/24"
      }

      chain PREROUTING {
         type nat hook prerouting priority -100

         iif "eth0" tcp dport 10022 dnat to 192.168.255.2:22 comment "DNAT al servidor SSH"
      }

      chain FORWARD {
         type filter hook forward priority filter
         policy drop

         ct status dnat flow add @sshpass comment "Aceleramos el tránsito hacia los servidores"
         ct status dnat accept
      }
   }

.. https://wiki.nftables.org/wiki-nftables/index.php/Flowtable
   https://github.com/torvalds/linux/blob/master/Documentation/networking/nf_flowtable.txt

.. _nftables-marcas:

Marcas
======

.. _nftables-recent:

Emulación de recent
===================

.. |ICMP| replace:: :abbr:`ICMP (Internet Control Message Protocol)`
.. |MAC| replace:: :abbr:`MAC (Media Access Control)`
.. |NAT| replace:: :abbr:`NAT (Network Address Translation)`
