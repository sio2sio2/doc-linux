Uso avanzado
************

.. _nftables-sets:

sets
====
En :program:`nftables` hay dos tipos de conjuntos:

* **Anónimos** que son aquellos invariables que se añaden directamente a las
  reglas y, sin ponerles nombre, ya se han introducidos en algunos ejemplos::

   # nft add rule filter INPUT tcp dport {http, https} accept

  este, por ejemplo, es un conjunto anónimimo que almacena dos puertos: el
  **80** y el **443**. El conjunto se ha creado así y así permanecerá mientras
  exista la regla.

* **Nominados**, que se asocian a tablas y pueden usarse en las reglas. Estos
  conjuntos implementan las posibilidades de :ref:`ipset <ipset>` en
  :command:`iptables`. A ellos dedicaremos el epígrafe.

Los *conjuntos nominados* se crean asociándole una tabla, dotándolos de un
nombre y declarando qué tipo de dato contendrán. Por ejemplo::

   # nft add table filter
   # nft add set filter www {type inet_service\;}

Por ahora nos hemos limitado a crear un conjunto llamado "www" que puede
contener puertos. Podría haber contenido también:

.. table::
   :class: nftables-set-type

   =============== =====================================
    Tipo            Descripción
   =============== =====================================
    ipv4_address     Direcciones |IP|\ v4
    ipv6_address     Direcciones |IP|\ v6
    ether_address    Direcciones |MAC|.
    inet_proto       Protocolos 
    inet_service     Puertos de conexión.
    mark             Marcas.
    ifname           Nombres de interfaces.
   =============== =====================================

Para usarlo basta anteponer una arroba al nombre::

   # nft add chain filter INPUT "{type filter hook input priority 0;}"
   # nft add rule filter INPUT tcp dport @www counter

aunque aún no contiene ningún puerto. Además del tipo, pueden añadirse otras
características al crear el conjunto:

.. table::
   :class: nftables-set-caract

   +----------------+----------+--------------------------------------------------------------------------------------+
   | Característica | Opción   | Descripción                                                                          |
   +================+==========+======================================================================================+
   | type           | Tipo de los elementos que constituyen el conjunto.                                              |
   +----------------+-------------------------------------------------------------------------------------------------+
   | timeout        | Tiempo de vida de los elementos que se añaden. Pasado éste, desaparecen automáticamente.        |
   |                | Implica que se puedan indicar tiempo de vida al añadir elementos.                               |
   +----------------+-------------------------------------------------------------------------------------------------+
   | elements       | Añade los elementos de la lista al conjunto                                                     |
   |                +-------------------------------------------------------------------------------------------------+
   |                | nft add set filter hosts \\"{type ipv4_addr; elements={1.1.1.1, 1.0.0.1};}\\"                   |
   +----------------+----------+--------------------------------------------------------------------------------------+
   | flags          | constant | El contenido del conjunto no puede cambiar mientras esté vinculado a alguna regla.   |
   |                +----------+--------------------------------------------------------------------------------------+
   |                | dynamic  | Crea conjuntos dinámicos, que añaden elementos directamente desde las reglas. Lo     |
   |                |          | trataremos en el `epígrafe dedicado a meters <nftables-meters>`_.                    |
   |                +----------+--------------------------------------------------------------------------------------+
   |                | interval | El conjunto contiene intervalos, no elementos individuales.                          |
   |                +----------+--------------------------------------------------------------------------------------+
   |                | timeout  | Al añadir elementos, se puede indicar el tiempo de vida de cada elemento             |
   |                +----------+--------------------------------------------------------------------------------------+
   |                | | nft add set filter hosts \\"{type ipv4_addr; flags constant, timeout;}\\"                     |
   |                | | nft add element filter hosts {1.1.1.1 timeout 1m}                                             |
   +----------------+----------+--------------------------------------------------------------------------------------+
   | size           | Cantidad máxima de elementos que puede contener el conjunto.                                    |
   +----------------+----------+--------------------------------------------------------------------------------------+

Podemos añadir elementos::

   # nft add element filter www {http, https}
   # nft list set filter www
   table ip filter {
      set www {
         type inet_service
         elements = { http, https }
      }
   }

aunque también pueden añadirse automáticamente a través de las reglas. Por
ejemplo, así controlaríamos las máquinas que nos ha hecho :program:`ping` en la
última hora::

   # nft add set filter pines {type ipv4_addr; timeout 1h; size 65535}
   # nft add rule filter INPUT icmp type echo-request add @pines {ip saddr}

.. warning:: Cuando se añaden elementos de este modo, es más que conveniente
   fijar un tamaño máximo y un tiempo de vida del elemento en el conjunto.

Los conjuntos con nombre puede eliminarse::

   # nft delete set filter www

siempre y cuando no estén vinculados a ninguna regla.
   

.. _nftables-maps:

maps
====
Los :dfn:`mapas` son conjuntos de valores a los que se accede a través de una clave.
Como en el caso de los conjuntos pueden ser **anónimos**::

   # nft add rule nat PREROUTING dnat tcp dport map {80: 192.168.1.100, 8888: 192.168.1.101}

pero también pueden tener nombre::

   # nft add map nat servidores {type inet_service: ivp4_addr}
   # nft add element nat servidores {80: 192.168.1.100, 8888: 192.168.1.101}
   # nft add rule nat PREROUTING dnat tcp dport map @servidores

.. _nftables-vmap:

Diccionarios
============
Los :dfn:`diccionarios` son mapas en que los valores son acciones terminalesi (excepto
*reject*). Por ejemplo, esta regla salta dependiendo del tipo de tráfico a una u
otra cadena de usuario::

   # nft add rule filter ct state new tcp port vmap {ssh: jump SSH, ftp: jump FTP}

También es posible hacer diccionarios nominados.

.. _nftables-concat:

Concatenaciones
===============
Las :dfn:`concatenaciones` permiten agrupar selectores (o sea, condiciones) para
tratarlas de modo conjunto. Como operador se usa el punto ("."). Por ejemplo::

   # nft add filter FORWARD ip saddr . ip daddr {10.0.0.4 . 10.0.0.8, 10.0.0.5 . 10.0.0.10} counter

En este caso, el selector vandŕa tanto para si la conexión es entre *10.0.0.4* y
*10.0.0.8* como si es entre *10.0.0.5* y *10.0.0.10*.

Esta es una expresión literal, pero podría haberse construido también un
conjunto nomimal concatenado los dos valores necesarios::

   # nft add set filter orig-dest {type ipv4_addr . ipv4_addr\;}
   # nft add element filter orig-dest {10.0.0.4 . 10.0.0.8, 10.0.0.5 . 10.0.0.10}
   # nft add filter FORWARD ip saddr . ip daddr @orig-dest counter

También es posible concatenar las claves en los mapas y disccionarios.

.. seealso:: Échele un vistazo al `epigrafe de concatenaciones de la wiki de
   nftables
   <https://wiki.nftables.org/wiki-nftables/index.php/Concatenations>`_.

.. _nftables-limit:

limit
=====
:kbd:`limit` es la acción que posibilita la limitación de caudales de tráfico.
Cuando nuestra política es de **lista blanca**, entonces deberemos aceptar paquetes
mientras el tráfico se mantenga por debajo de un ratio. Por ejemplo, esta regla
acepta peticiones |ICMP| que se encuentren por debajo de la tasa de un paquete
por segundo::

   # nft add rule filter INPUT icmp type echo-request limit rate 1/second accept

los que la superen acabarán rechazados por la propia política predeterminada. En
cambio, si la política es de **lista negra**, lo que debemos hacer es rechazar las peticiones 
que superen la tasa::

   # nft add rule netdev filter INGRESS icmp type echo-request limit rate over 1/second drop

.. warning:: Hay que tener presente que, por defecto, la :ref:`ráfaga admisible
   <iptables-limit>` es de **5**, por lo que si se hacen pruebas de concepto para
   comprobar cómo funciona la limitación es preferible limitar la ráfaga a
   **1**::

      # nft add rule filter INPUT icmp type echo-request limit rate 1/second burst 1 packets accept
   
Esto implementaría una limitación básica (la que posibilita el módulo *limit* de
:command:`iptables`) sin discriminación de qué máquina es la que se conecta.
Para implementar *connlimit* y *hashlimit* deberíamos recurrir. además, al
:ref:`uso de conjuntos dinámicos <nftables-meters>` y quizás :ref:`concatenaciones
<nftables-concat>`.

.. todo:: Implementar defensa contra ataque DoS a semejanza de iptables.

.. _nftables-meters:

Conjuntos dinámicos
===================
Los :dfn:`conjuntos dinámicos` permiten incluir elementos atendiendo al estado
de la conexión. La diferencia con un conjunto a secas es que éstos últimos
incluyen, por ejemplo, una dirección |IP| a secas, mientras que los dinámicos
incluyen una dirección |IP| que cumple una determinada condición; y si no la
cumple, la |IP| no es añadida y, además, la acción fracasa. Tienen dos formas de
expresarse:

* Hasta la versión *0.9.0* (que es precisamente la que trae *Buster*) a través
  de la palabra clave :kbd:`meter`.
* A partir de la *0.9.1* a través del *flag* :kbd:`dynamic` al crear conjuntos.

Aunque :kbd:`meter` sigue existiendo, esta marcada como obsoleta por lo que
podría ocurrir que en el futuro desapareciera. En consecuencia, trataremos ambas
sintaxis. Para ilustrarlas consideremos en caso de que queramos aceptar
peticiones |ICMP| pero limitadas a una cada segundo por cliente como máximo.

.. rubric:: meter

Con *lista blanca*, deberíamos hacer::

   # nft add filter INPUT icmp type echo-request \
      meter pines size 65535 {ip saddr timeout 5s limit rate 1/second burst 1 packets} accept

En este caso, se añaden al *meter* (el conjunto) "pines" todas las direcciones
de origen cuyo ratio no sobrepase el de 1 por segundo. La sentencia resulta verdadera en ese caso y,
en consecuencia se acepta el paquete. En cambio, si el ratio es mayor, no se cumple la regla y,
consecuentemente por la política predeterminada, el paquete se desecha.

Con *lista negra*, el equivalente será::

   # nft add filter INPUT icmp type echo-request \
      meter pines size 1000 {ip saddr timeout 5s limit rate over 1/second burst 1 packets} drop

En que sólo se añadirán a "pines" las direccions de origen que sobrepasen la
cuota, de lo que resultará una evaluación verdadera y se acabará desechando el
paquete.

Em ambos casos, podremos consultar el contenido de "pines" con::

   # nft list meter filter pines

.. rubric:: dynamic

El equivalente usando el tipo *dinámico* consiste en definir primero el conjunto::

   # nft add set filter pines {type ipv4_addr; timeout 5s; flags dynamic; size 65535}

y añadir los elementos en la regla correspondiente. Con una política de *lista
blanca*, la regla quedaría así::

   # nft add filter INPUT icmp type echo-request \
      add @pines {ip saddr limit rate 1/second burst 1 packets} accept

Para aclarar el concepto, podemos hacernos la siguiente pregunta: ¿cuál es la
diferencia entre la sentencia anterior, y esta otra suponiendo que "pines" sea
un conjunto normal?

::

   # nft add filter INPUT icmp type echo-request \
       limit rate 1/second burst 1 packets add @pines {ip saddr} accept
   
La diferencia radica en que en este segundo caso, siempre que una máquina envíe
una peticion |ICMP| se comprueba el ratio de peticiones que incluirá todas las
peticiones de todas las máquinas; y, si ese ratio global no supera el límite, se
aceptará la petición. Por ese motivo, una máquina que individualmente no haga
más de una petición, puede ser rechazada, si otras máquinas contribuyeron a
alcanzar el límite. En cambio, con los conjuntos dinámicos, se analiza cada
ratio individual.

En conjunción con las concatenaciones los *conjuntos dinámicos* permiten la
implementación de las funcionalidades que ofrecen los módulos :ref:`hashlimit y
connlimit <iptables-limit>` de :program:`iptables`.

.. https://wiki.nftables.org/wiki-nftables/index.php/Meters

.. _nftables-hashlimit:

hashlimit
---------

.. _nftables-connlimit:

connlimit
---------

.. _nftables-recent:

recent
======

.. _nftables-flowtables:

flowtables
===========

.. |ICMP| replace:: :abbr:`ICMP (Internet Control Message Protocol)`
.. |MAC| replace:: :abbr:`MAC (Media Access Control)`
