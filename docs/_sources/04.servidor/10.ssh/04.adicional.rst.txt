Aspectos adicionales
********************

Transferencia de ficheros
=========================
El protocolo |SSH| permite también la transferencia de ficheros entre cliente y
servidor. Aunque puede :ref:`configurarse de modo que sustituya perfectamente a
un servidor FTP <ssh-ftp>`, por ahora nos limitaremos a usar la configuración
predeterminada y ver los clientes que nos permiten esta tarea.

.. index:: scp
.. _scp:

La primera forma de aprovechar las posibilidades de transferencia es usar una
herramienta de *copia remota* (:command:`scp` proporcionada por *openssh* o
:command:`pscp.exe` de la suite de :program:`putty`). El modo de usarlo es muy
semejante al de la orden :command:`cp` del mundo *unix*::

   $ scp /path/local/fichero.txt usuario@servidor:path/en/el/servidor

es decir, un *origen* (en este caso un fichero del cliente) y un destino que se
expresa como al conectarnos con el cliente :command:`ssh` seguido de dos puntos.
Si la ruta en el servidor es relativa se sobreentiende que lo es respecto al
directorio peronal del usuario. Si no se expresa ruta alguna, el fichero se
copiará en el directorio personal. En el ejemplo, el origen es local y el
destino remoto, por lo que la consecuencia es que *subimos* el fichero al
servidor. Para descargar no hay más que escoger un origen remoto y un destino
local\ [#]_::

   $ scp usuario@servidor:fichero_remoto.txt .

.. index:: sftp
.. _sftp:

La segunda forma de transferir ficheros es usar un cliente *[s]ftp*, similiar al
cliente del |FTP| tradicional. *openssh* proporciona :command:`sftp`, y
:program:`putty` su equivalente :command:`psftp`\ ::

   $ sftp usuario@servidor
   sftp> put fichero_local
   sftp> get fichero_remoto

Algunos clientes gráficos de |FTP| como `filezilla
<https://filezilla-project.org/>`_, soportan también el protocolo *sFTP*.

.. note:: Tanto :command:`scp` como :command:`sftp` hacen uso de la
   configuración contenida en :file:`~/.ssh/config`, por lo que podremos
   aprovechar las conexiones con nombre que hayamos creado en él.

.. index:: sshfs
.. _sshfs:

El tercer método para tranferir ficheros en sistemas *unix* es montar algún
directorio remoto del servidor en el cliente gracias a :program:`sshfs`::

   $ sshfs usuario@servidor: /tmp/ssh

De este modo, podremos traer y llevar ficheros de modo transparente haciendo uso
de las herramientas habituales (:command:`cp`, :command:`mv`, etc). Para
desmontar el fichero (si no somos el administrador) puede hacerse::

   $ fusermount -u /tmp/ssh

.. _ssh-traampolin:

Trampolín de acceso
===================
Un servidor |SSH| puede usarse como trampolín de acceso a servicios
inaccesibles, bien porque se encuentran en máquinas que no son accesibles desde
internet, bien porque, aunque lo sean, tengamos restringido su acceso.

#. El método más simple y universal es establecer :ref:`un túnel dinámico
   <ssh-socks>`, tal como se explicó anteriormente.

#. Para el caso particular de que queramos acceder a un servidor |SSH|
   inaccesible a través de otro servidor |SSH| que sí es accesible podemos usar
   *ProxyCommand*::

      $ ssh -o "ProxyCommand ssh usuario1@servidor_accesible nc -q0 %h %p" usuario2@servidor_inaccesible

   En este caso, antes de que el cliente :command:`ssh` intente cualquier
   comunicación, usamos otro cliente que accede al servidor accesible y ejecuta
   :ref:`netcat <netcat>` para enchufarnos al servicio |SSH| del inaccesible.
   :program:`netcat` nos ofrece acceso crudo a tal servicio lo cual es
   precisamente lo que necesitamos porque tenemos un cliente :command:`ssh`
   esperando iniciar una conexión.

   El único pero de este método es que necesitamos que el servidor accesible
   tenga instalado :command:`netcat`. Sin embargo, a partir de la versión *5.4*
   del cliente, :command:`ssh` tiene la opción ``-W``, que sirve para suplir el
   papel de :program:`netcat`::

      $ ssh -o "ProxyCommand ssh -W %h:%p usuario1@servidor_accesible" usuario2@servidor_inaccesible

   .. note:: A partir de la versión *7.2* usar un servidor |SSH| como trampolín
      para el acceso a otro es aún más fácil, porque se añade la opción
      *ProxyJump*::

         $ ssh -o "ProxyJump usuario1@servidor_accesible" usuario2@servidor_inaccesible

      que incluso tiene una opción propio :kbd:`-J`, que simplifica aún más la
      sintaxis::

         $ ssh -J usuario1@servidor_accesible usuario2@servidor_inaccesible

   Con :program:`putty` podemos hacer otro tanto, sabiendo que entre los
   programas de la *suite* de :program:`putty` está :command:`plink` que es la
   versión en línea de comandos del propio :program:`putty`. De este modo,
   podemos configurar el programa así:

   .. image:: files/SSHproxy_putty1.png

   .. image:: files/SSHproxy_putty2.png

   El comando es análogo al usado con *ProxyCommand* en :command:`ssh`::

      C:\path\a\plink.exe %user@%proxyhost -nc %host %port

   .. todo:: Y, sin embargo.., no funciona. 

.. _redes-restr:

Redes restringidas
==================
Lo explicado bajo el epígrafe anterior, presupone que, desde la red local,
disponemos de acceso a un servidor |SSH|. Sin embargo, es común encontrarse con
redes con políticas de acceso muy restrictivas a internet, en las que
prácticamente el único tráfico saliente permitido es el de navegación web
(|HTTP| y |HTTP|\ s). En estos caso, la única solución pàra poder burlar la
restricción es preparar nuestro servidor |SSH| para que se pueda acceder
a él a través de uno de los dos puertos anteriores.

.. seealso:: Lea la  discusión sobre :ref:`puerto compartido
   <80-443-compartido>` presente en la sección de configuración de :ref:`n-ginx`.

Dependiendo del grado de vigilancia en la red del cliente y de cómo hayamos
configurado el servidor, tenemos varias soluciones:

.. _ssh-443:

Escucha directa
---------------
Sirve para la situación menos restrictiva y, por tanto, es la más fácil de
solucionar, ya que basta con hacer escuchar el servidor también en el puerto
**443**. Para ello no hay más que usar repetidamente la directiva **Port** en
:file:`/etc/ssh/sshd_config`::

   Port 22
   Port 443

Una alternayiva igualmente eficar es usar el cortafuegos para redirigir el elñ
tráfico entrante con destino al puerto **443** al puerto **22**. Vea cómo
:ref:`configurar el cortaguegos <firewall>` para ello.

Puerto compartido
-----------------
Si el puerto comparte con otro servidor, será un *software* como :ref:`sslh
<sslh>` o el *proxy* el que dirija el tráfico hacia el servidor |SSH|. Como el
tráfico no se enmascara para ocultarlo, no es necesaria ningún configuración
adicional ni en el cliente ni en el servidor |SSH|.

.. _haproxy:

|SSH| sobre |HTTP|\ s
---------------------
.. todo:: Trasladar y modificar este apartado 

En este último caso, un proxy intermedio analiza si el tráfico que intentamos
dirigir hacia un puerto **443** sigue el protocolo |TLS|, como
en teoría debería ser\ [#]_. Ante esto, no podemos usar ninguna de las soluciones
anteriores, porque en ellas el tráfico |SSH| viaja desnudo y éste no usa la
cobertura |TLS| que espera encontrar el *proxy*. Ahora bien, |TLS| es una
envoltura que cifra todo el contenido, lo que significa que tal *proxy* es
incapaz de saber a qué protocolo envuelve |TLS|. Por tanto, para el
*proxy*  no hay diferencia entre una comunicación |HTTP| envuelta en |TLS| (o
sea, |HTTP|\ s) o una comunicación |SSH| envuelta en |TLS|\ [#]_\ [#]_.

Esta estrategia requiere que en el puerto **443** no escuche un simple
*multiplexor*, sino un *proxy*. Para la ocasión, usaremos `el programa haproxy
<http://www.haproxy.org/>`_\ [#]_ y supondremos que todos los servidores para
los que intermedia se encuentran en la misma máquina.

Servidor
""""""""
.. warning:: El presente epígrafe describe cómo configurar *exclusivamente*
   :program:`haproxy` y :program:`ssh` (servidor y cliente). Su uso, sin
   embargo, determina que otros servicios para los que también intermedia (como
   |HTTP| o |VPN|) deban modificar asimismo sus configuraciones en el lado
   cliente o servidor para adaptarse. Lea, al respecto, los epígrafes
   correspondientes a su :ref:`uso con nginx <nginx-tras-proxy>` o su :ref:`uso con
   openvpn <vpn+haproxy>`.

:program:`haproxy` es, en realidad, una solución bastante general y, no permite
sólo envolver el protocolo interno para hacerlo invisible al *proxy*, sino
también usarlo a la manera de un *multiplexor* como :ref:`sslh <sslh>` [#]_, de
modo que los protocolos (|SSH|, |VPN|) viajen sin envolver y, al llegar a
:program:`haproxy` sean identificados y redirigidos al verdadero servidor.

Describiremos **dos soluciones** distintas:

#. Una en la que todos los protocolos |HTTP|. |SSH| y |VPN| van encapsulados con
   |TLS| y es el propio :program:`haproxy` el que los desencapsula, los reconoce
   y los envía al servidor correspondiente.

#. Otra en que junto a tráfico |TLS|, se permite que |SSH| y |VPN| circulen sin
   encapsular, de manera que al llegar el tráfico a :program:`haproxy` se manda
   a sus respectivos servidores. El tráfico |TLS|, por su parte, se desemcapsula
   como en el caso anterior para comprobar si es |HTTP|, |SSH| y |VPN| y,
   reconocidos, se reenvían al servidor correspondiente.

   En este segundo caso, la configuración permite enviar encapsulado o no el
   tráfico |SSH| y |VPN| según el grado de restricción de la red remota. Tenga
   en cuenta que encapsular este tráfico, que ya es tráfico seguro, sólo tiene
   por finalidad engañar a los proxies intermedios pero a costa de reducir el
   rendimiento de la conexión (ya que la cobertura |TLS| ocupa espacio) y,
   además, consume recursos del procesador al tener que cifrar y descifrar una
   capa extra.

.. note:: Obsérvese que todo esto exige incorporar capaz intermedias a la
   comunicación con el consiguiente coste en el rendimiento.

Antes de entrar a configurar, es necesario instalar::

   # apt-get install haproxy

y tener un certificado digital para el servicio, que puede ser autofirmado o
acreditado por una autoridad certificadora (véase :ref:`cómo obtener uno
<tls-cert>`)\ [#]_.

Sea como sea, es preciso señalar que :program:`haproxy` requiere que todas las
claves públicas y la privada participantes en la autenticación estén reunidas en
un mismo fichero.

En el caso de un *certificado autofirmado*, muy probablemente tendremos que
hacer algo así::

   # cat /etc/ssl/{private/ssl-cert-snakeoil.key,certs/ssl-cert-snakeoil.pem} > /etc/haproxy/keycert.pem
   # chmod 600 /etc/haproxy/keycert.pem

y en el caso de haber usado *letsencrypt*, si no hemos creado un *gancho* de
postinstalación como se sugirió en las explicaciones::

   # cat /etc/letsencrypt/live/mi.servidor.org/{fullchain,privkey}.pem > /etc/haproxy/keycert.pem
   # chmod 600 /etc/haproxy/keycert.pem

Creado el certificado adecuado, podemos hacer la configuración propiamente
dicha, que es bastante más complicada y con muchísimas más variantes que la de
:ref:`sslh <sslh>`.

.. rubric:: Primera variante

En ella, :program:`haproxy` recibe tráfico cifrado con |TLS|, los descifra y,
dependiendo de su naturaleza, lo envía al servidor adecuado. Bajo estos
presupuestos la configuración en :file:`/etc/haproxy/haproxy.cfg` queda así:

.. literalinclude:: files/haproxy_1.cfg
   :language: none
   
Las claves de esta configuración son las siguientes:

* Las cláusulas *frontend* definen las conexiones con el cliente y las cláusulas
  *backend* las conexiones con los servidores, de lo que se deduce que
  :program:`haproxy` escucha en el puerto **443** de la interfaz real (se ha
  supuesto que su *ip* es *172.22.0.2*); y conecta con tres servidores: uno |SSH|,
  uno |VPN| y un web, todos en la propia máquina.
* Es justamente ahí donde se cifra a la salida y se descifra a la entrada
  por lo que se añade el parámetro ``ssl`` y se indica cuál el certificado\ [#]_.
* Como consecuencia de que se descifra, es posible analizar el contenido
  y distinguir entre los tres tráficos\ [#]_.
* La conexión con el servidor web se hace en modo |HTTP| por la razón que
  se dará más adelante. Por ello se envía la comunicación al puerto **80**\
  [#]_.Esto nos permite añadir los campos ``X-Forwarder-For``
  para indicar la *ip* del cliente y la cabecera ``X-Forwarder-Proto`` para
  avisar de que el protocolo que usó el cliente fue |HTTP|\ s y no |HTTP| que es
  el que ve el servidor. Si se tiene convenientemente configurado el servidor web,
  las aplicaciones web podrán saber quién se conecta y cómo.

.. warning:: A diferencia de :ref:`sslh <sslh>`, :command:`haproxy` es un proxy
   y como tal establece dos conexiones distintas: una entre el cliente y él; y
   otra entre él y el servidor.  Consecuentemente, el servidor destinatario
   final es incapaz de conocer cuál es la *ip* del cliente, y entenderá que se
   comunica siempre con la propia máquina local (o sea, *127.0.0.1*), ya que
   :program:`haproxy` está situado en la misma máquina. Esto, por ejemplo,
   nos impediría  :ref:`protegernos contra ataques de fuera bruta <fail2ban>`,
   cuando los ataques se dirigen al puerto **443**, en vez de al **22**. En el
   caso concreto de esta variante, no tiene excesiva importancia, ya que la
   conexión sólo es posible si se establece además un tunel |SSH|, lo cual es
   bastante improbable que intenten hacer estos atacantes chinos que hacen
   búsuqedas automáticas de servidores |SSH| en la red.

.. note:: :program:`haproxy` con la colaboración del núcleo de linux, puede
   funcionar en modo transparente, de manera que el servidor reciba la |IP| del
   cliente. Sin embargo, esto exige que el servidor se encuentre en una máquina
   distinta a :program:`haproxy`. Por si es este nuestro caso, se deja :ref:`un
   epígrafe específico para su explicación <haproxy-transparente>`.

.. _haproxy-2v:

.. rubric:: Segunda variante

Añade a la primera, la posibilidad de también conectarse al puerto **443** sin
necesidad de establecer el túnel |TLS|. Puede descargar el código de
:download:`este enlace <files/haproxy_2.cfg>`.

.. note:: Por el modo en que se ha realizado esta configuración del servidor (y
   tambiém la anterior), éste no necesita conocer de antemano de qué naturaleza
   es el tráfico escondido dentro de |TLS|, ya que antes de discriminar tal
   tráfico desencapsula. Como encapsulado, el tráfico está cifrado y es
   imposible conocer cuál es (esta es, precisamente, la base de que podamos
   burlar cualquier *proxy*), el protocolo |TLS| habilita una manera de que en
   la propia envoltura se indique el nombre del servidor: la extensión |SNI|.

   Una manera de distinguir el tipo de tráfico es hacer que el cliente incluya
   un |SNI| distinto para cada tipo de tráfico y reconocer éste leyendo el
   |SNI|::

      frontend main
         bind 172.22.0.2:443  # No descriframos en absoluto.
         mode tcp
         option tcplog

         tcp-request inspect-delay 5s
         tcp-request content accept if { req_ssl_hello_type 1 }

         acl   ssh_request   req_ssl_sni -i ssh.mi.servidor.org
         acl   vpn_request   req_ssl_sni -i vpn.mi.servidor.org
         
         use_backend ssl-ssh   if ssh_request
         use_backend ssl-vpn   if vpn_request
         default_backend       http

   Ahora bien, el tráfico sigue cifrado con |TLS| lo cual puede no ser un
   problema para el servidor web\ [#]_, pero sí para los otros servidores. Eso
   obligaría a que el backend (*ssl-ssh* o *ssl-vpn* en el ejemplo) no entregue
   directamente el flujo, sino que cada uno de ellos lo envíe a un puerto local
   particular en que escucha también :program:`haproxy` y que sea en este
   *frontend* donde :program:`haproxy` aplique el certificado para descifrar.

.. _haproxy-cliente:

Cliente
"""""""
.. rubric:: UNIX

El cliente :command:`ssh` requiere ayudarse de un *software* que con |TLS|
envuelva su salida y desenvuelva su entrada, y esa labor la puede hacer
:command:`openssl`\ [#]_::

   $ ssh -p443 -o "ProxyCommand openssl s_client -quiet -connect %h:%p" usuario@mi.servidor.org

lo cual es un poco engorroso, así que es mejor dejarlo ya escrito en el fichero
de configuración del cliente::

   Hostname *servidor
      Host           mi.servidor.org
      Username       usuario
      Port           443

   Hostname ssl*
      ProxyCommand   openssl s_client -quiet -connect %h:%p

.. note:: Obsérvese que, de este modo, cuando no necesitemos encapsular el tráfico
   podremos hacer::

      $ ssh servidor

   y cuando queramos encapsularlo::

      $ ssh ssl-servidor

.. note:: Si quiséramos enviar un |SNI| podríamos añadir a :command:`openssl` la
   opción ``-servername``::

      ProxyCommand   openssl s_client -quiet -connect %h:%p -servername ssh.%h
   
.. rubric:: Windows

Con :program:`putty` es posible hacer su equivalente, pero como careceremos de
:program:`openssl`, es necesario primero instalarlo. El modo más sencillo es
instalar la versión *light* que ofrece `esta página
<https://slproweb.com/products/Win32OpenSSL.html>`_, que no requerirá más que
vayamos aceptando los distintos pasos de instalación. Al término, tendremos un
ejecutable funcional en el directorio :file:`C:\OpenSSL-Win32\bin\\`.

Instalado, basta configurar :program:`putty` de este modo:

.. image:: files/SSHoverSSL1.png

.. image:: files/SSHoverSSL2.png

esto es, configurar la sesión para conectarnos al puerto **443** del servidor
que en esta ocasión hemos llamado *example.net*. A continuación debemos escoger
``Connection>Proxy``, escoger un *proxy* de tipo *local* y usar
:program:`openssl` para establecer el túnel del mismo modo en que lo usábamos
con *ProxyCommand*::

   C:\OpenSSL-Win32\bin\openssl.exe s_client -connect %host:%port -quiet

.. _haproxy-transparente:

Modo transparente
"""""""""""""""""
Es posible hacer que :program:`haproxy` actúe como *proxy* absolutamente
transparente, pero ello exige algo más que reconfigurarlo. Para empezar, hay dos
condiciones:

#. El servidor destino de las conexiones (|SSH|, web, etc.) debe estar en una
   máquina distinta de la que corre :program:`haproxy`.
#. La máquina con :program:`haproxy` debe encontrarse en la ruta de salida de
   los servidores hacia los clientes. Esta exigencia se debe a que al actuar
   nuestro *proxy* de forma transparente, envía a los servidores como *ip* de
   origen de la comunicación la *ip* del cliente original. Por ello, la
   respuesta del servidor tendrá por destino la *ip* del cliente y, si el *proxy*
   no se interpone, llegará al cliente sin haber pasado otra vez por el proxy.
   Es preciso, pues, interponerse, capturar la respuesta y pasarla otra vez por
   :program:`haproxy`.

Para ilustrarlo consideraremos el siguiente esquema:

.. image:: files/haproxy-trans.png

que cumple con lo que decimos. La configuración exige:

* La modificación de un par de parámetros del núcleo (en
  :file:`/etc/sysctl/sysctl.conf`)::

      net.ipv4.ip_forward = 1
      net.ipv4.ip_nonlocal_bind = 1

  .. note:: Si se quiere habilitarlos inmediatamente, se puede ejecutar::

      # sysctl -p

* La adición de reglas de encaminamiento y reglas de :ref:`iptables <iptables>`\ 
  [#]_. Como suponemos que usamos debian, podemos hacerlas perennes, manipulando
  el fichero :file:`/etc/network/interfaces` y dejando así la configuración de
  la interfaz que conecta con la red en la que están los servidores::

   allow-hotplug eth1
   iface eth1 inet static
      address 192.168.255.1/24
      # Creamos la reglas
      up   iptables -t mangle -A PREROUTING -i $IFACE -p tcp -m socket --transparent -j MARK --set-mark 111
      up   ip rule add fwmark 111 lookup 100
      up   ip route add local 0.0.0.0/0 dev lo table 100
      # Y las destruimos
      down iptables -t mangle -D PREROUTING -i $IFACE -p tcp -m socket --transparent -j MARK --set-mark 111
      down ip rule del fwmark 111 lookup 100
      down ip route del local 0.0.0.0/0 dev lo table 100

  .. note:: Nótese que por razones de encaminamiento es bastante probable que
     necesitemos hacer enmascaramiento en la máquina router-proxy, así que la
     interfaz externa puede estar configurada así::

      allow-hotplug eth0
      iface eth0 inet static
         address 172.22.0.2/16
         gateway 172.22.0.1
         up   iptables -t nat -A POSTROUTING -o $IFACE -j MASQUERADE
         down iptables -t nat -D POSTROUTING -o $IFACE -j MASQUERADE

* La modificación (mínima) de la configuración de :program:`haproxy` que
  implica:

  * Comentar en la sección *global* los líneas que impiden que
    :program:`haproxy` se ejecute con premisos de administrador::

      #user haproxy
      #group haproxy

  * Añadir a todos los servidores con los que se quiere actuar como proxy
    transparente una directiva más para que se envíen los paquetes utilizando
    la *ip* del cliente como origen::

      backend ssh
         mode tcp
         source 0.0.0.0 usesrc clientip
         server ssh 192.168.255.2:22

.. note:: En el supuesto de que clientes y servidores estén en la misma red, no
   tiene efecto colocar como puerta de enlace de los servidores el *proxy* para
   obligar a que la respuesta pase por él, De todos modos, aún puede hacer que
   la comunicación pase por él, manipulando el encaminamiento de los servidores.
   Suponiendo que la red sea la *192.168.255.0/24*, y la *ip* del *proxy* la
   *192.168.255.10*, podríamos configurar la interfaz de cada servidor, así::

      allow-hotplug eth0
      iface eth0 inet static
         address 192.168.255.100/24   # La IP que deba tener el servidor.
         gateway 192.168.255.1
         up   ip route add 192.168.255.0/24 via 192.168.255.10 metric 1 dev eth0
         up   ip route del 192.168.255.0/24 dev eth0
         down ip route del 192.168.255.0/24 viua 192.168.255.10 metric 1 dev eth0
         down ip route add 192.168.255.0/24 dev eth0

.. _ssh-agent:

Persistencia de claves
======================
.. nota:: Este apartado sólo tiene interés cuando se usan clientes *linux*.

Ya se ha dicho muy a la ligera que el cliente de *openssh* sólo permite la
introducción de claves de manera interactiva, por lo que no hay opción que
permita pasarla al programa ni tampoco se lee esta de la entrada estándar. Si
optamos por el uso de certificados, podemos evitar la introducción de la
contraseña dejando la clave de paso en blanco, pero eso hace que ante un robo de
la clave privada, quedemos sin protección. Por otro lado, es posible que durante
nuestra sesión en el cliente necesitemos repetidamente acceder al servidor y, en
estos casos, será tedioso tener que estar repetidamente introduciendo la
contraseña.

Para paliar este inconveniente tenemos dos soluciones distintas, ambas basadas
en la autenticación con certificado y en *hacer coincidir la contraseña del
usuario local en el cliente con la clave de paso* que desbloquea la clave
privada.

.. warning:: Ambas soluciones exigen que la clave de paso sea la misma que la
   contraseña del usuario en el cliente, es decir, si en el cliente somos el
   usuario *pepe* con contraseña *pepesoyyo*, la clave de paso que debemos
   escoger al crear el certificado debe ser *pepesoyyo*.

.. index:: ssh-agent
.. index:: ssh-add

:command:`ssh-agent`
--------------------
Este programa permite almacenar claves de paso que luego se usarán cuando sea
necesario para desbloquear la clave privada. Su uso manual es el siguiente::

   $ ssh-agent
   SSH_AUTH_SOCK=/tmp/ssh-wuZYTNFc1wq1/agent.656; export SSH_AUTH_SOCK;
   SSH_AGENT_PID=657; export SSH_AGENT_PID;
   echo Agent pid 657;

Al arrancarlo devuelve su *PID* y el *socket* que usará para
comunicarse con el resto de programas de *ssh*. Para que sea así,
deben definirse como variables de ambiente las dos variables que se ven. De
hecho, la salida es el código que lleva a cabo tal cosa, por lo que la mejor
forma de poner en marcha el programa es así\ [#]_::

   $ eval $(ssh-agent)
   Agent pid 660

de modo que directamente::

   $ env | grep ^SSH
   SSH_AUTH_SOCK=/tmp/ssh-K4lZOZ1jc1iQ/agent.659
   SSH_AGENT_PID=660

Como ahora están definidas las variables de ambiente que identifican el
:command:`ssh-agent` encargado de gestionar claves, podemos usar
:command:`ssh-add` para añadir una::

   $ ssh-add
   Enter passphrase for /home/usuario/.ssh/id_ecdsa:
   Identity added: /home/usuario/.ssh/id_ecdsa (/home/usuario/.ssh/id_ecdsa)

Introducida la clave de paso, ya podremos usar en esta terminal las herramientas
de |SSH| (:command:`ssh`, :command:`sftp`, :command:`scp`) sin necesidad de
introducir clave alguna. Si cambiamos a otra terminal tendremos que definir y
exportar las variables de ambiente anteriores (pero no volver a añadir la clave),
para hacer accesible el agente a las aplicaciones.

Aunque lo anterior funciona sin problemas, puede seguir resultando algo
engorroso; así que se le puede dar una vuelta de tuerca más e instalar::

   # apt-get install libpam-ssh

Este es un módulo que está pensado para tomar la propia contraseña de
autenticación del usuario y usarla para arrancar :command:`ssh-agent` y
desbloquear la clave privada almacenada en :file:`~/.ssh/`\ [#]_. No requiere de
configuración adicional, porque la instalación se encarga de añadirlo a *pam*
convenientemente. Hecho esto, no tenemos más que asegurarnos de que tenemos
creado un certificado::

   $ ssh-keygen -t ecdsa

en que la clave de paso coincide con la contraseña del usuario en el cliente (no
con la contraseña del usuario remoto).

.. note:: Desgraciadamente, el módulo *pam_ssh* no está disponible en *buster*,
   ya que `no es compatible con la versión que usa ésta de openssl
   <https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=859054>`_

Como alternativa al uso de *pam_ssh*, en los clientes con entorno gráfico puede
compprobarse\ [#]_ que está escrito lo siguiente en
:file:`/etc/X11/Xsession.options`::

   $ grep ssh /etc/X11/Xsession.options 
   use-ssh-agent

Esto provoca que al realizarse el login gráfico el entorno gráfico arranque
dentro de una sesión de :command:`ssh-agent`, por lo que todas las terminales de
texto que abramos dentro de él, tendrán definidas las dos variables que lo
identifican. Por tanto, basta realizar un :command:`ssh-add` para que a partir
de ese momento no requiramos introducir más claves de paso al acceder al
servidor. Para automatizar un poco el proceso, podemos añadir la siguiente línea
a :file:`.bashrc`::

   [ -n "$SSH_AGENT_PID" ] && { ssh-add -L > /dev/null || ssh-add; }

que provocará que se nos pida automáticamente la coontraseña al abrir la primera
terminal.

.. warning:: El uso del módulo de *pam* es más adecuado, ya que el arranque del
   gestor de ventanas dentro del ambiente creado por :command:`ssh-agent` hace
   que la definición de las dos variables de ambiente sólo exista dentro del
   entorno gráfico, por lo que si salimos de él a una terminal de texto pura,
   éstas no existen y tendremos que definirlas a mano. En cualquier
   caso, si el módulo de *pam* no puede usarse y se opta por esta segunda vía,
   no es necesario que la clave de paso coincida con la contraseña de usuario,
   ya que la clave se introduce a posteriori de forma independiente.

.. note:: Más adelante, se propone cómo usar un :ref:`script para emular el módulo
   pam_ssh <pseudopam-ssh>` si no disponemos en el sistema de él.

:command:`gnome-keyring`
------------------------

.. todo:: Por investigar...

.. _ssh-no-interactivo:

Acceso no interactivo
=====================
Se ha expuesto bajo el epígrafe anterior cómo evitar tener que escribir
constantemente la clave de paso, pero eso no da respuesta completa a cómo
ejecutar de manera no interactiva un acceso por *ssh*; no, al menos, antes de
que hayamos accedido al sistema y tenido oportunidad de escribir la clave, si es
que optamos por usar :command:`ssh-agent` y no disponemos del módulo *pam_ssh*.

Para poder hacer esto, es necesario saber que la variable *SSH_ASKPASS* le
indica a :command:`ssh` (y toda la familia de programas clientes) qué programa
usar para obtener la contraseña. Por este motivo, si creamos el programa
:file:`$XDG_RUNTIME_DIR/askpass.sh`\ [#]_::

   #!/bin/sh
   cat

Podremos añadir la clave de paso a :command:`ssh-agent` del siguiente modo::

   $ echo "mi clave de paso" | SSH_ASKPASS=$XDG_RUNTIME_DIR/askpass.sh ssh-add

Pasar la clave de paso\ [#]_ directamente a :command:`ssh` es algo más
complicado y no resultará en una sesión interactiva (lo cual no es un problema,
si el propio acceso pretendemos que sea interactivo)::

   $  echo "mi clave de paso" | SSH_ASKPASS=$XDG_RUNTIME_DIR/askpass.sh setsid ssh castillo ls /

.. note:: Hay que hacer dos puntualizaciones a la orden anterior:

   #. Se requiere que esté definida la variable de ambiente *DISPLAY*, que lo
      estará si estamos usando una terminal gráfica. Si no es el caso, podemos
      definirla con un valor cualquiera::

         export DISPLAY=dummy:0

   #. Si no hemos accedido anteriormente al servidor, el acceso fallará porque
      no seremos capaces de aceptar la clave. Para evitarlo es necesario
      aceptarla autómaticamente añadiendo a :command:`ssh` la opción :code:`-o
      StrictHostKeyChecking=no`

Lo anterior mostrará el contenido del directorio :file:`/` del servidor.

.. _pseudopam-ssh:

.. rubric:: Aplicación práctica

Todo esto tiene utlidad si se programa algún *script*, por ejemplo, uno que se
ejecute con *pam_exec* y que nos haga las veces del módulo *pam_ssh*, por si
definitivamente deja de ser efectivo en las versiones modernas de *debian*. Los
principios del *script* son los siguientes:

#. Al autenticarse, sólo si no hay sesiones abiertas para el usuario, el *script*
   arranca :command:`ssh-agent`, guarda los valores de ``SSH_AGENT_PID`` y
   ``SSH_AUTH_SOCK`` en un *fichero de ambiente* y desbloquea la clave privada con
   :command:`ssh-add`.
#. Al abrir sesión, se usa *pam_env* para hacer que las dos variables contenidas
   en el fichero sean variables de ambiente.
#. Al cerrar sesión, si no hay otras sesiones abiertas por el usuario, se borra
   el fichero de ambiente y se mata :command:`ssh-agent`.

El *script* es :download:`éste <files/pam_ssh.sh>`, que debe alojarse en
:file:`/usr/local/bin/`. Para automatizar la manipulación de *pam* se incluye
:download:`este otro fichero <files/pam-ssh>`, de manera que debemos hacer lo
siguiente::

   # mv /path/donde/este/pam_ssh.sh /usr/local/bin
   # mv /path/donde/este/pam-ssh /usr/share/pam-configs
   # pam-auth-update

Para habilitar la acción del *script* debemos seleccionar el desbloqueo de
claves |SSH|.

.. note:: El *script* usa :command:`ssh-add` sin argumentos, así que se
   detectará la clave privada si esta tiene su ubicación predeterminada. Además,
   se ejecuta para los servicios *login*, *slim*, *lightdm*, *gdm*, *xdm* y
   *kdm*. Es posible escoger otros servicios, manipulando :file:`pam-ssh` y
   añadiendo a la dos líneas presentes en *Auth* y *Auth-Initial*::

      optional pam_exec.so expose_authtok quiet /usr/local/bin/pam_ssh.sh

   el parámetro *start_if*, cuyo valor debe ser todos los servicios para los
   que deseemos ejecutar el *script* separados por comas::

      optional pam_exec.so expose_authtok quiet /usr/local/bin/pam_ssh.sh start_if=login,sshd,slim

.. rubric:: Notas al pie

.. [#] Observe que::

      $ scp usuario@servidor:fichero{1,2}.txt .

   y::

      $ scp usuario@servidor:"fichero{1,2}.txt" .

   pretenden lo mismo: descargar los ficheros :file:`fichero1.txt` y
   :file:`fichero2.txt` en el cliente, pero hay una diferencia importante entre
   ellos. En el primer caso la expansión de la *shell* se produce en el cliente,
   mientras que en la segunda se produce en el servidor. Como consecuencia, en
   el primer caso habrá dos autenticaciones, mientras que en el segundo sólo
   una. Así pues, es mejor usar la segunda forma.

.. [#] El acceso por el puerto **443** ofrece la ventaja de que, en caso de que
   un *proxy* vigile el tráfico, no podrá más que comprobar que existe protocolo
   |TLS| y hacer algunas comprobaciones sobre éste (por ejemplo, la autenticidad
   del certificado del servidor), ya que el contenido encapsulado está cifrado
   y, consecuentemente, es totalmente opaco. Por contra, un *proxy* que vigile el
   puerto **80** puede acceder al contenido y ver que esas supuestas páginas son
   bastante raras. Si su filtrado también se basa en analizar el contenido, lo
   más probable es que no pasemos su filtro.

.. [#] En teoría, el tráfico debe ser |HTTP|\ s, es decir, |HTTP| ofuscado e
   irreconocible gracias a la envoltura segura que ofrece |TLS|.

.. [#] De lo que se deduce que el epígrafe es inexacto: debería llamarse *SSH
   sobre TLS*.

.. [#] Como el *proxy* es capaz de *ver* la capa |TLS|, no solamente puede
   comprobar si se usa tal protocolo, sino también exigir la validez del
   certificado. En ese caso, no tendremos más remedio que generar un certificado
   válido.

.. [#] También podría usarse el módulo `mod_proxy
   <https://httpd.apache.org/docs/2.4/mod/mod_proxy.html>`_ de `apache
   <http://apache.org/>`_ o `squid <http://www.squid-cache.org/>`_.
   Desgraciadamente, no puede usarse como *proxy* :ref:`nginx <n-ginx>`,
   ya que éste sólo funciona como *proxy inverso*. En realidad,
   :command:`nginx` tiene un módulo de terceros que sí lo permite,
   `ngx_http_proxy_connect
   <https://github.com/chobits/ngx_http_proxy_connect_module>`_, pero en el
   estado actual en que se halla la modularidad de :program:`nginx` es un
   engorro utilizarlo.

.. [#] Con una importante diferencia: se altera el origen de la conexión y el
   servidor creerá que las peticiones las recibe de :program:`haproxy` (o sea,
   la máquina local) y del cliente original. Se discutirá más adelante.

.. [#] Ahora bien, en la práctica deberemos usar un certificado fiable, porque
   si el motivo de usar :program:`haproxy` es la existencia de un *proxy*, lo
   necesitaremos; y, si tal *proxy* no existe, es mejor usar una solución como
   :program:`sslh`.

.. [#] En el *gancho* propuesto el fichero con las claves no se llama
   *keycert.pem*, sino *nombre_del_servidor.pem*. Téngalo en cuenta a la hora de
   copiar la configuración de ejemplo.

.. [#] Todo cliente debe empezar su comunicación con la cadena "*SSH-2.0*", que
   puesta en binario es el código hexadecimal escrito en la configuración.

.. [#] Para profundizar en la configuración del servidor web, cuando es el
   *proxy* de cifrar y descifrar la comunicación, vea el :ref:`apartado
   correspondiente <nginx-tras-proxy>`.

.. [#] En realidad sí lo es, porque no habrá forma de conocer el origen de la
   petición, a menos que, además, se configure :program:`haproxy` en :ref:`modo
   transparente <haproxy-transparente>`.

.. [#] Obviamente, este software de *proxy* para el cliente sólo es necesario si
   necesitamos establecer el túnel |TLS|. Si no es el caso (segunda variante en
   redes sin proxy que fiscalece la comunicación), en el cliente no hay más que
   asegurarse de que nos conectamos al puerto **443**.

.. [#] Esta configuración requiere que el núcleo se haya compilado con el módulo
   ``NETFILTER_XT_MATCH_SOCKET``, pero esto es así en las *debian* modernas::

      # grep -i match_socket /boot/config-`uname -r`
      CONFIG_NETFILTER_XT_MATCH_SOCKET=m

.. [#] Si antes queremos deshacernos del :command:`ssh-agent` ya en ejecucion
   podemos hacer lo siguiente::

      $ export SSH_AUTH_SOCK=/tmp/ssh-wuZYTNFc1wq1/agent.656
      $ export SSH_AGENT_PID=657
      $ ssh-agent -k

   o matarlo directamente, que es más rápido::

      $ kill -1 657

.. [#] Consúltese su página de manual para que la clave privada no sea una de
   las predeterminadas de :command:`ssh` (:file:`~/.ssh/id_rsa`,
   :file:`~/.ssh/id_ecdsa`, etc.)

.. [#] Si se usa *pam_ssh* (o el :ref:`script sustitutorio después propuesto
   <pseudopam-ssh>`) conviene, precisamente, cerciorarse de que esto no está
   activo comentando la opción)

.. [#] No se usa directamente :command:`cat` porque :program:`ssh-add` y el
   resto de programas pasan argumentos que lo malogran. El *script* desecha los
   argumentos y sólo atiende a la entrada estándar que es lo que interesa.

.. [#] O la contraseña, no es necesario la autenticación mediante clave pública
   y privada.

.. |TLS| replace:: :abbr:`TLS (Transport Layer Security)`
.. |SNI| replace:: :abbr:`SNI (Server Name Identification)`
