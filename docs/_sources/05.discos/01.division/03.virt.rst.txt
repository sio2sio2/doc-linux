.. _lvm:

Volúmenes lógicos
*****************
A diferencia de otros como zfs_ o btrfs_, *ext4* no soporta nativamente la
gestión de volúmenes lógicos. Sin embargo, podemos manejar discos y particiones
virtuales, ayudándonos de un *software* adicional llamado |LVM|. Las
**ventajas** de su uso, ya se han establecido en epígrafes anteriores:

- Permite agrandar indiscriminadamente el disco: basta con comprar un nuevo
  disco físico e incluirlo como integrante del disco virtual.

  .. image:: files/1+1disks.png

- Permite agrandar indiscriminadamente las particiones sin cuidarse de que el
  espacio que constituye la partición deba ser contiguo. Cuando tratamos
  particiones físicas, ampliar una partición es todo un engorro, sobre todo si
  está encajonada entre otras dos particiones. Por ejemplo, ampliar en el
  siguiente gráfico :file:`sda3`, implica también mover :file:`sda4`:

  .. image:: files/ampl-part.png

Logramos, por tanto, muchísima más versatilidad que usando particiones fisicas.
En contraprestación, hay una **desventaja** evidente: las particiones lógicas
sólo son visibles con el *software* de |LVM|. 

.. rubric:: Definiciones

Antes de pasar a exponer cómo crear y manejar volúmenes lógicos, es pertinente
fijar el significado de algunos términos que se usarán en la exposición:

**Volúmen físico** (|PV|)
   Son las particiones físicas o incluso discos físicos completos sobre las que
   se definen los discos virtuales.

**Grupo de volúmenes** (|VG|)
   Es el conjunto de volúmenes físicos que conforma un disco virtual.

**Volúmenes lógicos** (|LV|)
   Es el dispoitivo virtual de bloques que alberga un sistemas de ficheros, esto
   es, lo que hemos venido definiendo como *partición virtual* a lo largo de
   nuestra exposición.

En la tarea de constituir volúmenes lógicos:

- Deben definirse cuáles son los volúmenes físicos.
- Deben definirse cómo se agrupan esos volúmenes físicos en grupos de volúmenes.
  Lo habitual es que haya un grupo de volúmenes.
- Debe particionarse cada grupo de volúmenes en volúmenes logicos.

.. note:: Es importante tener presente que |GRUB| soporta |LVM| y, por tanto, es
   capaz de arrancar un *Linux* aunque los ficheros de su fase 3 y el kernel se
   encuentren dentro de volúmenes lógicos.

Es muy probable que el *software* para gestionar volúmenes lógicos ya se
encuentre instalado, pero si no es así::

   # apt install lvm2

.. note:: |LVM| permite también la creación de |RAID|\ s, pero no es
   propósito de este apartado, tratarlo. Bajo el epígrafe dedicado a :ref:`RAUDs
   <raid>` hay :ref:`todo un apartado dedicado a la creación de RAIDs con LVM
   <lvmraid>`.

.. _pvcreate:
.. _vgcreate:
.. _lvcreate:

.. index:: pvcreate, lvcreate, vgcreate

Creación
========
Dentro del grupo de volúmenes podemos incluir todas las particiones que deseemos
crear, excepto aquellas necesarias para el arranque del disco. Por tanto, un
particionado físico del disco apropiado para crear volúmenes lógicos puede ser
el siguiente:

.. image:: files/part-lvm.png

que usando :ref:`sgdisk <sgdisk>` puede realizarse de esta forma::

   $ sgdisk -a 8 -n "0:40:2047" -t "0:0xef02" -c "0:BOOTBIOS" \
            -a 2048 -n "0:2048:+50M" -t "0:0xef00" -c "0:EFI" \
            -N 0 -t "3:0x8e00" -c "3:LVM" /tmp/disco.raw

de forma que creamos las dos particiones necesarias para el arranque aparte,
y una tercera partición destinanda a ser el volumen físico que constituya el
grupo de volúmenes. La partición destinada para este fin se nota con el código
*0x8E00*.

.. note:: Por supuesto, podemos crear volúmenes lógicos partiendo también de un
   particionado |DOS|

Como estamos particionando un fichero, no podemos acceder
directamente a sus particiones como sí sería posible si particionáramos un disco
(p.e. de :file:`/dev/sda` aparecerían :file:`/dev/sda1`, file:`/dev/sda2`,
etc.). Para hacerlas accesibles es necesario asegurarse de que está cargado el
módulo *loop*::

   # modprobe loop

y usar :command:`losetup` para asociar/desasociar el fichero a un dispositivo de
bucle:

.. _losetup:
.. index:: losetup

::

   # losetup /dev/loop0 /tmp/disco.raw
   # losetup
   NAME       SIZELIMIT OFFSET AUTOCLEAR RO BACK-FILE      DIO LOG-SEC
   /dev/loop0         0      0         0  0 /tmp/disco.raw   0     512
   # losetup -d /dev/loop0

Con todo, asociar el fichero al dispositivo no provoca que aparezcan las
particiones, para ello es necesario usar :command:`partx`

.. _partx:
.. index:: partx

::

   # partx -a /dev/loop0
   # ls -1 /dev/loop0*
   /dev/loop0
   /dev/loop0p1
   /dev/loop0p2
   /dev/loop0p3
   # partx -d /dev/loop0
   # ls -1 /dev/loop0*
   /dev/loop0

Hecho el particionado y expuestas las particiones, lo primero es declarar que la
tercera partición es un volumen físico::

   # pvcreate /dev/loop0p3

tras lo cual ya puede constituirse un grupo de volúmenes llamado "VGtest" con
este volumen físico::

   # vgcreate VGtest /dev/loop0p3
   # vgs VGtest
     VG       #PV #LV #SN Attr   VSize    VFree  
     VGtest   1   0   0 wz--n-  <19,95g <19,95g

Esta última acción permite empezar a crear particiones lógicas con la orden
:command:`lvcreate`. Por ejemplo::

   # lvcreate -L 2G VGtest -n primera
   # lvcreate -L 5G VGtest -n segunda
   # vgs VGtest
     VG       #PV #LV #SN Attr   VSize    VFree  
     VGtest   1   0   0 wz--n-  <19,95g <12,95g
   # lvs VGtest
     LV      VG    Attr       LSize Pool Origin Data%  Meta%  Move Log Cpy%Sync Convert
     primera VGxxx -wi-a----- 2,00g                                                    
     segunda VGxxx -wi-a----- 5,00g

Estas acciones han particionado 7 de los 20GB del grupo de volúmenes y crean dos
dispostivos virtuales, :file:`/dev/VGtest/primera` y
:file:`/dev/VGtest/segunda` que podemos tratar como si de particiones fisicas
se tratasen. Por ejemplo, podemos dotarlas de un sistema de ficheros::

   # mkfs.ext4 -L PRIMERA /dev/VGtest/primera
   # mkfs.ext4 -L SEGUNDA /dev/VGtest/primera

Disponibilidad
==============
Habitualmente la aparición de los volúmenes lógicos es automática al hacer
disponibles los volúmenes que constituyen el grupo de volúmenes. Si no es así,
pueden habilitar con la orden::

   # vgchange -ay VGtest

Lo que es más útil es deshabilitar los volúmenes lógicos::

   # vgchange -an VGtest

ya que es indispensable hacerlo si queremos hacer desaparecer los volúmenes
físicos sobre los que se asientan. Por ejemplo, para el caso que nos ocupa, en
que hacemos pruebas con un fichero, la única forma de usar :ref:`partx <losetup>` y
:ref:`losetup <losetup>` para desasociar el fichero al dispositivo de bucle es
deshabilitar los volúmenes lógicos porque de lo contrario, fallará::

   # partx -d /dev/loop

al encontrar la partición :file:`/dev/loop03` ocupada.

.. _pvs:
.. _vgs:
.. _lvs:
.. index:: pvs, vgs, lvs

Consulta
========
Hay tres tipos de entidades (volúmenes físicos, grupos de volúmenes y volúmenes
lógicos) y dos tipos de consultas sobre ellas: la resumida y la extensa, por lo
que podemos llegar a hacer seis consultas distintas. En los seis casos, puede
añadirse como argumento una entidad concreta (|PV|, |VG| o |LV|) para recibir
información exclusivamente de ella o no añadir ninguna y recibir información de
todas.

Para volúmenes físicos, las órdenes son::

   # pvs
     PV           VG       Fmt  Attr PSize   PFree  
     /dev/sdc2    vgdebian lvm2 a--  <465,70g  79,39g
     /dev/loop0p3 VGtest   lvm2 a--  <19,95g <12,95g
   # pvdisplay /dev/loop0p3
     --- Physical volume ---
     PV Name               /dev/loop0p3
     VG Name               VGtest
     PV Size               19,95 GiB / not usable 4,98 MiB
     Allocatable           yes 
     PE Size               4,00 MiB
     Total PE              5106
     Free PE               3314
     Allocated PE          1792
     PV UUID               36SmEX-lPxG-qFW2-iMGl-1c5T-CLlb-LqLY1

Para grupos de volúmenes::

   # vgs
     VG       #PV #LV #SN Attr   VSize    VFree  
     VGtest     1   2   0 wz--n-  <19,95g <12,95g
     vgdebian   1   4   0 wz--n- <465,70g  79,39g

   # vgdisplay VGtest
     --- Volume group ---
     VG Name               VGtest
     System ID             
     Format                lvm2
     Metadata Areas        1
     Metadata Sequence No  3
     VG Access             read/write
     VG Status             resizable
     MAX LV                0
     Cur LV                2
     Open LV               0
     Max PV                0
     Cur PV                1
     Act PV                1
     VG Size               <19,95 GiB
     PE Size               4,00 MiB
     Total PE              5106
     Alloc PE / Size       1792 / 7,00 GiB
     Free  PE / Size       3314 / <12,95 GiB
     VG UUID               P3dDgq-AeHA-7Vur-Jy48-fzlm-wnC1-jf0x85

Y para volúmenes lógicos::

   # lvs
     LV      VG       Attr       LSize   Pool Origin Data%  Meta%  Move Log Cpy%Sync Convert
     primera VGtest   -wi-a-----   2,00g                                                    
     segunda VGtest   -wi-a-----   5,00g                                                    
     home    vgdebian -wi-a----- 370,00g                                                    
     lxc     vgdebian -wi-a-----   2,00g                                                    
     raiz    vgdebian -wi-a----- <12,45g                                                    
     swap    vgdebian -wc-a-----  <1,86g

   # lvdisplay /dev/VGtest/primera
     --- Logical volume ---
     LV Path                /dev/VGtest/primera
     LV Name                primera
     VG Name                VGtest
     LV UUID                KBMwih-Mctp-rOcv-W3aK-iqTG-2vXo-KlpQxs
     LV Write Access        read/write
     LV Creation host, time choquereta, 2019-11-27 07:40:59 +0100
     LV Status              available
     # open                 0
     LV Size                2,00 GiB
     Current LE             512
     Segments               1
     Allocation             inherit
     Read ahead sectors     auto
     - currently set to     256
     Block device           253:4

.. seealso:: El significado de los atributos indicados por :command:`lvs` puede
   consultarse `en esta página de Github
   <https://github.com/UnderV/py3tools/wiki/LVM-Attributes-Explained>`_.

.. _vgextend:
.. _lvextend:
.. _lvreduce:
.. _vgreduce:
.. index:: vgextend, lvextend, lvreduce, vgreduce

Modificación
============
La ventaja fundamental de las volúmenes lógicos es que podemos ampliarlos a
voluntad sin que el espacio tenga que ser contiguo. Por ejemplo::

   # lvextend -L 3G /dev/VGtest/primera

Aumenta hasta 3GiB el primer volumen lógico, aunque no el sistema de ficheros
contenido, por lo que el espacio ocupable seguirá siendo de 2GiB. Para ampliar
también el sistema de fichero es necesario, en este caso::

   # resize2fs /dev/Vgtest/primera

No obstante, podemos incluir la opción :kbd:`-r` y :command:`lvextend` se
encargará de comprobar cuál el sistema de ficheros y aplicar el comando
adecuando para que éste colonice el nuevo espacio disponible. En consecuencia
las dos órdenes anteriores son equivalente a::

   # lvextend -r -L 3G /dev/VGtest/primera

También puede indicarse, en vez de el nuevo tamaño, el incremento. Esta orden::

   # lvextend -r -L +1G /dev/VGtest/segunda

aumenta hasta los 6GiB el volumen lógico cuyo anterior tamaño era 5GiB. Es
posible también usar porcentajes en vez de tamaños o incrementos absolutos a
través de la opción :kbd:`-l`\ [#]_::

   # lvcreate -l 100%FREE VGtest -n tercera

De esta manera, la nueva partición ocupará todo el espacio libre que uqede en el
grupo de volúmenes. El disco físico se ha acabado, pero si "compráramos" otro,
podríamos añadirlo como volumen lógico a *VGtest* y volveríamos a disponer de
espacio libre::

   # truncate -s 10G /tmp/otrodisco.raw
   # losetup /dev/loop1 /tmp/otrodisco.raw
   # pvcreate /dev/loop1
   # vgextend VGtest /dev/loop1
   # vgs VGtest
     VG     #PV #LV #SN Attr   VSize  VFree 
     VGtest   2   2   0 wz--n- 29,94g  9,94g
   
Ahora el grupo de volúmenes tiene 30GiB, ya que hemos añadido 10GiB más.

Todas estas operaciones son de incremento y no requieren siquiera que
desmontemos los sistemas de ficheros para ser llevadas a cabo. En cambio, las
operaciones de reducción son más traumáticas ya que, por lo general, requieren
dejar hueco y en el caso de reducir particiones lógicas, desmontar previamente
el sistema de ficheros que contiene. Por lo demás, el procedimiento es
semejante::

   # lvresize -r -L -2G /dev/VGtest/segunda
   # lvs /dev/VGtest/segunda
     LV      VG     Attr       LSize Pool Origin Data%  Meta%  Move Log Cpy%Sync Convert
     segunda VGtest -wi-a----- 4,00g 
   # lvreduce -r -l -25%LV /dev/VGtest/segunda
   # lvs /dev/VGtest/segunda
     LV      VG     Attr       LSize Pool Origin Data%  Meta%  Move Log Cpy%Sync Convert
     segunda VGtest -wi-a----- 3,00g

.. _lvm-snapshots:

Instártaneas
============

.. todo:: Por escribir

.. rubric:: Notas al pie

.. [#] Los porcentajes puede referise al espacio libre (:kbd:`FREE`) en el grupo
   de volúmenes, al espacio del volúmen lógico (:kbd:`LV`), al espacio del grupo
   de volúmenes (:kbd:`VG`) y algún otro.

.. |LVM| replace:: :abbr:`LVM (Logical Volume Management)`
.. |LV| replace:: :abbr:`LV (Logical Volume)`
.. |PV| replace:: :abbr:`PV (Physical Volume)`
.. |VG| replace:: :abbr:`PV (Volume Group)`
.. |DOS| replace:: :abbr:`DOS (Disk Operating System)`
.. |GRUB| replace:: :abbr:`GRUB (GRand Unified Bootloader)`
.. |RAID| replace:: :abbr:`RAID (Redundant Array of Independent Disks)`

.. _btrfs: https://es.wikipedia.org/wiki/Btrfs
.. _zfs: https://es.wikipedia.org/wiki/ZFS_(sistema_de_archivos)

