

<!DOCTYPE html>

<html lang="es" data-content_root="../../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>7.5.2.3.2. Transparencia &#8212; documentación de Linuxnomicón - rolling</title>
    <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="../../../_static/classic.css?v=514cf933" />
    <link rel="stylesheet" href="../../../_static/custom.css" type="text/css" />
    
    <script src="../../../_static/documentation_options.js?v=a621b78a"></script>
    <script src="../../../_static/doctools.js?v=888ff710"></script>
    <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../_static/translations.js?v=efdbd0b9"></script>
    
    <link rel="index" title="Índice" href="../../../genindex.html" />
    <link rel="search" title="Búsqueda" href="../../../search.html" />
    <link rel="next" title="7.5.2.3.3. Web" href="03.web.html" />
    <link rel="prev" title="7.5.2.3.1. Multiplexores" href="01.multi.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navegación</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="Índice General"
             accesskey="I">índice</a></li>
        <li class="right" >
          <a href="03.web.html" title="7.5.2.3.3. Web"
             accesskey="N">siguiente</a> |</li>
        <li class="right" >
          <a href="01.multi.html" title="7.5.2.3.1. Multiplexores"
             accesskey="P">anterior</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">documentación de Linuxnomicón - rolling</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" ><span class="section-number">7. </span>Servicios de red</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="../index.html" ><span class="section-number">7.5. </span>Proxies</a> &#187;</li>
          <li class="nav-item nav-item-3"><a href="../03.reverse.html" accesskey="U"><span class="section-number">7.5.2.3. </span>Proxies inversos</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href=""><span class="section-number">7.5.2.3.2. </span>Transparencia</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="transparencia">
<span id="proxy-transparente"></span><h1><span class="section-number">7.5.2.3.2. </span>Transparencia<a class="headerlink" href="#transparencia" title="Link to this heading">¶</a></h1>
<p>En ocasiones, por ejemplo cuando se han habilitido mecanismos para restringir el
acceso según el origen o se desea limitar el número de accesos, es imprescindible
para los servidores conocer cuál es el cliente que lleva a cabo la petición. Sin
embargo, un <em>proxy</em> inverso recoibe la peticion original del cliente y la replique
dirigiéndola al servidor por lo que la petición recibe el servidor
la hace el <em>proxy</em> y no el cliente. En consecuencia, el servidor final sólo
recibirá peticiones originadas por una única máquina (el <em>proxy</em>) y será
incapaz de tomar decisiones en base al origen de la petición.</p>
<p>Para paliar este problema existen dos soluciones:</p>
<ul class="simple">
<li><p>Que el protocolo de capa de aplicación articule algún mecanismo para informar al
servidor final de que la petición se hacen a través de un <em>proxy</em> y de cuál
es el cliente en realidad. Tal es el caso en <abbr title="HyperText Transfer Protocol">HTTP</abbr> de la cabecera
<a class="reference internal" href="../../02.web/01.desc/03.cabecera.html#xforwardedfor"><span class="std std-ref">X-Forwarder-For</span></a>, gracias a la cual el servidor <em>web</em>
será capaz de saber cuál es en realidad el cliente, aunque la <abbr title="Internet Protocol">IP</abbr> de origen
de los paquetes sea la del <em>proxy</em>, El tratamiento de esta cabecera en
<a class="reference internal" href="../../02.web/02.nginx/index.html#n-ginx"><span class="std std-ref">nginx</span></a>, se lleva a cabo en <a class="reference internal" href="../../02.web/02.nginx/02.avanz/09.misc.html#nginx-tras-proxy"><span class="std std-ref">su epígrafe correspondiente</span></a>.</p></li>
<li><p>La que nos ocupa que es hacer el <em>proxy</em> realmente <strong>transparente</strong>, esto es,
que en los paquetes de la petición que recibe el servidor fiunal, la <abbr title="Internet Protocol">IP</abbr> de
origen sea la del cliente y no la del <em>proxy</em>.</p></li>
</ul>
<section id="requisitos">
<span id="proxy-transparente-req"></span><h2><span class="section-number">7.5.2.3.2.1. </span>Requisitos<a class="headerlink" href="#requisitos" title="Link to this heading">¶</a></h2>
<p>Para hacer un transparente un <em>proxy</em> es necesario:</p>
<ul class="simple">
<li><p>Que los clientes comuniquen con el proxy (lo cual es lo que se espera
si el proxy es inverso).</p></li>
<li><p>Una configuración extra de la máquina en la que se ejecuta de forma
transparente el <em>proxy</em>.</p></li>
<li><p>Que las respuestas del servidor, que obviamente tendrán como destino el
cliente, puedan ser interceptadas por el <em>proxy</em> para que sea él quien las
despache hacia el cliente original. Así pues, el servidor final no puede estar
dispuesto en cualquier lugar, sino en uno cuyo camino de regreso pase por el
proxy.</p></li>
</ul>
<p>Lustremnos lo dicho con un ejemplo:</p>
<img alt="../../../_images/transparente.png" src="../../../_images/transparente.png" />
<p>Las comunicaciones del esquema son las siguientes:</p>
<table class="docutils align-default" id="id9">
<caption><span class="caption-text">proxy-transparente</span><a class="headerlink" href="#id9" title="Link to this table">¶</a></caption>
<thead>
<tr class="row-odd"><th class="head"><p>Conexión</p></th>
<th class="head"><p>Origen</p></th>
<th class="head"><p>Destino</p></th>
<th class="head"><p>Comentario</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><ol class="arabic simple">
<li></li>
</ol>
</td>
<td><p>213.10.11.12</p></td>
<td><p>80.80.80.80</p></td>
<td><p>El cliente conecta coon la <abbr title="Internet Protocol">IP</abbr> 80.80.80.80 que, en realidad,
es el <em>proxy</em> y no el servidor final.</p></td>
</tr>
<tr class="row-odd"><td><ol class="arabic simple" start="2">
<li></li>
</ol>
</td>
<td><p>213.10.11.12</p></td>
<td><p>192.168.255.10</p></td>
<td><p>La <abbr title="Internet Protocol">IP</abbr> original no cambia porque el proxy es transparebte.</p></td>
</tr>
<tr class="row-even"><td><ol class="arabic simple" start="3">
<li></li>
</ol>
</td>
<td><p>192.168.255.10</p></td>
<td><p>213.10.11.12</p></td>
<td><p>El servidor responde al cliente, pero el proxy captura la
respuesta, porque está situado en el camino de vuelta.</p></td>
</tr>
<tr class="row-odd"><td><ol class="arabic simple" start="4">
<li></li>
</ol>
</td>
<td><p>80.80.80.80</p></td>
<td><p>213.10.11.12</p></td>
<td><p>La respuesta acaba en el cliente.</p></td>
</tr>
</tbody>
</table>
<p>En consecuencia, aunque el cliente habla con el <em>proxy</em> y el <em>proxy</em> redirige la
petición al servidor; el servidor recibe las peticiones como si estuviera
hablando directamente con el cliente.</p>
</section>
<section id="solucion-general">
<span id="proxy-transparente-sol-gen"></span><h2><span class="section-number">7.5.2.3.2.2. </span>Solución general<a class="headerlink" href="#solucion-general" title="Link to this heading">¶</a></h2>
<p>Desde la versión 2.2 del núcleo, <em>Linux</em> es capaz de comportarse como un <em>proxy</em>
transparente, para lo cual se requiere:</p>
<ol class="arabic">
<li><p>Que la aplicación <em>proxy</em> esté <strong>preparada para ello</strong> y utilice un <em>socket</em>
transparente. Este requisito debe cumplirlo la aplicación, por lo que como
administradores sólo podemos comprobar si es apta o no. Ahora bien, poder
crear un <em>socket</em> transparente  exige a la aplicación la capacidad (véase
<em class="manpage"><a class="manpage reference external" href="https://manpages.debian.org/capabilities(7)">capabilities(7)</a></em>) <code class="docutils literal notranslate"><span class="pre">CAP_NET_ADMIN</span></code>. Esto puede lograrse:</p>
<ul class="simple">
<li><p>Ejecutando la aplicación como <em>root</em>.</p></li>
<li><p>Concediéndole tal capacidad al ejecutable (p.e. <a class="reference internal" href="../../../02.conbas/09.admbasica/10.priv/02.capabilities.html#capabilities-prof"><span class="std std-ref">vea cómo hacerlo</span></a>).</p></li>
</ul>
<p>Cómo se configure la aplicación para que pueda actuar transparentemente es
particular de cada una: el siguiente epígrafe estará dedicado a la
configuración de algunas.</p>
</li>
<li><p>Como el tráfico de respuesta del servidor tiene por destino el cliente original
y el <em>proxy</em> ha de interceptar también este tráfico, <strong>es forzoso que el proxy
se interponga en el camnio de regreso</strong>.</p></li>
<li><p>Finalmente, al pasar los paquetes de respuesta por el <em>proxy</em> éste debe
procesarlos, aunque la <abbr title="Internet Protocol">IP</abbr> de destino sea la del cliente. Para ello debe
<strong>manipularse el encaminamiento</strong>. Este es el único requisito que sí podemos
configurar de forma general y al que dedicaremos el resto del epígrafe.</p>
<p>Para que los paquetes de respuesta dirigidos al cliente pasen por la aplicación
de <em>proxy</em> debe lograrse que éstos se encaminen a través de la interfaz de
<em>loopback</em>. Para ello:</p>
<ol class="arabic">
<li><p>Hacemos que el tráfico que debe volver a pasar por el <em>proxy</em> esté marcado
con una marca (p.e. la <em>0xff</em>), para lo cual podemos utilizar el
cortafuegos. Cómo deba utilizarse el cortafuegos depende de dónde se
encuentre el servidor final:</p>
<ol class="loweralpha">
<li><p>Cuando está en la misma máquina que el <em>proxy</em><a class="footnote-reference brackets" href="#id5" id="id1" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a>, podemos usar la
estrategia de que éste redirija los paquetes a una dirección local
particular (p.e. la <em>127.1.1.1</em>, en la que debe escuchar el
servidor y ningún otro). De esta forma, lograremos marcar sólo los
paquetes dirigidos al servidor procedentes del <em>proxy</em>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp"># </span>iptables<span class="w"> </span>-t<span class="w"> </span>raw<span class="w"> </span>-A<span class="w"> </span>PREROUTING<span class="w"> </span>!<span class="w"> </span>-i<span class="w"> </span>lo<span class="w"> </span>-d<span class="w"> </span><span class="m">127</span>.0.0.0/8<span class="w"> </span>-j<span class="w"> </span>DROP
<span class="gp"># </span>iptables<span class="w"> </span>-t<span class="w"> </span>mangle<span class="w"> </span>-A<span class="w"> </span>POSTROUTING<span class="w"> </span>!<span class="w"> </span>-o<span class="w"> </span>lo<span class="w"> </span>-s<span class="w"> </span><span class="m">127</span>.0.0.0/8<span class="w"> </span>-j<span class="w"> </span>DROP

<span class="gp"># </span>iptables<span class="w"> </span>-t<span class="w"> </span>nat<span class="w"> </span>-A<span class="w"> </span>OUTPUT<span class="w"> </span>-d<span class="w"> </span><span class="m">127</span>.1.1.1<span class="w"> </span>-j<span class="w"> </span>CONNMARK<span class="w"> </span>--set-mark<span class="w"> </span>0xff
<span class="gp"># </span>iptables<span class="w"> </span>-t<span class="w"> </span>mangle<span class="w"> </span>-A<span class="w"> </span>OUTPUT<span class="w"> </span>-m<span class="w"> </span>connmark<span class="w"> </span>--mark<span class="w"> </span>0xff<span class="w"> </span>-j<span class="w"> </span>CONNMARK<span class="w"> </span>--restore-mark
</pre></div>
</div>
</li>
<li><p>Cuando está en una máquina distinta, la estrategia es marcar en el <em>proxy</em>
los paquetes entrantes (que son los de vuelta) cuyo destino es un proxy
transparente<a class="footnote-reference brackets" href="#id6" id="id2" role="doc-noteref"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></a>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp"># </span>iptables<span class="w"> </span>-t<span class="w"> </span>mangle<span class="w"> </span>-A<span class="w"> </span>PREROUTING<span class="w"> </span>-m<span class="w"> </span>socket<span class="w"> </span>--transparent<span class="w"> </span>-j<span class="w"> </span>MARK<span class="w"> </span>--set-mark<span class="w"> </span>0xff
</pre></div>
</div>
<div class="admonition warning">
<p class="admonition-title">Advertencia</p>
<p>Por alguna razón en mi sistema, <strong class="program">nftables</strong> es
incapaz de traducir la sentencia anterior, pero existe equivalente:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp"># </span>nft<span class="w"> </span>add<span class="w"> </span>table<span class="w"> </span>mangle
<span class="gp"># </span>nft<span class="w"> </span>add<span class="w"> </span>chain<span class="w"> </span>mangle<span class="w"> </span>PREROUTING<span class="w"> </span><span class="s2">&quot;{ type filter hook prerouting priority -150; }&quot;</span>
<span class="gp"># </span>nft<span class="w"> </span>add<span class="w"> </span>rule<span class="w"> </span>mangle<span class="w"> </span>PREROUTING<span class="w"> </span>socket<span class="w"> </span>transparent<span class="w"> </span><span class="m">1</span><span class="w"> </span>meta<span class="w"> </span>mark<span class="w"> </span><span class="nb">set</span><span class="w"> </span>0xff
</pre></div>
</div>
</div>
</li>
</ol>
</li>
<li><p>Se indica al núcleo que haga posible el encaminamiento a través de la
interfaz de <em>loopback</em><a class="footnote-reference brackets" href="#id7" id="id3" role="doc-noteref"><span class="fn-bracket">[</span>3<span class="fn-bracket">]</span></a>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp"># </span>sysctl<span class="w"> </span>-w<span class="w"> </span>net.ipv4.conf.default.route_localnet<span class="o">=</span><span class="m">1</span>
<span class="gp"># </span>sysctl<span class="w"> </span>-w<span class="w"> </span>net.ipv4.conf.all.route_localnet<span class="o">=</span><span class="m">1</span>
</pre></div>
</div>
</li>
<li><p>Se alteran las reglas de encaminamiento para que el tráfico marcado (con, por
ejemplo, <em>0xff</em>) vaya a la interfaz de <em>loopback</em>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp"># </span>ip<span class="w"> </span>rule<span class="w"> </span>add<span class="w"> </span>fwmark<span class="w"> </span>0xff<span class="w"> </span>lookup<span class="w"> </span><span class="m">100</span>
<span class="gp"># </span>ip<span class="w"> </span>route<span class="w"> </span>add<span class="w"> </span><span class="nb">local</span><span class="w"> </span><span class="m">0</span>.0.0.0/0<span class="w"> </span>dev<span class="w"> </span>lo<span class="w"> </span>table<span class="w"> </span><span class="m">100</span>
</pre></div>
</div>
</li>
</ol>
</li>
</ol>
</section>
<section id="soluciones-particulares">
<h2><span class="section-number">7.5.2.3.2.3. </span>Soluciones particulares<a class="headerlink" href="#soluciones-particulares" title="Link to this heading">¶</a></h2>
<p>La intención es aplicar la solución antes descrita para que actúen como
<em>proxies</em> transparentes aplicaciones utilizados en este manual: <a class="reference internal" href="../../../98.apendice/01.cryto/03.aplicaciones/04.ssl.html#stunnel"><span class="std std-ref">stunnel</span></a>, <a class="reference internal" href="01.multi.html#sslh"><span class="std std-ref">sslh</span></a>, <a class="reference internal" href="01.multi.html#haproxy"><span class="std std-ref">haproxy</span></a> y <a class="reference internal" href="../../02.web/02.nginx/index.html#n-ginx"><span class="std std-ref">nginx</span></a>. Ahora bien, para comprobar si, efectivamente, el <em>proxy</em> actúa de
modo transparente, es necesario que el servidor final nos muestre cuál es la
<abbr title="Internet Protocol">IP</abbr> del cliente. Un modo muy sencillo es usar como servidor final
<strong class="program">nginx</strong> con esta configuración:</p>
<div class="highlight-nginx notranslate"><div class="highlight"><pre><span></span><span class="k">server</span><span class="w"> </span><span class="p">{</span>
<span class="w">   </span><span class="kn">listen</span><span class="w"> </span><span class="mi">80</span><span class="p">;</span><span class="w">  </span><span class="c1"># Puerto y dirección de escucha pueden cambiar según el caso.</span>

<span class="w">   </span><span class="kn">location</span><span class="w"> </span><span class="s">/</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="kn">default_type</span><span class="w"> </span><span class="s">text/plain</span><span class="p">;</span>
<span class="w">      </span><span class="kn">return</span><span class="w"> </span><span class="mi">200</span><span class="w"> </span><span class="s">&quot;Saludos</span><span class="w"> </span><span class="s">desde</span><span class="w"> </span><span class="s">&#39;</span><span class="nv">$hostname&#39;.</span><span class="w"> </span><span class="s">Te</span><span class="w"> </span><span class="s">conectas</span><span class="w"> </span><span class="s">desde</span><span class="w"> </span><span class="nv">$remote_addr:$remote_port.\n&quot;</span><span class="p">;</span>
<span class="w">   </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>y que desde el cliente se haga la consulta<a class="footnote-reference brackets" href="#id8" id="id4" role="doc-noteref"><span class="fn-bracket">[</span>4<span class="fn-bracket">]</span></a>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp"># </span>wget<span class="w"> </span>--no-check-certificate<span class="w"> </span>-qO-<span class="w"> </span>https://destino
<span class="go">Saludos desde &#39;servidor&#39;. Te conectas desde 192.168.0.20:43123.</span>
</pre></div>
</div>
<p>donde el destino será el proxy (probablemente) y el protocolo dependerá de qué
papel juegue el <em>proxy</em>. Si el proxy inverso es explícito veremos la <abbr title="Internet Protocol">IP</abbr> del <em>proxy</em>,
pero si es transparente –como pretendemos–, aparecerá la <abbr title="Internet Protocol">IP</abbr> del propio cliente.</p>
<section id="stunnel">
<span id="stunnel-transparente"></span><h3><span class="section-number">7.5.2.3.2.3.1. </span>stunnel<a class="headerlink" href="#stunnel" title="Link to this heading">¶</a></h3>
<p><a class="reference internal" href="../../../98.apendice/01.cryto/03.aplicaciones/04.ssl.html#stunnel"><span class="std std-ref">stunnel</span></a> permite encapsular con <abbr title="Secure Socket Layer">SSL</abbr> cualquier tipo de tráfico;
y, si queremos que el servidor final conozca la dirección del cliente original y
no la <abbr title="Internet Protocol">IP</abbr> de la parte servidor de <strong class="program">stunnel</strong> debemos hacer que éste se
comporte de forma transparente.</p>
<p>Podemos poner en práctica la <a class="reference internal" href="#proxy-transparente-sol-gen"><span class="std std-ref">solución general</span></a>, a la cual sólo le falta desarrollar la primera
parte, esto es, la relativa a la propia aplicación <em>proxy</em>. Es configuración
(partido del <a class="reference internal" href="../../../98.apendice/01.cryto/03.aplicaciones/04.ssl.html#stunnel"><span class="std std-ref">ejemplo ilustrativo en que se expuso qué es stunnel</span></a>),
puede ser esta, si el servidor final se encuentra en la misma máquina:</p>
<div class="highlight-ini notranslate"><div class="highlight"><pre><span></span><span class="c1">; La IP de la interfaz física del servidor es 192.168.0.14</span>

<span class="k">[netcat-ssl]</span>
<span class="hll"><span class="na">transparent</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">source</span>
</span><span class="na">cert</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">/etc/stunnel/stunnel.pem</span>
<span class="na">accept</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">192.168.0.14:443</span>
<span class="hll"><span class="na">connect</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">127.1.1.1:80</span>
</span></pre></div>
</div>
<p>donde las novedades son la particular dirección local del servidor final
(coherente con la que se cita en la <a class="reference internal" href="#proxy-transparente-sol-gen"><span class="std std-ref">solución general para proxy
transparente</span></a>), y la línea en que indicamos a
<strong class="program">stunnel</strong> que mantenga la <abbr title="Internet Protocol">IP</abbr> original del cliente.</p>
<p>En caso de que el servidor final estuviera en una máquina distinta, la última
línea deberíamos cambiarla por algo así:</p>
<div class="highlight-ini notranslate"><div class="highlight"><pre><span></span><span class="c1">; El servicio final se encuentra en otra máquina (192.168.255.10)</span>
<span class="na">connect</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">192.168.255.100:80</span>
</pre></div>
</div>
<div class="admonition warning">
<p class="admonition-title">Advertencia</p>
<p>Tenga presente que, además de toda la configuración de cortafuegos
y reglas de encaminamiento, debemos asegurarnos de que <strong class="program">stunnel</strong>
tiene capacidad para crear el <em>socket</em> transparente y que la vuelta de los
paquetes pasará por la máquina con <strong class="program">stunnel</strong>.</p>
</div>
</section>
<section id="sslh">
<span id="sslh-transparente"></span><h3><span class="section-number">7.5.2.3.2.3.2. </span>SSLH<a class="headerlink" href="#sslh" title="Link to this heading">¶</a></h3>
<p>A la <a class="reference internal" href="#proxy-transparente-sol-gen"><span class="std std-ref">solución general</span></a>, basta añadirle la
configuración particular del <strong class="program">sslh</strong>, que podría ser la siguiente en
<code class="file docutils literal notranslate"><span class="pre">/etc/default/sslh</span></code>:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="nv">RUN</span><span class="o">=</span>yes<span class="w">  </span><span class="c1"># SSLH corre permanentemente, no a través de inetd.</span>

<span class="o">[</span>...<span class="o">]</span>

<span class="nv">DAEMON_OPTS</span><span class="o">=</span><span class="s2">&quot;--transparent --user sslh --listen 172.22.0.2:443 \</span>
<span class="s2">             --ssh 127.1.1.1:22 --ssl 127.1.1.1:443 --openvpn 127.1.1.1:1194 \</span>
<span class="s2">             --pidfile /var/run/sslh/sslh.pid&quot;</span>
</pre></div>
</div>
<p>donde se indica que se quiere hacer transparente el servicio, y se redirige el
tráfico a una interfaz local particular.</p>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>En este caso, no se tiene que ejecutar como administrador porque
<em>Debian</em> compila el programa con la opción <code class="docutils literal notranslate"><span class="pre">USELIBCAP=1</span></code>.</p>
</div>
</section>
<section id="nginx">
<span id="nginx-transparente"></span><h3><span class="section-number">7.5.2.3.2.3.3. </span>nginx<a class="headerlink" href="#nginx" title="Link to this heading">¶</a></h3>
<p>La configuración para hacer que <strong class="program">nginx</strong> se comporte como proxy
<em>transparente</em> pasa por ejecutarlo como administrador:</p>
<div class="highlight-nginx notranslate"><div class="highlight"><pre><span></span><span class="c1"># Esto es nginx.conf</span>

<span class="k">user</span><span class="w"> </span><span class="s">root</span>

<span class="s">[...]</span>

<span class="s">stream</span><span class="w"> </span><span class="p">{</span>
<span class="w">   </span><span class="kn">server</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="kn">listen</span><span class="w"> </span><span class="mi">80</span><span class="p">;</span>

<span class="w">      </span><span class="kn">proxy_bind</span><span class="w"> </span><span class="nv">$remote_addr</span><span class="w"> </span><span class="s">transparent</span><span class="p">;</span>
<span class="w">      </span><span class="kn">proxy_pass</span><span class="w"> </span><span class="mi">127</span><span class="s">.1.1.1</span><span class="p">;</span>
<span class="w">   </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>que supone que el servidor final está en la propia máquina. Esta configuración
de proxy <abbr title="Transmission Control Protocol">TCP</abbr>, a menos que fuera con <abbr title="Secure Socket Layer">SSL</abbr> y se usara <abbr title="Server Name Indication">SNI</abbr> para discriminar
los tráficos, resulta un poco inútil. La transparencia también puede practicarse
en un <em>proxy</em> <abbr title="HyperText Transfer Protocol">HTTP</abbr>:</p>
<div class="highlight-nginx notranslate"><div class="highlight"><pre><span></span><span class="k">upstream</span><span class="w"> </span><span class="s">backend</span><span class="w"> </span><span class="p">{</span>
<span class="w">   </span><span class="kn">server</span><span class="w"> </span><span class="mi">192</span><span class="s">.168.0.100</span><span class="p">;</span>
<span class="w">   </span><span class="kn">server</span><span class="w"> </span><span class="mi">192</span><span class="s">.168.0.200</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">server</span><span class="w"> </span><span class="p">{</span>
<span class="w">   </span><span class="kn">listen</span><span class="w"> </span><span class="mi">80</span><span class="p">;</span>

<span class="w">   </span><span class="kn">location</span><span class="w"> </span><span class="s">/</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="kn">proxy_bind</span><span class="w"> </span><span class="nv">$remote_addr</span><span class="w"> </span><span class="s">transparent</span><span class="p">;</span>
<span class="w">      </span><span class="kn">proxy_pass</span><span class="w"> </span><span class="s">http://</span><span class="nv">$backend$uri</span><span class="p">;</span>
<span class="w">   </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">Ver también</p>
<p>Échele un ojo a una <a class="reference external" href="https://www.nginx.com/blog/ip-transparency-direct-server-return-nginx-plus-transparent-proxy/">entrada sobre el asunto</a>
en el blog oficial.</p>
</div>
</section>
<section id="haproxy">
<span id="haproxy-transparent"></span><h3><span class="section-number">7.5.2.3.2.3.4. </span>haproxy<a class="headerlink" href="#haproxy" title="Link to this heading">¶</a></h3>
<p>A la <a class="reference internal" href="#proxy-transparente-sol-gen"><span class="std std-ref">solución general</span></a>, basta añadirle
algunos pequeños cambios en la configuración. Dependiendo de si queremos correr
el servicio como administrador o utilizar las <a class="reference internal" href="../../../02.conbas/09.admbasica/10.priv.html#capabilities"><span class="std std-ref">capabilities</span></a>
así deberán ser los cambios, pero en cualquier caso deberemos configurar
cualquier <em>backend</em> de este modo:</p>
<blockquote>
<div><div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>backend<span class="w"> </span>ssh
<span class="w">   </span>mode<span class="w"> </span>tcp
<span class="hll"><span class="w">   </span><span class="nb">source</span><span class="w"> </span><span class="m">0</span>.0.0.0<span class="w"> </span>usesrc<span class="w"> </span>clientip
</span><span class="w">   </span>server<span class="w"> </span>ssh<span class="w"> </span><span class="m">127</span>.1.1.1:22
</pre></div>
</div>
</div></blockquote>
<p>para que se envíen los paquetes utilizando la <abbr title="Internet Protocol">IP</abbr> del cliente como origen.</p>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>Si los servidores finales están en la misma máquina recuerde hacer
referencia a ellos usando una <abbr title="Internet Protocol">IP</abbr> local no habitual como la <em>127.1.1.1</em>
sugerida en la solución general.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<dl class="simple">
<dt>En el caso del servidor web, como se conserva la <abbr title="Internet Protocol">IP</abbr> del cliente, no</dt><dd><p>es necesario alterar la cabecera <cite>X-Forwarded-For</cite>, pero sí la referente al
protocolo, que cambia de <abbr title="HyperText Transfer Protocol">HTTP</abbr>s a <abbr title="HyperText Transfer Protocol">HTTP</abbr>. Por tanto:</p>
</dd>
</dl>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>backend<span class="w"> </span>http
<span class="w">   </span>mode<span class="w"> </span>http
<span class="hll"><span class="w">   </span><span class="c1">#option forwardfor</span>
</span><span class="hll"><span class="w">   </span><span class="nb">source</span><span class="w"> </span><span class="m">0</span>.0.0.0<span class="w"> </span>usesrc<span class="w"> </span>clientip
</span><span class="w">   </span>reqadd<span class="w"> </span>X-Forwarded-Proto:<span class="se">\ </span>https
<span class="w">   </span>server<span class="w"> </span>nginx<span class="w"> </span><span class="m">127</span>.1.1.1:80
</pre></div>
</div>
</div>
<p>Y los cambios, según optemos por una estrategia u otra:</p>
<dl>
<dt><strong>Como root</strong></dt><dd><ul>
<li><p>Comentar en la sección <em>global</em> los líneas que propician
que <strong class="program">haproxy</strong> degrade sus permisos una vez arrancado:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="c1">#user haproxy</span>
<span class="c1">#group haproxy</span>
</pre></div>
</div>
</li>
</ul>
</dd>
<dt><strong>Usando capabilities</strong></dt><dd><ul>
<li><p>Habrá que conferir las <em>capabilities</em> adecuadas al ejecutable:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp"># </span>setcap<span class="w"> </span><span class="s1">&#39;cap_net_admin,cap_net_bind_service=ep&#39;</span><span class="w"> </span>/usr/sbin/haproxy
</pre></div>
</div>
<p>La primera ya hemos dicho que permite crear el <em>socket</em> transparente,
mientras que la segunda escuchar en puerto privilegiado.</p>
<div class="admonition warning">
<p class="admonition-title">Advertencia</p>
<p>Cada vez que se sustituya el ejecutable con una actualización,
se perderán estas capacidades y habrá que volver a definirlas.</p>
</div>
</li>
<li><p>Comentar en la sesión <em>global</em> las dos líneas anteriores y también otra
referente a una jaula que ya es imposible e innecesaria:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="c1">#chroot /var/lib/haproxy</span>
<span class="c1">#user haproxy</span>
<span class="c1">#group haproxy</span>
</pre></div>
</div>
</li>
<li><p>Como posiblemente hayamos arrancado ya el servicio, limpiar algunos
archivos que genera la ejecución porque pertenecen a <em>root</em> y el usuario
sin privilegios no tiene permisos para sobrescribirlos:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp"># </span>invoke-rc.d<span class="w"> </span>haproxy<span class="w"> </span>stop
<span class="gp"># </span>rm<span class="w"> </span>-f<span class="w"> </span>/run/haproxy.pid<span class="w"> </span>/run/haproxy/*<span class="w"> </span>/run/haproxy-master.sock
<span class="gp"># </span>ls<span class="w"> </span>-ld<span class="w"> </span>/run/haproxy
<span class="go">drwxrwsr-x 2 haproxy haproxy 80 Jul 17 21:59 /run/haproxy/</span>
<span class="gp"># </span>cat<span class="w"> </span>&gt;&gt;<span class="w"> </span>/etc/default/haproxy
<span class="go">PIDFILE=&quot;/run/haproxy/haproxy.pid&quot;</span>
<span class="go">EXTRAOPTS=&quot;-S /run/haproxy/haproxy-master.sock&quot;</span>
</pre></div>
</div>
</li>
<li><p>Forzar a <a class="reference internal" href="../../../04.servidor/03.init/index.html#systemd"><span class="std std-ref">systemd</span></a> para que ejecute el servicio como el
usuario <em>haproxy</em>, lo cual implica <a class="reference internal" href="../../../04.servidor/03.init/systemd/04.personalizacion.html#systemd-edicion"><span class="std std-ref">manipular su configuración de
arranque</span></a>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp"># </span>mkdir<span class="w"> </span>/etc/systemd/system/haproxy.service.d
<span class="gp"># </span>cat<span class="w"> </span>&gt;<span class="w"> </span>/etc/systemd/system/haproxy.service.d/10-nonroot.conf
<span class="go">[Service]</span>
<span class="go">User=haproxy</span>
<span class="go">Group=haproxy</span>
<span class="gp"># </span>systemctl<span class="w"> </span>daemon-reload
<span class="gp"># </span>systemctl<span class="w"> </span>cat<span class="w"> </span>haproxy.service
<span class="go">[... configuración vigente del arranque de haproxy ...]</span>
<span class="gp"># </span>invoke.rc-d<span class="w"> </span>haproxy<span class="w"> </span>start
</pre></div>
</div>
</li>
</ul>
</dd>
</dl>
<p class="rubric">Notas al pie</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id5" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id1">1</a><span class="fn-bracket">]</span></span>
<p>Si el <em>proxy</em> no se ejecuta como administrador, sino con su propio usuario,
entonces podemos identificar el tráfico, no por el destino, sino por el usuario
que lo ejecuta:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp"># </span>iptables<span class="w"> </span>-t<span class="w"> </span>nat<span class="w"> </span>-A<span class="w"> </span>OUTPUT<span class="w"> </span>-m<span class="w"> </span>owner<span class="w"> </span>--uid-owner<span class="w"> </span>stunnel<span class="w"> </span>-j<span class="w"> </span>CONNMARK<span class="w"> </span>--set-mark<span class="w"> </span>0xff
</pre></div>
</div>
</aside>
<aside class="footnote brackets" id="id6" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id2">2</a><span class="fn-bracket">]</span></span>
<p>Esta configuración requiere que el núcleo se haya compilado con el módulo
<code class="docutils literal notranslate"><span class="pre">NETFILTER_XT_MATCH_SOCKET</span></code>, pero esto es así en las <em>debian</em> modernas:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp"># </span>grep<span class="w"> </span>-i<span class="w"> </span>match_socket<span class="w"> </span>/boot/config-<span class="sb">`</span>uname<span class="w"> </span>-r<span class="sb">`</span>
<span class="go">CONFIG_NETFILTER_XT_MATCH_SOCKET=m</span>
</pre></div>
</div>
</aside>
<aside class="footnote brackets" id="id7" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id3">3</a><span class="fn-bracket">]</span></span>
<p>Si queremos hacer permanente el cambio, podemos incluir la definición de
los parámentros en <code class="file docutils literal notranslate"><span class="pre">/etC/sysctl.conf</span></code> como ya se ha hecho en otros
epígrafes de este manual.</p>
</aside>
<aside class="footnote brackets" id="id8" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id4">4</a><span class="fn-bracket">]</span></span>
<p>Se añade <kbd class="kbd compound docutils literal notranslate"><kbd class="kbd docutils literal notranslate">-</kbd>-<kbd class="kbd docutils literal notranslate">no</kbd>-<kbd class="kbd docutils literal notranslate">check</kbd>-<kbd class="kbd docutils literal notranslate">certificate</kbd></kbd> para evitar problemas si en
nuestras pruebas usamos certificados autofirmados.</p>
</aside>
</aside>
</section>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <div>
    <h3><a href="../../../index.html">Tabla de contenido</a></h3>
    <ul>
<li><a class="reference internal" href="#">7.5.2.3.2. Transparencia</a><ul>
<li><a class="reference internal" href="#requisitos">7.5.2.3.2.1. Requisitos</a></li>
<li><a class="reference internal" href="#solucion-general">7.5.2.3.2.2. Solución general</a></li>
<li><a class="reference internal" href="#soluciones-particulares">7.5.2.3.2.3. Soluciones particulares</a><ul>
<li><a class="reference internal" href="#stunnel">7.5.2.3.2.3.1. stunnel</a></li>
<li><a class="reference internal" href="#sslh">7.5.2.3.2.3.2. SSLH</a></li>
<li><a class="reference internal" href="#nginx">7.5.2.3.2.3.3. nginx</a></li>
<li><a class="reference internal" href="#haproxy">7.5.2.3.2.3.4. haproxy</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>Tema anterior</h4>
    <p class="topless"><a href="01.multi.html"
                          title="capítulo anterior"><span class="section-number">7.5.2.3.1. </span>Multiplexores</a></p>
  </div>
  <div>
    <h4>Próximo tema</h4>
    <p class="topless"><a href="03.web.html"
                          title="próximo capítulo"><span class="section-number">7.5.2.3.3. </span>Web</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>Esta página</h3>
    <ul class="this-page-menu">
      <li><a href="../../../_sources/07.serre/05.proxies/03.reverse/02.transparencia.rst.txt"
            rel="nofollow">Mostrar el código</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Búsqueda rápida</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Ir a" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navegación</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="Índice General"
             >índice</a></li>
        <li class="right" >
          <a href="03.web.html" title="7.5.2.3.3. Web"
             >siguiente</a> |</li>
        <li class="right" >
          <a href="01.multi.html" title="7.5.2.3.1. Multiplexores"
             >anterior</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">documentación de Linuxnomicón - rolling</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" ><span class="section-number">7. </span>Servicios de red</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="../index.html" ><span class="section-number">7.5. </span>Proxies</a> &#187;</li>
          <li class="nav-item nav-item-3"><a href="../03.reverse.html" ><span class="section-number">7.5.2.3. </span>Proxies inversos</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href=""><span class="section-number">7.5.2.3.2. </span>Transparencia</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
    &#169; Copyright CC BY 4.0, 2016-2024, José Miguel Sánchez Alés.
      Creado usando <a href="https://www.sphinx-doc.org/">Sphinx</a> 7.2.6.
    </div>
  </body>
</html>