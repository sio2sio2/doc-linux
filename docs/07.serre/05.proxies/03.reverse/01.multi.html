

<!DOCTYPE html>

<html lang="es" data-content_root="../../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>7.5.2.3.1. Multiplexores &#8212; documentación de Linuxnomicón - rolling</title>
    <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="../../../_static/classic.css?v=2bf1fcf8" />
    <link rel="stylesheet" href="../../../_static/custom.css" type="text/css" />
    
    <script src="../../../_static/documentation_options.js?v=a621b78a"></script>
    <script src="../../../_static/doctools.js?v=9bcbadda"></script>
    <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../_static/translations.js?v=f85f4cfb"></script>
    
    <link rel="index" title="Índice" href="../../../genindex.html" />
    <link rel="search" title="Búsqueda" href="../../../search.html" />
    <link rel="next" title="7.5.2.3.2. Transparencia" href="02.transparencia.html" />
    <link rel="prev" title="7.5.2.3. Proxies inversos" href="../03.reverse.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="Related">
      <h3>Navegación</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="Índice General"
             accesskey="I">índice</a></li>
        <li class="right" >
          <a href="02.transparencia.html" title="7.5.2.3.2. Transparencia"
             accesskey="N">siguiente</a> |</li>
        <li class="right" >
          <a href="../03.reverse.html" title="7.5.2.3. Proxies inversos"
             accesskey="P">anterior</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">documentación de Linuxnomicón - rolling</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" ><span class="section-number">7. </span>Servicios de red</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="../index.html" ><span class="section-number">7.5. </span>Proxies</a> &#187;</li>
          <li class="nav-item nav-item-3"><a href="../03.reverse.html" accesskey="U"><span class="section-number">7.5.2.3. </span>Proxies inversos</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href=""><span class="section-number">7.5.2.3.1. </span>Multiplexores</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="multiplexores">
<span id="multiplexor"></span><h1><span class="section-number">7.5.2.3.1. </span>Multiplexores<a class="headerlink" href="#multiplexores" title="Link to this heading">¶</a></h1>
<p>Un <em class="dfn">multiplexor</em> es un <em>proxy</em> capaz de recibir tráfico de distinta
naturaleza y dirigirlo cada cual a su servicio correspondiente:</p>
<img alt="../../../_images/multiplexor.png" src="../../../_images/multiplexor.png" />
<p>Su función es la de permitir que un mismo puerto pueda ser compartido por varios
servicios distintos, comúnmente en previsión de que los clientes se encuentren
en redes que, mediante el uso de una <a class="reference external" href="https://es.wikipedia.org/wiki/Inspecci%C3%B3n_profunda_de_paquete">herramienta DPI</a>, les
restrinjan el acceso a determinados puertos. Lo habitual es que el <em>multiplexor</em>
se coloque en el puerto <strong>443</strong>, ya que es el puerto para <abbr title="HyperText Transfer Protocol">HTTP</abbr>s y el tráfico
web seguro suele permitirse en todas las redes.</p>
<p>En el esquema se han representado los servidores finales cada uno en su máquina
y, a su vez, en distinta máquina de la que corre el <em>multiplexor</em>, pero es
posible también que <em>multiplexor</em> y servicios finales corran todos en el mismo
equipo.</p>
<p>Nos detendremos en analizar cinco estrategias de multiplexación:</p>
<ul class="simple">
<li><p><a class="reference internal" href="#sslh"><span class="std std-ref">sslh</span></a>, que permite multiplexar tráfico <abbr title="Security SHell">SSH</abbr>, <abbr title="Secure Socket Layer">SSL</abbr> y Open<abbr title="Virtual Private Network">VPN</abbr>
entre otros.</p></li>
<li><p><a class="reference internal" href="#wstunnel"><span class="std std-ref">wstunnel</span></a>, que nos permite canalizar cualesquiera aplicaciones a
través de <a class="reference external" href="https://v0ctor.me/websocket">Websockets</a>, lo cual es, por tanto, una manera de conseguir
multiplexación.</p></li>
<li><p><a class="reference internal" href="#haproxy"><span class="std std-ref">haproxy</span></a>, que entre otras cosas, es capaz de multiplexar al
menos <abbr title="Security SHell">SSH</abbr>, <abbr title="Secure Socket Layer">SSL</abbr> y Open<abbr title="Virtual Private Network">VPN</abbr>.</p></li>
<li><p><a class="reference internal" href="../../02.web/02.nginx/index.html#n-ginx"><span class="std std-ref">nginx</span></a>, que es capaz de distinguir entre tráfico <abbr title="Secure Socket Layer">SSL</abbr> y tráfico no <abbr title="Secure Socket Layer">SSL</abbr>
y, por tanto, puede hacer una labor de multiplexación. Se trata en el
<a class="reference internal" href="../../02.web/02.nginx/02.avanz/08.multiplex.html#nginx-multiplexacion"><span class="std std-ref">epígrafe sobre nginx dedicado a la multiplexación</span></a>.</p></li>
<li><p><em class="dfn">Multiplexión SSL</em> que es una técnica que consiste en encapsular
cualquier tráfico <abbr title="Transmission Control Protocol">TCP</abbr> con <abbr title="Secure Socket Layer">SSL</abbr> y distinguir el tipo por el <a class="reference internal" href="../../../98.apendice/01.cryto/03.aplicaciones/04.ssl.html#sni"><span class="std std-ref">SNI</span></a>. Trataremos su implementación con <a class="reference internal" href="#haproxy"><span class="std std-ref">haproxy</span></a> y al
analizar la <a class="reference internal" href="../../02.web/02.nginx/02.avanz/08.multiplex.html#nginx-multiplexacion"><span class="std std-ref">multiplexación con nginx</span></a>.</p></li>
</ul>
<section id="sslh">
<span id="id1"></span><h2><span class="section-number">7.5.2.3.1.1. </span>SSLH<a class="headerlink" href="#sslh" title="Link to this heading">¶</a></h2>
<p>El <a class="reference external" href="http://www.rutschle.net/tech/sslh/README.html">servicio SSLH</a> se
limita a multiplexar distintos tipos de tráfico por lo que tiene una
configuración muy sencilla. Para instalarlo:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp"># </span>apt<span class="w"> </span>install<span class="w"> </span>sslh
</pre></div>
</div>
<p>y todo consiste en que sea él el que escuche en las interfaces físicas
por las que se puede recibir tráfico externo. Suponiendo que los servicios
finales se encuentren en la misma máquina la configuración se reduce a editar el
fichero <code class="file docutils literal notranslate"><span class="pre">/etc/default/sslh</span></code> del siguiente modo:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="nv">RUN</span><span class="o">=</span>yes<span class="w">  </span><span class="c1"># SSLH corre permanentemente, no a través de inetd.</span>

<span class="nv">DAEMON</span><span class="o">=</span>/usr/sbin/sslh<span class="w">  </span><span class="c1"># Puede cambiarse por sslh-select</span>

<span class="nv">DAEMON_OPTS</span><span class="o">=</span><span class="s2">&quot;--user sslh --listen 172.22.0.2:443 \</span>
<span class="s2">             --ssh 127.0.0.1:22 --ssl 127.0.0.1:443 --openvpn 127.0.0.1:1194 \</span>
<span class="s2">             --pidfile /var/run/sslh/sslh.pid&quot;</span>
</pre></div>
</div>
<p>suponiendo que se escucha la interfaz física tiene la <abbr title="Internet Protocol">IP</abbr> <em>172.22.0.2</em> y que se
desea multiplexar tráfico <abbr title="Security SHell">SSH</abbr>, <abbr title="Secure Socket Layer">SSL</abbr> y <abbr title="Virtual Private Network">VPN</abbr>. Las respectivos servicios deben
estar escuchando, al menos, en esas interfaces por los puertos indicados. Una
propuesta podría ser esta:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Servicio</p></th>
<th class="head"><p>Interfaz</p></th>
<th class="head"><p>Puerto</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><abbr title="Security SHell">SSH</abbr></p></td>
<td><p>0.0.0.0</p></td>
<td><p>22/TCP</p></td>
</tr>
<tr class="row-odd"><td><p><em>OpenVPN</em><a class="footnote-reference brackets" href="#id10" id="id2" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a></p></td>
<td><p>127.0.0.1</p></td>
<td><p>1194/TCP</p></td>
</tr>
<tr class="row-even"><td><p><abbr title="HyperText Transfer Protocol">HTTP</abbr>s</p></td>
<td><p>127.0.0.1</p></td>
<td><p>443/TCP</p></td>
</tr>
<tr class="row-odd"><td><p><em>SSLH</em></p></td>
<td><p>Todas excepto local</p></td>
<td><p>443/TCP</p></td>
</tr>
</tbody>
</table>
<p>Si existen varias interfaces físicas entonces puede repetirse la opción
<kbd class="kbd compound docutils literal notranslate"><kbd class="kbd docutils literal notranslate">-</kbd>-<kbd class="kbd docutils literal notranslate">listen</kbd></kbd> para incluirlas todas.</p>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>Existen dos versiones del programa: <strong class="program">sslh-fork</strong> (o
<strong class="program">sslh</strong> a secas) que utiliza un proceso para cada conexión y
<strong class="program">sslh-select</strong> que usa un solo hilo para gestionar todas las
conexiones. El primero consume más recursos, pero está mejor testeado y un
error no afecta a todas las conexiones. A través de <code class="docutils literal notranslate"><span class="pre">DAEMON</span></code> puede
utilizarse uno y otro ejecutable.</p>
</div>
</section>
<section id="haproxy">
<span id="id3"></span><h2><span class="section-number">7.5.2.3.1.2. </span><strong class="program">haproxy</strong><a class="headerlink" href="#haproxy" title="Link to this heading">¶</a></h2>
<p><strong class="program">haproxy</strong> es, en realidad, un <em>proxy</em> bastante más completo de lo que
expondremos aquí, por cuanto sólo expondremos como hacer que multiplexe tráficos
de distinto tipo.</p>
<p>Desrrollaremos <strong>dos soluciones</strong> distintas:</p>
<ol class="arabic">
<li><p>Una en la que todos los protocolos (<abbr title="HyperText Transfer Protocol">HTTP</abbr>, <abbr title="Security SHell">SSH</abbr> y <abbr title="Virtual Private Network">VPN</abbr>) van encapsulados con
<abbr title="Transport Layer Security">TLS</abbr> y es el propio <strong class="program">haproxy</strong> el que los desencapsula, los reconoce
y los envía al servidor correspondiente.</p></li>
<li><p>Otra en que junto a tráfico <abbr title="Transport Layer Security">TLS</abbr>, se permite que <abbr title="Security SHell">SSH</abbr> y <abbr title="Virtual Private Network">VPN</abbr> circulen sin
encapsular, de manera que al llegar el tráfico a <strong class="program">haproxy</strong>, este lo manda
a sus respectivos servidores. Hasta aquí, <strong class="program">haproxy</strong> se comporta
exactamente igual que <a class="reference internal" href="#sslh"><span class="std std-ref">sslh</span></a>. Sin embargo, el tráfico <abbr title="Transport Layer Security">TLS</abbr> no lo
envía al servidor <em>web</em>, sino que lo desencapsula, como en el caso anterior,
para comprobar si es <abbr title="HyperText Transfer Protocol">HTTP</abbr>, <abbr title="Security SHell">SSH</abbr> y <abbr title="Virtual Private Network">VPN</abbr> y, reconocidos, se reenvían al servidor
correspondiente.</p>
<p>En este segundo caso, la configuración permite enviar encapsulado o no el
tráfico <abbr title="Security SHell">SSH</abbr> y <abbr title="Virtual Private Network">VPN</abbr> según el grado de restricción de la red remota. Tenga
en cuenta que encapsular este tráfico, que ya es tráfico seguro, sólo tiene
por finalidad engañar a los proxies intermedios pero a costa de reducir el
rendimiento de la conexión, ya que la capsula <abbr title="Transport Layer Security">TLS</abbr> supone procesamiento y
metainformación extra.</p>
</li>
</ol>
<p>Antes de entrar a configurar, es necesario instalar:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp"># </span>apt<span class="w"> </span>install<span class="w"> </span>haproxy
</pre></div>
</div>
<p>y tener un certificado digital para el servicio, que puede ser autofirmado o
acreditado por una autoridad certificadora (véase <a class="reference internal" href="../../02.web/02.nginx/02.avanz/07.https.html#tls-cert"><span class="std std-ref">cómo obtener uno</span></a>)<a class="footnote-reference brackets" href="#id11" id="id4" role="doc-noteref"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></a>.</p>
<p>Sea como sea, es preciso señalar que <strong class="program">haproxy</strong> requiere que todas las
claves públicas y la privada participantes en la autenticación estén reunidas en
un mismo fichero.</p>
<p>En el caso de un <em>certificado autofirmado</em>, muy probablemente tendremos que
hacer algo así:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp"># </span>cat<span class="w"> </span>/etc/ssl/<span class="o">{</span>private/ssl-cert-snakeoil.key,certs/ssl-cert-snakeoil.pem<span class="o">}</span><span class="w"> </span>&gt;<span class="w"> </span>/etc/haproxy/keycert.pem
<span class="gp"># </span>chmod<span class="w"> </span><span class="m">600</span><span class="w"> </span>/etc/haproxy/keycert.pem
</pre></div>
</div>
<p>y en el caso de haber usado <em>letsencrypt</em>, si no hemos creado un <em>gancho</em> de
postinstalación como se sugirió en las explicaciones:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp"># </span>cat<span class="w"> </span>/etc/letsencrypt/live/mi.servidor.org/<span class="o">{</span>fullchain,privkey<span class="o">}</span>.pem<span class="w"> </span>&gt;<span class="w"> </span>/etc/haproxy/keycert.pem
<span class="gp"># </span>chmod<span class="w"> </span><span class="m">600</span><span class="w"> </span>/etc/haproxy/keycert.pem
</pre></div>
</div>
<p>Creado el certificado adecuado, podemos hacer la configuración propiamente
dicha, que es bastante más complicada y con muchísimas más variantes que la de
<a class="reference internal" href="#sslh"><span class="std std-ref">sslh</span></a>.</p>
<p class="rubric">Primera variante</p>
<p>En ella, <strong class="program">haproxy</strong> recibe tráfico cifrado con <abbr title="Transport Layer Security">TLS</abbr>, lo descifra y,
dependiendo de su naturaleza, lo envía al servidor adecuado. Bajo estos
presupuestos la configuración en <code class="file docutils literal notranslate"><span class="pre">/etc/haproxy/haproxy.cfg</span></code> queda así:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>global
   # directivas que trae ya el fichero

   tune.ssl.default-dh-param 2048


default
   # directivas que trae ya el fichero


frontend ssl
   bind *:443 ssl crt /etc/haproxy/keycert.pem
   mode tcp
   option tcplog

   tcp-request inspect-delay 5s
   tcp-request content accept  if  { req.ssl_hello_type 1 }

   acl ssh_request     payload(0,7) -m bin 5353482d322e30  

   use_backend http     if HTTP
   use_backend ssh      if ssh_request
   use_backend vpn      if !{ req.ssl_hello_type 1 } !{ req.len 0 }


backend ssh
   mode tcp
   timeout server 2h
   server ssh 127.0.0.1:22


backend vpn
   mode tcp
   timeout server 2h
   server openvpn 127.0.0.1:1194
   

backend http
   mode http
   option forwardfor
   http-request add-header X-Forwarded-Proto https
   #reqadd X-Forwarded-Proto:\ https   # Sintaxis anterior a haproxy 2.1
   server nginx 127.0.0.1:80
</pre></div>
</div>
<p>Las claves de esta configuración son las siguientes:</p>
<ul class="simple">
<li><p>Las cláusulas <em>frontend</em> definen las conexiones con el cliente y las cláusulas
<em>backend</em> las conexiones con los servidores, de lo que se deduce que
<strong class="program">haproxy</strong> escucha en el puerto <strong>443</strong> de la interfaz real (se ha
supuesto que su <em>ip</em> es <em>172.22.0.2</em>); y conecta con tres servidores: uno <abbr title="Security SHell">SSH</abbr>,
uno <abbr title="Virtual Private Network">VPN</abbr> y un web, todos en la propia máquina.</p></li>
<li><p>Es justamente ahí donde se cifra a la salida y se descifra a la entrada
por lo que se añade el parámetro <code class="docutils literal notranslate"><span class="pre">ssl</span></code> y se indica cuál el certificado<a class="footnote-reference brackets" href="#id12" id="id5" role="doc-noteref"><span class="fn-bracket">[</span>3<span class="fn-bracket">]</span></a>.</p></li>
<li><p>Como consecuencia de que se descifra, es posible analizar el contenido
y distinguir entre los tres tráficos<a class="footnote-reference brackets" href="#id13" id="id6" role="doc-noteref"><span class="fn-bracket">[</span>4<span class="fn-bracket">]</span></a>.</p></li>
<li><p>La conexión con el servidor se hace en modo <abbr title="HyperText Transfer Protocol">HTTP</abbr> al puerto <strong>80</strong><a class="footnote-reference brackets" href="#id14" id="id7" role="doc-noteref"><span class="fn-bracket">[</span>5<span class="fn-bracket">]</span></a>.
Esto nos permite añadir los campos <code class="docutils literal notranslate"><span class="pre">X-Forwarder-For</span></code>
para indicar la <abbr title="Internet Protocol">IP</abbr> del cliente original y la cabecera <code class="docutils literal notranslate"><span class="pre">X-Forwarder-Proto</span></code>
para avisar de que el protocolo que usó el cliente fue <abbr title="HyperText Transfer Protocol">HTTP</abbr>s y no <abbr title="HyperText Transfer Protocol">HTTP</abbr>
que es el que ve el servidor. Si se tiene convenientemente configurado el
servidor web, las aplicaciones web podrán saber quién se conecta y cómo.</p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p><strong class="program">haproxy</strong>. en este caso, no actúa como <em>proxy</em> transparente,
por lo que todos los servidores finales entenderán que reciben las peticiones
de la propia máquina. Si el origen de las peticiones para <abbr title="Virtual Private Network">VPN</abbr> y <abbr title="Security SHell">SSH</abbr> nos
fuera fundamental (en el servicio web se han resuelto vía cabeceras <abbr title="HyperText Transfer Protocol">HTTP</abbr>),
podemos ponerlo a funcionar en <a class="reference internal" href="02.transparencia.html#haproxy-transparent"><span class="std std-ref">modo transparente</span></a>.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>Si se dispone de varios certificados digitales, <strong class="program">haproxy</strong> (a
partir de su versión <strong>1.6</strong>) permite declararlos todos en la misma
instrucción:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">bind *:443 ssl crt /etc/haproxy/keycert.pem crt /etc/haproxy/otro.pem</span>
</pre></div>
</div>
<p>y él se encargará de determinar cuál es el apropiado utilizando <a class="reference internal" href="../../../98.apendice/01.cryto/03.aplicaciones/04.ssl.html#sni"><span class="std std-ref">la
extensión SNI</span></a>.</p>
</div>
<p class="rubric" id="haproxy-2v">Segunda variante</p>
<p>No presupone que el tráfico al puerto <strong>443</strong> sea forzosamente <abbr title="Secure Socket Layer">SSL</abbr> como la
anterior, sino que primero discrimina entre <abbr title="Transport Layer Security">TLS</abbr>, <abbr title="Security SHell">SSH</abbr> o <abbr title="Virtual Private Network">VPN</abbr>. El tráfico
<abbr title="Transport Layer Security">TLS</abbr> lo desencapsula y vuelve a discriminarlo según sea la naturaleza del
tráfico tunelizado.  Puede descargar el código de <a class="reference download internal" download="" href="../../../_downloads/ed326395f55140bd49934276dc7d2094/haproxy_2.cfg"><code class="xref download docutils literal notranslate"><span class="pre">este</span> <span class="pre">enlace</span></code></a>.</p>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>Por el modo en que se ha realizado esta configuración del servidor (y
tambiém la anterior), éste no necesita conocer de antemano de qué naturaleza
es el tráfico escondido dentro de <abbr title="Transport Layer Security">TLS</abbr>, ya que antes de discriminar tal
tráfico desencapsula. Como encapsulado, el tráfico está cifrado y es
imposible conocer cuál es (esta es, precisamente, la base de que podamos
burlar cualquier <em>proxy</em>), el protocolo <abbr title="Transport Layer Security">TLS</abbr> habilita una manera de que en
la propia envoltura se indique el nombre del servidor: la extensión <abbr title="Server Name Indication">SNI</abbr>.</p>
<p>Una manera de distinguir el tipo de tráfico es hacer que el cliente incluya
un <abbr title="Server Name Indication">SNI</abbr> distinto para cada tipo de tráfico y reconocer éste leyendo el
<abbr title="Server Name Indication">SNI</abbr>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">frontend main</span>
<span class="go">   bind 172.22.0.2:443  # No descriframos en absoluto.</span>
<span class="go">   mode tcp</span>
<span class="go">   option tcplog</span>

<span class="go">   tcp-request inspect-delay 5s</span>
<span class="go">   tcp-request content accept if { req_ssl_hello_type 1 }</span>

<span class="go">   acl   ssh_request   req_ssl_sni -i ssh.mi.servidor.org</span>
<span class="go">   acl   vpn_request   req_ssl_sni -i vpn.mi.servidor.org</span>

<span class="go">   use_backend ssl-ssh   if ssh_request</span>
<span class="go">   use_backend ssl-vpn   if vpn_request</span>
<span class="go">   default_backend       http</span>
</pre></div>
</div>
<p>Ahora bien, el tráfico sigue cifrado con <abbr title="Transport Layer Security">TLS</abbr> lo cual puede no ser un
problema para el servidor web<a class="footnote-reference brackets" href="#id15" id="id8" role="doc-noteref"><span class="fn-bracket">[</span>6<span class="fn-bracket">]</span></a>, pero sí para los otros servidores. Eso
obligaría a que el backend (<em>ssl-ssh</em> o <em>ssl-vpn</em> en el ejemplo) no entregue
directamente el flujo, sino que cada uno de ellos lo envíe a un puerto local
particular en que escucha también <strong class="program">haproxy</strong> y que sea en este
<em>frontend</em> donde <strong class="program">haproxy</strong> aplique el certificado para descifrar.</p>
</div>
</section>
<section id="wstunnel">
<span id="id9"></span><h2><span class="section-number">7.5.2.3.1.3. </span>wstunnel<a class="headerlink" href="#wstunnel" title="Link to this heading">¶</a></h2>
<p><strong class="program">wstunnel</strong> no es exactamente un multiplexador, sino un <em>proxy</em> que nos
permite tunelizar a través de <a class="reference external" href="https://v0ctor.me/websocket">Websockets</a> cualquier servicio (p.e.
<a class="reference internal" href="../../04.vpn/02.wireguard/index.html#wireguard"><span class="std std-ref">wireguard</span></a>). Este programa actuará tanto en la parte cliente
como en la servidor, de manera que el cliente (pongamos que <abbr title="Security SHell">SSH</abbr>) conecta con
su parte servidor y esta parte servidor la que entrega el tráfico al servidor
<abbr title="Security SHell">SSH</abbr>.</p>
<img alt="../../../_images/websocket.png" src="../../../_images/websocket.png" />
<p>En el gráfico situamos en la parte delantera del cliente y el servidor los
servicios expuestos (porque escuchan en la interfaz física) y en la trasera los
no expuestos (porque escuchan en la interfaz de <em>loopback</em>). Obsérvese que como
el servidor <abbr title="Security SHell">SSH</abbr> sigue expuesto, en las redes remotas en que no hay
restricciones seguirá pudiéndose acceder a él directamente.</p>
<p>La aplicación nos permite multiplexar por dos razones:</p>
<ul>
<li><p>Porque un misma parte servidor puede tunelizar tráfico de distinto tipo.</p></li>
<li><p>Porque al ser una tecnología web, podemos colocar a la escucha un un <em>proxy</em>
web inverso y que éste tenga como uno de sus <em>backends</em> la parte servidor de
<strong class="program">wstunnel</strong>:</p>
<img alt="../../../_images/websocket-compartido.png" src="../../../_images/websocket-compartido.png" />
</li>
</ul>
<p>No existe paquete para <em>Debian</em>, pero podemos descargar el ejecutable de <a class="reference external" href="https://github.com/erebe/wstunnel">su
repositorio de Github</a>. Su uso es bastante
sencillo. Debemos descargar en las dos máquinas el ejecutable y colocarlo en un
lugar adecuado (p.e. <code class="file docutils literal notranslate"><span class="pre">/usr/local/bin</span></code>).</p>
<dl>
<dt><strong>Servidor</strong></dt><dd><p>En la máquina servidor, que es lo que realmente nos interesa a efectos de
este epígrafe, debe escuchar según nos interese. Por ejemplo, así:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp"># </span>wstunnel<span class="w"> </span>-v<span class="w"> </span>--server<span class="w"> </span>ws://0.0.0.0
</pre></div>
</div>
<p>lo cual supone que la aplicación escuche sin cifrado en el puerto <strong>80</strong>
(<em>ws</em>) de todas las interfaces los datos tunelizados. Podríamos modificar la
escucha cambiando el protocolo por <em>wss</em> que cifrará y escuchará por el
<strong>443</strong>. Si nos interesara, podríamos alterar los puertos prefijados también
(p.e. <kbd class="kbd docutils literal notranslate">ws://0.0.0.0:8080</kbd>). A qué aplicación se redirijan los datos
dependerá de lo que se especifique en el cliente. La línea anterior supone
exponer <strong class="program">wstunnel</strong> (tal como representa la primera figura) y como no
se ha establecido ninguna restricción sobre el destino del tráfico, esto
podría propiciar que cualquier máquina utilizara ilegítimamente nuestro
túnel. Así pues, cuando se expone el túnel lo más prudente es restringir el
destino:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp"># </span>wstunnel<span class="w"> </span>-v<span class="w"> </span>--server<span class="w"> </span>ws://0.0.0.0<span class="w"> </span>-r<span class="w"> </span><span class="m">127</span>.0.0.1:22
</pre></div>
</div>
<p>que sólo aceptará tráfico de clientes que indiquen que el tráfico debe
mandarse al servicio <abbr title="Security SHell">SSH</abbr> local a la parte servidor, o sea, a un servidor
<abbr title="Security SHell">SSH</abbr> que está conectado en la misma máquina.</p>
<p>Para resolver la situación en la que queremos compartir el puerto y exponemos
el <em>proxy</em> (o sea, <strong class="program">nginx</strong>) y no <strong class="program">wstunnel</strong> basta con que
hagamos que éste último escuche en algún puerto libre de una interfaz de <em>loopback</em>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp"># </span>wstunnel<span class="w"> </span>-v<span class="w"> </span>--server<span class="w"> </span>ws://127.0.0.1:8080
</pre></div>
</div>
<p>en que podemos hacer exactamente la misma puntualización a la restricción
sobre el destino.</p>
</dd>
<dt><strong>Cliente</strong></dt><dd><p>En la máquina cliente establecemos el otro extremo del túnel de este modo:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp"># </span>wstunnel<span class="w"> </span>-v<span class="w"> </span>-L<span class="w"> </span><span class="m">12345</span>:127.0.0.1:22<span class="w"> </span>ws://203.0.113.1
</pre></div>
</div>
<p>donde hemos supuesto que la máquina servidor tiene la <abbr title="Internet Protocol">IP</abbr> <em>203.0.113.1</em>.  En
este extremo del túnel indicamos a <strong class="program">wstunnel</strong> que el tráfico que
escuche por el puerto <strong>12345</strong> de la interfaz de <em>loopback</em> debe ser
dirigido en el servidor al puerto <strong>22</strong> de la interfaz de <em>loopback</em> (del
servidor claro está). Esto supone que si queremos usar el túnel, el cliente
<abbr title="Security SHell">SSH</abbr> deberá conectar al puerto <strong>12345</strong> de <em>lo</em>. Ha de hacerse notar que
el que no se cifra y conectamos al puerto <strong>80</strong>, es coherente con el modo en
que arrancamos <strong class="program">wstunnel</strong> en el servidor.</p>
<p>Es importante señalar también que al no haber especificado en el cliente, el
puerto <strong>12345</strong> en el cliente y el puerto <strong>22</strong> en el servidor son <abbr title="Transmission Control Protocol">TCP</abbr>.
Sin embargo, <strong class="program">wstunnel</strong> tiene capacidad para tunelizar protocolos
<abbr title="User Datagram Protocol">UDP</abbr> con tan solo indicarlo al arrancar el cliente (en el lado del servidor
todo sigue igual):</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp"># </span>wstunnel<span class="w"> </span>-v<span class="w"> </span>--udp<span class="w"> </span>--udpTimeoutSec<span class="w"> </span>-1<span class="w"> </span>-L<span class="w"> </span><span class="m">12345</span>:127.0.0.1:1194<span class="w"> </span>ws://203.0.113.1
</pre></div>
</div>
<p>En este caso el cliente escucha en el puerto <em>12345/UDP</em> y en el servidor los
datos acaban dirigidos al puerto <em>1194/UDP</em>.</p>
<p>Por último, cuando en el servidor colocamos un <em>proxy</em> que recibe distinto
tráfico y debe identificar cuál es el dirigido al <em>websocket</em> podremos usar
un nombre específico de máquina:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp"># </span>wstunnel<span class="w"> </span>-v<span class="w"> </span>-L<span class="w"> </span><span class="m">12345</span>:127.0.0.1:22<span class="w"> </span>ws://ssh.example.net
</pre></div>
</div>
<p>o incluso una ruta:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp"># </span>wstunnel<span class="w"> </span>-v<span class="w"> </span>-L<span class="w"> </span><span class="m">12345</span>:127.0.0.1:22<span class="w"> </span>ws://www.example.net/ssh
</pre></div>
</div>
</dd>
<dt><strong>Ejemplo de uso</strong></dt><dd><p>Para ilustrar el uso de <strong class="program">wstunnel</strong>, podemos hacer lo siguiente en el
<strong>servidor</strong>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp"># </span>wstunnel<span class="w"> </span>-v<span class="w"> </span>--server<span class="w"> </span>ws://0.0.0.0<span class="w"> </span>-r<span class="w"> </span><span class="m">127</span>.0.0.1:11111
</pre></div>
</div>
<p>y poner a escuchar el simple <a class="reference internal" href="../../../02.conbas/99.misc/10.netcat.html#netcat"><span class="std std-ref">netcat</span></a>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp"># </span>netcat<span class="w"> </span>-l<span class="w"> </span>-p<span class="w"> </span><span class="m">11111</span>
</pre></div>
</div>
<p>En el <strong>cliente</strong>, establecemos el otro extremo del túnel así:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp"># </span>wstunnel<span class="w"> </span>-v<span class="w"> </span>-L<span class="w"> </span><span class="m">22222</span>:127.0.0.1:11111<span class="w"> </span>ws://203.0.113.1
</pre></div>
</div>
<p>y utilizamos <a class="reference internal" href="../../../02.conbas/99.misc/10.netcat.html#netcat"><span class="std std-ref">netcat</span></a> para conversar con el del servidor:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp"># </span>netcat<span class="w"> </span>localhost<span class="w"> </span><span class="m">22222</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>En este caso concreto en el cliente podemos simplificar ejecutando:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp"># </span>wstunnel<span class="w"> </span>-v<span class="w"> </span>-L<span class="w"> </span>stdio:127.0.0.1:11111<span class="w"> </span>ws://203.0.113.1
</pre></div>
</div>
</div>
<p>que hace que el <strong class="program">wstunnel</strong> del cliente no converse con el puerto
<strong>22222</strong>, sino con la entrada y salida estándar, por lo que pondemos
ahorranos la ejecución de <a class="reference internal" href="../../../02.conbas/99.misc/10.netcat.html#netcat"><span class="std std-ref">netcat</span></a> en el cliente.</p>
</dd>
</dl>
<dl id="wstunnel-systemd">
<dt><strong>Servicio</strong></dt><dd><p>Para la parte de servidor, es espcialmente aconsejable convertir
<strong class="program">wstunnel</strong> en un servicio de <a class="reference internal" href="../../../04.servidor/03.init/index.html#systemd"><span class="std std-ref">systemd</span></a> creando el
siguiente servicio en <code class="file docutils literal notranslate"><span class="pre">/etc/systemd/system/wstunnel.service</span></code>:</p>
<div class="highlight-ini notranslate"><div class="highlight"><pre><span></span><span class="k">[Service]</span>
<span class="na">EnvironmentFile</span><span class="o">=</span><span class="s">-/etc/default/wstunnel</span>
<span class="na">ExecStart</span><span class="o">=</span><span class="s">/usr/bin/wstunnel $OPTIONS</span>
<span class="na">Restart</span><span class="o">=</span><span class="s">always</span>
<span class="na">StandardOutput</span><span class="o">=</span><span class="s">syslog</span>
<span class="na">StandardError</span><span class="o">=</span><span class="s">syslog</span>
<span class="na">SyslogIdentifier</span><span class="o">=</span><span class="s">wstunnel</span>
<span class="na">User</span><span class="o">=</span><span class="s">nobody</span>
<span class="na">Group</span><span class="o">=</span><span class="s">nogroup</span>

<span class="k">[Install]</span>
<span class="na">WantedBy</span><span class="o">=</span><span class="s">multi-user.target</span>
</pre></div>
</div>
<p>que requiere un fichero <code class="file docutils literal notranslate"><span class="pre">/etc/default/wstunnel</span></code> para definir las
opciones de arranque:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="c1">#OPTIONS=&quot;--server ws://127.0.0.1:8080&quot;</span>
<span class="nv">OPTIONS</span><span class="o">=</span><span class="s2">&quot;--server ws://0.0.0.0:8080&quot;</span>
</pre></div>
</div>
<p>Por último, habrá que habilitarlo para arranques futuros:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp"># </span>systemctl<span class="w"> </span>daemon-reload
<span class="gp"># </span>systemctl<span class="w"> </span><span class="nb">enable</span><span class="w"> </span>wstunnel
<span class="gp"># </span>systemctl<span class="w"> </span>start<span class="w"> </span>wstunnel
</pre></div>
</div>
</dd>
</dl>
<p class="rubric">Notas al pie</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id10" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id2">1</a><span class="fn-bracket">]</span></span>
<p>Donde queramos poner a escuchar <strong class="program">openvpn</strong> depende de nuestras
intenciones, pero deberá ser <abbr title="Transmission Control Protocol">TCP</abbr> porque así lo podrá encapsular
<strong class="program">sslh</strong>. Escoger el puerto <strong>1194</strong> responde a que ese es el puerto
estándar para esa aplicación (de hecho, aparece referido en
<code class="file docutils literal notranslate"><span class="pre">/etc/services</span></code>). Una buena estrategia es ponerlo a escuchar:</p>
<ul class="simple">
<li><p>En el puerto <em>1194/UDP</em> en todas las interfaces.</p></li>
<li><p>En el puerto <em>1194/TCP</em> de la interfaz local, cuyo acceso será posible
gracias al multiplexor.</p></li>
</ul>
</aside>
<aside class="footnote brackets" id="id11" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id4">2</a><span class="fn-bracket">]</span></span>
<p>Ahora bien, en la práctica deberemos usar un certificado fiable, porque
si el motivo de usar <strong class="program">haproxy</strong> es la existencia de un <em>proxy</em>, lo
necesitaremos; y, si tal <em>proxy</em> no existe, es mejor usar una solución como
<strong class="program">sslh</strong>.</p>
</aside>
<aside class="footnote brackets" id="id12" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id5">3</a><span class="fn-bracket">]</span></span>
<p>En el <em>gancho</em> propuesto el fichero con las claves no se llama
<em>keycert.pem</em>, sino <em>nombre_del_servidor.pem</em>. Téngalo en cuenta a la hora de
copiar la configuración de ejemplo.</p>
</aside>
<aside class="footnote brackets" id="id13" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id6">4</a><span class="fn-bracket">]</span></span>
<p>Todo cliente debe empezar su comunicación con la cadena «<em>SSH-2.0</em>», que
puesta en binario es el código hexadecimal escrito en la configuración.</p>
</aside>
<aside class="footnote brackets" id="id14" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id7">5</a><span class="fn-bracket">]</span></span>
<p>Para profundizar en la configuración del servidor web, cuando es el
<em>proxy</em> de cifrar y descifrar la comunicación, vea el <a class="reference internal" href="../../02.web/02.nginx/02.avanz/09.misc.html#nginx-tras-proxy"><span class="std std-ref">apartado
correspondiente</span></a>.</p>
</aside>
<aside class="footnote brackets" id="id15" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id8">6</a><span class="fn-bracket">]</span></span>
<p>En realidad sí lo es, porque no habrá forma de conocer el origen de la
petición, a menos que, además, se configure <strong class="program">haproxy</strong> en <a class="reference internal" href="02.transparencia.html#haproxy-transparent"><span class="std std-ref">modo
transparente</span></a>.</p>
</aside>
</aside>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
  <div>
    <h3><a href="../../../index.html">Tabla de contenido</a></h3>
    <ul>
<li><a class="reference internal" href="#">7.5.2.3.1. Multiplexores</a><ul>
<li><a class="reference internal" href="#sslh">7.5.2.3.1.1. SSLH</a></li>
<li><a class="reference internal" href="#haproxy">7.5.2.3.1.2. <strong class="program">haproxy</strong></a></li>
<li><a class="reference internal" href="#wstunnel">7.5.2.3.1.3. wstunnel</a></li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>Tema anterior</h4>
    <p class="topless"><a href="../03.reverse.html"
                          title="capítulo anterior"><span class="section-number">7.5.2.3. </span>Proxies inversos</a></p>
  </div>
  <div>
    <h4>Próximo tema</h4>
    <p class="topless"><a href="02.transparencia.html"
                          title="próximo capítulo"><span class="section-number">7.5.2.3.2. </span>Transparencia</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>Esta página</h3>
    <ul class="this-page-menu">
      <li><a href="../../../_sources/07.serre/05.proxies/03.reverse/01.multi.rst.txt"
            rel="nofollow">Mostrar el código</a></li>
    </ul>
   </div>
<search id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Búsqueda rápida</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Ir a" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="Related">
      <h3>Navegación</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="Índice General"
             >índice</a></li>
        <li class="right" >
          <a href="02.transparencia.html" title="7.5.2.3.2. Transparencia"
             >siguiente</a> |</li>
        <li class="right" >
          <a href="../03.reverse.html" title="7.5.2.3. Proxies inversos"
             >anterior</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">documentación de Linuxnomicón - rolling</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" ><span class="section-number">7. </span>Servicios de red</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="../index.html" ><span class="section-number">7.5. </span>Proxies</a> &#187;</li>
          <li class="nav-item nav-item-3"><a href="../03.reverse.html" ><span class="section-number">7.5.2.3. </span>Proxies inversos</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href=""><span class="section-number">7.5.2.3.1. </span>Multiplexores</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
    &#169; Copyright CC BY 4.0, 2016-2025, José Miguel Sánchez Alés.
      Creado usando <a href="https://www.sphinx-doc.org/">Sphinx</a> 8.1.3.
    </div>
  </body>
</html>