


<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" lang="es">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>7.2.2.2.8. Conexión segura &#8212; documentación de ServidorLinux - 0.1.0</title>
    <link rel="stylesheet" href="../../../../_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/custom.css" />
    
    <script type="text/javascript" id="documentation_options" data-url_root="../../../../" src="../../../../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../../../_static/language_data.js"></script>
    <script type="text/javascript" src="../../../../_static/translations.js"></script>
    <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <link rel="index" title="Índice" href="../../../../genindex.html" />
    <link rel="search" title="Búsqueda" href="../../../../search.html" />
    <link rel="next" title="7.2.2.2.9. Definición mediante mapeo" href="08.map.html" />
    <link rel="prev" title="7.2.2.2.7. Contenido dinámico" href="06.dynamic.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navegación</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../../genindex.html" title="Índice General"
             accesskey="I">índice</a></li>
        <li class="right" >
          <a href="08.map.html" title="7.2.2.2.9. Definición mediante mapeo"
             accesskey="N">siguiente</a> |</li>
        <li class="right" >
          <a href="06.dynamic.html" title="7.2.2.2.7. Contenido dinámico"
             accesskey="P">anterior</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../../index.html">documentación de ServidorLinux - 0.1.0</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../../index.html" >7. Servicios de red</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="../../index.html" >7.2. Web</a> &#187;</li>
          <li class="nav-item nav-item-3"><a href="../index.html" >7.2.2. nginx</a> &#187;</li>
          <li class="nav-item nav-item-4"><a href="index.html" accesskey="U">7.2.2.2. Configuración</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="conexion-segura">
<span id="https"></span><h1>7.2.2.2.8. Conexión segura<a class="headerlink" href="#conexion-segura" title="Enlazar permanentemente con este título">¶</a></h1>
<p>El protocolo <abbr title="HyperText Transfer Protocol">HTTP</abbr> no es seguro para la transmisión de contraseñas y otros
datos confidenciales, puesto que toda la información viaja en claro. La
solución, como en el caso de otros protocolos no seguros, es encapsularlo dentro
del protocolo criptográfico <abbr title="Secure Socket Layer">SSL</abbr>/<abbr title="Transport Layer Security">TLS</abbr><a class="footnote-reference" href="#id9" id="id1">[1]</a>, a fin de que el protocolo viaje
cifrado. Al <abbr title="HyperText Transfer Protocol">HTTP</abbr> encapsulado dentro de <abbr title="Transport Layer Security">TLS</abbr> es a lo que se denomina <abbr title="HTTP seguro">HTTPs</abbr>
Por lo general, el puerto reservado para comunicación <abbr title="HTTP seguro">HTTPs</abbr> es el <em>443/TCP</em>.</p>
<p>Consecuentemente, hacer que un servidor ofrezca páginas seguras se limita a:</p>
<ul class="simple">
<li>Obtener un certificado que permita el cifrado <abbr title="Transport Layer Security">TLS</abbr>.</li>
<li>Desarrollar la configuración que hace que el servidor escuche en el puerto
<strong>443</strong> tal como se hace cuando sirve <abbr title="HyperText Transfer Protocol">HTTP</abbr>, pero indicando que en este caso
debe usar el certificado anterior para cifrar.</li>
</ul>
<div class="admonition note">
<p class="first admonition-title">Nota</p>
<p class="last">Encapsular el tráfico <abbr title="HyperText Transfer Protocol">HTTP</abbr> dentro de <abbr title="Transport Layer Security">TLS</abbr> supone que todos los
paquetes viajan cifrados y que, en consecuencia, todo el contenido <abbr title="HyperText Transfer Protocol">HTTP</abbr>,
incluida la cabecera, está cifrado. Esto inutiliza cualquier cacheo de
contenido o cualquier filtrado web que se base en la <abbr title="Uniform Resource Locator">URL</abbr> o el propio
contenido.<a class="footnote-reference" href="#id10" id="id2">[2]</a></p>
</div>
<div class="section" id="obtencion-del-certificado">
<span id="tls-cert"></span><h2>7.2.2.2.8.1. Obtención del certificado<a class="headerlink" href="#obtencion-del-certificado" title="Enlazar permanentemente con este título">¶</a></h2>
<p>Para la obtención del certificado podemos optar por dos vías: crear un
certificado autofirmado o hacernos con un certificado expedido por una autoridad
acreditadora.</p>
<div class="admonition note">
<p class="first admonition-title">Nota</p>
<p class="last">Estos certificados no son exclusivos para el servicio web. Son
certificados que se usan con el protocolo <abbr title="Transport Layer Security">TLS</abbr> y, en consecuencia, sirven
para cualquier protocolo que se cifre con él. Por ejemplo, también son
válidos para usados con los protocolos <abbr title="Simple Mail Transfer Protocol">SMTP</abbr> o <abbr title="Internet Message Access Protocol">IMAP</abbr>.</p>
</div>
<div class="section" id="autofirmado">
<span id="auto-cert"></span><h3>7.2.2.2.8.1.1. Autofirmado<a class="headerlink" href="#autofirmado" title="Enlazar permanentemente con este título">¶</a></h3>
<p>La ventaja de hacer un certificado así es la inmediatez y gratuidad de su
obtención, pero a costa de no ser confiable para el cliente, que tendrá que
hacer un acto de fe al aceptarlo la primera vez que lo recibe.</p>
<div class="admonition warning">
<p class="first admonition-title">Advertencia</p>
<p class="last">Con toda lógica, los navegadores cada vez son más estrictos en la
admisión de estos certificados autofirmados y, además, hay proxies web que
los rechazan e impiden la conexión de los clientes a los que protegen. Por
tanto, lo más recomendable es pasarse al siguiente epigrafe.</p>
</div>
<span class="target" id="make-ssl-cert"></span><p id="index-0">Para la creación de certificados, debe usarse <strong class="command">openssl</strong><a class="footnote-reference" href="#id11" id="id3">[3]</a>. El método
más sencillo, no obstante, es hacerlo mediante <strong class="command">make-ssl-cert</strong>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> apt-get install ssl-cert
</pre></div>
</div>
<p>La postinstalación genera directamente la clave private en
<code class="file docutils literal notranslate"><span class="pre">/etc/ssl/private/ssl-cert-snakeoil.key</span></code> y la pública en
<code class="file docutils literal notranslate"><span class="pre">/etc/ssl/certs/ssl-cert-snakeoil.pem</span></code> y crea un certificado para el
nombre completo de la máquina<a class="footnote-reference" href="#id12" id="id4">[4]</a>. Si nuestra intención es que el certificado
sirva para distintos nombres (por ejemplo, porque tenemos definidos varios
dominios virtuales), entonces es necesario volver a generar los certificados:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> make-ssl-cert /usr/share/ssl-cert/ssleay.cnf keycert.pem
</pre></div>
</div>
<p>Así, mediante una interfaz amigable hecha en <a class="reference internal" href="../../../../03.scripts/06.misc/05.whiptail.html#whiptail"><span class="std std-ref">whiptail</span></a>, podemos
generar otro distinto. La manera más sencilla de obtener un certificado válido
para cualquier nombre del domino es contestar a la primera pregunta con
<kbd class="kbd docutils literal notranslate">*.example.net</kbd>. La segunda podemos dejarla en blanco. La orden genera un
único fichero con las claves pública y privada. Para separarlas y dejarlas en su
ubicación predeterminada:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> sed <span class="s1">&#39;1,/-END PRIVATE KEY-/d&#39;</span> keycert.pem &gt; /etc/ssl/certs/ssl-cert-snakeoil.pem
<span class="gp">#</span> sed <span class="s1">&#39;/-END PRIVATE KEY-/q&#39;</span> keycert.pem &gt; /etc/ssl/private/ssl-cert-snakeoil.key
</pre></div>
</div>
<p>¡Y listo! Ya tenemos un certificado no fiable para crear conexiones <abbr title="Secure Socket Layer">SSL</abbr>.</p>
</div>
<div class="section" id="acreditado">
<span id="certbot"></span><h3>7.2.2.2.8.1.2. Acreditado<a class="headerlink" href="#acreditado" title="Enlazar permanentemente con este título">¶</a></h3>
<p>El principal problema de estos certificados es que siempre ha habido que pagar
por ellos. Sin embargo, desde mediados de 2016, una autoridad de certificación,
<cite>Let’s Encrypt</cite>, facilita la obtención gratuita de certificados de un modo
bastante cómodo. Tienen la desventaja de que caducan a los tres meses, pero
proporcionan un mecanismo automático de renovación bastante cómodo.</p>
<p>Para la creación y renovación de estos certificados acreditados, necesitamos
instalar el paquete <em>certbot</em>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> apt-get install certbot
</pre></div>
</div>
<p>Antes, no obstante, de usar el programa es preciso entender cómo <em>Let’s Encrypt</em>
se cerciora de que somos quien decimos ser. Como la aplicación corre en el
servidor que usará el certificado, se supone que al conectar vía web a la
máquina con cuyo nombre pedimos el certificado, se accede efectivamente a ella.
Como esto es así, <strong class="command">certbot</strong> deja localmente en el directorio accesible
por el servidor web unos ficheros y, desde sus servidores intenta acceder a
ellos vía web: si lo consigue es que somos los propietarios del nombre y, por
tanto, ha comprobado nuestra identidad y puede emitirnos el certificado.</p>
<p>Como los certificados se usaran luego con distinto <em>software</em>,
<strong class="command">certbot</strong> tiene distintos <em>plugins</em> para, además de crear o renover el
certificado, proceder a su instalación en ellos. Nosotros, no obstante, sólo
repararemos en dos:</p>
<ul class="simple">
<li><strong>standalone</strong>, que debe usarse si prevemos que no tendremos ocupado nunca el
puerto <strong>80</strong>. Con este <em>plugin</em>, el propio <strong class="command">certboot</strong> levanta
temporalmente un servidor web en el proceso de creación o renovación. No debe
usarse si montamos un servidor web, porque en ese caso, la renovación fallará
levantando el servidor web temporal al encontrar ocupado el puerto.</li>
<li><strong>webroot</strong>, que implica tener un servidor web instalado e indicarle a
<strong class="command">certboot</strong> cuál es el directorio raíz del mismo.</li>
</ul>
<p>Nosotros usaremos este último, suponiendo que ya tenemos listo el servidor web y
que nuestro directorio raíz es <code class="file docutils literal notranslate"><span class="pre">/srv/www</span></code>, Tras ello, podemos lanzar la
generación del certificado así:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> certbot certonly --webroot -w /srv/www -d www.example.net <span class="se">\</span>
   --non-interactive --agree-tos --email licencias@iesmiravent.es <span class="se">\</span>
   --post-hook <span class="s2">&quot;/etc/letsencrypt/posthook.sh&quot;</span>
</pre></div>
</div>
<p>Como resultado de la orden tendremos dentro de
<code class="file docutils literal notranslate"><span class="pre">/etc/letsencrypt/live/www.example.net</span></code> las claves generadas y, además,
justamente tras la generación, se habrá ejecutado el <em>script</em> que pasemos con la
opción <code class="docutils literal notranslate"><span class="pre">--post-hook</span></code><a class="footnote-reference" href="#id13" id="id5">[5]</a>. El <a class="reference download internal" download="" href="../../../../_downloads/d35614dfdda1cbcc8de5d4fd26d80ccf/posthook.sh"><code class="xref download docutils literal notranslate"><span class="pre">mío</span></code></a> copia
juntas las claves públicas y privada (<code class="file docutils literal notranslate"><span class="pre">fullchain.pem</span></code> y
<code class="file docutils literal notranslate"><span class="pre">privkey.pem</span></code>) en el lugar adecuado y reinicia <strong class="command">haproxy</strong>, que es
lo que necesito. Lo que realmente haya que hacer para que la nueva clave sea
efectiva dependerá de cómo se tenga configurado el servidor. La gracia de
incluir el <em>script</em> es que <em>certboot</em> viene con un <em>timer</em> de <strong class="program">systemd</strong>
para intentar diariamente la renovación del <em>script</em> y que este proceso de
renovación también lanza el <em>script</em>. Por tanto, podremos olvidarnos por
completo de estar al tanto de la actualización.</p>
<div class="admonition note">
<p class="first admonition-title">Nota</p>
<p>Es posible también generar un certificado asociados a varios nombres
repitiendo las opciones <code class="docutils literal notranslate"><span class="pre">-w</span></code> y <code class="docutils literal notranslate"><span class="pre">-d</span></code>, de modo que las opciones <code class="docutils literal notranslate"><span class="pre">-d</span></code>
harán referencia al <code class="docutils literal notranslate"><span class="pre">-w</span></code> que las precede. Por ejemplo:</p>
<div class="last highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> certbot certonly --webroot -w /srv/www/main -d example.net -d www.example.net <span class="se">\</span>
   -w /srv/www/blog -d blog.example.net --non-interactive --agree-tos <span class="se">\</span>
   --email licencias@iesmiravent.es --post-hook <span class="s2">&quot;/etc/letsencrypt/posthook.sh&quot;</span>
</pre></div>
</div>
</div>
<p>Es común que en algún momento añadamos un nuevo sitio al servidor y necesitemos
que este sitio también use cifrado. Podemos ampliar el uso del mismo
certificado al nuevo sitio usando la opción <code class="docutils literal notranslate"><span class="pre">--expand</span></code>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> certbot certonly --webroot --expand -w /srv/www -d www.example.net <span class="se">\</span>
   -w /srv/www/moodle -d moodle.example.net <span class="se">\</span>
   --non-interactive --agree-tos --email licencias@iesmiravent.es <span class="se">\</span>
   --post-hook <span class="s2">&quot;/etc/letsencrypt/posthook.sh&quot;</span>
</pre></div>
</div>
<p>Hay, eso sí, que enumerar todos los dominios a los que ya estaba asociado el
servidor y añadir los nuevos.</p>
</div>
</div>
<div class="section" id="configuracion">
<span id="nginx-https"></span><h2>7.2.2.2.8.2. Configuración<a class="headerlink" href="#configuracion" title="Enlazar permanentemente con este título">¶</a></h2>
<p>Para configurar un dominio virtual servidor por <abbr title="HyperText Transfer Protocol">HTTP</abbr>s es necesario crear el
fichero <code class="file docutils literal notranslate"><span class="pre">/etc/nginx/conf.d/ssl.conf</span></code><a class="footnote-reference" href="#id14" id="id6">[6]</a> que dependiendo de cómo hallamos
generado el certificado variará:</p>
<ul class="simple">
<li>Para el certificado autofirmado, <a class="reference download internal" download="" href="../../../../_downloads/1ec2f25228054e31dee6daac579628b6/ssl.auto.conf"><code class="xref download docutils literal notranslate"><span class="pre">éste</span></code></a>.</li>
<li>Para el certificado con <em>Let’s Encrypt</em> <a class="reference download internal" download="" href="../../../../_downloads/13be357bc660bedf832bcaec8fbc885f/ssl.certbot.conf"><code class="xref download docutils literal notranslate"><span class="pre">este</span> <span class="pre">otro</span></code></a>.</li>
</ul>
<p>Luego, tomando como referencia la configuración más básica, basta con incluir
los siguientes cambios:</p>
<div class="highlight-nginx notranslate"><div class="highlight"><pre><span></span><span class="k">server</span> <span class="p">{</span>
<span class="hll">   <span class="kn">listen</span>   <span class="mi">443</span> <span class="s">ssl</span><span class="p">;</span>
</span>
   <span class="kn">server_name</span> <span class="s">_</span><span class="p">;</span>

   <span class="kn">root</span> <span class="s">/srv/www</span><span class="p">;</span>
   <span class="kn">try_files</span> <span class="nv">$uri</span> <span class="nv">$uri/</span> <span class="p">=</span><span class="mi">404</span><span class="p">;</span>

<span class="hll">   <span class="kn">include</span> <span class="s">snippets/snakeoil.conf</span><span class="p">;</span>
</span><span class="p">}</span>
</pre></div>
</div>
<p>O sea, incluimos un fichero <code class="file docutils literal notranslate"><span class="pre">/etc/nginx/snippets/snakeoil.conf</span></code> que
indica cuáles son las claves de cifrado para el sitio y que deben ser las que
genera <a class="reference internal" href="#make-ssl-cert"><span class="std std-ref">make-ssl-cert</span></a>. El fichero ya está incluido en el
paquete de <em>debian</em> y, como no podía ser de otra firma, contiene estas dos
directivas:</p>
<div class="highlight-nginx notranslate"><div class="highlight"><pre><span></span><span class="k">ssl_certificate</span> <span class="s">/etc/ssl/certs/ssl-cert-snakeoil.pem</span><span class="p">;</span>
<span class="k">ssl_certificate_key</span> <span class="s">/etc/ssl/private/ssl-cert-snakeoil.key</span><span class="p">;</span>
</pre></div>
</div>
<p>Sin embargo, el propio fichero avisa que no deberían usarse en un servidor real.
Si hacemos caso y utilizamos las certificadas por <em>Let’s Encrypt</em>, entonces
deberemos indicar las claves que generamos con él de un modo análogo a cómo
hicimos antes:</p>
<div class="highlight-nginx notranslate"><div class="highlight"><pre><span></span><span class="k">server</span> <span class="p">{</span>
<span class="hll">   <span class="kn">listen</span>   <span class="mi">443</span> <span class="s">ssl</span><span class="p">;</span>
</span>
   <span class="kn">server_name</span> <span class="s">_</span><span class="p">;</span>

   <span class="kn">root</span> <span class="s">/srv/www</span><span class="p">;</span>
   <span class="kn">try_files</span> <span class="nv">$uri</span> <span class="nv">$uri/</span> <span class="p">=</span><span class="mi">404</span><span class="p">;</span>

<span class="hll">   <span class="kn">include</span> <span class="s">snippets/letsencrypt.conf</span><span class="p">;</span>
</span><span class="p">}</span>
</pre></div>
</div>
<p>y el fichero <code class="file docutils literal notranslate"><span class="pre">/etc/nginx/snippets/letsencrypt.conf</span></code> queda:</p>
<div class="highlight-nginx notranslate"><div class="highlight"><pre><span></span><span class="k">ssl_certificate</span> <span class="s">/etc/letsencrypt/live/www.example.net/fullchain.pem</span><span class="p">;</span>
<span class="k">ssl_certificate_key</span> <span class="s">/etc/letsencrypt/live/www.example.net/privkey.pem</span><span class="p">;</span>
<span class="k">ssl_trusted_certificate</span> <span class="s">/etc/letsencrypt/live/www.example.net/fullchain.pem</span><span class="p">;</span>
</pre></div>
</div>
<p id="nginx-https-http">Las configuraciones anteriores sólo ofrecerían servicio a través del puerto
<strong>443</strong>. Si queremos ofrecerlo a través del <strong>80</strong> también, podemos hacer lo
siguiente:</p>
<div class="highlight-nginx notranslate"><div class="highlight"><pre><span></span><span class="k">server</span> <span class="p">{</span>
   <span class="kn">listen</span>   <span class="mi">80</span><span class="p">;</span>
   <span class="kn">listen</span>   <span class="mi">443</span> <span class="s">ssl</span><span class="p">;</span>

   <span class="kn">server_name</span> <span class="s">_</span><span class="p">;</span>

   <span class="kn">root</span> <span class="s">/srv/www</span><span class="p">;</span>
   <span class="kn">try_files</span> <span class="nv">$uri</span> <span class="nv">$uri/</span> <span class="p">=</span><span class="mi">404</span><span class="p">;</span>

   <span class="kn">include</span> <span class="s">snippets/snakeoil.conf</span><span class="p">;</span>

   <span class="kn">if</span> <span class="s">(</span><span class="nv">$https</span> <span class="s">!=</span> <span class="s">&quot;on&quot;)</span> <span class="p">{</span>
      <span class="kn">return</span> <span class="mi">301</span> <span class="s">https://</span><span class="nv">$host$uri$is_args$args</span><span class="p">;</span>
   <span class="p">}</span>

   <span class="c1"># Cabecera HSTS (fuerza a que el certificado sea válido)</span>
   <span class="kn">add_header</span> <span class="s">Strict-Transport-Security</span> <span class="s">&quot;max-age=31536000</span><span class="p">;</span> <span class="kn">includeSubDomains&quot;</span> <span class="s">always</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="admonition warning">
<p class="first admonition-title">Advertencia</p>
<p class="last">El <code class="docutils literal notranslate"><span class="pre">if</span></code> provoca que, si el tráfico es no seguro, se repita la
petición por el puerto seguro. Si queremos permitir ambos podemos eliminar
este bloque. Añadimos, además, la cabecera <abbr title="HTTP Strict Transport Security">HSTS</abbr> para informar al cliente de
que use <abbr title="HyperText Transfer Protocol">HTTP</abbr>sy de que no acepte bajo ningún concepto un certificado no
fiable (p.e. uno autofirmado)<a class="footnote-reference" href="#id15" id="id7">[7]</a>. Para más información, consulte <a class="reference internal" href="../../../../08.redes/99.ataques/02.tecnicas/04.mitm.html#sslstrip"><span class="std std-ref">el
epígrafe dedicado al ataque SSLstrip</span></a>.</p>
</div>
<div class="admonition warning">
<p class="first admonition-title">Advertencia</p>
<p>Cuando el servidor define varios dominios virtuales y dos o más de
ellos usan tráfico seguro debe tenerse en cuenta que, antes de usar un
certificado para descifrar la comunicación, el servidor web es incapaz de
saber cuál es el nombre de <em>host</em> que usó el cliente para conectarse al
servidor. Por tanto, la directiva <code class="docutils literal notranslate"><span class="pre">server_name</span></code> es absolutamente inútil
para tomar decisiones sobre el cifrado. Por este motivo, <strong class="program">nginx</strong>
siempre usa la configuración de <abbr title="Secure Socket Layer">SSL</abbr> que se encuentra en el servidor
predeterminado e ignora cualquier otra. Por ello debemos usar siempre un
mismo certificado virtual para todos los dominios virtuales<a class="footnote-reference" href="#id16" id="id8">[8]</a> y hacer una
configuración de este estilo:</p>
<div class="last highlight-nginx notranslate"><div class="highlight"><pre><span></span><span class="k">server</span> <span class="p">{</span>
   <span class="kn">listen</span>   <span class="mi">80</span>       <span class="s">default_server</span><span class="p">;</span>
   <span class="kn">listen</span>   <span class="mi">443</span> <span class="s">ssl</span>  <span class="s">default_server</span><span class="p">;</span>

   <span class="kn">server</span> <span class="s">name</span> <span class="s">_</span><span class="p">;</span>

   <span class="kn">include</span> <span class="s">snippets/letsencrypt.conf</span><span class="p">;</span>

   <span class="c1"># Resto de configuración.</span>
<span class="p">}</span>

<span class="k">server</span> <span class="p">{</span>
   <span class="kn">listen</span> <span class="mi">80</span><span class="p">;</span>
   <span class="kn">listen</span> <span class="mi">443</span><span class="p">;</span>  <span class="c1"># Nótese que no hace falta ni usar ssl.</span>

   <span class="kn">server_name</span>  <span class="s">moodle.example.net</span><span class="p">;</span>

   <span class="c1"># Configuración para moodle</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="puerto-compartido">
<span id="nginx-haproxy"></span><h2>7.2.2.2.8.3. Puerto compartido<a class="headerlink" href="#puerto-compartido" title="Enlazar permanentemente con este título">¶</a></h2>
<p>En ocasiones necesitamos acceso remoto al servidor desde redes restringidas. Lo
habitual de estas redes es que, al menos, permitan el acceso al puerto <strong>443</strong>,
ya que de lo contrario sus clientes no podrían navegar por la mayoría de los
sitios web que, cada vez más, usan el protocolo seguro. Esto nos obliga a hacer
que el servidor <em>web</em> «comparta» con servicios de acceso remoto (típicamente
<abbr title="Security SHell">SSH</abbr> y <abbr title="Virtual Private Network">VPN</abbr>) tal puerto. «Compartir» en este caso es una forma de hablar; en
realidad, la técnica consiste en que el servidor web deje de ocupar ese puerto
y, en su sustitución, se ponga otro servicio capaz de identificar la
comunicación que recibe (<abbr title="HyperText Transfer Protocol">HTTP</abbr>, <abbr title="Security SHell">SSH</abbr>, <abbr title="Virtual Private Network">VPN</abbr>) y redirigirla al servicio
correspondiente.</p>
<div class="admonition note">
<p class="first admonition-title">Nota</p>
<p class="last">Bajo este epígrafe se trata exclusivamente cómo afecta esto a la
configuración del servicio <em>web</em>, y no cómo se configura el servicio
segregador. Esto último se discute en el <a class="reference internal" href="../../../../04.servidor/10.ssh/04.adicional.html#redes-restr"><span class="std std-ref">epígrafe dedicado a redes
restringidas</span></a>.</p>
</div>
<p>Hay dos ténicas para lograr esto:</p>
<ul class="simple">
<li>Colocar un <em>multiplexor</em> como <a class="reference internal" href="../../../../04.servidor/10.ssh/04.adicional.html#sslh"><span class="std std-ref">sslh</span></a> que discrimina el tráfico,
pero no altera en absoluto los paquetes.</li>
<li>Colocar un verdadero <em>proxy</em>, como <a class="reference internal" href="../../../../04.servidor/10.ssh/04.adicional.html#haproxy"><span class="std std-ref">haproxy</span></a>, que, además de
discriminar, manipula el tráfico lo cual supone, al menos, que el servidor
<em>web</em> vea como <abbr title="Internet Protocol">IP</abbr> de origen la del servicio segregador (típicamente la
<em>127.0.0.1</em> si <strong class="program">haproxy</strong> y <strong class="program">nginx</strong> están en la misma
máquina)</li>
</ul>
<p>En el primer caso, al no haberse obrado ninguna manipulación, el cambio se
limita a dejar libre el puerto <strong>443</strong> de la interfaz física por lo que bastará
con hacer:</p>
<div class="highlight-nginx notranslate"><div class="highlight"><pre><span></span><span class="k">listen</span> <span class="n">localhost</span><span class="p">:</span><span class="mi">443</span> <span class="s">ssl</span><span class="p">;</span>
</pre></div>
</div>
<p>En cambio, en el segudo caso los cambios son más profundos e incluyen
que la tarea de cifrado y descrifado se haga en <strong class="program">haproxy</strong>. Esto provoca
que:</p>
<ol class="arabic simple">
<li>Como lo que llega al servidor es siempre tráfico <abbr title="HyperText Transfer Protocol">HTTP</abbr> en claro, deja de tener
sentido que el servidor escuche en otro puerto distinto al <strong>80</strong>.</li>
<li>Es necesario, no obstante, que el servidor sea capaz de saber si la conexión
se hizo directamente al puerto <strong>80</strong> (y, por tanto, el tráfico siempre fue no
seguro) o si se hizo a través de <strong class="program">haproxy</strong> y originariamente era
segura. Para ello <strong class="program">haproxy</strong> puede añadir la cabecera
<em>X-Forwarded-Proto</em>.</li>
<li>También es necesario que el servidor web sea capaz de reconocer cuál es el
cliente original de la petición lo que obligará a añadir o modificar la
cabecera <em>X-Forwarded-For</em>.</li>
<li>Debe configurarse el servidor de modo que las dos circunstancias anteriores
no obliguen a las aplicaciones web a tener en cuenta si hubo o no <em>proxy</em>, esto
es a revisar esas dos cabeceras. Por ejemplo, las aplicaciones escritas en
<abbr title="PHP Hypertext Preprocessor">PHP</abbr> consultan la dirección remota a través de <code class="docutils literal notranslate"><span class="pre">$_SERVER[&quot;ADDRESS&quot;]</span></code> y si
está activo el protocolo seguro a través de <code class="docutils literal notranslate"><span class="pre">$_SERVER[&quot;HTTPS&quot;]</span></code>. Por tanto,
configurar bien el servidor para que ejecute aplicaciones <abbr title="PHP Hypertext Preprocessor">PHP</abbr> implica que
ambos parámetros que pasa el servidor <em>web</em> al intérprete tengan los valores
adecuados.</li>
</ol>
<p>La solución al problema de la dirección <a class="reference internal" href="03.acceso.html#nginx-clientip"><span class="std std-ref">ya se trató al discutir sobre el
control de accesos</span></a>. Para darle solución al segundo problema
podemos definir la variable <em>$_https</em>:</p>
<div class="highlight-nginx notranslate"><div class="highlight"><pre><span></span><span class="c1"># /etc/nginx/conf.d/https.conf</span>
<span class="k">map</span> <span class="nv">$http_x_forwarded_proto</span> <span class="nv">$_https</span> <span class="p">{</span>
   <span class="kn">default</span>  <span class="nv">$https</span><span class="p">;</span>
   <span class="kn">https</span>    <span class="no">on</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>que permite conocer la naturaleza original del tráfico en sustitución de la
variable <em>$https</em> que usamos cuando no hay proxy. De este modo, podemos hacer la
siguiente configuración:</p>
<div class="highlight-nginx notranslate"><div class="highlight"><pre><span></span><span class="k">server</span> <span class="p">{</span>
   <span class="kn">listen</span>   <span class="mi">80</span><span class="p">;</span>

   <span class="kn">server_name</span> <span class="s">_</span><span class="p">;</span>

   <span class="kn">root</span> <span class="s">/srv/www</span><span class="p">;</span>
   <span class="kn">try_files</span> <span class="nv">$uri</span> <span class="nv">$uri/</span> <span class="p">=</span><span class="mi">404</span><span class="p">;</span>

   <span class="c1"># Necesario si queremos redirigir el tráfico seguro a no seguro</span>
   <span class="kn">if</span> <span class="s">(</span><span class="nv">$_https</span> <span class="s">!=</span> <span class="s">&quot;on&quot;)</span> <span class="p">{</span>
      <span class="kn">return</span> <span class="mi">301</span> <span class="s">https://</span><span class="nv">$host$uri$is_args$args</span><span class="p">;</span>
   <span class="p">}</span>

   <span class="c1"># Cabecera HSTS (fuerza que el certificado sea válido)</span>
   <span class="kn">add_header</span> <span class="s">Strict-Transport-Security</span> <span class="s">&quot;max-age=31536000</span><span class="p">;</span> <span class="kn">includeSubDomains&quot;</span> <span class="s">always</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Es decir, una configuración exactamente igual que la <em>no</em> segura, puesto que al
servidor llega tráfico ya no seguro. El último bloque <code class="docutils literal notranslate"><span class="pre">if</span></code> puede interesarnos
si queremos que el tráfico originariamente no seguro pase a seguro.</p>
<p>Además, si el sitio es dinámico y usa <abbr title="PHP Hypertext Preprocessor">PHP</abbr>, entonces deberemos hacérselo saber
al cliente añadiendo otro bloque a la configuración:</p>
<div class="highlight-nginx notranslate"><div class="highlight"><pre><span></span><span class="k">location</span> <span class="p">~</span> <span class="sr">\.php$</span> <span class="p">{</span>
   <span class="kn">include</span> <span class="s">snippets/fastcgi-php.conf</span><span class="p">;</span>
<span class="hll">   <span class="kn">fastcgi_param</span>  <span class="s">HTTPS</span>  <span class="nv">$_https</span> <span class="s">if_not_empty</span><span class="p">;</span>
</span>   <span class="kn">fastcgi_pass</span> <span class="s">php</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="rubric">Notas al pie</p>
<table class="docutils footnote" frame="void" id="id9" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td><abbr title="Transport Layer Security">TLS</abbr> es simplemente la evolución de la versión 3 de <abbr title="Secure Socket Layer">SSL</abbr>. A menudo
suele decirse <abbr title="Secure Socket Layer">SSL</abbr> para referise también a <abbr title="Transport Layer Security">TLS</abbr>.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id10" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[2]</a></td><td>En principio, establecer un filtrado de sitios web para clientes sólo
puede hacerse manipulando la resolución <abbr title="Domain Name Server">DNS</abbr>, que sí que no está cifrada.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id11" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3">[3]</a></td><td><p class="first">Por ejemplo, para generar un certificado cuya validez sea de diez
años:</p>
<div class="last highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> openssl req -x509 -nodes -days <span class="m">3650</span> -newkey rsa:2048 -keyout /etc/ssl/private/ssl-cert-snakeoil.key <span class="se">\</span>
   -out /etc/ssl/certs/ssl-cert-snakeoil.pem
</pre></div>
</div>
</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id12" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id4">[4]</a></td><td><p class="first">o sea, el que se obtiene así:</p>
<div class="last highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> hostname -f
</pre></div>
</div>
</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id13" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id5">[5]</a></td><td>También hay una opción <code class="docutils literal notranslate"><span class="pre">-pre-hook</span></code> para ejecutar antes.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id14" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id6">[6]</a></td><td><p class="first">Las únicas directivas relativas al cifrado que se encuentran en
<code class="file docutils literal notranslate"><span class="pre">nginx.conf</span></code> son estas:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">ssl_protocols TLSv1 TLSv1.1 TLSv1.2; # Dropping SSLv3, ref: POODLE</span>
<span class="go">ssl_prefer_server_ciphers on</span>
</pre></div>
</div>
<p class="last">de ahí que no se hayan incluido en nuestra propia configuración.</p>
</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id15" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id7">[7]</a></td><td>Para más información sobre esta cabecera, consulte <a class="reference internal" href="../../../../08.redes/99.ataques/02.tecnicas/04.mitm.html#sslstrip"><span class="std std-ref">el ataque
SSLstrip</span></a>.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id16" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id8">[8]</a></td><td>Lo cual no es ningún problema, puesto que un certificado digital se puede
asociar a varios nombres.</td></tr>
</tbody>
</table>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../../../../index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">7.2.2.2.8. Conexión segura</a><ul>
<li><a class="reference internal" href="#obtencion-del-certificado">7.2.2.2.8.1. Obtención del certificado</a><ul>
<li><a class="reference internal" href="#autofirmado">7.2.2.2.8.1.1. Autofirmado</a></li>
<li><a class="reference internal" href="#acreditado">7.2.2.2.8.1.2. Acreditado</a></li>
</ul>
</li>
<li><a class="reference internal" href="#configuracion">7.2.2.2.8.2. Configuración</a></li>
<li><a class="reference internal" href="#puerto-compartido">7.2.2.2.8.3. Puerto compartido</a></li>
</ul>
</li>
</ul>

  <h4>Tema anterior</h4>
  <p class="topless"><a href="06.dynamic.html"
                        title="capítulo anterior">7.2.2.2.7. Contenido dinámico</a></p>
  <h4>Próximo tema</h4>
  <p class="topless"><a href="08.map.html"
                        title="próximo capítulo">7.2.2.2.9. Definición mediante mapeo</a></p>
  <div role="note" aria-label="source link">
    <h3>Esta página</h3>
    <ul class="this-page-menu">
      <li><a href="../../../../_sources/07.serre/02.web/02.nginx/02.avanz/07.https.rst.txt"
            rel="nofollow">Mostrar el código</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Búsqueda rápida</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Ir a" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navegación</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../../genindex.html" title="Índice General"
             >índice</a></li>
        <li class="right" >
          <a href="08.map.html" title="7.2.2.2.9. Definición mediante mapeo"
             >siguiente</a> |</li>
        <li class="right" >
          <a href="06.dynamic.html" title="7.2.2.2.7. Contenido dinámico"
             >anterior</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../../index.html">documentación de ServidorLinux - 0.1.0</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../../index.html" >7. Servicios de red</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="../../index.html" >7.2. Web</a> &#187;</li>
          <li class="nav-item nav-item-3"><a href="../index.html" >7.2.2. nginx</a> &#187;</li>
          <li class="nav-item nav-item-4"><a href="index.html" >7.2.2.2. Configuración</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Derechos de autor 2016, José Miguel Sánchez Alés.
      Creado con <a href="http://sphinx-doc.org/">Sphinx</a> 1.8.5.
    </div>
  </body>
</html>