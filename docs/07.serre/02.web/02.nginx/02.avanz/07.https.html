


<!DOCTYPE html>

<html lang="es">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>7.2.2.2.8. Conexión segura &#8212; documentación de Linuxnomicón - rolling</title>
    <link rel="stylesheet" type="text/css" href="../../../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/classic.css" />
    <link rel="stylesheet" href="../../../../_static/custom.css" type="text/css" />
    
    <script data-url_root="../../../../" id="documentation_options" src="../../../../_static/documentation_options.js"></script>
    <script src="../../../../_static/jquery.js"></script>
    <script src="../../../../_static/underscore.js"></script>
    <script src="../../../../_static/doctools.js"></script>
    <script src="../../../../_static/translations.js"></script>
    
    <link rel="index" title="Índice" href="../../../../genindex.html" />
    <link rel="search" title="Búsqueda" href="../../../../search.html" />
    <link rel="next" title="7.2.2.2.9. Multiplexación" href="08.multiplex.html" />
    <link rel="prev" title="7.2.2.2.7. Contenido dinámico" href="06.dynamic.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navegación</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../../genindex.html" title="Índice General"
             accesskey="I">índice</a></li>
        <li class="right" >
          <a href="08.multiplex.html" title="7.2.2.2.9. Multiplexación"
             accesskey="N">siguiente</a> |</li>
        <li class="right" >
          <a href="06.dynamic.html" title="7.2.2.2.7. Contenido dinámico"
             accesskey="P">anterior</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../../index.html">documentación de Linuxnomicón - rolling</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../../index.html" ><span class="section-number">7. </span>Servicios de red</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="../../index.html" ><span class="section-number">7.2. </span>Web</a> &#187;</li>
          <li class="nav-item nav-item-3"><a href="../index.html" ><span class="section-number">7.2.2. </span>nginx</a> &#187;</li>
          <li class="nav-item nav-item-4"><a href="index.html" accesskey="U"><span class="section-number">7.2.2.2. </span>Configuración</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href=""><span class="section-number">7.2.2.2.8. </span>Conexión segura</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="conexion-segura">
<span id="https"></span><h1><span class="section-number">7.2.2.2.8. </span>Conexión segura<a class="headerlink" href="#conexion-segura" title="Enlazar permanentemente con este título">¶</a></h1>
<p>El protocolo <abbr title="HyperText Transfer Protocol">HTTP</abbr> no es seguro para la transmisión de contraseñas y otros
datos confidenciales, puesto que toda la información viaja en claro. La
solución, como en el caso de otros protocolos no seguros, es encapsularlo dentro
del protocolo criptográfico <abbr title="Secure Socket Layer">SSL</abbr>/<abbr title="Transport Layer Security">TLS</abbr><a class="footnote-reference brackets" href="#id16" id="id1">1</a>, a fin de que el protocolo viaje
cifrado. Al <abbr title="HyperText Transfer Protocol">HTTP</abbr> encapsulado dentro de <abbr title="Transport Layer Security">TLS</abbr> es a lo que se denomina <abbr title="HTTP seguro">HTTPs</abbr>
Por lo general, el puerto reservado para comunicación <abbr title="HTTP seguro">HTTPs</abbr> es el <em>443/TCP</em>.</p>
<p>Consecuentemente, hacer que un servidor ofrezca páginas seguras se limita a:</p>
<ul class="simple">
<li><p>Obtener un certificado que permita el cifrado <abbr title="Transport Layer Security">TLS</abbr>.</p></li>
<li><p>Desarrollar la configuración que hace que el servidor escuche en el puerto
<strong>443</strong> tal como se hace cuando sirve <abbr title="HyperText Transfer Protocol">HTTP</abbr>, pero indicando que en este caso
debe usar el certificado anterior para cifrar.</p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>Encapsular el tráfico <abbr title="HyperText Transfer Protocol">HTTP</abbr> dentro de <abbr title="Transport Layer Security">TLS</abbr> supone que todos los
paquetes viajan cifrados y que, en consecuencia, todo el contenido <abbr title="HyperText Transfer Protocol">HTTP</abbr>,
incluida la cabecera, está cifrado. Esto inutiliza cualquier cacheo de
contenido o cualquier filtrado web que se base en la <abbr title="Uniform Resource Locator">URL</abbr> o el propio
contenido.<a class="footnote-reference brackets" href="#id17" id="id2">2</a></p>
</div>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>Estos certificados no son exclusivos para el servicio web. Son
certificados que se usan con el protocolo <abbr title="Transport Layer Security">TLS</abbr> y, en consecuencia, sirven
para cualquier protocolo que se cifre con él. Por ejemplo, también son
válidos para usados con los protocolos <abbr title="Simple Mail Transfer Protocol">SMTP</abbr> o <abbr title="Internet Message Access Protocol">IMAP</abbr>.</p>
</div>
<section id="certificados-autofirmados">
<span id="auto-cert"></span><span id="tls-cert"></span><h2><span class="section-number">7.2.2.2.8.1. </span>Certificados autofirmados<a class="headerlink" href="#certificados-autofirmados" title="Enlazar permanentemente con este título">¶</a></h2>
<div class="admonition warning">
<p class="admonition-title">Advertencia</p>
<p>Jamás haga esto en un servidor real en producción: un certificado
autofirmado no ofrece garantías al cliente sobre la identidad del servidor y,
por ello, todos los navegadores alertan de la invalidez del certificado y
sugieren al navegante que no accede a la página. En fase de pruebas, en
cambio, sí nos puede ser muy útil utilizar certificados de estas
características y por ello incluimos este epígrafe en la guía.</p>
</div>
<span class="target" id="make-ssl-cert"></span><p id="index-0">Crear un certificado autofirmado puede hacerse, simplemente, con openssle<a class="footnote-reference brackets" href="#id18" id="id3">3</a>,
pero es aún más sencillo usar <strong class="command">make-ssl-cert</strong>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> apt install ssl-cert
</pre></div>
</div>
<p>La postinstalación genera directamente la clave private en
<code class="file docutils literal notranslate"><span class="pre">/etc/ssl/private/ssl-cert-snakeoil.key</span></code> y la pública en
<code class="file docutils literal notranslate"><span class="pre">/etc/ssl/certs/ssl-cert-snakeoil.pem</span></code> y crea un certificado para el
nombre completo de la máquina<a class="footnote-reference brackets" href="#id19" id="id4">4</a>. Si nuestra intención es que el certificado
sirva para distintos nombres (por ejemplo, porque tenemos definidos varios
dominios virtuales), entonces es necesario volver a generar los certificados:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> make-ssl-cert /usr/share/ssl-cert/ssleay.cnf keycert.pem
</pre></div>
</div>
<p>Así, mediante una interfaz amigable hecha en <a class="reference internal" href="../../../../03.scripts/06.misc/05.whiptail.html#whiptail"><span class="std std-ref">whiptail</span></a>, podemos
generar otro distinto. La manera más sencilla de obtener un certificado válido
para cualquier nombre del domino es contestar a la primera pregunta con
<kbd class="kbd docutils literal notranslate">*.example.net</kbd>. La segunda podemos dejarla en blanco. La orden genera un
único fichero con las claves pública y privada. Para separarlas y dejarlas en su
ubicación predeterminada:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> sed <span class="s1">&#39;1,/-END PRIVATE KEY-/d&#39;</span> keycert.pem &gt; /etc/ssl/certs/ssl-cert-snakeoil.pem
<span class="gp">#</span> sed <span class="s1">&#39;/-END PRIVATE KEY-/q&#39;</span> keycert.pem &gt; /etc/ssl/private/ssl-cert-snakeoil.key
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>Si no queremos usar <em>software</em> adicional, podemos crear un certificado
autofirmado directamente con <a class="reference internal" href="../../../../98.apendice/01.cryto/02.algo.html#openssl"><span class="std std-ref">openssl</span></a> con la siguiente orden:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> openssl req -newkey rsa:2048 -nodes -x509 -days <span class="m">365</span> -subj <span class="s1">&#39;/CN=info.iescastillodeluna.es&#39;</span> <span class="se">\</span>
   -keyout /etc/ssl/private/ssl-cert-snakeoil.key <span class="se">\</span>
   -out /etc/ssl/certs/ssl-cert-snakeoil.pem
</pre></div>
</div>
</div>
<p>Y ¡listo! Ya tenemos un certificado no fiable para crear conexiones <abbr title="Secure Socket Layer">SSL</abbr>. Ahora
resta configurar <strong class="program">nginx</strong> para que lo use:</p>
<div class="highlight-nginx notranslate" id="nginx-autofirmado"><div class="highlight"><pre><span></span><span class="k">server</span> <span class="p">{</span>
<span class="hll">   <span class="kn">listen</span>   <span class="mi">443</span> <span class="s">ssl</span><span class="p">;</span>
</span>
   <span class="kn">server_name</span> <span class="s">_</span><span class="p">;</span>

   <span class="kn">root</span> <span class="s">/srv/www</span><span class="p">;</span>
   <span class="kn">try_files</span> <span class="nv">$uri</span> <span class="nv">$uri/</span> <span class="p">=</span><span class="mi">404</span><span class="p">;</span>

<span class="hll">   <span class="kn">include</span> <span class="s">snippets/snakeoil.conf</span><span class="p">;</span>
</span><span class="p">}</span>
</pre></div>
</div>
<p>O sea, advertimos que la conexión por el puerto <strong>443</strong> es segura y referimos el
archivo <code class="file docutils literal notranslate"><span class="pre">/etc/nginx/snippets/snakeoil.conf</span></code> que a su vez, incluye las
directivas de <strong class="program">nginx</strong> necesarias para saber dónde se encuentran las
claves. No hace falta escribir el archivo puesto que el paquete de <em>Debian</em> ya
lo ha escrito por nosotros. Si le echamos un vistazo veremos que contiene dos
directivas que refieren los archivos que generamos con <a class="reference internal" href="#make-ssl-cert"><span class="std std-ref">make-ssl-cert</span></a>:</p>
<div class="highlight-nginx notranslate"><div class="highlight"><pre><span></span><span class="k">ssl_certificate</span> <span class="s">/etc/ssl/certs/ssl-cert-snakeoil.pem</span><span class="p">;</span>
<span class="k">ssl_certificate_key</span> <span class="s">/etc/ssl/private/ssl-cert-snakeoil.key</span><span class="p">;</span>
</pre></div>
</div>
<p>Además, debemos incluir un archivo <code class="file docutils literal notranslate"><span class="pre">/etc/nginx/conf.d/ssl.conf</span></code><a class="footnote-reference brackets" href="#id20" id="id5">5</a> con
algunas directivas relativas al cifrado cuyo contenido es <a class="reference download internal" download="" href="../../../../_downloads/1ec2f25228054e31dee6daac579628b6/ssl.auto.conf"><code class="xref download docutils literal notranslate"><span class="pre">éste</span></code></a>.</p>
<p id="nginx-https-http">La configuración del sitio es muy simple y crea un servidor que sólo responde a
peticiones seguras. Esto no es lo más apropiado ya que probablemente algún
cliente nos haga una petición no segura por el puerto <strong>80</strong> y se encuentre con
que el servidor, aparentemente, no existe. Así, pues, cambiemos la
configuración:</p>
<div class="highlight-nginx notranslate"><div class="highlight"><pre><span></span><span class="k">server</span> <span class="p">{</span>
<span class="hll">   <span class="kn">listen</span>   <span class="mi">80</span><span class="p">;</span>
</span>   <span class="kn">listen</span>   <span class="mi">443</span> <span class="s">ssl</span><span class="p">;</span>

   <span class="kn">server_name</span> <span class="s">_</span><span class="p">;</span>

   <span class="kn">root</span> <span class="s">/srv/www</span><span class="p">;</span>
   <span class="kn">try_files</span> <span class="nv">$uri</span> <span class="nv">$uri/</span> <span class="p">=</span><span class="mi">404</span><span class="p">;</span>

<span class="hll">   <span class="kn">include</span> <span class="s">snippets/snakeoil.conf</span><span class="p">;</span>
</span>
<span class="hll">   <span class="kn">if</span> <span class="s">(</span><span class="nv">$https</span> <span class="s">!=</span> <span class="s">&quot;on&quot;)</span> <span class="p">{</span>
</span><span class="hll">      <span class="kn">return</span> <span class="mi">301</span> <span class="s">https://</span><span class="nv">$host$uri$is_args$args</span><span class="p">;</span>
</span><span class="hll">   <span class="p">}</span>
</span><span class="p">}</span>
</pre></div>
</div>
<div class="admonition warning">
<p class="admonition-title">Advertencia</p>
<p>El <code class="docutils literal notranslate"><span class="pre">if</span></code> provoca que, si el tráfico es no seguro, se repita la
petición por el puerto seguro. Si queremos permitir ambos tráficos podemos
eliminar este bloque.</p>
</div>
</section>
<section id="certificados-acreditados">
<span id="nginx-https"></span><h2><span class="section-number">7.2.2.2.8.2. </span>Certificados acreditados<a class="headerlink" href="#certificados-acreditados" title="Enlazar permanentemente con este título">¶</a></h2>
<div class="admonition seealso">
<p class="admonition-title">Ver también</p>
<p>Si quiere profundizar en los conceptos teóricos detrás de los
certificados, échele un ojo a la <a class="reference internal" href="../../../../98.apendice/01.cryto/03.aplicaciones/01.certdig.html#cert-digital"><span class="std std-ref">explicación sobre certificados
digitales</span></a>.</p>
</div>
<p>Para que un certificado de servidor cumpla con uno de sus objetivos, la
identificación fehaciente del propio servidor<a class="footnote-reference brackets" href="#id21" id="id6">6</a>, es indispensable que una
autoridad de certificación ampliamente reconocida lo firme. Eso, por lo general,
supone:</p>
<ul class="simple">
<li><p>Acreditar ante la <abbr title="Certification Authority">CA</abbr>, que somos los dueños del dominio.</p></li>
<li><p>Pagar para la generación y renovación de los certificados.</p></li>
</ul>
<p>Lo segundo provocó que en <em>Internet</em> durante mucho tiempo proliferaran los
certificados autofirmados y que toparnos con uno, si la página no era la de un
banco, no produjera demasiadas sospechas. Sin embargo con la aparición de <a class="reference external" href="https://letsencrypt.org/es`">Let’s Encrypt</a>
y el patrocinio de muchas empresas del sector tecnológico y las comunicaciones
que han apostado por hacer definitivamente la web segura y la sufragan, la
situación ha cambiado: ahora es muy sencillo y totalmente gratuito obtener
certificados válidos y es absolutamente injustificable haber generados
certificados autofirmados en un servidor público en producción.</p>
<p>En la actualidad, hay algunas alternativas para obtener certificados gratuitos:</p>
<ul class="simple">
<li><p><a class="reference external" href="https://letsencrypt.org/es`">Let’s Encrypt</a></p></li>
<li><p><a class="reference external" href="https://zerossl.com">ZeroSSL</a></p></li>
<li><p><a class="reference external" href="https://www.buypass.com/ssl/products/acme">BuyPass</a>.</p></li>
</ul>
<p>Otro aspecto a tener en cuenta, además de quién nos proporcione el certificado,
es cómo se acredita ante el certificador la propiedad del dominio. Los métodos
son esencialmente tres:</p>
<ol class="arabic">
<li><p>Mediante <strong>correo electrónico</strong>, que consiste en que la autoridad nos envía un
mensaje de confirmación a una dirección de correo electrónico muy concreta
del dominio que hayamos afirmado que es nuestro, como <code class="docutils literal notranslate"><span class="pre">admin&#64;example.net</span></code>
o <code class="docutils literal notranslate"><span class="pre">webmaster&#64;example.net</span></code>. Los nombres de las cuentas son tales que sólo
podremos poseerlos si realmente somos los propietarios.</p></li>
<li><p>Mediante <abbr title="Domain Name Server">DNS</abbr>, que consiste en que la autoridad nos pide que incluyamos en
la zona de nuestro dominio un registro (generalmente <code class="docutils literal notranslate"><span class="pre">TXT</span></code> o <code class="docutils literal notranslate"><span class="pre">CNAME</span></code>) muy
particular, cuya posterior consulta sirve a la autoridad para confirmar que
somos los propietarios.</p></li>
<li><p>Mediante el protocolo <abbr title="Automated Certificate Management Environment">ACME</abbr>, inicialmente propuesto como estándar por <a class="reference external" href="https://letsencrypt.org/es`">Let’s
Encrypt</a> que consiste en correr un cliente en la máquina del servidor web
que envía un anuncio al servidor <abbr title="Automated Certificate Management Environment">ACME</abbr> (la autoridad de certificación)
instándole a comprobar la propiedad del dominio. Esta comprobación se lleva a
cabo por una de estas dos alternativas llamadas <em class="dfn">desafíos</em>.</p>
<dl class="simple" id="desafios-acme">
<dt><em class="dfn">Desafío HTTP</em></dt><dd><p>Consiste en que el servidor <abbr title="Automated Certificate Management Environment">ACME</abbr> entrega al cliente un <em>token</em>, para que
este se lo haga accesible a través del protocolo <abbr title="HyperText Transfer Protocol">HTTP</abbr>. A continuación
conectará con el cliente a través de estew protocolo usando el nombre
(p.e. <code class="docutils literal notranslate"><span class="pre">www.example.net</span></code>) con el fin de acreditar que el cliente es
realmente la máquina de tal nombre. Si la comprobación tiene éxito,
se entrega el certificado firmado al cliente. Si se quieren acreditar
varios nombres en un mismo certificado, entonces el desafío consistirá en
hacer sendas pruebas para cada uno de los nombres deseados; y sólo si
todas tienen buen suceso, se entregará el certificado.</p>
</dd>
<dt><em class="dfn">Desafío DNS</em></dt><dd><p>En este caso, el cliente utiliza el <em>token</em> para crear un registro <code class="docutils literal notranslate"><span class="pre">TXT</span></code>
en la zona del dominio que se desea acreditar para que la autoridad
compruebe a continuación la existencia de tal registro. En este caso, dado
que se puede acreditar la propiedad sobre todo el dominio, se pueden generar
certificados comodín (o sea, un certificado para <code class="docutils literal notranslate"><span class="pre">*.example.net</span></code> que servirá
para cualquier nombre de máquina del dominio).</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">Ver también</p>
<p>Para más información consulte las <a class="reference external" href="acme.sh_0.1-2_amd64.deb">explicaciones más prolijas
de Let’s Encrypt sobre desafíos</a></p>
</div>
</li>
</ol>
<p>Como los certificados tienen un tiempo de vigencia (p.e. los certificados
gratuitos de las dos primeras autoridades reseñadas, 90 días; y el de la última,
180), lo adecuado es utilizar un mecanismo que habilite las renovaciones
automáticas lo cual es posible si hacemos uso de clientes <abbr title="Automated Certificate Management Environment">ACME</abbr>. Las tres
autoridades soportan este protocolo, así que lo que necesitamos es un cliente
<abbr title="Automated Certificate Management Environment">ACME</abbr> solvente. Hay varios (<a class="reference internal" href="#certbot">certbot</a>, <a class="reference external" href="https://github.com/dehydrated-io/dehydrated">dehydrated</a>, etc), pero nos centraremos
en el <em>script</em> <a class="reference external" href="https://github.com/acmesh-official/acme.sh">acme.sh</a> porque presenta algunas ventajas:</p>
<ul class="simple">
<li><p>Está enteramente escrito en <em>POSIX shell</em>, lo que evita la necesidad de
dependencias más allá de las estrictamente necesarias (<strong class="command">openssl</strong> y
<strong class="command">wget</strong> o <strong class="command">curl</strong>) que de todas maneras ya tendremos
instaladas.</p></li>
<li><p>Soporta las tres autoridades referidas que permiten obtener certificados
gratuitos.</p></li>
</ul>
<p>En cambio, no tiene paquete oficial en <em>Debian</em>, pero podemos suplir esto de un
modo bastante sencillo.</p>
<p class="rubric">Instalación de <strong class="command">acme.sh</strong></p>
<div class="admonition warning">
<p class="admonition-title">Advertencia</p>
<p>El método de instalación que se propone consiste en generar un
archivo <em>deb</em>, en vez de hacer una instalación directa. Para generar tal
archivo son necesarias herramientas accesorias que no se necesitarán para
nada más, por lo que se recomienda generar el <em>deb</em> en una máquina distinta a
la que albergue el servidor. Para instalar las herramientas accesorias
es necesario hacer:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> apt install unzip debhelper
</pre></div>
</div>
<p>que, como verá, instala bastantes paquetes.</p>
</div>
<p>El propio <em>script</em> proporciona un método de instalación, pero es más
conveniente que procuremos crear un paquete de <em>Debian</em>, Para ello, existe
<a class="reference external" href="https://github.com/mdbraber/acme.sh-debian">otro repositorio</a> que nos
permite generar el paquete que deseamos. Basta con descargar el repositorio
(por ejemplo el <kbd class="kbd docutils literal notranslate">zip</kbd>) y:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> unzip acme.sh-debian-master.zip
<span class="gp">#</span> <span class="nb">cd</span> acme.sh-debian-master
</pre></div>
</div>
<p>El <em>script</em> genera el paquete a partir de una copia del repositorio oficial que
puede estar desfasada, así que antes de generarlo es conveniente editar <code class="file docutils literal notranslate"><span class="pre">debian/rules</span></code>:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="nv">GITHUBUSER</span> <span class="o">=</span> acmesh-official
<span class="nv">BRANCH</span> <span class="o">=</span> master
</pre></div>
</div>
<p>y, hecha la modificación, ya se puede generar el paquete:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> make debian
</pre></div>
</div>
<p>que generará en el directorio padre el paquete listo para ser instalado:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> <span class="nb">cd</span> ..
<span class="gp">#</span> apt install ./acme.sh_0.1-2_amd64.deb
</pre></div>
</div>
<div class="admonition warning">
<p class="admonition-title">Advertencia</p>
<p>El paquete, no obstante, tiene <strong>un par de defectos</strong> que es imprescindible
corregir:</p>
<ul>
<li><p>Para las renovaciones automáticas de certificados, el <em>script</em> original
añade una línea al <a class="reference internal" href="../../../../04.servidor/07.tareas/01.cronat.html#cron"><span class="std std-ref">cron</span></a> de <em>root</em> para que comprueba diariamente
si es preciso renovar alguno:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">11 0 * * * &quot;/usr/lib/acme.sh&quot;/acme.sh --cron --home /usr/lib/acme.sh &gt; /dev/null</span>
</pre></div>
</div>
<p>donde <strong>11</strong> es un minuto aleatorio. Esto tal vez funcione, si se usa
directamente el <em>script</em> sin demasiada personalización. Sin embargo, el
paquete guarda la configuración en <code class="file docutils literal notranslate"><span class="pre">/etc/acme.sh</span></code> y es dentro de ese
directorio donde se encuentran los certificados, por lo que la renovación
automática fallará. La solución es alterar esa línea para que se carguen las
variables de ambiente:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">11 0 * * * . /etc/acme.sh/acme.sh.env ; &quot;/usr/lib/acme.sh&quot;/acme.sh --cron &gt; /dev/null</span>
</pre></div>
</div>
</li>
<li><p>No incluye ningún script de desinstalación <code class="file docutils literal notranslate"><span class="pre">prerm</span></code>, por lo que ni se
elimina el trabajo de <a class="reference internal" href="../../../../04.servidor/07.tareas/01.cronat.html#cron"><span class="std std-ref">cron</span></a> ni la línea que se creó en
<code class="file docutils literal notranslate"><span class="pre">/root/.bashrc</span></code> por lo que habrá que hacer ambas acciones a mano.</p></li>
</ul>
</div>
<p class="rubric">Generación del certificado</p>
<p>Proponemos lo más sencillo<a class="footnote-reference brackets" href="#id22" id="id7">7</a> (y que en muchos casos nos será suficiente):</p>
<ul>
<li><p>Con <a class="reference external" href="https://letsencrypt.org/es`">Let’s Encrypt</a>, puesto que no requiere ningún tipo de registro.</p></li>
<li><p>El <a class="reference internal" href="#desafios-acme"><span class="std std-ref">desafío HTTP</span></a>.</p>
<div class="admonition warning">
<p class="admonition-title">Advertencia</p>
<p>No obstante, si pretende albergar múltiples sitios en el mismo
servidor web, sopese la posibilidad de generar <a class="reference internal" href="#dns-challenge"><span class="std std-ref">un certificado comodín
con el desafío DNS</span></a>.</p>
</div>
</li>
<li><p>Ya tenemos creado el servidor <em>web</em>, aunque no seguro porque carecemos aún de
certificado<a class="footnote-reference brackets" href="#id23" id="id8">8</a>. Por ejemplo:</p>
<div class="highlight-nginx notranslate"><div class="highlight"><pre><span></span><span class="k">server</span> <span class="p">{</span>
   <span class="kn">listen</span>   <span class="mi">80</span><span class="p">;</span>

   <span class="kn">server_name</span> <span class="s">example.net</span>
               <span class="s">www.example.net</span><span class="p">;</span>

   <span class="kn">root</span> <span class="s">/srv/www/default</span><span class="p">;</span>
   <span class="kn">try_files</span> <span class="nv">$uri</span> <span class="nv">$uri/</span> <span class="p">=</span><span class="mi">404</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</li>
</ul>
<p>Si la resolución <abbr title="Domain Name Server">DNS</abbr> de esos dos nombres conduce a nuestro servidor <em>web</em>,
generar un certificado para esos nombres se lleva a cabo con:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> acme.sh --issue --server letsencrypt -d example.net -d www.example.net -w /srv/www/default
</pre></div>
</div>
<p>donde <kbd class="kbd docutils literal notranslate">-d</kbd> introduce los nombres de máquina y <kbd class="kbd docutils literal notranslate">-w</kbd> el directorio raíz
para ese servidor virtual. La opción <kbd class="kbd compound docutils literal notranslate"><kbd class="kbd docutils literal notranslate">-</kbd>-<kbd class="kbd docutils literal notranslate">server</kbd></kbd> indica cuál es la <abbr title="Certification Authority">CA</abbr> con
la que queremos generar certificados (véase <a class="reference external" href="https://github.com/acmesh-official/acme.sh/wiki/Server">todas las alternativas en la
documentación oficial</a>) y es necesario
incluirla en las operaciones que requieren conexión con la <abbr title="Certification Authority">CA</abbr> como
<kbd class="kbd compound docutils literal notranslate"><kbd class="kbd docutils literal notranslate">-</kbd>-<kbd class="kbd docutils literal notranslate">issue</kbd></kbd> o <kbd class="kbd compound docutils literal notranslate"><kbd class="kbd docutils literal notranslate">-</kbd>-<kbd class="kbd docutils literal notranslate">revoke</kbd></kbd>.</p>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>Podemos en un mismo certificado asociar varios nombres a distintos
directorios raíz, para lo cual debemos expresar cada directorio raíz
inmediatamente después de cada nombre:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> acme.sh --issue --server letsencrypt
<span class="go">                  -d example.net -w /srv/www/default \</span>
<span class="go">                  -d www.example.net -w /srv/www/default \</span>
<span class="go">                  -d moodle.example.net -w /srv/www/moodle</span>
</pre></div>
</div>
</div>
<p>Una vez generado el certificado, debemos instalarlo para que pueda usarlo
nuestro servidor <strong class="program">nginx</strong><a class="footnote-reference brackets" href="#id24" id="id9">9</a>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> acme.sh --install-cert -d example.net --key-file /etc/ssl/private/letsencrypt-example.net.key <span class="se">\</span>
   --fullchain-file /etc/ssl/certs/letsencrypt-fullchain-example.net.cer --reloadcmd <span class="s2">&quot;systemctl force-reload nginx&quot;</span>
</pre></div>
</div>
<p>Esta orden toma las claves, la copia en la localización que indicamos y reinicia
el servidor por lo que ya es funcional el certificado y, además, se renovará
automáticamente sin necesidad de que demos la orden expresa o tengamos que
reiniciar el servidor manualmente.</p>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>Una línea como la anterior es útil cuando el servidor que usa el
certificado mantiene por separado la(s) clave(s) pública(s) de la privada. No
hay, sin embargo, ninguna opción que copie juntas en un mismo archivo todas
las claves, por lo que si el servidor que usa el certificado requiere esto
(p.e. el <em>proxy</em> inverso <a class="reference internal" href="../../../05.proxies/03.reverse/01.multi.html#haproxy"><span class="std std-ref">haproxy</span></a>) entonces tenemos que recurrir a
generar el archivo dentro de la orden que expresa <kbd class="kbd compound docutils literal notranslate"><kbd class="kbd docutils literal notranslate">-</kbd>-<kbd class="kbd docutils literal notranslate">reloadcmd</kbd></kbd>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> acme.sh --install-cert -d example.net <span class="se">\</span>
          --reloadcmd <span class="s1">&#39;cat $CERT_KEY_PATH $CERT_FULLCHAIN_PATH &gt; /etc/haproxy/keycert.pem &amp;&amp; systemctl restart haproxy&#39;</span>
</pre></div>
</div>
</div>
<p>Nos pueden interesar algunas órdenes adicionales, como la que nos permite
listar todos los certificados gestionados por el <em>script</em>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> acme.sh --list
</pre></div>
</div>
<p>o la que permite revocar y borrar alguno de los certificados:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> acme.sh --revoke --server letsencrypt -d example.net
<span class="gp">#</span> acme.sh --remove -d example.net
</pre></div>
</div>
<p>El certificado, aunque ya no esté activo (no aparecerá al usar <kbd class="kbd compound docutils literal notranslate"><kbd class="kbd docutils literal notranslate">-</kbd>-<kbd class="kbd docutils literal notranslate">list</kbd></kbd>),
no se borrará del directorio <code class="file docutils literal notranslate"><span class="pre">/etc/acme.sh/cert/example.net</span></code>. Esta operación deberemos hacerla a mano.</p>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>A partir de la versión <strong>3.0</strong>, <a class="reference external" href="https://letsencrypt.org/es`">Let’s Encrypt</a> dejó de ser la <abbr title="Certification Authority">CA</abbr>
predeterminada y pasó a serlo <a class="reference external" href="https://zerossl.com">ZeroSSL</a>. Esa es la razón por la que hemos
necesita explicitar el servidor a través de la opción <kbd class="kbd compound docutils literal notranslate"><kbd class="kbd docutils literal notranslate">-</kbd>-<kbd class="kbd docutils literal notranslate">server</kbd></kbd>.
Podemos cambiar, no obstante, muy fácilmente la <abbr title="Certification Authority">CA</abbr> predeterminada:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> acme.sh -set-default-ca  --server letsencrypt
</pre></div>
</div>
</div>
<div class="admonition warning">
<p class="admonition-title">Advertencia</p>
<p>Si ha configurado el servidor de manera que <a class="reference internal" href="#nginx-https-http"><span class="std std-ref">la conexión no segura
redirige a la segura</span></a> (lo cual es muy habitual), la
revocación no funcionará, así que, antes de revocar comprueba, asegúrese de
inhabilitarlo temporalmente.</p>
</div>
<p class="rubric">Configuración</p>
<p>La configuración es prácticamente idéntica a la <a class="reference internal" href="#nginx-autofirmado"><span class="std std-ref">propuesta para los
certificados autofirmados</span></a>:</p>
<div class="highlight-nginx notranslate"><div class="highlight"><pre><span></span><span class="k">server</span> <span class="p">{</span>
   <span class="kn">listen</span>   <span class="mi">443</span> <span class="s">ssl</span><span class="p">;</span>

   <span class="kn">server_name</span> <span class="s">_</span><span class="p">;</span>

   <span class="kn">root</span> <span class="s">/srv/www</span><span class="p">;</span>
   <span class="kn">try_files</span> <span class="nv">$uri</span> <span class="nv">$uri/</span> <span class="p">=</span><span class="mi">404</span><span class="p">;</span>

<span class="hll">   <span class="kn">include</span> <span class="s">snippets/cert.conf</span><span class="p">;</span>
</span>
<span class="hll">   <span class="c1"># Cabecera HSTS</span>
</span><span class="hll">   <span class="kn">add_header</span> <span class="s">Strict-Transport-Security</span> <span class="s">&quot;max-age=15768000</span><span class="p">;</span> <span class="kn">includeSubdomains</span><span class="p">;</span> <span class="kn">preload&quot;</span><span class="p">;</span>
</span><span class="p">}</span>
</pre></div>
</div>
<p>La última línea de la configuración (opcional) añade una cabecera <abbr title="HTTP Strict Transport Security">HSTS</abbr> a las
respuestas que obliga al cliente a usar siempre <abbr title="HyperText Transfer Protocol">HTTP</abbr>s y a no aceptar tras la
primera visita a la página bajo ningún concepto un certificado no fiable. (p.e.
uno autofirmado)<a class="footnote-reference brackets" href="#id25" id="id10">10</a>. Para más información, consulte <a class="reference internal" href="../../../../08.redes/99.ataques/02.tecnicas/04.mitm.html#sslstrip"><span class="std std-ref">el epígrafe
dedicado al ataque SSLstrip</span></a>.</p>
<p>Por su parte, <code class="file docutils literal notranslate"><span class="pre">cert.conf</span></code> (que cumple el papel de <code class="file docutils literal notranslate"><span class="pre">snakeoil.conf</span></code> y
en esta ocasión sí tendremos que crear) tiene el siguiente contenido:</p>
<div class="highlight-nginx notranslate"><div class="highlight"><pre><span></span><span class="k">ssl_certificate</span> <span class="s">/etc/ssl/certs/letsencrypt-fullchain-example.net.cer</span><span class="p">;</span>
<span class="k">ssl_certificate_key</span> <span class="s">/etc/ssl/private/letsencrypt-example.net.key</span><span class="p">;</span>
<span class="k">ssl_trusted_certificate</span> <span class="s">/etc/ssl/certs/letsencrypt-fullchain-example.net.cer</span><span class="p">;</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>Es posible que deseemos que el tráfico sea exclusivamente seguro y
evitar que el usuario se comunique a través del puerto <strong>80</strong>. Eso podemos
lograrlo con la cabecera <abbr title="HTTP Strict Transport Security">HSTS</abbr> o incluyendo la <a class="reference internal" href="#nginx-autofirmado"><span class="std std-ref">redirección con el if
comentada anteriormente</span></a>.</p>
</div>
<p>Además, debemos definir un archivo para configurar algunas directivas
relacionadas con el <abbr title="Secure Socket Layer">SSL</abbr> en <code class="file docutils literal notranslate"><span class="pre">/etc/nginx/conf.d/ssl.conf</span></code> con
<a class="reference download internal" download="" href="../../../../_downloads/13be357bc660bedf832bcaec8fbc885f/ssl.certbot.conf"><code class="xref download docutils literal notranslate"><span class="pre">este</span> <span class="pre">contenido</span></code></a>:</p>
<div class="highlight-nginx notranslate"><div class="highlight"><pre><span></span><span class="k">ssl_session_timeout</span> <span class="s">1d</span><span class="p">;</span>
<span class="k">ssl_session_cache</span> <span class="s">shared:SSL:50m</span><span class="p">;</span>
<span class="k">ssl_session_tickets</span> <span class="no">off</span><span class="p">;</span>

<span class="k">ssl_protocols</span> <span class="s">TLSv1.2</span><span class="p">;</span>
<span class="k">ssl_ciphers</span> <span class="s">EECDH+AESGCM:EECDH+AES</span><span class="p">;</span>
<span class="k">ssl_ecdh_curve</span> <span class="s">secp384r1</span><span class="p">;</span>

<span class="k">ssl_stapling</span> <span class="no">on</span><span class="p">;</span>
<span class="k">ssl_stapling_verify</span> <span class="no">on</span><span class="p">;</span>

<span class="k">add_header</span> <span class="s">X-Frame-Options</span> <span class="s">DENY</span><span class="p">;</span>
<span class="k">add_header</span> <span class="s">X-Content-Type-Options</span> <span class="s">nosniff</span><span class="p">;</span>
</pre></div>
</div>
</section>
<section id="aspectos-adicionales">
<h2><span class="section-number">7.2.2.2.8.3. </span>Aspectos adicionales<a class="headerlink" href="#aspectos-adicionales" title="Enlazar permanentemente con este título">¶</a></h2>
<section id="multiples-dominios-virtuales">
<h3><span class="section-number">7.2.2.2.8.3.1. </span>Múltiples dominios virtuales<a class="headerlink" href="#multiples-dominios-virtuales" title="Enlazar permanentemente con este título">¶</a></h3>
<p>Cuando el servidor define varios dominios virtuales y dos o más de ellos usan
tráfico seguro debe tenerse en cuenta que, en principio, el servidor web conoce
cuál es el nombre de máquina usado en la petición a través del comando
<kbd class="kbd docutils literal notranslate">GET</kbd> o las cabeceras <abbr title="HyperText Transfer Protocol">HTTP</abbr>. Al ser el tráfico cifrado, el acceso
a esta información no es accesible hasta que no se use el certificado
correspondiente para descifrarla. Esa es la razón por la que, en principio, el
certificado debería ser común a todos los dominios virtuales. Para subsanar esta
limitación el protocolo <abbr title="Secure Socket Layer">SSL</abbr> ideó la <a class="reference internal" href="../../../../98.apendice/01.cryto/03.aplicaciones/04.ssl.html#sni"><span class="std std-ref">extensión SNI</span></a>, que soportan
la mayor parte de los navegadores modernos y, muy probablemente la versión de
<strong class="program">nginx</strong> que se esté utilizando:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> nginx -V
</pre></div>
</div>
<p>En caso de que <strong class="program">nginx</strong> soporte <abbr title="Server Name Indication">SNI</abbr>, puede definirse un certificado
diferente en cada sitio a través de <kbd class="kbd docutils literal notranslate">ssl_certificate</kbd> y
<kbd class="kbd docutils literal notranslate">ssl_certificate_key</kbd>. Para los sitios seguros en que no se defina un
certificado, se usará el declarado en el servidor predeterminado<a class="footnote-reference brackets" href="#id26" id="id11">11</a>. Una
configuración posible puede ser esta:</p>
<blockquote>
<div><div class="highlight-nginx notranslate"><div class="highlight"><pre><span></span><span class="k">server</span> <span class="p">{</span>
   <span class="kn">listen</span>   <span class="mi">80</span>       <span class="s">default_server</span><span class="p">;</span>
   <span class="kn">listen</span>   <span class="mi">443</span> <span class="s">ssl</span>  <span class="s">default_server</span><span class="p">;</span>

   <span class="kn">server</span> <span class="s">name</span> <span class="s">_</span><span class="p">;</span>

   <span class="kn">include</span> <span class="s">snippets/letsencrypt.conf</span><span class="p">;</span>

   <span class="c1"># Resto de configuración.</span>
<span class="p">}</span>

<span class="k">server</span> <span class="p">{</span>
   <span class="kn">listen</span> <span class="mi">80</span><span class="p">;</span>
   <span class="kn">listen</span> <span class="mi">443</span><span class="p">;</span>  <span class="c1"># Nótese que no hace falta ni usar ssl.</span>

   <span class="kn">server_name</span>  <span class="s">moodle.example.net</span><span class="p">;</span>

   <span class="c1"># Configuración para moodle</span>
<span class="p">}</span>

<span class="k">server</span>  <span class="p">{</span>
   <span class="kn">listen</span> <span class="mi">80</span><span class="p">;</span>
   <span class="kn">listen</span> <span class="mi">443</span> <span class="s">ssl</span><span class="p">;</span>

   <span class="kn">server_name</span>  <span class="s">alt.example.net</span><span class="p">;</span>

   <span class="kn">include</span> <span class="s">snippets/zerossl.conf</span><span class="p">;</span>

   <span class="c1"># Configuración para este sitio.</span>
<span class="p">}</span>
</pre></div>
</div>
</div></blockquote>
<p>Con esta configuración, el sitio <em>moodle.example.net</em> usará el mismo certificado
que el sitio predeterminado (el incluido en <code class="file docutils literal notranslate"><span class="pre">snippets/letsencrypt.conf</span></code>,
mientras que el sitio <em>alt.example.net</em> utiliza un certificado distinto definido
en <code class="file docutils literal notranslate"><span class="pre">snippets/zerossl.conf</span></code>. Podemos cerciorarnos de que esto realmente
funciona haciendo una consulte con el navegador y consultando los certificados,
o desde la consola con <strong class="command">openssl</strong> al servidor:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> openssl s_client -servername alt.example.net -connect alt.example.net:https &lt; /dev/null <span class="p">|</span> grep <span class="s1">&#39;CN =&#39;</span>
</pre></div>
</div>
<div class="admonition warning">
<p class="admonition-title">Advertencia</p>
<p><strong class="command">openssl</strong> no usa <abbr title="Server Name Indication">SNI</abbr> a menos que se use la opción
<kbd class="kbd docutils literal notranslate">-servername</kbd>, de modo que haga las pruebas incluyéndola.</p>
</div>
</section>
<section id="certificados-con-zerossl">
<span id="zerossl-cert"></span><h3><span class="section-number">7.2.2.2.8.3.2. </span>Certificados con <a class="reference external" href="https://zerossl.com">ZeroSSL</a><a class="headerlink" href="#certificados-con-zerossl" title="Enlazar permanentemente con este título">¶</a></h3>
<p><a class="reference external" href="https://zerossl.com">ZeroSSL</a> es una buena alternativa a <a class="reference external" href="https://letsencrypt.org/es`">Let’s Encrypt</a> y, además. en las últimas
versiones del <em>script</em> <a class="reference external" href="https://github.com/acmesh-official/acme.sh/wiki/ZeroSSL.com-CA">es la CA predefinida</a> <a class="footnote-reference brackets" href="#id27" id="id12">12</a>, aunque
requiere un registro previo que puede hacerse desde la propia línea de órdenes:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> acme.sh  --server zerossl --register-account -m micorreo@example.net
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>Si ya estábamos registrados, sígase la <a class="reference external" href="https://github.com/acmesh-official/acme.sh/wiki/ZeroSSL.com-CA">documentación oficial de acme.sh sobre
certificados de ZeroSSL</a></p>
</div>
<p>Hecho el registro, la generación de certificados con <kbd class="kbd compound docutils literal notranslate"><kbd class="kbd docutils literal notranslate">-</kbd>-<kbd class="kbd docutils literal notranslate">issue</kbd></kbd> es
exactamente igual, excepto pòr la salvedad de que deberermos añadir
<kbd class="kbd compound docutils literal notranslate"><kbd class="kbd docutils literal notranslate">-</kbd>-<kbd class="kbd docutils literal notranslate">server</kbd> <kbd class="kbd docutils literal notranslate">zerossl</kbd></kbd>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> acme.sh --server zerossl --issue -d zero.iescdl.es -w /srv/www/zero1 <span class="se">\</span>
   -d zero2.iescdl.es -w /srv/www/zero2
</pre></div>
</div>
<p>Obviamente, además habrá que instalar el certificado.</p>
<div class="admonition seealso">
<p class="admonition-title">Ver también</p>
<p>Échele un vistazo a la <a class="reference external" href="https://github.com/acmesh-official/acme.sh/wiki/ZeroSSL.com-CA">documentación oficial de acme.sh sobre
`certificados de ZeroSSL</a></p>
</div>
</section>
<section id="desafio-dns">
<span id="dns-challenge"></span><h3><span class="section-number">7.2.2.2.8.3.3. </span>Desafío <abbr title="Domain Name Server">DNS</abbr><a class="headerlink" href="#desafio-dns" title="Enlazar permanentemente con este título">¶</a></h3>
<p>Cuando en un servidor web disponemos distintos sitios (<em>blogs</em> con <em>wordpress</em>,
<em>moodle</em>, aplicaciones diversas), el certificado tendrá que contenemos muchos
nombres y se tendrán que llevar a cabo pruebas en muchos directorios raíz. Si,
además, ampliamos los servicios y creamos un nuevo sitio con un nuevo nombre,
tendremos que regenerar el certificado para incluirlo. Para evitarlo, lo mejor
es generar un certificado comodín y esto sólo se puede hacer utilizando el
<a class="reference internal" href="#desafios-acme"><span class="std std-ref">desafío DNS</span></a>. Su única dificultad es que durante la
generación y renovación del certificado, requiere la creación dinámica del
registro <code class="docutils literal notranslate"><span class="pre">TXT</span></code> en nuestra zona <abbr title="Domain Name Server">DNS</abbr> y que se pueda realmente hacer y cómo
depende de cuál sea nuestro proveedor de <abbr title="Domain Name Server">DNS</abbr><a class="footnote-reference brackets" href="#id28" id="id14">13</a>.</p>
<p>La documentación de <a class="reference external" href="https://github.com/acmesh-official/acme.sh">acme.sh</a> tiene un <a class="reference external" href="https://github.com/acmesh-official/acme.sh/wiki/dnsapi">documento donde repasa cómo usar con
acmes.sh las API de distintos proveedores de DNS</a>. Si se siguen las
instrucciones para nuestro proveedor, la obtención del certificado usando el
<a class="reference internal" href="#desafios-acme"><span class="std std-ref">desafío DNS</span></a> se limita a:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> acme.sh --issue -d example.net -d <span class="s1">&#39;*.example.net&#39;</span> --dns dns_ovh
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>El argumento de <kbd class="kbd compound docutils literal notranslate"><kbd class="kbd docutils literal notranslate">-</kbd>-<kbd class="kbd docutils literal notranslate">dns</kbd></kbd> depende del proveedor.</p>
</div>
</section>
<section id="el-cliente-certbot">
<span id="certbot"></span><h3><span class="section-number">7.2.2.2.8.3.4. </span>El cliente <strong class="command">certbot</strong><a class="headerlink" href="#el-cliente-certbot" title="Enlazar permanentemente con este título">¶</a></h3>
<div class="admonition warning">
<p class="admonition-title">Advertencia</p>
<p>Este epígrafe se incluye, exclusivamente, por haber sido escrito su
contenido con anterioridad a gran parte de la exposición sobre certificados
digitales. Es más aconsejable utilizar <a class="reference external" href="https://github.com/acmesh-official/acme.sh">acme.sh</a>, como se ha propuesto en el
resto del texto, puesto que <strong class="program">certbot</strong> está escrito en <em>Python</em> y
requiere dependencias que muy probable sólo necesite para su ejecución</p>
</div>
<p>Tiene paquete en <em>debian</em>, así que su instalación es sumamente sencilla:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> apt install certbot
</pre></div>
</div>
<p>Como los certificados obtenidos se pueden usar luego con distinto <em>software</em>,
<strong class="command">certbot</strong> tiene distintos <em>plugins</em> para, además de crear o renovar el
certificado, proceder a su instalación en ellos. Nosotros, no obstante, sólo
repararemos en dos:</p>
<ul class="simple">
<li><p><strong>standalone</strong>, que debe usarse si prevemos que no tendremos ocupado nunca el
puerto <strong>80</strong>. Con este <em>plugin</em>, el propio <strong class="command">certboot</strong> levanta
temporalmente un servidor web en el proceso de creación o renovación. No debe
usarse si montamos un servidor web, porque en ese caso, la renovación fallará
levantando el servidor web temporal al encontrar ocupado el puerto.</p></li>
<li><p><strong>webroot</strong>, que implica tener un servidor web instalado e indicarle a
<strong class="command">certboot</strong> cuál es el directorio raíz del mismo.</p></li>
</ul>
<p>Nosotros usaremos este último, suponiendo que ya tenemos listo el servidor web y
que nuestro directorio raíz es <code class="file docutils literal notranslate"><span class="pre">/srv/www</span></code>, Tras ello, podemos lanzar la
generación del certificado así:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> certbot certonly --webroot -w /srv/www -d www.example.net <span class="se">\</span>
   --non-interactive --agree-tos --email licencias@iesmiravent.es <span class="se">\</span>
   --post-hook <span class="s2">&quot;/etc/letsencrypt/posthook.sh&quot;</span>
</pre></div>
</div>
<p>Como resultado de la orden tendremos dentro de
<code class="file docutils literal notranslate"><span class="pre">/etc/letsencrypt/live/www.example.net</span></code> las claves generadas y, además,
justamente tras la generación, se habrá ejecutado el <em>script</em> que pasemos con la
opción <code class="docutils literal notranslate"><span class="pre">--post-hook</span></code><a class="footnote-reference brackets" href="#id29" id="id15">14</a>.  Lo que realmente haya que hacer para que la nueva
clave sea efectiva dependerá de cómo se tenga configurado el servidor. La gracia
de incluir el <em>script</em> es que <em>certboot</em> viene con un <em>timer</em> de
<strong class="program">systemd</strong> para intentar diariamente la renovación del <em>script</em> y que
este proceso de renovación también lanza el <em>script</em>. Por tanto, podremos
olvidarnos por completo de estar al tanto de la actualización.</p>
<p>En una configuración simple en que el propio <strong class="program">nginx</strong> se encarga del
cifrado y utilizamos la configuración propuesta en el próximo epígrafe, basta
con que el <em>script</em> se limite a reiniciar <strong class="program">nginx</strong>. Por tanto:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="ch">#!/bin/sh</span>

systemctl reload-or-restart nginx.service
</pre></div>
</div>
<p>Para casos más complejos, como cuando del cifrado se encarga <a class="reference internal" href="../../../05.proxies/03.reverse/01.multi.html#haproxy"><span class="std std-ref">haproxy</span></a>, es
necesario juntar las claves pública y privada (<code class="file docutils literal notranslate"><span class="pre">fullchain.pem</span></code> y
<code class="file docutils literal notranslate"><span class="pre">privkey.pem</span></code>) en un único fichero. <a class="reference download internal" download="" href="../../../../_downloads/d35614dfdda1cbcc8de5d4fd26d80ccf/posthook.sh"><code class="xref download docutils literal notranslate"><span class="pre">Este</span> <span class="pre">script</span></code></a> se encarga de ello.</p>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>Es posible también generar un certificado asociados a varios nombres
repitiendo las opciones <code class="docutils literal notranslate"><span class="pre">-w</span></code> y <code class="docutils literal notranslate"><span class="pre">-d</span></code>, de modo que las opciones <code class="docutils literal notranslate"><span class="pre">-d</span></code>
harán referencia al <code class="docutils literal notranslate"><span class="pre">-w</span></code> que las precede. Por ejemplo:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> certbot certonly --webroot -w /srv/www/main -d example.net -d www.example.net <span class="se">\</span>
   -w /srv/www/blog -d blog.example.net --non-interactive --agree-tos <span class="se">\</span>
   --email licencias@iesmiravent.es --post-hook <span class="s2">&quot;/etc/letsencrypt/posthook.sh&quot;</span>
</pre></div>
</div>
</div>
<p>Es común que en algún momento añadamos un nuevo sitio al servidor y necesitemos
que este sitio también use cifrado. Podemos ampliar el uso del mismo
certificado al nuevo sitio usando la opción <code class="docutils literal notranslate"><span class="pre">--expand</span></code>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> certbot certonly --webroot --expand -w /srv/www -d www.example.net <span class="se">\</span>
   -w /srv/www/moodle -d moodle.example.net <span class="se">\</span>
   --non-interactive --agree-tos --email licencias@iesmiravent.es <span class="se">\</span>
   --post-hook <span class="s2">&quot;/etc/letsencrypt/posthook.sh&quot;</span>
</pre></div>
</div>
<p>Hay, eso sí, que enumerar todos los dominios a los que ya estaba asociado el
servidor y añadir los nuevos.</p>
<p>La configuración es <a class="reference internal" href="#nginx-autofirmado"><span class="std std-ref">idéntica a la ya propuesta</span></a>,
aunque cambian las rutas a los archivos de claves, por lo que tendremos que
cambiar el contenido de <code class="file docutils literal notranslate"><span class="pre">snippets/cert.conf</span></code>:</p>
<div class="highlight-nginx notranslate"><div class="highlight"><pre><span></span><span class="k">ssl_certificate</span> <span class="s">/etc/letsencrypt/live/www.example.net/fullchain.pem</span><span class="p">;</span>
<span class="k">ssl_certificate_key</span> <span class="s">/etc/letsencrypt/live/www.example.net/privkey.pem</span><span class="p">;</span>
<span class="k">ssl_trusted_certificate</span> <span class="s">/etc/letsencrypt/live/www.example.net/fullchain.pem</span><span class="p">;</span>
</pre></div>
</div>
<p class="rubric">Notas al pie</p>
<dl class="footnote brackets">
<dt class="label" id="id16"><span class="brackets"><a class="fn-backref" href="#id1">1</a></span></dt>
<dd><p><abbr title="Transport Layer Security">TLS</abbr> es simplemente la evolución de la versión 3 de <abbr title="Secure Socket Layer">SSL</abbr>. A menudo
suele decirse <abbr title="Secure Socket Layer">SSL</abbr> para referirse también a <abbr title="Transport Layer Security">TLS</abbr>.</p>
</dd>
<dt class="label" id="id17"><span class="brackets"><a class="fn-backref" href="#id2">2</a></span></dt>
<dd><p>En principio, establecer un filtrado de sitios web para clientes sólo
puede hacerse manipulando la resolución <abbr title="Domain Name Server">DNS</abbr>, que sí que no está cifrada.</p>
</dd>
<dt class="label" id="id18"><span class="brackets"><a class="fn-backref" href="#id3">3</a></span></dt>
<dd><p>Por ejemplo, para generar un certificado cuya validez sea de diez
años:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> openssl req -x509 -nodes -days <span class="m">3650</span> -newkey rsa:2048 -keyout /etc/ssl/private/ssl-cert-snakeoil.key <span class="se">\</span>
   -out /etc/ssl/certs/ssl-cert-snakeoil.pem
</pre></div>
</div>
</dd>
<dt class="label" id="id19"><span class="brackets"><a class="fn-backref" href="#id4">4</a></span></dt>
<dd><p>O sea, el que se obtiene así:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> hostname -f
</pre></div>
</div>
</dd>
<dt class="label" id="id20"><span class="brackets"><a class="fn-backref" href="#id5">5</a></span></dt>
<dd><p>Las únicas directivas relativas al cifrado que se encuentran en
<code class="file docutils literal notranslate"><span class="pre">nginx.conf</span></code> son estas:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">ssl_protocols TLSv1 TLSv1.1 TLSv1.2; # Dropping SSLv3, ref: POODLE</span>
<span class="go">ssl_prefer_server_ciphers on</span>
</pre></div>
</div>
<p>de ahí que no se hayan incluido en nuestra propia configuración.</p>
</dd>
<dt class="label" id="id21"><span class="brackets"><a class="fn-backref" href="#id6">6</a></span></dt>
<dd><p>El otro objetivo es garantizar la privacidad, esto es, propiciar el
cifrado.</p>
</dd>
<dt class="label" id="id22"><span class="brackets"><a class="fn-backref" href="#id7">7</a></span></dt>
<dd><p>Más adelante, como conocimiento adicional, explicaremos cómo <a class="reference internal" href="#zerossl-cert"><span class="std std-ref">obtener
certificados con ZeroSSL</span></a> o <a class="reference internal" href="#dns-challenge"><span class="std std-ref">ejecutar el desafío DNS</span></a>.`</p>
</dd>
<dt class="label" id="id23"><span class="brackets"><a class="fn-backref" href="#id8">8</a></span></dt>
<dd><p>En puridad no necesitamos aún el servidor puesto que el <em>script</em>,
añadiendo la opción <code class="docutils literal notranslate"><span class="pre">--standalone</span></code>, es capaz de ponerse a escuchar en el
puerto <strong>80</strong> y atender la petición del servidor <abbr title="Automated Certificate Management Environment">ACME</abbr>. Si generamos el
certificado para un servidor no web (p.e. un servidor de correo), la
posibilidad es recomendable, pero si nuestra intención es dar servicio <em>web</em>
es preferible ya tener montado el servidor, ya que a la postre tendremos que
levantarlo y, sobre todo, porque en producción este servidor ocupará el
puerto <strong>80</strong> y el <em>script</em> no podrá escuchar en él.</p>
</dd>
<dt class="label" id="id24"><span class="brackets"><a class="fn-backref" href="#id9">9</a></span></dt>
<dd><p>Para más información sobre esta cabecera, consulte <a class="reference internal" href="../../../../08.redes/99.ataques/02.tecnicas/04.mitm.html#sslstrip"><span class="std std-ref">el ataque
SSLstrip</span></a>.</p>
</dd>
<dt class="label" id="id25"><span class="brackets"><a class="fn-backref" href="#id10">10</a></span></dt>
<dd><p>Desgraciadamente, no hay ninguna opción para copiar la clave privada y el
certificado en un mismo archivo que es lo que requieren servidores como
<a class="reference internal" href="../../../05.proxies/03.reverse/01.multi.html#haproxy"><span class="std std-ref">haproxy</span></a>. Para el caso de estos programas es posible generar
el archivo único incluyéndolo en <kbd class="kbd compound docutils literal notranslate"><kbd class="kbd docutils literal notranslate">-</kbd>-<kbd class="kbd docutils literal notranslate">reloadcmd</kbd></kbd>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> acme.sh --install-cert -d aulas.iescastillodeluna.es --reloadcmd <span class="se">\</span>
   <span class="s1">&#39;cat $CERT_KEY_PATH $CERT_FULLCHAIN_PATH &gt; /etc/haproxy/keycert.pem &amp;&amp; systemctl restart haproxy/etc/haproxy/keycert.pem&#39;</span>
</pre></div>
</div>
<p>Para acciones más complicadas, es posible usar ganchos (<kbd class="kbd compound docutils literal notranslate"><kbd class="kbd docutils literal notranslate">-</kbd>-<kbd class="kbd docutils literal notranslate">pre</kbd>-<kbd class="kbd docutils literal notranslate">hook</kbd></kbd>,
<kbd class="kbd compound docutils literal notranslate"><kbd class="kbd docutils literal notranslate">-</kbd>-<kbd class="kbd docutils literal notranslate">post</kbd>-<kbd class="kbd docutils literal notranslate">hook</kbd></kbd>).</p>
</dd>
<dt class="label" id="id26"><span class="brackets"><a class="fn-backref" href="#id11">11</a></span></dt>
<dd><p>Lo cual no es ningún problema, puesto que un certificado digital se puede
asociar a varios nombres.</p>
</dd>
<dt class="label" id="id27"><span class="brackets"><a class="fn-backref" href="#id12">12</a></span></dt>
<dd><p>Lo cuál significa que, si no se incluye la opción <kbd class="kbd compound docutils literal notranslate"><kbd class="kbd docutils literal notranslate">-</kbd>-<kbd class="kbd docutils literal notranslate">server</kbd></kbd>, se
supondrá que usamos esta <abbr title="Certification Authority">CA</abbr>.</p>
</dd>
<dt class="label" id="id28"><span class="brackets"><a class="fn-backref" href="#id14">13</a></span></dt>
<dd><p>Lo habitual es que el agente registrador del dominio nos ofrezca el
servicio <abbr title="Domain Name Server">DNS</abbr>, y dependiendo de cuál sea que nos ofrezca o no la
posibilidad de generar registros dinámicamente. Si la ofrece, es obvio que
se requerirá algún tipo de identificación para llevarla a cabo y eso es
probable que requiera un registro previo en ese servicio. Lo mejor es
consultar la documentación del proyecto <a class="reference external" href="https://github.com/acmesh-official/acme.sh">acme.sh</a></p>
</dd>
<dt class="label" id="id29"><span class="brackets"><a class="fn-backref" href="#id15">14</a></span></dt>
<dd><p>También hay una opción <kbd class="kbd compound docutils literal notranslate"><kbd class="kbd docutils literal notranslate">-</kbd>-<kbd class="kbd docutils literal notranslate">pre</kbd>-<kbd class="kbd docutils literal notranslate">hook</kbd></kbd> para ejecutar antes.</p>
</dd>
</dl>
</section>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../../../../index.html">Tabla de contenido</a></h3>
  <ul>
<li><a class="reference internal" href="#">7.2.2.2.8. Conexión segura</a><ul>
<li><a class="reference internal" href="#certificados-autofirmados">7.2.2.2.8.1. Certificados autofirmados</a></li>
<li><a class="reference internal" href="#certificados-acreditados">7.2.2.2.8.2. Certificados acreditados</a></li>
<li><a class="reference internal" href="#aspectos-adicionales">7.2.2.2.8.3. Aspectos adicionales</a><ul>
<li><a class="reference internal" href="#multiples-dominios-virtuales">7.2.2.2.8.3.1. Múltiples dominios virtuales</a></li>
<li><a class="reference internal" href="#certificados-con-zerossl">7.2.2.2.8.3.2. Certificados con ZeroSSL</a></li>
<li><a class="reference internal" href="#desafio-dns">7.2.2.2.8.3.3. Desafío <abbr title="Domain Name Server">DNS</abbr></a></li>
<li><a class="reference internal" href="#el-cliente-certbot">7.2.2.2.8.3.4. El cliente <strong class="command">certbot</strong></a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>Tema anterior</h4>
  <p class="topless"><a href="06.dynamic.html"
                        title="capítulo anterior"><span class="section-number">7.2.2.2.7. </span>Contenido dinámico</a></p>
  <h4>Próximo tema</h4>
  <p class="topless"><a href="08.multiplex.html"
                        title="próximo capítulo"><span class="section-number">7.2.2.2.9. </span>Multiplexación</a></p>
  <div role="note" aria-label="source link">
    <h3>Esta página</h3>
    <ul class="this-page-menu">
      <li><a href="../../../../_sources/07.serre/02.web/02.nginx/02.avanz/07.https.rst.txt"
            rel="nofollow">Mostrar el código</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Búsqueda rápida</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Ir a" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navegación</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../../genindex.html" title="Índice General"
             >índice</a></li>
        <li class="right" >
          <a href="08.multiplex.html" title="7.2.2.2.9. Multiplexación"
             >siguiente</a> |</li>
        <li class="right" >
          <a href="06.dynamic.html" title="7.2.2.2.7. Contenido dinámico"
             >anterior</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../../index.html">documentación de Linuxnomicón - rolling</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../../index.html" ><span class="section-number">7. </span>Servicios de red</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="../../index.html" ><span class="section-number">7.2. </span>Web</a> &#187;</li>
          <li class="nav-item nav-item-3"><a href="../index.html" ><span class="section-number">7.2.2. </span>nginx</a> &#187;</li>
          <li class="nav-item nav-item-4"><a href="index.html" ><span class="section-number">7.2.2.2. </span>Configuración</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href=""><span class="section-number">7.2.2.2.8. </span>Conexión segura</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Derechos de autor CC BY 4.0, 2016-2022, José Miguel Sánchez Alés.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 4.3.2.
    </div>
  </body>
</html>