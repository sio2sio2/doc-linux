


<!DOCTYPE html>

<html lang="es">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>7.2.2.2.8. Conexión segura &#8212; documentación de Linuxnomicón - rolling</title>
    <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../../../../_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="../../../../_static/custom.css" type="text/css" />
    
    <script id="documentation_options" data-url_root="../../../../" src="../../../../_static/documentation_options.js"></script>
    <script src="../../../../_static/jquery.js"></script>
    <script src="../../../../_static/underscore.js"></script>
    <script src="../../../../_static/doctools.js"></script>
    <script src="../../../../_static/language_data.js"></script>
    <script src="../../../../_static/translations.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <link rel="index" title="Índice" href="../../../../genindex.html" />
    <link rel="search" title="Búsqueda" href="../../../../search.html" />
    <link rel="next" title="7.2.2.2.9. Multiplexación" href="08.multiplex.html" />
    <link rel="prev" title="7.2.2.2.7. Contenido dinámico" href="06.dynamic.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navegación</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../../genindex.html" title="Índice General"
             accesskey="I">índice</a></li>
        <li class="right" >
          <a href="08.multiplex.html" title="7.2.2.2.9. Multiplexación"
             accesskey="N">siguiente</a> |</li>
        <li class="right" >
          <a href="06.dynamic.html" title="7.2.2.2.7. Contenido dinámico"
             accesskey="P">anterior</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../../index.html">documentación de Linuxnomicón - rolling</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../../index.html" ><span class="section-number">7. </span>Servicios de red</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="../../index.html" ><span class="section-number">7.2. </span>Web</a> &#187;</li>
          <li class="nav-item nav-item-3"><a href="../index.html" ><span class="section-number">7.2.2. </span>nginx</a> &#187;</li>
          <li class="nav-item nav-item-4"><a href="index.html" accesskey="U"><span class="section-number">7.2.2.2. </span>Configuración</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href=""><span class="section-number">7.2.2.2.8. </span>Conexión segura</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="conexion-segura">
<span id="https"></span><h1><span class="section-number">7.2.2.2.8. </span>Conexión segura<a class="headerlink" href="#conexion-segura" title="Enlazar permanentemente con este título">¶</a></h1>
<p>El protocolo <abbr title="HyperText Transfer Protocol">HTTP</abbr> no es seguro para la transmisión de contraseñas y otros
datos confidenciales, puesto que toda la información viaja en claro. La
solución, como en el caso de otros protocolos no seguros, es encapsularlo dentro
del protocolo criptográfico <abbr title="Secure Socket Layer">SSL</abbr>/<abbr title="Transport Layer Security">TLS</abbr><a class="footnote-reference brackets" href="#id9" id="id1">1</a>, a fin de que el protocolo viaje
cifrado. Al <abbr title="HyperText Transfer Protocol">HTTP</abbr> encapsulado dentro de <abbr title="Transport Layer Security">TLS</abbr> es a lo que se denomina <abbr title="HTTP seguro">HTTPs</abbr>
Por lo general, el puerto reservado para comunicación <abbr title="HTTP seguro">HTTPs</abbr> es el <em>443/TCP</em>.</p>
<p>Consecuentemente, hacer que un servidor ofrezca páginas seguras se limita a:</p>
<ul class="simple">
<li><p>Obtener un certificado que permita el cifrado <abbr title="Transport Layer Security">TLS</abbr>.</p></li>
<li><p>Desarrollar la configuración que hace que el servidor escuche en el puerto
<strong>443</strong> tal como se hace cuando sirve <abbr title="HyperText Transfer Protocol">HTTP</abbr>, pero indicando que en este caso
debe usar el certificado anterior para cifrar.</p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>Encapsular el tráfico <abbr title="HyperText Transfer Protocol">HTTP</abbr> dentro de <abbr title="Transport Layer Security">TLS</abbr> supone que todos los
paquetes viajan cifrados y que, en consecuencia, todo el contenido <abbr title="HyperText Transfer Protocol">HTTP</abbr>,
incluida la cabecera, está cifrado. Esto inutiliza cualquier cacheo de
contenido o cualquier filtrado web que se base en la <abbr title="Uniform Resource Locator">URL</abbr> o el propio
contenido.<a class="footnote-reference brackets" href="#id10" id="id2">2</a></p>
</div>
<div class="section" id="obtencion-del-certificado">
<span id="tls-cert"></span><h2><span class="section-number">7.2.2.2.8.1. </span>Obtención del certificado<a class="headerlink" href="#obtencion-del-certificado" title="Enlazar permanentemente con este título">¶</a></h2>
<p>Para la obtención del certificado podemos optar por dos vías: crear un
certificado autofirmado o hacernos con un certificado expedido por una autoridad
acreditadora.</p>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>Estos certificados no son exclusivos para el servicio web. Son
certificados que se usan con el protocolo <abbr title="Transport Layer Security">TLS</abbr> y, en consecuencia, sirven
para cualquier protocolo que se cifre con él. Por ejemplo, también son
válidos para usados con los protocolos <abbr title="Simple Mail Transfer Protocol">SMTP</abbr> o <abbr title="Internet Message Access Protocol">IMAP</abbr>.</p>
</div>
<div class="section" id="autofirmado">
<span id="auto-cert"></span><h3><span class="section-number">7.2.2.2.8.1.1. </span>Autofirmado<a class="headerlink" href="#autofirmado" title="Enlazar permanentemente con este título">¶</a></h3>
<p>La ventaja de hacer un certificado así es la inmediatez y gratuidad de su
obtención, pero a costa de no ser confiable para el cliente, que tendrá que
hacer un acto de fe al aceptarlo la primera vez que lo recibe.</p>
<div class="admonition warning">
<p class="admonition-title">Advertencia</p>
<p>Con toda lógica, los navegadores cada vez son más estrictos en la
admisión de estos certificados autofirmados y, además, hay proxies web que
los rechazan e impiden la conexión de los clientes a los que protegen. Por
tanto, lo más recomendable es pasarse al siguiente epigrafe.</p>
</div>
<span class="target" id="make-ssl-cert"></span><p id="index-0">Para la creación de certificados, debe usarse <strong class="command">openssl</strong><a class="footnote-reference brackets" href="#id11" id="id3">3</a>. El método
más sencillo, no obstante, es hacerlo mediante <strong class="command">make-ssl-cert</strong>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> apt-get install ssl-cert
</pre></div>
</div>
<p>La postinstalación genera directamente la clave private en
<code class="file docutils literal notranslate"><span class="pre">/etc/ssl/private/ssl-cert-snakeoil.key</span></code> y la pública en
<code class="file docutils literal notranslate"><span class="pre">/etc/ssl/certs/ssl-cert-snakeoil.pem</span></code> y crea un certificado para el
nombre completo de la máquina<a class="footnote-reference brackets" href="#id12" id="id4">4</a>. Si nuestra intención es que el certificado
sirva para distintos nombres (por ejemplo, porque tenemos definidos varios
dominios virtuales), entonces es necesario volver a generar los certificados:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> make-ssl-cert /usr/share/ssl-cert/ssleay.cnf keycert.pem
</pre></div>
</div>
<p>Así, mediante una interfaz amigable hecha en <a class="reference internal" href="../../../../03.scripts/06.misc/05.whiptail.html#whiptail"><span class="std std-ref">whiptail</span></a>, podemos
generar otro distinto. La manera más sencilla de obtener un certificado válido
para cualquier nombre del domino es contestar a la primera pregunta con
<kbd class="kbd docutils literal notranslate">*.example.net</kbd>. La segunda podemos dejarla en blanco. La orden genera un
único fichero con las claves pública y privada. Para separarlas y dejarlas en su
ubicación predeterminada:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> sed <span class="s1">&#39;1,/-END PRIVATE KEY-/d&#39;</span> keycert.pem &gt; /etc/ssl/certs/ssl-cert-snakeoil.pem
<span class="gp">#</span> sed <span class="s1">&#39;/-END PRIVATE KEY-/q&#39;</span> keycert.pem &gt; /etc/ssl/private/ssl-cert-snakeoil.key
</pre></div>
</div>
<p>¡Y listo! Ya tenemos un certificado no fiable para crear conexiones <abbr title="Secure Socket Layer">SSL</abbr>.</p>
</div>
<div class="section" id="acreditado">
<span id="certbot"></span><h3><span class="section-number">7.2.2.2.8.1.2. </span>Acreditado<a class="headerlink" href="#acreditado" title="Enlazar permanentemente con este título">¶</a></h3>
<p>El principal problema de estos certificados es que siempre ha habido que pagar
por ellos. Sin embargo, desde mediados de 2016, una autoridad de certificación,
<cite>Let”s Encrypt</cite>, facilita la obtención gratuita de certificados de un modo
bastante cómodo. Tienen la desventaja de que caducan a los tres meses, pero
proporcionan un mecanismo automático de renovación bastante cómodo.</p>
<p>Para la creación y renovación de estos certificados acreditados, necesitamos
instalar el paquete <em>certbot</em>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> apt-get install certbot
</pre></div>
</div>
<p>Antes, no obstante, de usar el programa es preciso entender cómo <em>Let’s Encrypt</em>
se cerciora de que somos quien decimos ser. Como la aplicación corre en el
servidor que usará el certificado, se supone que al conectar vía web a la
máquina con cuyo nombre pedimos el certificado, se accede efectivamente a ella.
Como esto es así, <strong class="command">certbot</strong> deja localmente en el directorio accesible
por el servidor web unos ficheros y, desde sus servidores intenta acceder a
ellos vía web: si lo consigue es que somos los propietarios del nombre y, por
tanto, ha comprobado nuestra identidad y puede emitirnos el certificado.</p>
<p>Como los certificados se usaran luego con distinto <em>software</em>,
<strong class="command">certbot</strong> tiene distintos <em>plugins</em> para, además de crear o renover el
certificado, proceder a su instalación en ellos. Nosotros, no obstante, sólo
repararemos en dos:</p>
<ul class="simple">
<li><p><strong>standalone</strong>, que debe usarse si prevemos que no tendremos ocupado nunca el
puerto <strong>80</strong>. Con este <em>plugin</em>, el propio <strong class="command">certboot</strong> levanta
temporalmente un servidor web en el proceso de creación o renovación. No debe
usarse si montamos un servidor web, porque en ese caso, la renovación fallará
levantando el servidor web temporal al encontrar ocupado el puerto.</p></li>
<li><p><strong>webroot</strong>, que implica tener un servidor web instalado e indicarle a
<strong class="command">certboot</strong> cuál es el directorio raíz del mismo.</p></li>
</ul>
<p>Nosotros usaremos este último, suponiendo que ya tenemos listo el servidor web y
que nuestro directorio raíz es <code class="file docutils literal notranslate"><span class="pre">/srv/www</span></code>, Tras ello, podemos lanzar la
generación del certificado así:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> certbot certonly --webroot -w /srv/www -d www.example.net <span class="se">\</span>
   --non-interactive --agree-tos --email licencias@iesmiravent.es <span class="se">\</span>
   --post-hook <span class="s2">&quot;/etc/letsencrypt/posthook.sh&quot;</span>
</pre></div>
</div>
<p>Como resultado de la orden tendremos dentro de
<code class="file docutils literal notranslate"><span class="pre">/etc/letsencrypt/live/www.example.net</span></code> las claves generadas y, además,
justamente tras la generación, se habrá ejecutado el <em>script</em> que pasemos con la
opción <code class="docutils literal notranslate"><span class="pre">--post-hook</span></code><a class="footnote-reference brackets" href="#id13" id="id5">5</a>.  Lo que realmente haya que hacer para que la nueva
clave sea efectiva dependerá de cómo se tenga configurado el servidor. La gracia
de incluir el <em>script</em> es que <em>certboot</em> viene con un <em>timer</em> de
<strong class="program">systemd</strong> para intentar diariamente la renovación del <em>script</em> y que
este proceso de renovación también lanza el <em>script</em>. Por tanto, podremos
olvidarnos por completo de estar al tanto de la actualización.</p>
<p>En un configuración simple en que el propio <strong class="program">nginx</strong> se encarga del
cifrado y utilizamos la configuración propuesta en el próximo epígrafe, basta
con que el <em>script</em> se limite a reiniciar <strong class="program">nginx</strong>. Por tanto:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="ch">#!/bin/sh</span>

systemctl reload-or-restart nginx.service
</pre></div>
</div>
<p>Para casos más complejos, como cuando del cifrado se encarga <a class="reference internal" href="../../../05.proxies/03.reverse/01.multi.html#haproxy"><span class="std std-ref">haproxy</span></a>, es
necesario juntar las claves pública y privada (<code class="file docutils literal notranslate"><span class="pre">fullchain.pem</span></code> y
<code class="file docutils literal notranslate"><span class="pre">privkey.pem</span></code>) en un único fichero. <a class="reference download internal" download="" href="../../../../_downloads/d35614dfdda1cbcc8de5d4fd26d80ccf/posthook.sh"><code class="xref download docutils literal notranslate"><span class="pre">Este</span> <span class="pre">script</span></code></a> se encarga de ello.</p>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>Es posible también generar un certificado asociados a varios nombres
repitiendo las opciones <code class="docutils literal notranslate"><span class="pre">-w</span></code> y <code class="docutils literal notranslate"><span class="pre">-d</span></code>, de modo que las opciones <code class="docutils literal notranslate"><span class="pre">-d</span></code>
harán referencia al <code class="docutils literal notranslate"><span class="pre">-w</span></code> que las precede. Por ejemplo:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> certbot certonly --webroot -w /srv/www/main -d example.net -d www.example.net <span class="se">\</span>
   -w /srv/www/blog -d blog.example.net --non-interactive --agree-tos <span class="se">\</span>
   --email licencias@iesmiravent.es --post-hook <span class="s2">&quot;/etc/letsencrypt/posthook.sh&quot;</span>
</pre></div>
</div>
</div>
<p>Es común que en algún momento añadamos un nuevo sitio al servidor y necesitemos
que este sitio también use cifrado. Podemos ampliar el uso del mismo
certificado al nuevo sitio usando la opción <code class="docutils literal notranslate"><span class="pre">--expand</span></code>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> certbot certonly --webroot --expand -w /srv/www -d www.example.net <span class="se">\</span>
   -w /srv/www/moodle -d moodle.example.net <span class="se">\</span>
   --non-interactive --agree-tos --email licencias@iesmiravent.es <span class="se">\</span>
   --post-hook <span class="s2">&quot;/etc/letsencrypt/posthook.sh&quot;</span>
</pre></div>
</div>
<p>Hay, eso sí, que enumerar todos los dominios a los que ya estaba asociado el
servidor y añadir los nuevos.</p>
</div>
</div>
<div class="section" id="configuracion">
<span id="nginx-https"></span><h2><span class="section-number">7.2.2.2.8.2. </span>Configuración<a class="headerlink" href="#configuracion" title="Enlazar permanentemente con este título">¶</a></h2>
<p>Para configurar un dominio virtual servidor por <abbr title="HyperText Transfer Protocol">HTTP</abbr>s es necesario crear el
fichero <code class="file docutils literal notranslate"><span class="pre">/etc/nginx/conf.d/ssl.conf</span></code><a class="footnote-reference brackets" href="#id14" id="id6">6</a> que dependiendo de cómo hallamos
generado el certificado variará:</p>
<ul class="simple">
<li><p>Para el certificado autofirmado, <a class="reference download internal" download="" href="../../../../_downloads/1ec2f25228054e31dee6daac579628b6/ssl.auto.conf"><code class="xref download docutils literal notranslate"><span class="pre">éste</span></code></a>.</p></li>
<li><p>Para el certificado con <em>Let’s Encrypt</em> <a class="reference download internal" download="" href="../../../../_downloads/13be357bc660bedf832bcaec8fbc885f/ssl.certbot.conf"><code class="xref download docutils literal notranslate"><span class="pre">este</span> <span class="pre">otro</span></code></a>.</p></li>
</ul>
<p>Luego, tomando como referencia la configuración más básica, basta con incluir
los siguientes cambios:</p>
<div class="highlight-nginx notranslate"><div class="highlight"><pre><span></span><span class="k">server</span> <span class="p">{</span>
<span class="hll">   <span class="kn">listen</span>   <span class="mi">443</span> <span class="s">ssl</span><span class="p">;</span>
</span>
   <span class="kn">server_name</span> <span class="s">_</span><span class="p">;</span>

   <span class="kn">root</span> <span class="s">/srv/www</span><span class="p">;</span>
   <span class="kn">try_files</span> <span class="nv">$uri</span> <span class="nv">$uri/</span> <span class="p">=</span><span class="mi">404</span><span class="p">;</span>

<span class="hll">   <span class="kn">include</span> <span class="s">snippets/snakeoil.conf</span><span class="p">;</span>
</span><span class="p">}</span>
</pre></div>
</div>
<p>O sea, incluimos un fichero <code class="file docutils literal notranslate"><span class="pre">/etc/nginx/snippets/snakeoil.conf</span></code> que
indica cuáles son las claves de cifrado para el sitio y que deben ser las que
genera <a class="reference internal" href="#make-ssl-cert"><span class="std std-ref">make-ssl-cert</span></a>. El fichero ya está incluido en el
paquete de <em>debian</em> y, como no podía ser de otra firma, contiene estas dos
directivas:</p>
<div class="highlight-nginx notranslate"><div class="highlight"><pre><span></span><span class="k">ssl_certificate</span> <span class="s">/etc/ssl/certs/ssl-cert-snakeoil.pem</span><span class="p">;</span>
<span class="k">ssl_certificate_key</span> <span class="s">/etc/ssl/private/ssl-cert-snakeoil.key</span><span class="p">;</span>
</pre></div>
</div>
<p>Sin embargo, el propio fichero avisa que no deberían usarse en un servidor real.
Si hacemos caso y utilizamos las certificadas por <em>Let’s Encrypt</em>, entonces
deberemos indicar las claves que generamos con él de un modo análogo a cómo
hicimos antes:</p>
<div class="highlight-nginx notranslate"><div class="highlight"><pre><span></span><span class="k">server</span> <span class="p">{</span>
<span class="hll">   <span class="kn">listen</span>   <span class="mi">443</span> <span class="s">ssl</span><span class="p">;</span>
</span>
   <span class="kn">server_name</span> <span class="s">_</span><span class="p">;</span>

   <span class="kn">root</span> <span class="s">/srv/www</span><span class="p">;</span>
   <span class="kn">try_files</span> <span class="nv">$uri</span> <span class="nv">$uri/</span> <span class="p">=</span><span class="mi">404</span><span class="p">;</span>

<span class="hll">   <span class="kn">include</span> <span class="s">snippets/letsencrypt.conf</span><span class="p">;</span>
</span><span class="p">}</span>
</pre></div>
</div>
<p>y el fichero <code class="file docutils literal notranslate"><span class="pre">/etc/nginx/snippets/letsencrypt.conf</span></code> queda:</p>
<div class="highlight-nginx notranslate"><div class="highlight"><pre><span></span><span class="k">ssl_certificate</span> <span class="s">/etc/letsencrypt/live/www.example.net/fullchain.pem</span><span class="p">;</span>
<span class="k">ssl_certificate_key</span> <span class="s">/etc/letsencrypt/live/www.example.net/privkey.pem</span><span class="p">;</span>
<span class="k">ssl_trusted_certificate</span> <span class="s">/etc/letsencrypt/live/www.example.net/fullchain.pem</span><span class="p">;</span>
</pre></div>
</div>
<p id="nginx-https-http">Las configuraciones anteriores sólo ofrecerían servicio a través del puerto
<strong>443</strong>. Si queremos ofrecerlo a través del <strong>80</strong> también, podemos hacer lo
siguiente:</p>
<div class="highlight-nginx notranslate"><div class="highlight"><pre><span></span><span class="k">server</span> <span class="p">{</span>
   <span class="kn">listen</span>   <span class="mi">80</span><span class="p">;</span>
   <span class="kn">listen</span>   <span class="mi">443</span> <span class="s">ssl</span><span class="p">;</span>

   <span class="kn">server_name</span> <span class="s">_</span><span class="p">;</span>

   <span class="kn">root</span> <span class="s">/srv/www</span><span class="p">;</span>
   <span class="kn">try_files</span> <span class="nv">$uri</span> <span class="nv">$uri/</span> <span class="p">=</span><span class="mi">404</span><span class="p">;</span>

   <span class="kn">include</span> <span class="s">snippets/snakeoil.conf</span><span class="p">;</span>

   <span class="kn">if</span> <span class="s">(</span><span class="nv">$https</span> <span class="s">!=</span> <span class="s">&quot;on&quot;)</span> <span class="p">{</span>
      <span class="kn">return</span> <span class="mi">301</span> <span class="s">https://</span><span class="nv">$host$uri$is_args$args</span><span class="p">;</span>
   <span class="p">}</span>

   <span class="c1"># Cabecera HSTS (fuerza a que el certificado sea válido)</span>
   <span class="kn">add_header</span> <span class="s">Strict-Transport-Security</span> <span class="s">&quot;max-age=31536000</span><span class="p">;</span> <span class="kn">includeSubDomains&quot;</span> <span class="s">always</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="admonition warning">
<p class="admonition-title">Advertencia</p>
<p>El <code class="docutils literal notranslate"><span class="pre">if</span></code> provoca que, si el tráfico es no seguro, se repita la
petición por el puerto seguro. Si queremos permitir ambos podemos eliminar
este bloque. Añadimos, además, la cabecera <abbr title="HTTP Strict Transport Security">HSTS</abbr> para informar al cliente de
que use <abbr title="HyperText Transfer Protocol">HTTP</abbr>sy de que no acepte bajo ningún concepto un certificado no
fiable (p.e. uno autofirmado)<a class="footnote-reference brackets" href="#id15" id="id7">7</a>. Para más información, consulte <a class="reference internal" href="../../../../08.redes/99.ataques/02.tecnicas/04.mitm.html#sslstrip"><span class="std std-ref">el
epígrafe dedicado al ataque SSLstrip</span></a>.</p>
</div>
<p class="rubric">Múltiples dominios virtual</p>
<p>Cuando el servidor define varios dominios virtuales y dos o más de ellos usan
tráfico seguro debe tenerse en cuenta que, en principio, el servidor web conoce
cuál es el nombre de máquina usado en la petición a través del comando
<kbd class="kbd docutils literal notranslate">GET</kbd> o las cabeceras <abbr title="HyperText Transfer Protocol">HTTP</abbr>. Al ser el tráfico cifrado, el acceso
a esta información no es accesible hasta que no se use el certificado
correspondiente para descifrarla. Ahora bien, si cada dominio virtual seguro usa
un certificado diferente, ¿cómo puede elegirse el adecuado si el nombre está
cifrado? Para solucionar este problema se creó la <a class="reference internal" href="../../../../09.apendice/01.cryto/03.aplicaciones.html#sni"><span class="std std-ref">extensión SNI</span></a> al
protocolo <abbr title="Secure Socket Layer">SSL</abbr>, que soportan la mayor parte de los navegadores modernos y, muy
probablemente la versión de <strong class="program">nginx</strong> que se esté utilizando:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> nginx -V
</pre></div>
</div>
<p>En caso de que <strong class="program">nginx</strong> soporte <abbr title="Server Name Indication">SNI</abbr>, puede definirse un certificado
diferente en cada sitio a través de <kbd class="kbd docutils literal notranslate">ssl_certificate</kbd> y
<kbd class="kbd docutils literal notranslate">ssl_certificate_key</kbd>. Para los sitios seguros en que no se defina un
certificado, se usará el declarado en el servidor predeterminado<a class="footnote-reference brackets" href="#id16" id="id8">8</a>. Una
configuración posible puede ser esta:</p>
<blockquote>
<div><div class="highlight-nginx notranslate"><div class="highlight"><pre><span></span><span class="k">server</span> <span class="p">{</span>
   <span class="kn">listen</span>   <span class="mi">80</span>       <span class="s">default_server</span><span class="p">;</span>
   <span class="kn">listen</span>   <span class="mi">443</span> <span class="s">ssl</span>  <span class="s">default_server</span><span class="p">;</span>

   <span class="kn">server</span> <span class="s">name</span> <span class="s">_</span><span class="p">;</span>

   <span class="kn">include</span> <span class="s">snippets/letsencrypt.conf</span><span class="p">;</span>

   <span class="c1"># Resto de configuración.</span>
<span class="p">}</span>

<span class="k">server</span> <span class="p">{</span>
   <span class="kn">listen</span> <span class="mi">80</span><span class="p">;</span>
   <span class="kn">listen</span> <span class="mi">443</span><span class="p">;</span>  <span class="c1"># Nótese que no hace falta ni usar ssl.</span>

   <span class="kn">server_name</span>  <span class="s">moodle.example.net</span><span class="p">;</span>

   <span class="c1"># Configuración para moodle</span>
<span class="p">}</span>

<span class="k">server</span>  <span class="p">{</span>
   <span class="kn">listen</span> <span class="mi">80</span><span class="p">;</span>
   <span class="kn">listen</span> <span class="mi">443</span> <span class="s">ssl</span><span class="p">;</span>

   <span class="kn">server_name</span>  <span class="s">alt.example.net</span><span class="p">;</span>

   <span class="kn">include</span> <span class="s">snippets/altcert.conf</span><span class="p">;</span>

   <span class="c1"># Configuración para este sitio.</span>
<span class="p">}</span>
</pre></div>
</div>
</div></blockquote>
<p>Con esta configuración, el sitio <em>moodle.example.net</em> usará el mismo certificado
que el sitio predeterminado (el incluido en <code class="file docutils literal notranslate"><span class="pre">snippets/letsencrypt.conf</span></code>,
mientras que el sitio <em>alt.example.net</em> utiliza un certificado distinto. Podemos
cerciorarnos de que esto realmente funciona haciendo una consulte con el
navegador y consultando los certificados, o desde la consola con
<strong class="command">openssl</strong> al servidor:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> openssl s_client -servername alt.example.net -connect alt.example.net:https &lt; /dev/null <span class="p">|</span> grep <span class="s1">&#39;CN =&#39;</span>
</pre></div>
</div>
<div class="admonition warning">
<p class="admonition-title">Advertencia</p>
<p><strong class="command">openssl</strong> no usa <abbr title="Server Name Indication">SNI</abbr> a menos que se use la opción
<kbd class="kbd docutils literal notranslate"><kbd class="kbd docutils literal notranslate"></kbd>-<kbd class="kbd docutils literal notranslate">servername</kbd></kbd>, de modo que haga las pruebas incluyéndola.</p>
</div>
<p class="rubric">Notas al pie</p>
<dl class="footnote brackets">
<dt class="label" id="id9"><span class="brackets"><a class="fn-backref" href="#id1">1</a></span></dt>
<dd><p><abbr title="Transport Layer Security">TLS</abbr> es simplemente la evolución de la versión 3 de <abbr title="Secure Socket Layer">SSL</abbr>. A menudo
suele decirse <abbr title="Secure Socket Layer">SSL</abbr> para referise también a <abbr title="Transport Layer Security">TLS</abbr>.</p>
</dd>
<dt class="label" id="id10"><span class="brackets"><a class="fn-backref" href="#id2">2</a></span></dt>
<dd><p>En principio, establecer un filtrado de sitios web para clientes sólo
puede hacerse manipulando la resolución <abbr title="Domain Name Server">DNS</abbr>, que sí que no está cifrada.</p>
</dd>
<dt class="label" id="id11"><span class="brackets"><a class="fn-backref" href="#id3">3</a></span></dt>
<dd><p>Por ejemplo, para generar un certificado cuya validez sea de diez
años:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> openssl req -x509 -nodes -days <span class="m">3650</span> -newkey rsa:2048 -keyout /etc/ssl/private/ssl-cert-snakeoil.key <span class="se">\</span>
   -out /etc/ssl/certs/ssl-cert-snakeoil.pem
</pre></div>
</div>
</dd>
<dt class="label" id="id12"><span class="brackets"><a class="fn-backref" href="#id4">4</a></span></dt>
<dd><p>o sea, el que se obtiene así:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> hostname -f
</pre></div>
</div>
</dd>
<dt class="label" id="id13"><span class="brackets"><a class="fn-backref" href="#id5">5</a></span></dt>
<dd><p>También hay una opción <code class="docutils literal notranslate"><span class="pre">-pre-hook</span></code> para ejecutar antes.</p>
</dd>
<dt class="label" id="id14"><span class="brackets"><a class="fn-backref" href="#id6">6</a></span></dt>
<dd><p>Las únicas directivas relativas al cifrado que se encuentran en
<code class="file docutils literal notranslate"><span class="pre">nginx.conf</span></code> son estas:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">ssl_protocols TLSv1 TLSv1.1 TLSv1.2; # Dropping SSLv3, ref: POODLE</span>
<span class="go">ssl_prefer_server_ciphers on</span>
</pre></div>
</div>
<p>de ahí que no se hayan incluido en nuestra propia configuración.</p>
</dd>
<dt class="label" id="id15"><span class="brackets"><a class="fn-backref" href="#id7">7</a></span></dt>
<dd><p>Para más información sobre esta cabecera, consulte <a class="reference internal" href="../../../../08.redes/99.ataques/02.tecnicas/04.mitm.html#sslstrip"><span class="std std-ref">el ataque
SSLstrip</span></a>.</p>
</dd>
<dt class="label" id="id16"><span class="brackets"><a class="fn-backref" href="#id8">8</a></span></dt>
<dd><p>Lo cual no es ningún problema, puesto que un certificado digital se puede
asociar a varios nombres.</p>
</dd>
</dl>
</div>
</div>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../../../../index.html">Tabla de contenido</a></h3>
  <ul>
<li><a class="reference internal" href="#">7.2.2.2.8. Conexión segura</a><ul>
<li><a class="reference internal" href="#obtencion-del-certificado">7.2.2.2.8.1. Obtención del certificado</a><ul>
<li><a class="reference internal" href="#autofirmado">7.2.2.2.8.1.1. Autofirmado</a></li>
<li><a class="reference internal" href="#acreditado">7.2.2.2.8.1.2. Acreditado</a></li>
</ul>
</li>
<li><a class="reference internal" href="#configuracion">7.2.2.2.8.2. Configuración</a></li>
</ul>
</li>
</ul>

  <h4>Tema anterior</h4>
  <p class="topless"><a href="06.dynamic.html"
                        title="capítulo anterior"><span class="section-number">7.2.2.2.7. </span>Contenido dinámico</a></p>
  <h4>Próximo tema</h4>
  <p class="topless"><a href="08.multiplex.html"
                        title="próximo capítulo"><span class="section-number">7.2.2.2.9. </span>Multiplexación</a></p>
  <div role="note" aria-label="source link">
    <h3>Esta página</h3>
    <ul class="this-page-menu">
      <li><a href="../../../../_sources/07.serre/02.web/02.nginx/02.avanz/07.https.rst.txt"
            rel="nofollow">Mostrar el código</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Búsqueda rápida</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Ir a" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navegación</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../../genindex.html" title="Índice General"
             >índice</a></li>
        <li class="right" >
          <a href="08.multiplex.html" title="7.2.2.2.9. Multiplexación"
             >siguiente</a> |</li>
        <li class="right" >
          <a href="06.dynamic.html" title="7.2.2.2.7. Contenido dinámico"
             >anterior</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../../index.html">documentación de Linuxnomicón - rolling</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../../index.html" ><span class="section-number">7. </span>Servicios de red</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="../../index.html" ><span class="section-number">7.2. </span>Web</a> &#187;</li>
          <li class="nav-item nav-item-3"><a href="../index.html" ><span class="section-number">7.2.2. </span>nginx</a> &#187;</li>
          <li class="nav-item nav-item-4"><a href="index.html" ><span class="section-number">7.2.2.2. </span>Configuración</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href=""><span class="section-number">7.2.2.2.8. </span>Conexión segura</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Derechos de autor CC BY 4.0, 2016-2020, José Miguel Sánchez Alés.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 3.3.1.
    </div>
  </body>
</html>