


<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" lang="es">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>7.2.2.2.9. Puerto compartido &#8212; documentación de Linuxnomicón - rolling</title>
    <link rel="stylesheet" href="../../../../_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/custom.css" />
    
    <script type="text/javascript" id="documentation_options" data-url_root="../../../../" src="../../../../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../../../_static/language_data.js"></script>
    <script type="text/javascript" src="../../../../_static/translations.js"></script>
    <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <link rel="index" title="Índice" href="../../../../genindex.html" />
    <link rel="search" title="Búsqueda" href="../../../../search.html" />
    <link rel="next" title="7.2.2.2.10. Otros aspectos" href="08.misc.html" />
    <link rel="prev" title="7.2.2.2.8. Conexión segura" href="07.https.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navegación</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../../genindex.html" title="Índice General"
             accesskey="I">índice</a></li>
        <li class="right" >
          <a href="08.misc.html" title="7.2.2.2.10. Otros aspectos"
             accesskey="N">siguiente</a> |</li>
        <li class="right" >
          <a href="07.https.html" title="7.2.2.2.8. Conexión segura"
             accesskey="P">anterior</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../../index.html">documentación de Linuxnomicón - rolling</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../../index.html" >7. Servicios de red</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="../../index.html" >7.2. Web</a> &#187;</li>
          <li class="nav-item nav-item-3"><a href="../index.html" >7.2.2. nginx</a> &#187;</li>
          <li class="nav-item nav-item-4"><a href="index.html" accesskey="U">7.2.2.2. Configuración</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="puerto-compartido">
<span id="compartido"></span><h1>7.2.2.2.9. Puerto compartido<a class="headerlink" href="#puerto-compartido" title="Enlazar permanentemente con este título">¶</a></h1>
<div class="admonition-todo admonition" id="index-0">
<p class="first admonition-title">Por hacer</p>
<p>Este apartado debe ser más general y trasladarse a <a class="reference internal" href="../../../05.proxies/03.reverse.html#proxy-inverso"><span class="std std-ref">proxies
inversos</span></a> y hacer aquí una pequeña explicación y dar el
enlace:</p>
<ul class="last">
<li><p class="first"><a class="reference external" href="https://superuser.com/a/1343424">Multiplexar directamente con nginx</a>.</p>
</li>
<li><p class="first">Incluir <a class="reference internal" href="../../../../04.servidor/10.ssh/04.adicional.html#haproxy"><span class="std std-ref">haproxy</span></a>.</p>
</li>
<li><p class="first">Referir <a class="reference internal" href="../../../../09.apendice/01.cryto/03.aplicaciones.html#stunnel"><span class="std std-ref">stunnel</span></a> en el apartado de <abbr title="Secure Socket Layer">SSL</abbr>, tanto
en el cliente como en el servidor.</p>
</li>
<li><p class="first">Proxy transparente:</p>
<ul class="simple">
<li><a class="reference external" href="https://blog.inf.re/stunnel-transparent-proxy-to-localhost.html">stunnel transparente</a>.</li>
<li><strong class="program">haproxy</strong> transparente.</li>
<li><a class="reference external" href="https://www.nginx.com/blog/ip-transparency-direct-server-return-nginx-plus-transparent-proxy/">nginx transparente</a>.</li>
</ul>
<p>Es probable que con la técnica usada para <strong class="program">stunnel</strong> se puedan hacer
<strong class="program">haproxy</strong> y <strong class="program">nginx</strong> transparentes aunque el servidor
final esté en la misma máquina.</p>
</li>
</ul>
</div>
<p>Los puertos <strong>80</strong> y <strong>443</strong> son puertos a los que comúnmente todas las redes,
por muy restrictivas que sean, dejan salir ya que de lo contrario ni siquiera
se permitiría la navegación en ellas. Por esto motivo, puede darse el caso de
que, para asegurarnos el acceso, tengamos interés es que nuestro servicio <abbr title="Security SHell">SSH</abbr>
o <abbr title="Virtual Private Network">VPN</abbr> escuche en ellos. Cuando esto es así caben dos posibilidades en el lado
del servidor:</p>
<ul class="simple">
<li>Que no tengamos servidor web y, por tanto, los puertos estén libres.</li>
<li>Que sí tengamos servidor web y, consecuentemente, no podamos ocupar los puertos
con ningún otro servicio.</li>
</ul>
<p>Por su parte, en el lado del cliente hay dos posibilidades también para la red
restringida:</p>
<ul class="simple">
<li>Que no haya vigilancia sobre esos puertos y, por tanto, pueda enviarse
tráfico no web.</li>
<li>Que los puertos sí esten vigilados por un proxy y, en consecuencia, el tráfico
deba ser forzosamente web. A este respecto es más común la vigilancia del
puerto <strong>80</strong> que la del puerto <strong>443</strong>.</li>
</ul>
<p>Un cuadro resumen con las alternativas posibles es el siguiente:</p>
<table border="1" class="docutils">
<colgroup>
<col width="11%" />
<col width="13%" />
<col width="76%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Puerto</th>
<th class="head">Vigilancia</th>
<th class="head">Solución</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Libre</td>
<td>No</td>
<td>Poner a escuchar directamente el servicio.</td>
</tr>
<tr class="row-odd"><td>Ocupado</td>
<td>No</td>
<td>Usar un multiplexor como <a class="reference internal" href="../../../05.proxies/03.reverse/01.multi.html#sslh"><span class="std std-ref">sslh</span></a>.</td>
</tr>
<tr class="row-even"><td>Libre</td>
<td>Sí</td>
<td>Enmascarar el tráfico.</td>
</tr>
<tr class="row-odd"><td>Ocupado</td>
<td>Sí</td>
<td>Enmascarar el tráfico y discriminar tráfico a continuación.</td>
</tr>
</tbody>
</table>
<p>Por supuesto, que el puerto esté ocupado depende de nuestro servidor, pero que
la red remota esté sometida a vigilancia depende de cuál sea la red desde la que
se conecta el cliente: en ocasiones no habrá restricción alguna y en otra la
rstricción y vigilancia puede ser máxima. Hay, además, otra circunstancia a
tener en cuenta y es el coste para la conexión de la solución. Es obvio que
escuchar directamente es la solución más ventajosa desde el punto de vista del
rendimiento, mientras que tener que enmascarar el tráfico y, además, deber
discriminar tráfico por compartir el puerto la más costosa.</p>
<p>Las posibles soluciones para puerto compartido, ajustadas a la necesidad, son:</p>
<ul class="simple">
<li><a class="reference internal" href="../../../05.proxies/03.reverse/01.multi.html#multiplexor"><span class="std std-ref">Multiplexar los tráficos</span></a>, esto es, colocar en el puerto
<strong>443</strong> un servicio que identifique de qué tipo es cada tráfico y lo redirija
al servicio final adecuado. Como cada tráfico circula sin modificaciones, la
solución es inútil si un <em>proxy</em> comprueba si el tráfico de salida hacia el
puerto <strong>443</strong> es tráfico <abbr title="Secure Socket Layer">SSL</abbr>.</li>
<li>Enmascarar el tráfico haciéndolo pasar como una aplicación que usa <a class="reference external" href="https://v0ctor.me/websocket">Websocket</a>.. Como <em>Websocket</em> forma parte del estándar
HTML5, la comunicación debería ser aceptada incluso en presencia de un <em>proxy</em>.
Aún con ello, si se usa una comunicación sin cifrar, en teoría, se podría
analizar cuál es el tráfico de la aplicación que usa <em>websocket</em> y rechazarlo.</li>
<li>Enmascarar el tráfico cifrándolo con <abbr title="Secure Socket Layer">SSL</abbr> y enviándolo al puerto <strong>443</strong>.
Esto lo haría indistiguible del tráfico <abbr title="HyperText Transfer Protocol">HTTP</abbr>s por cualquier proxy y, <em>en
consecuencia</em>, irrestringible. La contrapartida es que se añade un cifrado
sonre un protocolo ya cifrado (<abbr title="Security SHell">SSH</abbr> o <abbr title="Virtual Private Network">VPN</abbr>) lo que disminuye enormemente el
rendimiento. Es obvio que la solución de tunelizar con <em>Websocket</em> también
puede llevarse a cabo sobre <abbr title="HyperText Transfer Protocol">HTTP</abbr>s, pero no añade más que un poco de
pérdida de rendimiento. Ahora bien, si se implementó la solución de
<em>Websocket</em> para <abbr title="HyperText Transfer Protocol">HTTP</abbr>, puede ser interesante, ya que la configuración
adicional sería mínima.</li>
</ul>
<div class="section" id="nginx-websocket">
<span id="id1"></span><h2>7.2.2.2.9.1. Websocket<a class="headerlink" href="#nginx-websocket" title="Enlazar permanentemente con este título">¶</a></h2>
<p>Para la segunda estrategia necesitamos un programa, como <a class="reference external" href="https://github.com/erebe/wstunnel">el proxy wstunnel</a>, que
permita al servicio que deseamos utilizar (<abbr title="Security SHell">SSH</abbr>, <abbr title="Virtual Private Network">VPN</abbr> o cualquier otro) el
paso por el <em>Websocket</em>.  Este programa actuará tanto en la parte cliente como
en la servidor, de manera que el cliente (pongamos que <abbr title="Security SHell">SSH</abbr>) conecta con él y no con el servidor.
él conecta con su correspondiente parte servidor y, finalmente, esta parte servidor
le entrega el tráfico al servidor <abbr title="Security SHell">SSH</abbr>:</p>
<img alt="../../../../_images/websocket.png" src="../../../../_images/websocket.png" />
<p>En el gráfico situamos en la parte delantera del cliente y el servidor los
servicios expuestos (porque escuchan en la interfaz física) y en la trasera los
no expuestos (porque escuchan en la interfaz de <em>loopback</em>). Obsérvese que como
el servidor <abbr title="Security SHell">SSH</abbr> sigue expuesto, en las redes remotas en que no hay
restricciones seguirá pudiéndose acceder a él directamente.</p>
<p>Ahora bien, si requerimos compartir el puerto del servidor con un servicio web
normal, entonces deberemos colocar un <em>proxy</em> inverso que redirija el tráfico
hacia el <em>backend</em> apropiado:</p>
<img alt="../../../../_images/websocket-compartido.png" src="../../../../_images/websocket-compartido.png" />
<p>En este caso, nuestro <em>proxy</em> es el propio <strong class="program">nginx</strong>, por lo que las
peticiones <em>web</em> podrá gestionarlas él mismo.</p>
<div class="section" id="wstunnel">
<span id="id2"></span><h3>7.2.2.2.9.1.1. <strong class="program">wstunnel</strong><a class="headerlink" href="#wstunnel" title="Enlazar permanentemente con este título">¶</a></h3>
<p>No tiene paquete en <em>Debian</em>, así que debemos instalarlo a mano. El propio
respositorio de <a class="reference external" href="https://github.com">Github</a> facilita una versión compilada para <em>64bits</em>, así que la
instalación puede limitarse a descargar el fichero precompilado y colocarlo en
algún lugar adecuado en el <em>PATH</em> (típicamente <code class="file docutils literal notranslate"><span class="pre">/usr/local/bin</span></code>). Su uso es
bastante sencillo: debemos instalarlo tanto en la máquina servidor como en la
máquina cliente (véanse lo esquemas superiores).</p>
<dl class="docutils">
<dt><strong>Servidor</strong></dt>
<dd><p class="first">En la máquina servidor, que es lo que realmente nos interesa a efectos de
este epígrafe, debe escuchar según nos interese. Por ejemplo, así:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> wstunnel -v --server ws://0.0.0.0
</pre></div>
</div>
<p>lo cual supone que la aplicación escuche sin cifrado en el puerto <strong>80</strong>
(<em>ws</em>) de todas las interfaces los datos tunelizados. Podríamos modificar la
escucha cambiando el protocolo por <em>wss</em> que cifrará y escuchará por el
<strong>443</strong>. Si nos interesara, podríamos alterar los puertos prefijados también
(p.e. <kbd class="kbd docutils literal notranslate">ws://0.0.0.0:8080</kbd>). A qué aplicación se redirijan los datos
dependerá de lo que se especifique en el cliente. La línea anterior supone
exponer <strong class="program">wstunnel</strong> (tal como representa la primera figura) y como no
se ha establecido ninguna restricción sobre el destino del tráfico, esto
podría propiciar que cualquier máquina utilizara ilegítimamente nuestro
túnel. Así pues, cuando se expone el túnel lo más prudente es restringir el
destino:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> wstunnel -v --server ws://0.0.0.0 -r <span class="m">127</span>.0.0.1:22
</pre></div>
</div>
<p>que sólo aceptará tráfico de clientes que indiquen que el tráfico debe
mandarse al servicio <abbr title="Security SHell">SSH</abbr> local a la parte servidor, o sea, a un servidor
<abbr title="Security SHell">SSH</abbr> que está conectado en la misma máquina.</p>
<p>Para resolver la situación en la que queremos compartir el puerto y exponemos
el <em>proxy</em> (o sea, <strong class="program">nginx</strong>) y no <strong class="program">wstunnel</strong> basta con que
hagamos que éste último escuche en algún puerto libre de una interfaz de <em>loopback</em>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> wstunnel -v --server ws://127.0.0.1:8080
</pre></div>
</div>
<p class="last">en que podemos hacer exactamente la misma puntualización a la restricción
sobre el destino.</p>
</dd>
<dt><strong>Cliente</strong></dt>
<dd><p class="first">En la máquina cliente establecemos el otro extremo del túnel de este modo:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> wstunnel -v -L <span class="m">12345</span>:127.0.0.1:22 ws://203.0.113.1
</pre></div>
</div>
<p>donde hemos supuesto que la máquina servidor tiene la <abbr title="Internet Protocol">IP</abbr> <em>203.0.113.1</em>.  En
este extremo del túnel indicamos a <strong class="program">wstunnel</strong> que el tráfico que
escuche por el puerto <strong>12345</strong> de la interfaz de <em>loopback</em> debe ser
dirigido en el servidor al puerto <strong>22</strong> de la interfaz de <em>loopback</em> (del
servidor claro está). Esto supone que si queremos usar el túnel, el cliente
<abbr title="Security SHell">SSH</abbr> deberá conectar al puerto <strong>12345* de *lo*. Ha de hacerse notar que
el que no se cifra y conectamos al puerto **80</strong>, es coherente con el modo en
que arrancamos <strong class="program">wstunnel</strong> en el servidor.</p>
<p>Es importante señalar también que al no haber especificado en el cliente, el
puerto <strong>12345</strong> en el cliente y el puerto <strong>22</strong> en el servidor son <abbr title="Transmission Control Protocol">UDP</abbr>.
Sin embargo, <strong class="program">wstunnel</strong> tiene capacidad para tunelizar protocolos
<abbr title="User Datagram Protocol">UDP</abbr> con tan solo indicarlo al arrancar el cliente (en el lado del servidor
todo sigue igual):</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> wstunnel -v --udp --udpTimeoutSec -1 -L <span class="m">12345</span>:127.0.0.1:1194 ws://203.0.113.1
</pre></div>
</div>
<p>En este caso el cliente escucha en el puerto <em>12345/UDP</em> y en el servidor los
datos acaban dirigidos al puerto <em>1194/UDP</em>.</p>
<p>Por último, cuando en el servidor colocamos un <em>proxy</em> que recibe distinto
tráfico y debe identificar cuál es el dirigido al <em>websocket</em> podremos usar
un nombre específico de máquina:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> wstunnel -v -L <span class="m">12345</span>:127.0.0.1:22 ws://ssh.example.net
</pre></div>
</div>
<p>o incluso una ruta:</p>
<div class="last highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> wstunnel -v -L <span class="m">12345</span>:127.0.0.1:22 ws://www.example.net/ssh
</pre></div>
</div>
</dd>
<dt><strong>Ejemplo de uso</strong></dt>
<dd><p class="first">Para ilustrar el uso de <strong class="program">wstunnel</strong>, podemos hacer lo siguiente en el
<strong>servidor</strong>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> wstunnel -v --server ws://0.0.0.0 -r <span class="m">127</span>.0.0.1:11111
</pre></div>
</div>
<p>y poner a escuchar el simple <a class="reference internal" href="../../../../02.conbas/99.misc/05.ordenes.html#netcat"><span class="std std-ref">netcat</span></a>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> netcat -l -p <span class="m">11111</span>
</pre></div>
</div>
<p>En el <strong>cliente</strong>, establecemos el otro extremo del túnel así:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> wstunnel -v -L <span class="m">22222</span>:127.0.0.1:11111 ws://203.0.113.1
</pre></div>
</div>
<p>y utilizamos <a class="reference internal" href="../../../../02.conbas/99.misc/05.ordenes.html#netcat"><span class="std std-ref">netcat</span></a> para conversar con el del servidor:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> netcat localhost <span class="m">22222</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Nota</p>
<p>En este caso concreto en el cliente podemos simplificar ejecutando:</p>
<div class="last highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> wstunnel -v -L stdio:127.0.0.1:11111 ws://203.0.113.1
</pre></div>
</div>
</div>
<p class="last">que hace que el <strong class="program">wstunnel</strong> del cliente no converse con el puerto
<strong>22222</strong>, sino con la entrada y salida estándar, por lo que pondemos
ahorranos la ejecución de <a class="reference internal" href="../../../../02.conbas/99.misc/05.ordenes.html#netcat"><span class="std std-ref">netcat</span></a> en el cliente.</p>
</dd>
</dl>
</div>
<div class="section" id="nginx">
<span id="nginx-wstunnel"></span><h3>7.2.2.2.9.1.2. <strong class="program">nginx</strong><a class="headerlink" href="#nginx" title="Enlazar permanentemente con este título">¶</a></h3>
<p>Cuando queremos compartir el puerto (<strong>80</strong> o <strong>443</strong>) entre distintas
aplicaciones, incluido el propio servidor <em>web</em> es necesario trasladar
<strong class="program">wstunnel</strong> a la interfaz de <em>loopback</em>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> wstunnel -v --server ws://127.0.0.1:8080
</pre></div>
</div>
<p>y poner en la interfaz física a <strong class="program">nginx</strong> con una configuración en la que
podemos definir el fichero <code class="file docutils literal notranslate"><span class="pre">snippets/websocket.conf</span></code>:</p>
<div class="highlight-nginx notranslate"><div class="highlight"><pre><span></span><span class="k">proxy_http_version</span> <span class="mi">1</span><span class="s">.1</span><span class="p">;</span>
<span class="k">proxy_set_header</span> <span class="s">Upgrade</span> <span class="nv">$http_upgrade</span><span class="p">;</span>
<span class="k">proxy_set_header</span> <span class="s">Connection</span> <span class="nv">$connection_upgrade</span><span class="p">;</span>

<span class="k">proxy_set_header</span> <span class="s">X-Forwarded-Host</span> <span class="nv">$host</span><span class="p">;</span>
<span class="k">proxy_set_header</span> <span class="s">X-Forwarded-Proto</span> <span class="nv">$x_forwarded_proto</span><span class="p">;</span>
<span class="k">proxy_set_header</span> <span class="s">X-Forwarded-For</span> <span class="nv">$proxy_add_x_forwarded_for</span><span class="p">;</span>
<span class="k">proxy_set_header</span> <span class="s">Host</span> <span class="nv">$http_host</span><span class="p">;</span>
</pre></div>
</div>
<p>y una configuración de sitio:</p>
<div class="highlight-nginx notranslate"><div class="highlight"><pre><span></span><span class="k">map</span> <span class="nv">$http_upgrade</span> <span class="nv">$connection_upgrade</span> <span class="p">{</span>
   <span class="kn">default</span> <span class="s">upgrade</span><span class="p">;</span>
   <span class="kn">&#39;&#39;</span> <span class="s">close</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">map</span> <span class="nv">$https</span> <span class="nv">$x_forwarded_proto</span> <span class="p">{</span>
   <span class="kn">default</span> <span class="s">http</span><span class="p">;</span>
   <span class="kn">on</span>      <span class="s">https</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">server</span> <span class="p">{</span>
   <span class="kn">listen</span> <span class="mi">80</span><span class="p">;</span>
   <span class="kn">listen</span> <span class="mi">443</span> <span class="s">ssl</span><span class="p">;</span>

   <span class="kn">server_name</span> <span class="s">ws.example.net</span><span class="p">;</span>

   <span class="kn">include</span> <span class="s">snippets/snakeoil.conf</span><span class="p">;</span>

   <span class="kn">location</span> <span class="s">/</span> <span class="p">{</span>
      <span class="kn">proxy_pass</span> <span class="s">http://127.0.0.1:8080</span><span class="p">;</span>
      <span class="kn">include</span> <span class="s">snippets/websocket.conf</span><span class="p">;</span>
   <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>En la configuración aceptamos tanto conexiones cifradas (para lo cual en el
cliente deberíamos usar el protocolo <em>wss</em>) como conexiones sin cifrar. En ambos
casos, la parte servidor de <strong class="program">wstunnel</strong> escucharía usando el protocolo
<em>ws</em>, ya que el extremo del cifrado es el <em>proxy</em>.</p>
<p>En la configuración propuesta se identifica el tráfico del túnel por ir dirigido
al nombre <em>ws.example.net</em> y, como no hemos restringido el destino, podremos con
el mismo túnel dar servicio a varios servidores (<abbr title="Security SHell">SSH</abbr>, <abbr title="Virtual Private Network">VPN</abbr>. etc.).</p>
<div class="admonition-todo admonition" id="index-1">
<p class="first admonition-title">Por hacer</p>
<p class="last">Comprobar si con el cortafuegos podemos restringir los destinos
posibles y mirar una forma de <a class="reference external" href="https://tlbdk.github.io/websocket/ssh/tunnel/2016/04/14/setting-up-websocket-ssh-tunnel.html">hacer wstunnel un servicio de systemd</a>.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Nota</p>
<p>Si la conexión se hubiera identificado con una ruta, no habría más que
haber cambiado la localización:</p>
<div class="last highlight-nginx notranslate"><div class="highlight"><pre><span></span><span class="k">location</span> <span class="s">^~</span> <span class="s">/wireguard/</span> <span class="p">{</span>
   <span class="kn">proxy_pass</span> <span class="s">http://127.0.0.1:8080</span><span class="p">;</span>
   <span class="kn">include</span> <span class="s">snippets/websocket.conf</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="ssl">
<span id="nginx-tunnel-ssl"></span><h2>7.2.2.2.9.2. <abbr title="Secure Socket Layer">SSL</abbr><a class="headerlink" href="#ssl" title="Enlazar permanentemente con este título">¶</a></h2>
<p>La última técnica es cifrar el tráfico con <abbr title="Secure Socket Layer">SSL</abbr> en el cliente y enviarlo al
puerto <strong>443</strong> del servidor. Esto hace este tráfico indistinguible de <abbr title="HyperText Transfer Protocol">HTTP</abbr>s
y, en consecuencia, burlará cualquier restricción.</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../../../../index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">7.2.2.2.9. Puerto compartido</a><ul>
<li><a class="reference internal" href="#nginx-websocket">7.2.2.2.9.1. Websocket</a><ul>
<li><a class="reference internal" href="#wstunnel">7.2.2.2.9.1.1. <strong class="program">wstunnel</strong></a></li>
<li><a class="reference internal" href="#nginx">7.2.2.2.9.1.2. <strong class="program">nginx</strong></a></li>
</ul>
</li>
<li><a class="reference internal" href="#ssl">7.2.2.2.9.2. <abbr title="Secure Socket Layer">SSL</abbr></a></li>
</ul>
</li>
</ul>

  <h4>Tema anterior</h4>
  <p class="topless"><a href="07.https.html"
                        title="capítulo anterior">7.2.2.2.8. Conexión segura</a></p>
  <h4>Próximo tema</h4>
  <p class="topless"><a href="08.misc.html"
                        title="próximo capítulo">7.2.2.2.10. Otros aspectos</a></p>
  <div role="note" aria-label="source link">
    <h3>Esta página</h3>
    <ul class="this-page-menu">
      <li><a href="../../../../_sources/07.serre/02.web/02.nginx/02.avanz/08.compartido.rst.txt"
            rel="nofollow">Mostrar el código</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Búsqueda rápida</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Ir a" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navegación</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../../genindex.html" title="Índice General"
             >índice</a></li>
        <li class="right" >
          <a href="08.misc.html" title="7.2.2.2.10. Otros aspectos"
             >siguiente</a> |</li>
        <li class="right" >
          <a href="07.https.html" title="7.2.2.2.8. Conexión segura"
             >anterior</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../../index.html">documentación de Linuxnomicón - rolling</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../../index.html" >7. Servicios de red</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="../../index.html" >7.2. Web</a> &#187;</li>
          <li class="nav-item nav-item-3"><a href="../index.html" >7.2.2. nginx</a> &#187;</li>
          <li class="nav-item nav-item-4"><a href="index.html" >7.2.2.2. Configuración</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Derechos de autor CC BY 4.0, 2016-2020, José Miguel Sánchez Alés.
      Creado con <a href="http://sphinx-doc.org/">Sphinx</a> 1.8.5.
    </div>
  </body>
</html>