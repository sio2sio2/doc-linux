


<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" lang="es">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>5.4. RAIDs &#8212; documentación de ServidorLinux - 0.1.0</title>
    <link rel="stylesheet" href="../../_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../_static/custom.css" />
    
    <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../_static/language_data.js"></script>
    <script type="text/javascript" src="../../_static/translations.js"></script>
    <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <link rel="index" title="Índice" href="../../genindex.html" />
    <link rel="search" title="Búsqueda" href="../../search.html" />
    <link rel="next" title="5.5. Gestor de arranque" href="../06.grub/index.html" />
    <link rel="prev" title="5.3.2. Clonaciones" href="../04.copias/02.clona/index.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navegación</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="Índice General"
             accesskey="I">índice</a></li>
        <li class="right" >
          <a href="../06.grub/index.html" title="5.5. Gestor de arranque"
             accesskey="N">siguiente</a> |</li>
        <li class="right" >
          <a href="../04.copias/02.clona/index.html" title="5.3.2. Clonaciones"
             accesskey="P">anterior</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">documentación de ServidorLinux - 0.1.0</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" accesskey="U">5. Gestión de discos</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="raids">
<span id="raid"></span><h1>5.4. <abbr title="Redundant Array of Independent Disks">RAID</abbr>s<a class="headerlink" href="#raids" title="Enlazar permanentemente con este título">¶</a></h1>
<div class="section" id="introduccion-teorica">
<h2>5.4.1. Introducción teórica<a class="headerlink" href="#introduccion-teorica" title="Enlazar permanentemente con este título">¶</a></h2>
<p>Un <abbr title="Redundant Array of Independent Disks">RAID</abbr> puede definirse como un sistemas de almacenamiento que, mediante
técnicas <em>hardware</em> o <em>software</em>, utiliza de manera conjunta varios discos para
distribuir los datos entre todos ellos con la finalidad de:</p>
<ul class="simple">
<li>Introducir <strong>redundancia</strong> para hacer el sistema tolerante a fallos, de manera
que aunque falle algún disco, el sistema pueda seguir accediendo a los datos
sin interrupciones</li>
<li>Aumentar la <strong>capacidad</strong> de almacenamiento, esto es, constituir una unidad de
almacenamiento mayor que cada una de los discos físicos por separado.</li>
<li>Aumentar el <strong>rendimiento</strong> en las lecturas y escrituras.</li>
</ul>
<p>Dependiendo de cuál sea el <abbr title="Redundant Array of Independent Disks">RAID</abbr> que se implemente se lograran alcanzar uno o
más de estos propósitos; y el resultado de su implementación será la creación de
un dispositivo virtual sobre el que el sistema operativo podra crear particiones
y sistemas de archivos.</p>
<p class="rubric">Tipos de <abbr title="Redundant Array of Independent Disks">RAID</abbr>s</p>
<p>Hay diversos tipos o niveles de <abbr title="Redundant Array of Independent Disks">RAID</abbr>s, para cuyas descripciones llamaremos
<span class="var">s</span> a la capacidad del disco físico más pequeño y <span class="var">n</span> al número de
discos que lo conforman:</p>
<dl class="docutils">
<dt><strong>RAID 0</strong> (o <strong>Volumen dividido</strong>)</dt>
<dd><p class="first">Se forma con dos o más discos entre los cuales se distribuye equitativamente
la información sin incluir información redudante.</p>
<img alt="../../_images/RAID0.png" src="../../_images/RAID0.png" />
<p>Es conveniente, como en el resto de tipos, que los discos sean de la misma
capacidad, ya que sólo es aprovechable cada disco hasta la capacidad del más
pequeño. En lo referente a los propósitos de <abbr title="Redundant Array of Independent Disks">RAID</abbr>:</p>
<ul class="last simple">
<li>El sistema no es tolerante a fallos, puesto que no existe redundancia. En
consecuencia, no puede romperse ningún disco. Y es más, cuanto mayor sea el
número de discos, menos fiabilidad tendrá el sistema, ya que aumenta la
probabilidad de que uno de ellos falle y se desbarate toda la información.</li>
<li>La capacidad del conjunto es <span class="math notranslate nohighlight">\(c*s\)</span>.</li>
<li>Mejora el rendimiento tanto en la lectura como en la escritura, ya que se
puede leer y escribir simultáneamente en los discos.</li>
</ul>
</dd>
<dt><strong>RAID 1</strong> (o <strong>Espejo</strong>)</dt>
<dd><p class="first">Se forma con dos o más discos de modo que lo que se escribe en uno se
replica en todos los demás.</p>
<img alt="../../_images/RAID1.png" src="../../_images/RAID1.png" />
<p>En este caso, el conjunto es altamente redundante tanto más cuantos más
discos haya, a costa de sacrificar capacidad:</p>
<ul class="last simple">
<li>El sistema es capaz de soportar la ruptura de <span class="math notranslate nohighlight">\(n-1\)</span> discos sin que se
produzca pérdida de información.</li>
<li>No aumenta la capacidad del conjunto que seguirá siendo la capacidad
individual de uno de los discos, <span class="math notranslate nohighlight">\(s\)</span>.</li>
<li>Aumenta el rendimiento de las lecturas, ya que pueden realizarse lecturas
simultáneas, pero no el de escritura.</li>
</ul>
</dd>
<dt><strong>RAID 0+1</strong> (o <strong>Espejo de divisiones</strong>):</dt>
<dd><p class="first">Es un sistema híbrido formado con un mínimo de cuatro discos, de manera que
primero se crean dos dispositivos <abbr title="Redundant Array of Independent Disks">RAID</abbr> 0 que a su vez se toman para
constituir un <abbr title="Redundant Array of Independent Disks">RAID</abbr> 1.</p>
<img alt="../../_images/RAID0+1.png" src="../../_images/RAID0+1.png" />
<p>Con esta disposición:</p>
<ul class="last simple">
<li>Hay tolerancia a fallos, aunque sólo pueden fallar discos de un mismo
<abbr title="Redundant Array of Independent Disks">RAID</abbr> 0. Si fallan discos de distinto <abbr title="Redundant Array of Independent Disks">RAID</abbr> 0, el sistema colapsa.</li>
<li>Aumenta la capacidad hasta <span class="math notranslate nohighlight">\(\frac{n}{2} * s\)</span>.</li>
<li>Hay mejora en el redimiento de lecturas y escrituras.</li>
</ul>
</dd>
<dt><strong>RAID 1+0</strong> (o <strong>Divisiones en espejo</strong> o <strong>RAID 10</strong>):</dt>
<dd><p class="first">El sistema es parecido al anterior, pero se invierten los niveles: primero se
hacen dos divisiones cada una de las cuales la constituyen discos en
<abbr title="Redundant Array of Independent Disks">RAID</abbr> 1 y con estas dos divisiones se forma un <abbr title="Redundant Array of Independent Disks">RAID</abbr> 0. Como en el caso
anterior requieren al menos cuatro discos:</p>
<img alt="../../_images/RAID1+0.png" src="../../_images/RAID1+0.png" />
<p>Esta disposición sopone:</p>
<ul class="last simple">
<li>Gran toleracia a fallos, ya que el sistema falla solamente cuando fallan
todos los discos de una misma división.</li>
<li>Se duplica la capacidad individual: <span class="math notranslate nohighlight">\(2*s\)</span>.</li>
<li>Hay mejora en el rendimiento de las lecturas y las escrituras,</li>
</ul>
</dd>
<dt><strong>RAID 5</strong></dt>
<dd><p class="first">Es un sistema de al menos tres discos fisicos, de manera que la información
se distribuye en todos ellos, excepto en uno en el que se incluye información
de paridad, por lo que es posible recuperar la información ante el fallo de
uno de los discos. La base del cálculo de la paridad es la operación lógica
<em>XOR</em> que se caracteriza porque cuando el número de <strong>1</strong> en los operandos es
impar el resultado es <strong>1</strong> y, cuando es par, <strong>0</strong>. En consecuencia,
suponiendo que los operandos sean <em>bits</em>, obtenemos la siguiente tabla:</p>
<table border="1" class="xor docutils">
<colgroup>
<col width="11%" />
<col width="11%" />
<col width="11%" />
<col width="68%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">O1</th>
<th class="head">O2</th>
<th class="head">O2</th>
<th class="head">O1⊕O2⊕O3</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr class="row-odd"><td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
</tr>
<tr class="row-even"><td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
</tr>
<tr class="row-odd"><td>0</td>
<td>1</td>
<td>1</td>
<td>0</td>
</tr>
<tr class="row-even"><td>1</td>
<td>0</td>
<td>0</td>
<td>1</td>
</tr>
<tr class="row-odd"><td>1</td>
<td>0</td>
<td>1</td>
<td>0</td>
</tr>
<tr class="row-even"><td>1</td>
<td>1</td>
<td>0</td>
<td>0</td>
</tr>
<tr class="row-odd"><td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
</tbody>
</table>
<p>en la que podremos darnos cuenta, que tapemos la columna que tapemos, podemos
deducir sus valores aplicando la operación <em>XOR</em> a los valores de las
columnas aún visibles. En un <abbr title="Redundant Array of Independent Disks">RAID</abbr> 5 el cálculo de la paridad es más
complejo, ya que tal cálculo  se hace a nivel de bloques y el bloque de
paridad se distribuye equitativamente entre todos los discos físicos.</p>
<img alt="../../_images/RAID5.png" src="../../_images/RAID5.png" />
<p>En este tipo:</p>
<ul class="simple">
<li>Es tolerante a fallos en la medida, en que la paridad permite que se pueda
estropear un único disco.</li>
<li>Aumenta la capacidad, ya que la paridad sólo ocupa el equivalente a un
disco físico. Por tanto, obtendremos una capacidad de <span class="math notranslate nohighlight">\((n-1)*s\)</span>.</li>
<li>No hay mejora en el rendimiento de las escrituras, y hay una penalización
en las escrituras, ya que una escritura implica leer datos del resto de
discos para generar la paridad y escribir ésta.</li>
</ul>
<p>Variantes de este nivel son:</p>
<ul class="last simple">
<li>El <abbr title="Redundant Array of Independent Disks">RAID</abbr> 4 en que la información de paridad se almacena siempre en el
mismo disco.</li>
<li>El <abbr title="Redundant Array of Independent Disks">RAID</abbr> 3 en que ocurre lo mismo, pero además, los datos se dividen en
<em>bytes</em> y no en bloques.</li>
<li>El <abbr title="Redundant Array of Independent Disks">RAID</abbr> Z, que es implementado por el sistema de fichero <abbr title="Zettavyte File System">ZFS</abbr> y es
semejante al <abbr title="Redundant Array of Independent Disks">RAID</abbr> 5, pero que añade variantes para mejorar el rendimiento
en las escrituras.</li>
</ul>
</dd>
<dt><strong>RAID 6</strong></dt>
<dd><p class="first">Es parecido a un <abbr title="Redundant Array of Independent Disks">RAID</abbr> 5, pero genera dos bloques de paridad y no uso sólo.
Por tanto, el número mínimo de discos para constituirlo es 4. En él, se
sacrifica la capacidad por el aumento de fiabilidad, ya que pueden fallar
hasta dos discos:</p>
<ul class="simple">
<li>Tolera que fallen hasta dos discos.</li>
<li>Aumenta la capacidad, hasta <span class="math notranslate nohighlight">\((n-2)*s\)</span>.</li>
<li>Presenta los mismos incovenientes de rendimiento que su primo hermano el
<abbr title="Redundant Array of Independent Disks">RAID</abbr>5: no mejora las operaciones de lectura y penaliza las de
escritura.</li>
</ul>
<img alt="../../_images/RAID6.png" class="last" src="../../_images/RAID6.png" />
</dd>
</dl>
<p class="rubric">Particularidades</p>
<p>Sea cuál sea la implementación y el nivel del <abbr title="Redundant Array of Independent Disks">RAID</abbr>, hay una serie de
particularidades que comparten todos los sistemas <abbr title="Redundant Array of Independent Disks">RAID</abbr>:</p>
<ol class="arabic simple">
<li>Al constituirlos es necesario que se creen una serie de <strong>estructuras de
metadatos</strong> a semejanza de lo que ocurre con los sistemas de ficheros.</li>
<li>Habilitan algún mecanismo para advertir al administrador de la <strong>rotura de
disco</strong>, a fin de que este sea diligente en su sustitución. Estos mecanismos
pueden ser muy variados (pitidos, leds), pero suelen incluir el envío de un
correo electrónico de aviso.</li>
<li>Al reemplazarse un dispositivo defectuoso por uno nuevo, se desencadena un
<strong>proceso de recuperación</strong> para volver a la situación previa a la rotura.</li>
<li id="hot-spare">Para minimizar el tiempo de sustitución de un disco defectuoso, algunos
sistemas incorporan un <strong>dispositivo de reserva</strong> (<em>hot spare</em>) que se
encuentra conectado pero inactivo, por lo que no forma parte efectiva del
<abbr title="Redundant Array of Independent Disks">RAID</abbr>. En el momento en que se detecta una avería, el disco de reserva se
incorpora al <abbr title="Redundant Array of Independent Disks">RAID</abbr> y comienza inmediatamente el <em>proceso de recuperación</em>.
La labor del administrador consistirá en añadir al sistema un nuevo disco de
reserva.</li>
</ol>
<p class="rubric">Técnicas de implementación</p>
<p>Hay tres estrategias para la implementación de un sistema <abbr title="Redundant Array of Independent Disks">RAID</abbr>:</p>
<dl class="docutils">
<dt>Mediante <strong>controladora hardware</strong></dt>
<dd><p class="first">Por lo general, a una tarjeta de expansión que hace las veces de controladora
de disco se le conectan los discos físicos que consituirán el <abbr title="Redundant Array of Independent Disks">RAID</abbr>. En este
caso, la configuración se establece mediante un firmware particular de la
propia controladora y se carga con anterioridad al arranque del sistema
operativo, por lo que para el sistema operativo sólo tiene conocimiento de la
existencia del dispositivo virtualizado.</p>
<p class="last">Es la solución más costosa, pero la más eficiente al dedicarse a ella
<em>hardware</em> específico.</p>
</dd>
<dt>Mediante <strong>firmware</strong></dt>
<dd><p class="first">También denominado <em class="dfn">RAID híbrido</em> o <em class="dfn">fakeRAID</em>, que es una solución
barata en la que no hay ninguna controladora específica dedicada a la
constitución del <abbr title="Redundant Array of Independent Disks">RAID</abbr>, sino que el chip de la controladora de disco
incluye <em>firmware</em> específico para la definición del <abbr title="Redundant Array of Independent Disks">RAID</abbr>. Como en el caso
anterior, la configuración del <abbr title="Redundant Array of Independent Disks">RAID</abbr> se hace con anterioridad a la carga del
sistema operativo, por la que éste sólo detecta el dispositivo virtual.</p>
<p class="last">Aunque aparentemente es una solución similiar, al no existir <em>hardware</em>
expecífico dedicado, su rendimiento es peor y, por lo general, es conveniente
una solución <em>software</em> pura.</p>
</dd>
<dt>Mediante <strong>software</strong></dt>
<dd><p class="first">esto es, mediante aplicaciones que provee el propio sistema operativo o
porque sea una característica que soporta el sistema de ficheros. En este
caso, el sistema operativo verá tanto los dispositivos físicos como el
dispositivo virtual resultado de haber constituido el <abbr title="Redundant Array of Independent Disks">RAID</abbr>.</p>
<p>Los sistemas operativos comunes traen herramientas para la creación de
<abbr title="Redundant Array of Independent Disks">RAID</abbr>s:</p>
<ul class="simple">
<li><em>MasOs</em>, <em>FreeBSD</em>, <em>NetBSD</em> o <em>OpenBSD</em> cada uno con sus respectivas
herramientas.</li>
<li><em>Windows</em> gracias a <a class="reference external" href="https://en.wikipedia.org/wiki/Logical_Disk_Manager">Logical Disk Manager</a> y en las versiones modernas
de servidor a <a class="reference external" href="https://en.wikipedia.org/wiki/Features_new_to_Windows_8#Storage">Sorage Spaces</a>.</li>
<li><em>Linux</em> mediante su herramienta <strong class="command">md</strong>, que será a la que dediquemos
el resto del epígrafe.</li>
</ul>
<p class="last">Por su parte, algunos sistemas de ficheros soportan directamente la
constitución de dispositivos <abbr title="Redundant Array of Independent Disks">RAID</abbr> como <abbr title="Zettavyte File System">ZFS</abbr> o <abbr title="B-TRee File System">BtrFS</abbr>.</p>
</dd>
</dl>
<span class="target" id="mdadm"></span></div>
<div class="section" id="raids-en-linux">
<span id="index-0"></span><h2>5.4.2. <abbr title="Redundant Array of Independent Disks">RAID</abbr>s en <em>Linux</em><a class="headerlink" href="#raids-en-linux" title="Enlazar permanentemente con este título">¶</a></h2>
<p><em>Linux</em> dispone de la orden <strong class="command">mdadm</strong> que nos permite crear, destruir y
modificar <abbr title="Redundant Array of Independent Disks">RAID</abbr>s de nivel 0, 1, 5, 6 y 10.</p>
<div class="section" id="preliminares">
<h3>5.4.2.1. Preliminares<a class="headerlink" href="#preliminares" title="Enlazar permanentemente con este título">¶</a></h3>
<p>Es obvio que para nuestras pruebas necesitaremos los discos físicos que
constituyen el <abbr title="Redundant Array of Independent Disks">RAID</abbr>. Para evitarlos usaremos ficheros que emulen estos discos
físicos:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> truncate -s 500M disco1.raw
<span class="gp">#</span> losetup /dev/loop0 disco1.raw
<span class="gp">#</span> truncate -s 500M disco2.raw
<span class="gp">#</span> losetup /dev/loop1 disco1.raw
</pre></div>
</div>
<p>De modo que nuestros dispositivos físicos serán <code class="file docutils literal notranslate"><span class="pre">/dev/loop0</span></code> y
<code class="file docutils literal notranslate"><span class="pre">/dev/loop1</span></code> en vez de <code class="file docutils literal notranslate"><span class="pre">sda</span></code>, <code class="file docutils literal notranslate"><span class="pre">sdb</span></code>, etc.</p>
<div class="admonition warning">
<p class="first admonition-title">Advertencia</p>
<p class="last">Tenga presente que está manipulando directamente dispositivos de
disco, por lo que si confunde las unidades y realiza la operación sobre el
disco que contiene su sistema operativo, lo perderá todo. La guía utiliza
<code class="file docutils literal notranslate"><span class="pre">/dev/loop0</span></code> y <code class="file docutils literal notranslate"><span class="pre">/dev/loop1</span></code> entre otras cosas para evitar que un
<em>corta y pega</em> irreflexivo, provoque una catástrofe en su sistema.</p>
</div>
<p>No obstante, los preparativos no acaban aquí. En el <abbr title="Redundant Array of Independent Disks">RAID</abbr> no debemos incluir
dispositivos físicos, sino particiones, así que necesitamos particionar los
discos. Si pretendemos que nuestro disco contenga el sistema operativo y sea
arrancable, entonces tendremos que dejar el arranque fuera del <abbr title="Redundant Array of Independent Disks">RAID</abbr>.
Suponiendo que utilicemos particionado <abbr title="GUID Partition Table">GPT</abbr> y el disco sea compatible con
arranques <abbr title="Basic I/O System">BIOS</abbr> y <abbr title="Unified Extensible Firmware Interface">UEFI</abbr><a class="footnote-reference" href="#id3" id="id1">[1]</a>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> sgdisk -a <span class="m">8</span> -n <span class="s2">&quot;0:40:2047&quot;</span> -t <span class="s2">&quot;0:0xef02&quot;</span> -c <span class="s2">&quot;0:BOOTBIOS&quot;</span> <span class="se">\</span>
         -a <span class="m">2048</span> -n <span class="s2">&quot;0:2048:+50M&quot;</span> -t <span class="s2">&quot;0:0xef00&quot;</span> -c <span class="s2">&quot;0:EFI&quot;</span> <span class="se">\</span>
                 -N <span class="m">0</span> -c <span class="s2">&quot;3:RAID&quot;</span> -t <span class="s2">&quot;3:0xfd00&quot;</span> /dev/loop0
</pre></div>
</div>
<p>en que creamos dos particiones para el arranque y una partición que ocupa
prácticamente todo el disco encargada de formar parte del <abbr title="Redundant Array of Independent Disks">RAID</abbr>.</p>
<div class="admonition warning">
<p class="first admonition-title">Advertencia</p>
<p class="last">Lo conveniente es que los discos sean del mismo tamaño. Es común,
sin embargo, que si los discos son de diferente fabricante no contengan
exactamente el mismo número de sectores. Asegúrese de hacer esta operación
sobre el disco con menos sectores.</p>
</div>
<p>Podemos llevar a cabo la misma operación sobre <code class="file docutils literal notranslate"><span class="pre">/dev/loop1</span></code>, pero es
más cómodo y más conveniente, simplemente, copiar la tabla de particiones en el
otro disco:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> sgdisk -R /dev/loop1 /dev/loop0
<span class="gp">#</span> sgdisk -G /dev/loop1
</pre></div>
</div>
<p>Hecho lo cual, ya podemos exponer las particiones de ambos discos:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> partx -a /dev/loop0
<span class="gp">#</span> partx -a /dev/loop1
</pre></div>
</div>
</div>
<div class="section" id="creacion">
<h3>5.4.2.2. Creación<a class="headerlink" href="#creacion" title="Enlazar permanentemente con este título">¶</a></h3>
<p>Crearemos un <abbr title="Redundant Array of Independent Disks">RAID</abbr> 1, ya que disponemos de dos discos. La creación de otros
tipos de <abbr title="Redundant Array of Independent Disks">RAID</abbr> suele limitarse, simplemente, a cambiar el nivel:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> mdadm --create /dev/md0 --metadata<span class="o">=</span><span class="m">1</span> --homehost<span class="o">=</span>any --name<span class="o">=</span><span class="m">0</span> --verbose <span class="se">\</span>
        --level<span class="o">=</span><span class="m">1</span> --raid-devices<span class="o">=</span><span class="m">2</span> --assume-clean /dev/loop0p3 /dev/loop1p3
</pre></div>
</div>
<p>Que creará un <abbr title="Redundant Array of Independent Disks">RAID</abbr> 1 (<kbd class="kbd docutils literal notranslate">--level</kbd>) con dos dispositivos físicos. El
dispositivo virtual que representará al <abbr title="Redundant Array of Independent Disks">RAID</abbr> hemos prescrito que se llame
<code class="file docutils literal notranslate"><span class="pre">/dev/md0</span></code>. Además, incluimos la opción <kbd class="kbd docutils literal notranslate">--assume-clean</kbd> para que el
<em>software</em> no intente sincronizar el contenido de ambos discos. En este caso,
la sincronización es una operación absurda, ya que creamos <em>ex novo</em> el <abbr title="Redundant Array of Independent Disks">RAID</abbr>
y, en consecuencia, los discos físicos están vacíos.i</p>
<p class="rubric">Nombre del dispositivo virtual</p>
<p>Como hemos prescrito que sea <code class="file docutils literal notranslate"><span class="pre">/dev/md0</span></code> por esta vez se denominará así.
Sin embargo, cuando el sistema se monte automáticamente el nombre no tiene por
qué conservarse:</p>
<ul>
<li><p class="first">En ausencia de configuración alguna, será <code class="file docutils literal notranslate"><span class="pre">/dev/md127</span></code><a class="footnote-reference" href="#id4" id="id2">[2]</a>.</p>
</li>
<li><p class="first">Si se incluye la opción <kbd class="kbd docutils literal notranslate">--name</kbd> durante la creación y como valor se le
asigna un número, entonces se creará el dispositivo <code class="file docutils literal notranslate"><span class="pre">/dev/mdN</span></code> y el
enlace simbólico <code class="file docutils literal notranslate"><span class="pre">/dev/md/N</span></code>.</p>
</li>
<li><p class="first">Ahora bien, la opción de creación <kbd class="kbd docutils literal notranslate">--homehost</kbd> determina cuál es el
nombre de la máquina que debe hospedar al <abbr title="Redundant Array of Independent Disks">RAID</abbr>. Si su valor es <em>any</em> o
coincide con el nombre de la máquina, entonces se cumple lo indicado en el
punto anterior. En cambio, si no coincide, se utilizará el dispositivo
predeterminado (<code class="file docutils literal notranslate"><span class="pre">/dev/md127</span></code>) y se creará el enlace simbólico
<code class="file docutils literal notranslate"><span class="pre">/dev/md/nombre:N</span></code>. No indicar la opción durante la creación provoca
que <strong class="command">mdadm</strong> tome como valor el nombre actual de la máquina. Por
último, el nombre de la máquina es el que se puede obtener con la orden
<span class="xref std std-ref">hostname</span>, porque en el fichero de configuración
<code class="file docutils literal notranslate"><span class="pre">/etc/mdadm/mdadm.conf</span></code> así se prescribe:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>HOMEHOST &lt;system&gt;
</pre></div>
</div>
<p>Sin embargo puede fijarse otro nombre la configuración y ese será el nombre que tome
en consideración <strong class="command">mdadm</strong>.</p>
<div class="admonition warning">
<p class="first admonition-title">Advertencia</p>
<p class="last">Hay otro consecuencia de que no coincidan el nombre de la máquina
con el «<em>homehost</em>» del <abbr title="Redundant Array of Independent Disks">RAID</abbr>: que el automontaje hará que el dispositivo
se monte en sólo lectura.</p>
</div>
</li>
<li><p class="first">Con independencia de todo lo anterior, en <code class="file docutils literal notranslate"><span class="pre">/etc/mdadm/mdadm.conf</span></code> puede
establecerse cuál es el dispositivo que quiere asociarse al <abbr title="Redundant Array of Independent Disks">RAID</abbr>. Para ello
basta con hacer:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> mdadm --detail --scan
<span class="go">ARRAY /dev/md/xxx:1 metadata=1.2 name=xxx:1 UUID=58fb8eec:f831093a:f521de2d:9c6943a4</span>
</pre></div>
</div>
<p>añadir la salida al fichero y corregir el nombre del dispositivo para que
se ajuste a nuestro gusto (p.e. <code class="file docutils literal notranslate"><span class="pre">/dev/md/0</span></code>). De este modo, podemos
ahorrarnos el prever cómo denominará el <em>software</em> al <abbr title="Redundant Array of Independent Disks">RAID</abbr>.</p>
</li>
</ul>
<div class="admonition note">
<p class="first admonition-title">Nota</p>
<p>Para forzar el montaje automático del <abbr title="Redundant Array of Independent Disks">RAID</abbr> podemos pararlo:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> mdadm --stop /dev/md0
</pre></div>
</div>
<p>y probar a ensamblarlo automáticamente:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> mdadm --assemble --scan
</pre></div>
</div>
<p>Si esto no funciona, aún podemos hacer desaparecer las particiones que forman
el <abbr title="Redundant Array of Independent Disks">RAID</abbr> y hacerlas aparecer de nuevo:</p>
<div class="last highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> partx -d /dev/loop0
<span class="gp">#</span> partx -d /dev/loop1
<span class="gp">#</span> partx -a /dev/loop0
<span class="gp">#</span> partx -a /dev/loop1
</pre></div>
</div>
</div>
<p class="rubric">Disco de reserva (<em>hot spare</em>)</p>
<p>Podemos también crear el <abbr title="Redundant Array of Independent Disks">RAID</abbr> incorporando un <a class="reference internal" href="#hot-spare"><span class="std std-ref">disco de reserva</span></a>. Así, suponiendo que hubiéramos creado un fichero-disco más y
lo hubiéramos asociado a <code class="file docutils literal notranslate"><span class="pre">/dev/loop2</span></code>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> mdadm --create /dev/md0 --metadata<span class="o">=</span><span class="m">1</span> --homehost<span class="o">=</span>any --name<span class="o">=</span><span class="m">0</span> --verbose <span class="se">\</span>
        --level<span class="o">=</span><span class="m">1</span> --raid-devices<span class="o">=</span><span class="m">2</span> --spare-devices<span class="o">=</span><span class="m">1</span> --assume-clean
<span class="go">        /dev/loop0p3 /dev/loop1p3 /dev/loop2p3</span>
</pre></div>
</div>
<p>De esta forma dos discos formarán el <abbr title="Redundant Array of Independent Disks">RAID</abbr> espejo y el tercero quedará en
reserva esperando a que uno de los otros falle. En cuanto esto ocurra, se
añadirça automática al <abbr title="Redundant Array of Independent Disks">RAID</abbr> sincronizándose con el disco sobreviviente.</p>
<p class="rubric"><abbr title="Redundant Array of Independent Disks">RAID</abbr> 1 sin redundancia</p>
<p>Es posible forzar a <strong class="command">mdadm</strong> a crear un <abbr title="Redundant Array of Independent Disks">RAID</abbr> 1 con un único disco lo
cual es, en principio, absurdo, ya que no existe redundancia. Sin embargo, es
una buena forma de comenzar a instalar un sistema que se prevé que acabe
funcionado sobre un <abbr title="Redundant Array of Independent Disks">RAID</abbr>. De esta forma, las estructuras ya están creadas y
sólo es necesario modificar el <abbr title="Redundant Array of Independent Disks">RAID</abbr> para añadir otros ficheros:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> mdadm --create /dev/md0 --metadata<span class="o">=</span><span class="m">1</span> --homehost<span class="o">=</span>any --name<span class="o">=</span><span class="m">0</span> --verbose <span class="se">\</span>
        --level<span class="o">=</span><span class="m">1</span> --raid-devices<span class="o">=</span><span class="m">1</span> --force --assume-clean /dev/loop0p3
</pre></div>
</div>
</div>
<div class="section" id="consulta">
<h3>5.4.2.3. Consulta<a class="headerlink" href="#consulta" title="Enlazar permanentemente con este título">¶</a></h3>
<p>El modo más simple de consultar el funcionamiento de un <abbr title="Redundant Array of Independent Disks">RAID</abbr>, es mirar el
contenido de <code class="file docutils literal notranslate"><span class="pre">/proc/mdstat</span></code>. Por ejemplo, en el caso del <abbr title="Redundant Array of Independent Disks">RAID</abbr> 1 con dos
discos, veremos:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> cat /proc/mdstat
<span class="go">Personalities : [raid1] [linear] [multipath] [raid0] [raid6] [raid5] [raid4] [raid10]</span>
<span class="hll"><span class="go">md0 : active raid1 loop1p3[1] loop0p3[0]</span>
</span><span class="hll"><span class="go">      458688 blocks super 1.2 [2/2] [UU]</span>
</span></pre></div>
</div>
<p>En cuya salida podemos ver nuestro <abbr title="Redundant Array of Independent Disks">RAID</abbr> de nivel <strong>1</strong> constituido por dos
dispositivos perfectamente sincronizados (ambos <strong>U</strong>[pdated]). En el caso del
<abbr title="Redundant Array of Independent Disks">RAID</abbr> 1 sin redundancia, la salida sería esta:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> cat /proc/mdstat
<span class="go">Personalities : [raid1] [linear] [multipath] [raid0] [raid6] [raid5] [raid4] [raid10]</span>
<span class="go">md0 : active raid1 loop0p3[0]</span>
<span class="go">      458688 blocks super 1.2 [1/1] [U]</span>
</pre></div>
</div>
<p>Y en el caso del <abbr title="Redundant Array of Independent Disks">RAID</abbr> 1 de dos discos con otro de reserva:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> cat /proc/mdstat
<span class="go">Personalities : [raid1] [linear] [multipath] [raid0] [raid6] [raid5] [raid4] [raid10]</span>
<span class="go">md0 : active raid1 loop2p3[2](S) loop1p3[1] loop0p3[0]</span>
<span class="go">      458688 blocks super 1.2 [2/2] [UU]</span>
</pre></div>
</div>
<p>Además, de ser muy ilustrativa, lo interesante de esta salida es que, cuando el
<abbr title="Redundant Array of Independent Disks">RAID</abbr> se encuentra sincronizando discos (p.e. tras incorporar uno nuevo al
<abbr title="Redundant Array of Independent Disks">RAID</abbr>), nos informará de ello y de cuál es su porcentaje de sincronización. Más
adelante, al manipular los <abbr title="Redundant Array of Independent Disks">RAID</abbr> volveremos sobre esta salida.</p>
<p>Otras consultas más detalladas son:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> mdadm --detail /dev/md0
<span class="go">/dev/md0:</span>
<span class="go">           Version : 1.2</span>
<span class="go">     Creation Time : Mon Dec  9 22:08:29 2019</span>
<span class="go">        Raid Level : raid1</span>
<span class="go">        Array Size : 458688 (447.94 MiB 469.70 MB)</span>
<span class="go">     Used Dev Size : 458688 (447.94 MiB 469.70 MB)</span>
<span class="go">      Raid Devices : 2</span>
<span class="go">     Total Devices : 2</span>
<span class="go">       Persistence : Superblock is persistent</span>

<span class="go">       Update Time : Mon Dec  9 22:08:29 2019</span>
<span class="go">             State : clean</span>
<span class="go">    Active Devices : 2</span>
<span class="go">   Working Devices : 2</span>
<span class="go">    Failed Devices : 0</span>
<span class="go">     Spare Devices : 0</span>

<span class="go">Consistency Policy : resync</span>

<span class="go">              Name : any:0</span>
<span class="go">              UUID : 8597a136:4199ae3e:897e9269:97cd0c37</span>
<span class="go">            Events : 0</span>

<span class="go">    Number   Major   Minor   RaidDevice State</span>
<span class="go">       0     259        2        0      active sync   /dev/loop0p3</span>
<span class="go">       1     259        5        1      active sync   /dev/loop1p3</span>
</pre></div>
</div>
<p>o <kbd class="kbd docutils literal notranslate">--examine</kbd> que permite consultar cada componente del <abbr title="Redundant Array of Independent Disks">RAID</abbr>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> mdadm --examine /dev/loop0p3
<span class="go">/dev/loop0p3:</span>
<span class="go">          Magic : a92b4efc</span>
<span class="go">        Version : 1.2</span>
<span class="go">    Feature Map : 0x0</span>
<span class="go">     Array UUID : 8597a136:4199ae3e:897e9269:97cd0c37</span>
<span class="go">           Name : any:0</span>
<span class="go">  Creation Time : Mon Dec  9 22:08:29 2019</span>
<span class="go">     Raid Level : raid1</span>
<span class="go">   Raid Devices : 2</span>

<span class="go"> Avail Dev Size : 917471 (447.98 MiB 469.75 MB)</span>
<span class="go">     Array Size : 458688 (447.94 MiB 469.70 MB)</span>
<span class="go">  Used Dev Size : 917376 (447.94 MiB 469.70 MB)</span>
<span class="go">    Data Offset : 2048 sectors</span>
<span class="go">   Super Offset : 8 sectors</span>
<span class="go">   Unused Space : before=1968 sectors, after=95 sectors</span>
<span class="go">          State : clean</span>
<span class="go">    Device UUID : 4a4685b3:2d2c868d:674d24ad:f76d4eea</span>

<span class="go">    Update Time : Mon Dec  9 22:08:29 2019</span>
<span class="go">  Bad Block Log : 512 entries available at offset 16 sectors</span>
<span class="go">       Checksum : 8e14dfe2 - correct</span>
<span class="go">         Events : 0</span>


<span class="go">   Device Role : Active device 0</span>
<span class="go">   Array State : AA (&#39;A&#39; == active, &#39;.&#39; == missing, &#39;R&#39; == replacing)</span>
</pre></div>
</div>
</div>
<div class="section" id="ensamblaje">
<h3>5.4.2.4. Ensamblaje<a class="headerlink" href="#ensamblaje" title="Enlazar permanentemente con este título">¶</a></h3>
</div>
<div class="section" id="sustitucion-de-disco">
<h3>5.4.2.5. Sustitución de disco<a class="headerlink" href="#sustitucion-de-disco" title="Enlazar permanentemente con este título">¶</a></h3>
</div>
<div class="section" id="modificacion">
<h3>5.4.2.6. Modificación<a class="headerlink" href="#modificacion" title="Enlazar permanentemente con este título">¶</a></h3>
<div class="admonition-todo admonition" id="index-1">
<p class="first admonition-title">Por hacer</p>
<p class="last">Adición de disco, adición de disco de reserva, eliminación de disco,
aumento del tamaño del raid.</p>
</div>
<p class="rubric">Notas al pie</p>
<table class="docutils footnote" frame="void" id="id3" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td>Véase la discusión sobre <a class="reference internal" href="../01.division/02.part.html#part-gpt-uefi"><span class="std std-ref">particionado GPT para UEFI</span></a>.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id4" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[2]</a></td><td>Supuesto libre, en caso contrario se usará <code class="file docutils literal notranslate"><span class="pre">/dev/md126</span></code> y así
sucesivamente hasta encontrar el primero libre.</td></tr>
</tbody>
</table>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../../index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">5.4. <abbr title="Redundant Array of Independent Disks">RAID</abbr>s</a><ul>
<li><a class="reference internal" href="#introduccion-teorica">5.4.1. Introducción teórica</a></li>
<li><a class="reference internal" href="#raids-en-linux">5.4.2. <abbr title="Redundant Array of Independent Disks">RAID</abbr>s en <em>Linux</em></a><ul>
<li><a class="reference internal" href="#preliminares">5.4.2.1. Preliminares</a></li>
<li><a class="reference internal" href="#creacion">5.4.2.2. Creación</a></li>
<li><a class="reference internal" href="#consulta">5.4.2.3. Consulta</a></li>
<li><a class="reference internal" href="#ensamblaje">5.4.2.4. Ensamblaje</a></li>
<li><a class="reference internal" href="#sustitucion-de-disco">5.4.2.5. Sustitución de disco</a></li>
<li><a class="reference internal" href="#modificacion">5.4.2.6. Modificación</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>Tema anterior</h4>
  <p class="topless"><a href="../04.copias/02.clona/index.html"
                        title="capítulo anterior">5.3.2. Clonaciones</a></p>
  <h4>Próximo tema</h4>
  <p class="topless"><a href="../06.grub/index.html"
                        title="próximo capítulo">5.5. Gestor de arranque</a></p>
  <div role="note" aria-label="source link">
    <h3>Esta página</h3>
    <ul class="this-page-menu">
      <li><a href="../../_sources/05.discos/05.raid/index.rst.txt"
            rel="nofollow">Mostrar el código</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Búsqueda rápida</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Ir a" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navegación</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="Índice General"
             >índice</a></li>
        <li class="right" >
          <a href="../06.grub/index.html" title="5.5. Gestor de arranque"
             >siguiente</a> |</li>
        <li class="right" >
          <a href="../04.copias/02.clona/index.html" title="5.3.2. Clonaciones"
             >anterior</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">documentación de ServidorLinux - 0.1.0</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" >5. Gestión de discos</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Derechos de autor 2016, José Miguel Sánchez Alés.
      Creado con <a href="http://sphinx-doc.org/">Sphinx</a> 1.8.5.
    </div>
  </body>
</html>