


<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" lang="es">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>5.5. RAIDs &#8212; documentación de ServidorLinux - 0.1.0</title>
    <link rel="stylesheet" href="../../_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../_static/custom.css" />
    
    <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../_static/language_data.js"></script>
    <script type="text/javascript" src="../../_static/translations.js"></script>
    <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <link rel="index" title="Índice" href="../../genindex.html" />
    <link rel="search" title="Búsqueda" href="../../search.html" />
    <link rel="next" title="5.5.2.1.1. mdadm" href="01.mdadm.html" />
    <link rel="prev" title="5.4.2. Clonaciones" href="../04.copias/02.clona/index.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navegación</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="Índice General"
             accesskey="I">índice</a></li>
        <li class="right" >
          <a href="01.mdadm.html" title="5.5.2.1.1. mdadm"
             accesskey="N">siguiente</a> |</li>
        <li class="right" >
          <a href="../04.copias/02.clona/index.html" title="5.4.2. Clonaciones"
             accesskey="P">anterior</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">documentación de ServidorLinux - 0.1.0</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" accesskey="U">5. Gestión de discos</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="raids">
<span id="raid"></span><h1>5.5. <abbr title="Redundant Array of Independent Disks">RAID</abbr>s<a class="headerlink" href="#raids" title="Enlazar permanentemente con este título">¶</a></h1>
<div class="section" id="introduccion-teorica">
<h2>5.5.1. Introducción teórica<a class="headerlink" href="#introduccion-teorica" title="Enlazar permanentemente con este título">¶</a></h2>
<p>Un <abbr title="Redundant Array of Independent Disks">RAID</abbr> puede definirse como un sistemas de almacenamiento que, mediante
técnicas <em>hardware</em> o <em>software</em>, utiliza de manera conjunta varios discos para
distribuir los datos entre todos ellos con la finalidad, respecto al uso de un
único disco. de:</p>
<ul>
<li><p class="first">Introducir <strong>redundancia</strong> para hacer el sistema más tolerante a fallos, de
manera que, aunque falle algún disco, el sistema pueda seguir accediendo a los
datos sin interrupciones. El grado de tolerancia a los fallos puede medirse
calculando la <strong>probabilidad de fallo irrecuperable</strong>.</p>
<p>Tengase en cuenta que cuando hay redundancia más importante que el hecho de
que fallen los discos es el hecho de que lo hagan varios casi simultáneamente.
Por ese motivo, algunos consideran buena idea mezclar discos de distinto
fabricante o discos de un mismo fabricante, pero de distinto lote. Pero, por
otro lado, puede no ser una buena idea mezclar discos con distinto
rendimiento.</p>
</li>
<li><p class="first">Aumentar la <strong>capacidad</strong> de almacenamiento, esto es, constituir una unidad de
almacenamiento mayor que la de un disco individual. Es conveniente tener en
cuenta que en los discos que constituyen un <abbr title="Redundant Array of Independent Disks">RAID</abbr> es aprovechable la
capacidad de cada uno sólo hasta la capacidad del más pequeño, por lo que para
no desaprovechar espacio de disco lo óptimo es que todos los discos sean del
mismo tamaño.</p>
</li>
<li><p class="first">Aumentar el <strong>rendimiento</strong> en las operaciones de lectura y escritura.</p>
</li>
</ul>
<p>El grado de consecuención de estos propósitos depende de cuál sea el tipo de
<abbr title="Redundant Array of Independent Disks">RAID</abbr> que se implemente; y el resultado aparente de la implementación será la
creación de un dispositivo virtual sobre el que el sistema operativo podra crear
particiones y sistemas de archivos.</p>
<p class="rubric">Tipos de <abbr title="Redundant Array of Independent Disks">RAID</abbr>s</p>
<p>Antes de pasar a describir los más comunes, es preciso fijar la siguiente
<strong>nomenclatura</strong>:</p>
<ul class="simple">
<li><span class="var">s</span> es la capacidad del disco físico más pequeño.</li>
<li><span class="var">n</span> es el número de discos físicos que constituye el <abbr title="Redundant Array of Independent Disks">RAID</abbr>.</li>
<li><span class="var">m</span> es, en los <abbr title="Redundant Array of Independent Disks">RAID</abbr>s anidados, el número de discos del grupo anidado.</li>
<li><span class="var">g</span> es, en los <abbr title="Redundant Array of Independent Disks">RAID</abbr>s anidados, el número de grupos de discos. Por tanto,
<span class="math notranslate nohighlight">\(n = g*s\)</span>.</li>
<li><span class="var">p</span> es la probabilidad de que se rompa un disco en un periodo de tiempo
determinado. Se supondrá la misma para todos los discos. Para estimarla
podemos guiarnos por las estadísticas que publica la compañía <a class="reference external" href="https://www.backblaze.com">Backblaze</a>
basada en los fallos de sus propios discos duros. Para 2018, <a class="reference external" href="https://www.backblaze.com/blog/hard-drive-stats-for-2018/">estos fueron los
datos</a>.</li>
<li><span class="math notranslate nohighlight">\(P^n_{rX}(p)\)</span> es la probabilidad de fallo irrecuperable de un <abbr title="Redundant Array of Independent Disks">RAID</abbr> <strong>X</strong>
constituido por <span class="var">n</span> discos cuya probabilidad individual de fallo es <span class="var">p</span>.
Cuando el <abbr title="Redundant Array of Independent Disks">RAID</abbr> es anidado, el número de discos se notará <span class="math notranslate nohighlight">\(n,m\)</span>. Por
ejemplo, <span class="math notranslate nohighlight">\(P^{6,2}_{r10}(1\%)\)</span> es la probabilidad de fallo irrecuperable de
un <abbr title="Redundant Array of Independent Disks">RAID</abbr> 10 de seis discos con tres divisiones de dos discos y una
probabilidad de fallo del 1%.</li>
</ul>
<dl class="docutils">
<dt><strong>RAID 0</strong> (o <strong>Volumen dividido</strong>)</dt>
<dd><p class="first">Se forma con dos o más discos entre los cuales se distribuye equitativamente
la información sin incluir información redudante.</p>
<img alt="../../_images/RAID0.png" src="../../_images/RAID0.png" />
<p>En lo referente a los propósitos de <abbr title="Redundant Array of Independent Disks">RAID</abbr>:</p>
<ul class="last simple">
<li>El sistema no es tolerante a fallos, puesto que no existe redundancia. En
consecuencia, no puede romperse ningún disco. Y es más, cuanto mayor sea el
número de discos, menos fiabilidad tendrá el sistema, ya que aumenta la
probabilidad de que uno de ellos falle y se desbarate toda la información.</li>
<li>La probabilidad de que el sistema falle es de <span class="math notranslate nohighlight">\(P^n_{r0}(p) = 1-(1-p)^n\)</span>.</li>
<li>La capacidad del conjunto es <span class="math notranslate nohighlight">\(n*s\)</span>.</li>
<li>Mejora el rendimiento tanto en la lectura como en la escritura, ya que se
puede leer y escribir simultáneamente en los discos.</li>
</ul>
</dd>
<dt><strong>RAID 1</strong> (o <strong>Espejo</strong>)</dt>
<dd><p class="first">Se forma con dos o más discos de modo que lo que se escribe en uno se
replica en todos los demás.</p>
<img alt="../../_images/RAID1.png" src="../../_images/RAID1.png" />
<p>En este caso, el conjunto es altamente redundante tanto más cuantos más
discos haya, a costa de sacrificar capacidad:</p>
<ul class="last simple">
<li>El sistema es capaz de soportar la ruptura de <span class="math notranslate nohighlight">\(n-1\)</span> discos sin que se
produzca pérdida de información.</li>
<li>La probabilidad de que el sistema falle es de <span class="math notranslate nohighlight">\(P^n_{r1}(p) = p^n\)</span>.</li>
<li>No aumenta la capacidad del conjunto que seguirá siendo la capacidad
individual de uno de los discos, <span class="math notranslate nohighlight">\(s\)</span>.</li>
<li>Aumenta el rendimiento de las lecturas, ya que pueden realizarse lecturas
simultáneas, pero no el de escritura.</li>
</ul>
</dd>
<dt><strong>RAID 5</strong></dt>
<dd><p class="first">Es un sistema de al menos tres discos fisicos, de manera que la información
se distribuye en todos ellos, excepto en uno en el que se incluye información
de paridad, por lo que es posible recuperar la información ante el fallo de
uno de los discos. La base del cálculo de la paridad es la operación lógica
<em>XOR</em> que se caracteriza porque cuando el número de <strong>1</strong> en los operandos es
impar el resultado es <strong>1</strong> y, cuando es par, <strong>0</strong>. En consecuencia,
suponiendo que los operandos sean <em>bits</em>, obtenemos la siguiente tabla:</p>
<table border="1" class="xor docutils">
<colgroup>
<col width="11%" />
<col width="11%" />
<col width="11%" />
<col width="68%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">O1</th>
<th class="head">O2</th>
<th class="head">O2</th>
<th class="head">O1⊕O2⊕O3</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr class="row-odd"><td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
</tr>
<tr class="row-even"><td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
</tr>
<tr class="row-odd"><td>0</td>
<td>1</td>
<td>1</td>
<td>0</td>
</tr>
<tr class="row-even"><td>1</td>
<td>0</td>
<td>0</td>
<td>1</td>
</tr>
<tr class="row-odd"><td>1</td>
<td>0</td>
<td>1</td>
<td>0</td>
</tr>
<tr class="row-even"><td>1</td>
<td>1</td>
<td>0</td>
<td>0</td>
</tr>
<tr class="row-odd"><td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
</tbody>
</table>
<p>en la que podremos darnos cuenta, que tapemos la columna que tapemos, podemos
deducir sus valores aplicando la operación <em>XOR</em> a los valores de las
columnas aún visibles. En un <abbr title="Redundant Array of Independent Disks">RAID</abbr> 5 el cálculo de la paridad es más
complejo, ya que tal cálculo  se hace a nivel de bloques y el bloque de
paridad se distribuye equitativamente entre todos los discos físicos.</p>
<img alt="../../_images/RAID5.png" src="../../_images/RAID5.png" />
<p>En este tipo:</p>
<ul class="simple">
<li>Es tolerante a fallos en la medida, en que la paridad permite que se pueda
estropear un único disco.</li>
<li>La probabilidad de que el sistema falle es la probabilidad de que falle
un <abbr title="Redundant Array of Independent Disks">RAID</abbr> 0 menos la probabilidad de que sólo se rompa un disco, ya que en
este caso el <abbr title="Redundant Array of Independent Disks">RAID</abbr> 0 sí falla, pero el <abbr title="Redundant Array of Independent Disks">RAID</abbr> 5, no. Por tanto:
<span class="math notranslate nohighlight">\(P^n_{r5}(p) = P^n_{r0} - n*p*(1-p)^{n-1}\)</span>.</li>
<li>Aumenta la capacidad, ya que la paridad sólo ocupa el equivalente a un
disco físico. Por tanto, obtendremos una capacidad de <span class="math notranslate nohighlight">\((n-1)*s\)</span>.</li>
<li>Hay mejora en el rendimiento de las lecturas, pero hay una penalización
en las escrituras, ya que una escritura implica leer datos del resto de
discos para generar la paridad y escribir ésta. Esta bajada en el
rendimiento en la escrituras es su principal defecto.</li>
</ul>
<p>Variantes de este nivel son:</p>
<ul class="last simple">
<li>El <abbr title="Redundant Array of Independent Disks">RAID</abbr> 4 en que la información de paridad se almacena siempre en el
mismo disco.</li>
<li>El <abbr title="Redundant Array of Independent Disks">RAID</abbr> 3 en que ocurre lo mismo, pero además, los datos se dividen en
<em>bytes</em> y no en bloques.</li>
<li>El <abbr title="Redundant Array of Independent Disks">RAID</abbr> Z, que es implementado por el sistema de fichero <abbr title="Zettavyte File System">ZFS</abbr> y es
semejante al <abbr title="Redundant Array of Independent Disks">RAID</abbr> 5, pero que añade variantes para mejorar el rendimiento
en las escrituras.</li>
</ul>
</dd>
<dt><strong>RAID 6</strong></dt>
<dd><p class="first">Es parecido a un <abbr title="Redundant Array of Independent Disks">RAID</abbr> 5, pero genera dos bloques de paridad y no uso sólo.
Por tanto, el número mínimo de discos para constituirlo es 4. En él, se
sacrifica la capacidad por el aumento de fiabilidad, ya que pueden fallar
hasta dos discos:</p>
<ul class="simple">
<li>Tolera que fallen hasta dos discos.</li>
<li>La probabilidad de que el sistema falle es la probabilidad de que falle un
<abbr title="Redundant Array of Independent Disks">RAID</abbr> 5 menos la probabilidad de que fallen dos discos, ya que en este
caso un <abbr title="Redundant Array of Independent Disks">RAID</abbr> 5 falla, pero un <abbr title="Redundant Array of Independent Disks">RAID</abbr> 6, no. Por tanto:
<span class="math notranslate nohighlight">\(P^n_{r6}(p) = P^n_{r5}(p) - n*(n-1)*p^2*(1-p)^{n-2}\)</span>.</li>
<li>Aumenta la capacidad, hasta <span class="math notranslate nohighlight">\((n-2)*s\)</span>.</li>
<li>Presenta los mismos incovenientes de rendimiento que su primo hermano el
<abbr title="Redundant Array of Independent Disks">RAID</abbr>5: no mejora las operaciones de lectura y penaliza las de
escritura.</li>
</ul>
<img alt="../../_images/RAID6.png" class="last" src="../../_images/RAID6.png" />
</dd>
</dl>
<p>Hay, además, sistemas <abbr title="Redundant Array of Independent Disks">RAID</abbr>s que se constituyen <strong>anidando</strong> dos o más
niveles de <abbr title="Redundant Array of Independent Disks">RAID</abbr>. Los más utilizados son:</p>
<dl class="docutils">
<dt><strong>RAID 0+1</strong> (o <strong>Espejo de divisiones</strong> o <strong>RAID 01</strong>):</dt>
<dd><p class="first">Es un sistema híbrido formado con un mínimo de cuatro discos, en los que los
<span class="var">n</span> discos se agrupan en grupos de <span class="var">m</span>. Cada grupo de <span class="var">m</span>
discos constituye un <abbr title="Redundant Array of Independent Disks">RAID</abbr> 0 y con todos los grupos se forma un <abbr title="Redundant Array of Independent Disks">RAID</abbr> 1.
Si tenemos cuatro discos y los agrupamos de 2 en 2, este será el resultado:</p>
<img alt="../../_images/RAID0+1.png" src="../../_images/RAID0+1.png" />
<p>Con esta disposición:</p>
<ul class="last simple">
<li>Hay tolerancia a fallos, ya que el sistema falla sólo cuando falla al menos
un mismo disco de todos los grupos en <abbr title="Redundant Array of Independent Disks">RAID</abbr> 0.</li>
<li>¿Alguien me calcula la probabilidad de que este sistema falle?</li>
<li>Aumenta la capacidad hasta <span class="math notranslate nohighlight">\(m * s\)</span>.</li>
<li>Hay mejora en el rendimiento de lecturas y escrituras.</li>
</ul>
</dd>
<dt><strong>RAID 1+0</strong> (o <strong>Divisiones en espejo</strong> o <strong>RAID 10</strong>):</dt>
<dd><p class="first">El sistema es parecido al anterior, pero se invierten los niveles: cada grupo
de <span class="var">m</span> discos forma un <abbr title="Redundant Array of Independent Disks">RAID</abbr> 1 y con todos los grupos se forma un
<abbr title="Redundant Array of Independent Disks">RAID</abbr> 0. Como en el caso anterior se requieren al menos cuatro discos:</p>
<img alt="../../_images/RAID1+0.png" src="../../_images/RAID1+0.png" />
<p>Esta disposición sopone:</p>
<ul class="last simple">
<li>Hay toleracia a fallos, ya que el sistema falla cuando fallan
todos los discos de una misma división.</li>
<li>La probabilidad de que el sistema falle es de <span class="math notranslate nohighlight">\(P^{n,m}_{r10}(p) = P^{n/m}_{0}(P^m_{r1}(p)) = 1-(1-p^m)^\frac{n}{m}\)</span>.</li>
<li>Aumenta la capacidad hasta <span class="math notranslate nohighlight">\(\frac{n}{m}*s\)</span>.</li>
<li>Hay mejora en el rendimiento de las lecturas y las escrituras,</li>
</ul>
</dd>
<dt><strong>RAID 5+0</strong> (o <strong>RAID 50</strong>)</dt>
<dd><p class="first">Como el anterior, pero el nivel del <abbr title="Redundant Array of Independent Disks">RAID</abbr> anidado es un <abbr title="Redundant Array of Independent Disks">RAID</abbr>5, por lo
que el mínimo de discos para constituirlo es <strong>6</strong>:</p>
<ul class="last simple">
<li>Hay tolerancia a fallos, ya que el sistema falla cuando falla uno
de los <abbr title="Redundant Array of Independent Disks">RAID</abbr>s 5 que constituye cualquiera de las divisiones, esto es
que fallen dos discos de una misma división.</li>
<li>La probabilidad de que el sistema falle es de <span class="math notranslate nohighlight">\(P{n.m}_{r50}(p) = P^{n/m}_{0}(P^m_{r5}(p))\)</span>.</li>
<li>Aumenta la capacidad hasta <span class="math notranslate nohighlight">\((n - \frac{n}{m})*s\)</span>.</li>
<li>Mejora el rendimiento en lectura y escritura respecto al <abbr title="Redundant Array of Independent Disks">RAID</abbr> 5.</li>
</ul>
</dd>
</dl>
<p class="rubric">Particularidades</p>
<p>Sea cuál sea la implementación y el nivel del <abbr title="Redundant Array of Independent Disks">RAID</abbr>, hay una serie de
particularidades que comparten todos los sistemas <abbr title="Redundant Array of Independent Disks">RAID</abbr>:</p>
<ol class="arabic simple">
<li>Al constituirlos es necesario que se creen una serie de <strong>estructuras de
metadatos</strong> a semejanza de lo que ocurre con los sistemas de ficheros.</li>
<li>Debe Habilitarse algún mecanismo para advertir al administrador del <strong>fallo
de disco</strong>, a fin de que sea diligente en su sustitución. Estos mecanismos
pueden ser muy variados (pitidos, leds), pero suelen incluir el envío de un
correo electrónico de aviso.</li>
<li>Al reemplazarse un dispositivo defectuoso por uno nuevo, se desencadena un
<strong>proceso de recuperación</strong> para volver a la situación previa a la rotura.</li>
<li id="hot-spare">Para minimizar el tiempo de sustitución de un disco defectuoso, algunos
sistemas incorporan un <strong>dispositivo de reserva</strong> (<em>hot spare</em>) que se
encuentra conectado pero inactivo, por lo que no forma parte efectiva del
<abbr title="Redundant Array of Independent Disks">RAID</abbr>. En el momento en que se detecta una avería, el disco de reserva se
incorpora al <abbr title="Redundant Array of Independent Disks">RAID</abbr> y comienza inmediatamente el <em>proceso de recuperación</em>.
La labor del administrador consistirá en añadir al sistema un nuevo disco de
reserva.</li>
<li>Tenga presente que, si el sistema sólo tenía un grado de redundancia (p.e. un
<abbr title="Redundant Array of Independent Disks">RAID</abbr> 5 o un <abbr title="Redundant Array of Independent Disks">RAID</abbr> 1 de dos discos), durante el proceso de reconstrucción
el sistema es vulnerable  por lo que cualquier nuevo fallo provoca la pérdida
irrecuperable de los datos. Además, el proceso de reconstrucción es una tarea
penosa que implica muchas lecturas sobre los discos supervivientes y,
consecuentemente, la sobrecarga de trabajo justamente durante este periodo de
vulnerabilidad, hace al sistema especialmente propenso a un nuevo fallo en
alguno de los supervivientes. Por eso, algunos administradores consideran que
tras un fallo lo mejor es proceder a un <em>backup</em> de los datos antes de la
resconstrucción; y rechazan como buena la idea de habilitar discos de reserva
(véase, por ejemplo, <a class="reference external" href="https://blog.open-e.com/why-a-hot-spare-hard-disk-is-a-bad-idea/">este artículo</a>).</li>
</ol>
<p class="rubric">Técnicas de implementación</p>
<p>Hay tres estrategias para la implementación de un sistema <abbr title="Redundant Array of Independent Disks">RAID</abbr>:</p>
<dl class="docutils">
<dt>Mediante <strong>controladora hardware</strong></dt>
<dd><p class="first">Por lo general, a una tarjeta de expansión que hace las veces de controladora
de disco se le conectan los discos físicos que consituirán el <abbr title="Redundant Array of Independent Disks">RAID</abbr>. En este
caso, la configuración se establece mediante un firmware particular de la
propia controladora y se carga con anterioridad al arranque del sistema
operativo, por lo que para el sistema operativo sólo tiene conocimiento de la
existencia del dispositivo virtualizado.</p>
<p class="last">Es la solución más costosa, pero la más eficiente al dedicarse a ella
<em>hardware</em> específico.</p>
</dd>
<dt>Mediante <strong>firmware</strong></dt>
<dd><p class="first">También denominado <em class="dfn">RAID híbrido</em> o <em class="dfn">fakeRAID</em>, que es una solución
barata en la que no hay ninguna controladora específica dedicada a la
constitución del <abbr title="Redundant Array of Independent Disks">RAID</abbr>, sino que el chip de la controladora de disco
incluye <em>firmware</em> específico para la definición del <abbr title="Redundant Array of Independent Disks">RAID</abbr>. Como en el caso
anterior, la configuración del <abbr title="Redundant Array of Independent Disks">RAID</abbr> se hace con anterioridad a la carga del
sistema operativo, por la que éste sólo detecta el dispositivo virtual.</p>
<p class="last">Aunque aparentemente es una solución similiar, al no existir <em>hardware</em>
expecífico dedicado, su rendimiento es peor y, por lo general, es conveniente
una solución <em>software</em> pura.</p>
</dd>
<dt>Mediante <strong>software</strong></dt>
<dd><p class="first">esto es, mediante aplicaciones que provee el propio sistema operativo o
porque sea una característica que soporta el sistema de ficheros. En este
caso, el sistema operativo verá tanto los dispositivos físicos como el
dispositivo virtual resultado de haber constituido el <abbr title="Redundant Array of Independent Disks">RAID</abbr>.</p>
<p>Los sistemas operativos comunes traen herramientas para la creación de
<abbr title="Redundant Array of Independent Disks">RAID</abbr>s:</p>
<ul class="simple">
<li><em>MasOs</em>, <em>FreeBSD</em>, <em>NetBSD</em> o <em>OpenBSD</em> cada uno con sus respectivas
herramientas.</li>
<li><em>Windows</em> gracias a <a class="reference external" href="https://en.wikipedia.org/wiki/Logical_Disk_Manager">Logical Disk Manager</a> y en las versiones modernas
de servidor a <a class="reference external" href="https://en.wikipedia.org/wiki/Features_new_to_Windows_8#Storage">Sorage Spaces</a>.</li>
<li><em>Linux</em> mediante su herramienta <strong class="command">md</strong>, que será a la que dediquemos
el resto del epígrafe.</li>
</ul>
<p class="last">Por su parte, algunos sistemas de ficheros soportan directamente la
constitución de dispositivos <abbr title="Redundant Array of Independent Disks">RAID</abbr> como <abbr title="Zettavyte File System">ZFS</abbr> o <abbr title="B-TRee File System">BtrFS</abbr>.</p>
</dd>
</dl>
<p>Es importante tener presente que la constitución de un <abbr title="Redundant Array of Independent Disks">RAID</abbr> exige el
almacenamiento de los metadatos que lo definen. En los tres casos, esos
metadatos se almacenan en los propios dispositivos de almacenamiento<a class="footnote-reference" href="#id2" id="id1">[1]</a>. Es
conveniente, tener presente esto, sobre todo cuando sustuimos el <em>hardware</em> en
los dos primeros casos:</p>
<ul>
<li><p class="first">Si nuestra intención es ser capaz de leer datos, entonces necesitaremos
que el sistema sea capaz de entender tales metadatos:</p>
<ul class="simple">
<li>En el caso de los <abbr title="Redundant Array of Independent Disks">RAID</abbr> por <em>hardware</em>, el núcleo de linux dispone de
algunos <em>drivers</em> (véase <a class="reference external" href="https://wiki.debian.org/LinuxRaidForAdmins">esta página de la wiki de debian al respecto</a>).</li>
<li>En el caso de los fake<abbr title="Redundant Array of Independent Disks">RAID</abbr>, puede sacarnos del apuro <em class="manpage"><a class="manpage reference external" href="https://manpages.debian.org/dmraid(8)">dmraid(8)</a></em>.</li>
</ul>
</li>
<li><p class="first">Si nuestra intención es reaprovechar los discos sin preocuparnos por la
información, entonces deberemos asegurarnos de eliminar los metadatos. Para
ello, suele ser suficiente con sobrescrbir con ceros los primeros y los
últimos 512KiB:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> dd &lt; /dev/zero &gt; /dev/sdX <span class="nv">bs</span><span class="o">=</span><span class="m">512</span> <span class="nv">count</span><span class="o">=</span><span class="m">1024</span>
<span class="gp">#</span> dd &lt; /dev/zero &gt; /dev/sdX <span class="nv">bs</span><span class="o">=</span><span class="m">512</span> <span class="nv">seek</span><span class="o">=</span><span class="k">$((</span><span class="sb">`</span>blockdev --getsz /dev/sdX<span class="sb">`</span> <span class="o">-</span> <span class="m">1024</span><span class="k">))</span> <span class="nv">count</span><span class="o">=</span><span class="m">1024</span>
</pre></div>
</div>
</li>
</ul>
</div>
<div class="section" id="raids-en-linux">
<span id="raid-linux"></span><h2>5.5.2. <abbr title="Redundant Array of Independent Disks">RAID</abbr>s en <em>Linux</em><a class="headerlink" href="#raids-en-linux" title="Enlazar permanentemente con este título">¶</a></h2>
<p>Ilustraremos la creación y manipulación de <abbr title="Redundant Array of Independent Disks">RAID</abbr> implementando un <abbr title="Redundant Array of Independent Disks">RAID</abbr> 1,
porque no entraña excesiva dificultad crear <abbr title="Redundant Array of Independent Disks">RAID</abbr>s de otros niveles. Es obvio
que para ello necesitaremos los discos físicos que
constituyen el <abbr title="Redundant Array of Independent Disks">RAID</abbr>. Para evitarlos usaremos ficheros que emulen estos discos
físicos:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> truncate -s 500M disco1.raw
<span class="gp">#</span> losetup /dev/loop0 disco1.raw
<span class="gp">#</span> truncate -s 500M disco2.raw
<span class="gp">#</span> losetup /dev/loop1 disco1.raw
</pre></div>
</div>
<p>De modo que nuestros dispositivos físicos serán <code class="file docutils literal notranslate"><span class="pre">/dev/loop0</span></code> y
<code class="file docutils literal notranslate"><span class="pre">/dev/loop1</span></code> en vez de <code class="file docutils literal notranslate"><span class="pre">sda</span></code>, <code class="file docutils literal notranslate"><span class="pre">sdb</span></code>, etc.</p>
<div class="admonition warning">
<p class="first admonition-title">Advertencia</p>
<p class="last">Tenga presente que está manipulando directamente dispositivos de
disco, por lo que si confunde las unidades y realiza la operación sobre el
disco que contiene su sistema operativo, lo perderá todo. La guía utiliza
<code class="file docutils literal notranslate"><span class="pre">/dev/loop0</span></code> y <code class="file docutils literal notranslate"><span class="pre">/dev/loop1</span></code> entre otras cosas para evitar que un
<em>corta y pega</em> irreflexivo, provoque una catástrofe en su sistema.</p>
</div>
<div class="section" id="implementaciones">
<h3>5.5.2.1. Implementaciones<a class="headerlink" href="#implementaciones" title="Enlazar permanentemente con este título">¶</a></h3>
<p>El núcleo de linux dispone de un driver llamado <abbr title="Multiple Devices">MD</abbr> para el soporte de
volúmenes <abbr title="Redundant Array of Independent Disks">RAID</abbr>. Y, de hecho, como herramienta de bajo nivel existe
<em class="manpage"><a class="manpage reference external" href="https://manpages.debian.org/dmsetup(8)">dmsetup(8)</a></em>.  Sin embargo, es mejor usar herramientas de usuario
más sencillas para la creación y gestión de estos dispositivos, para lo cual
tenemos fundamentalmente dos posibilidades:</p>
<ul class="simple">
<li><a class="reference internal" href="01.mdadm.html#mdadm"><span class="std std-ref">mdadm</span></a>, que es una herramienta exclusiva para la gestión de
estos dispositivos y que nos permite un control más preciso sobre nuestra
configuración.</li>
<li><a class="reference internal" href="../01.division/03.virt.html#lvm"><span class="std std-ref">lvm</span></a> que, desde su versión 2, permite la definición de volúmenes
lógicos que sean a su vez dispositivos <abbr title="Redundant Array of Independent Disks">RAID</abbr>, para lo cual el grupo de
volúmenes deberá haberse construido sobre dos o mas volúmenes físicos,
obviamente.</li>
</ul>
<p>Estudiaremos ambas posibilidades.</p>
<div class="toctree-wrapper compound">
<ul>
<li class="toctree-l1"><a class="reference internal" href="01.mdadm.html">5.5.2.1.1. <strong class="command">mdadm</strong></a></li>
<li class="toctree-l1"><a class="reference internal" href="02.lvm.html">5.5.2.1.2. <abbr title="Logical Volume Management">LVM</abbr></a></li>
</ul>
</div>
<p class="rubric">Notas al pie</p>
<table class="docutils footnote" frame="void" id="id2" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td>Incluso en los <abbr title="Redundant Array of Independent Disks">RAID</abbr> por <em>hardware</em> y los fake<abbr title="Redundant Array of Independent Disks">RAID</abbr> en los que habría
cabido la posibilidad de que esos metadatos se hubieran registrado en memoria
<em>NVRAM</em> la contraladora controladora o de la placa base.</td></tr>
</tbody>
</table>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../../index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">5.5. <abbr title="Redundant Array of Independent Disks">RAID</abbr>s</a><ul>
<li><a class="reference internal" href="#introduccion-teorica">5.5.1. Introducción teórica</a></li>
<li><a class="reference internal" href="#raids-en-linux">5.5.2. <abbr title="Redundant Array of Independent Disks">RAID</abbr>s en <em>Linux</em></a><ul>
<li><a class="reference internal" href="#implementaciones">5.5.2.1. Implementaciones</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>Tema anterior</h4>
  <p class="topless"><a href="../04.copias/02.clona/index.html"
                        title="capítulo anterior">5.4.2. Clonaciones</a></p>
  <h4>Próximo tema</h4>
  <p class="topless"><a href="01.mdadm.html"
                        title="próximo capítulo">5.5.2.1.1. <strong class="command">mdadm</strong></a></p>
  <div role="note" aria-label="source link">
    <h3>Esta página</h3>
    <ul class="this-page-menu">
      <li><a href="../../_sources/05.discos/05.raid/index.rst.txt"
            rel="nofollow">Mostrar el código</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Búsqueda rápida</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Ir a" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navegación</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="Índice General"
             >índice</a></li>
        <li class="right" >
          <a href="01.mdadm.html" title="5.5.2.1.1. mdadm"
             >siguiente</a> |</li>
        <li class="right" >
          <a href="../04.copias/02.clona/index.html" title="5.4.2. Clonaciones"
             >anterior</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">documentación de ServidorLinux - 0.1.0</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" >5. Gestión de discos</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Derechos de autor 2016, José Miguel Sánchez Alés.
      Creado con <a href="http://sphinx-doc.org/">Sphinx</a> 1.8.5.
    </div>
  </body>
</html>