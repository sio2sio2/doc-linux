


<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" lang="es">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>5.4. RAIDs &#8212; documentación de ServidorLinux - 0.1.0</title>
    <link rel="stylesheet" href="../../_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../_static/custom.css" />
    
    <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../_static/language_data.js"></script>
    <script type="text/javascript" src="../../_static/translations.js"></script>
    <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <link rel="index" title="Índice" href="../../genindex.html" />
    <link rel="search" title="Búsqueda" href="../../search.html" />
    <link rel="next" title="5.4.2.2.1. mdadm" href="01.mdadm.html" />
    <link rel="prev" title="5.3.2. Clonaciones" href="../04.copias/02.clona/index.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navegación</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="Índice General"
             accesskey="I">índice</a></li>
        <li class="right" >
          <a href="01.mdadm.html" title="5.4.2.2.1. mdadm"
             accesskey="N">siguiente</a> |</li>
        <li class="right" >
          <a href="../04.copias/02.clona/index.html" title="5.3.2. Clonaciones"
             accesskey="P">anterior</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">documentación de ServidorLinux - 0.1.0</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" accesskey="U">5. Gestión de discos</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="raids">
<span id="raid"></span><h1>5.4. <abbr title="Redundant Array of Independent Disks">RAID</abbr>s<a class="headerlink" href="#raids" title="Enlazar permanentemente con este título">¶</a></h1>
<div class="section" id="introduccion-teorica">
<h2>5.4.1. Introducción teórica<a class="headerlink" href="#introduccion-teorica" title="Enlazar permanentemente con este título">¶</a></h2>
<p>Un <abbr title="Redundant Array of Independent Disks">RAID</abbr> puede definirse como un sistemas de almacenamiento que, mediante
técnicas <em>hardware</em> o <em>software</em>, utiliza de manera conjunta varios discos para
distribuir los datos entre todos ellos con la finalidad de:</p>
<ul class="simple">
<li>Introducir <strong>redundancia</strong> para hacer el sistema tolerante a fallos, de manera
que aunque falle algún disco, el sistema pueda seguir accediendo a los datos
sin interrupciones</li>
<li>Aumentar la <strong>capacidad</strong> de almacenamiento, esto es, constituir una unidad de
almacenamiento mayor que cada una de los discos físicos por separado.</li>
<li>Aumentar el <strong>rendimiento</strong> en las lecturas y escrituras.</li>
</ul>
<p>Dependiendo de cuál sea el <abbr title="Redundant Array of Independent Disks">RAID</abbr> que se implemente se lograran alcanzar uno o
más de estos propósitos; y el resultado de su implementación será la creación de
un dispositivo virtual sobre el que el sistema operativo podra crear particiones
y sistemas de archivos.</p>
<p class="rubric">Tipos de <abbr title="Redundant Array of Independent Disks">RAID</abbr>s</p>
<p>Hay diversos tipos o niveles de <abbr title="Redundant Array of Independent Disks">RAID</abbr>s, para cuyas descripciones llamaremos
<span class="var">s</span> a la capacidad del disco físico más pequeño y <span class="var">n</span> al número de
discos que lo conforman:</p>
<dl class="docutils">
<dt><strong>RAID 0</strong> (o <strong>Volumen dividido</strong>)</dt>
<dd><p class="first">Se forma con dos o más discos entre los cuales se distribuye equitativamente
la información sin incluir información redudante.</p>
<img alt="../../_images/RAID0.png" src="../../_images/RAID0.png" />
<p>Es conveniente, como en el resto de tipos, que los discos sean de la misma
capacidad, ya que sólo es aprovechable cada disco hasta la capacidad del más
pequeño. En lo referente a los propósitos de <abbr title="Redundant Array of Independent Disks">RAID</abbr>:</p>
<ul class="last simple">
<li>El sistema no es tolerante a fallos, puesto que no existe redundancia. En
consecuencia, no puede romperse ningún disco. Y es más, cuanto mayor sea el
número de discos, menos fiabilidad tendrá el sistema, ya que aumenta la
probabilidad de que uno de ellos falle y se desbarate toda la información.</li>
<li>La capacidad del conjunto es <span class="math notranslate nohighlight">\(c*s\)</span>.</li>
<li>Mejora el rendimiento tanto en la lectura como en la escritura, ya que se
puede leer y escribir simultáneamente en los discos.</li>
</ul>
</dd>
<dt><strong>RAID 1</strong> (o <strong>Espejo</strong>)</dt>
<dd><p class="first">Se forma con dos o más discos de modo que lo que se escribe en uno se
replica en todos los demás.</p>
<img alt="../../_images/RAID1.png" src="../../_images/RAID1.png" />
<p>En este caso, el conjunto es altamente redundante tanto más cuantos más
discos haya, a costa de sacrificar capacidad:</p>
<ul class="last simple">
<li>El sistema es capaz de soportar la ruptura de <span class="math notranslate nohighlight">\(n-1\)</span> discos sin que se
produzca pérdida de información.</li>
<li>No aumenta la capacidad del conjunto que seguirá siendo la capacidad
individual de uno de los discos, <span class="math notranslate nohighlight">\(s\)</span>.</li>
<li>Aumenta el rendimiento de las lecturas, ya que pueden realizarse lecturas
simultáneas, pero no el de escritura.</li>
</ul>
</dd>
<dt><strong>RAID 0+1</strong> (o <strong>Espejo de divisiones</strong>):</dt>
<dd><p class="first">Es un sistema híbrido formado con un mínimo de cuatro discos, de manera que
primero se crean dos dispositivos <abbr title="Redundant Array of Independent Disks">RAID</abbr> 0 que a su vez se toman para
constituir un <abbr title="Redundant Array of Independent Disks">RAID</abbr> 1.</p>
<img alt="../../_images/RAID0+1.png" src="../../_images/RAID0+1.png" />
<p>Con esta disposición:</p>
<ul class="last simple">
<li>Hay tolerancia a fallos, aunque sólo pueden fallar discos de un mismo
<abbr title="Redundant Array of Independent Disks">RAID</abbr> 0. Si fallan discos de distinto <abbr title="Redundant Array of Independent Disks">RAID</abbr> 0, el sistema colapsa.</li>
<li>Aumenta la capacidad hasta <span class="math notranslate nohighlight">\(\frac{n}{2} * s\)</span>.</li>
<li>Hay mejora en el redimiento de lecturas y escrituras.</li>
</ul>
</dd>
<dt><strong>RAID 1+0</strong> (o <strong>Divisiones en espejo</strong> o <strong>RAID 10</strong>):</dt>
<dd><p class="first">El sistema es parecido al anterior, pero se invierten los niveles: primero se
hacen dos divisiones cada una de las cuales la constituyen discos en
<abbr title="Redundant Array of Independent Disks">RAID</abbr> 1 y con estas dos divisiones se forma un <abbr title="Redundant Array of Independent Disks">RAID</abbr> 0. Como en el caso
anterior requieren al menos cuatro discos:</p>
<img alt="../../_images/RAID1+0.png" src="../../_images/RAID1+0.png" />
<p>Esta disposición sopone:</p>
<ul class="last simple">
<li>Gran toleracia a fallos, ya que el sistema falla solamente cuando fallan
todos los discos de una misma división.</li>
<li>Se duplica la capacidad individual: <span class="math notranslate nohighlight">\(2*s\)</span>.</li>
<li>Hay mejora en el rendimiento de las lecturas y las escrituras,</li>
</ul>
</dd>
<dt><strong>RAID 5</strong></dt>
<dd><p class="first">Es un sistema de al menos tres discos fisicos, de manera que la información
se distribuye en todos ellos, excepto en uno en el que se incluye información
de paridad, por lo que es posible recuperar la información ante el fallo de
uno de los discos. La base del cálculo de la paridad es la operación lógica
<em>XOR</em> que se caracteriza porque cuando el número de <strong>1</strong> en los operandos es
impar el resultado es <strong>1</strong> y, cuando es par, <strong>0</strong>. En consecuencia,
suponiendo que los operandos sean <em>bits</em>, obtenemos la siguiente tabla:</p>
<table border="1" class="xor docutils">
<colgroup>
<col width="11%" />
<col width="11%" />
<col width="11%" />
<col width="68%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">O1</th>
<th class="head">O2</th>
<th class="head">O2</th>
<th class="head">O1⊕O2⊕O3</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr class="row-odd"><td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
</tr>
<tr class="row-even"><td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
</tr>
<tr class="row-odd"><td>0</td>
<td>1</td>
<td>1</td>
<td>0</td>
</tr>
<tr class="row-even"><td>1</td>
<td>0</td>
<td>0</td>
<td>1</td>
</tr>
<tr class="row-odd"><td>1</td>
<td>0</td>
<td>1</td>
<td>0</td>
</tr>
<tr class="row-even"><td>1</td>
<td>1</td>
<td>0</td>
<td>0</td>
</tr>
<tr class="row-odd"><td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
</tbody>
</table>
<p>en la que podremos darnos cuenta, que tapemos la columna que tapemos, podemos
deducir sus valores aplicando la operación <em>XOR</em> a los valores de las
columnas aún visibles. En un <abbr title="Redundant Array of Independent Disks">RAID</abbr> 5 el cálculo de la paridad es más
complejo, ya que tal cálculo  se hace a nivel de bloques y el bloque de
paridad se distribuye equitativamente entre todos los discos físicos.</p>
<img alt="../../_images/RAID5.png" src="../../_images/RAID5.png" />
<p>En este tipo:</p>
<ul class="simple">
<li>Es tolerante a fallos en la medida, en que la paridad permite que se pueda
estropear un único disco.</li>
<li>Aumenta la capacidad, ya que la paridad sólo ocupa el equivalente a un
disco físico. Por tanto, obtendremos una capacidad de <span class="math notranslate nohighlight">\((n-1)*s\)</span>.</li>
<li>No hay mejora en el rendimiento de las escrituras, y hay una penalización
en las escrituras, ya que una escritura implica leer datos del resto de
discos para generar la paridad y escribir ésta.</li>
</ul>
<p>Variantes de este nivel son:</p>
<ul class="last simple">
<li>El <abbr title="Redundant Array of Independent Disks">RAID</abbr> 4 en que la información de paridad se almacena siempre en el
mismo disco.</li>
<li>El <abbr title="Redundant Array of Independent Disks">RAID</abbr> 3 en que ocurre lo mismo, pero además, los datos se dividen en
<em>bytes</em> y no en bloques.</li>
<li>El <abbr title="Redundant Array of Independent Disks">RAID</abbr> Z, que es implementado por el sistema de fichero <abbr title="Zettavyte File System">ZFS</abbr> y es
semejante al <abbr title="Redundant Array of Independent Disks">RAID</abbr> 5, pero que añade variantes para mejorar el rendimiento
en las escrituras.</li>
</ul>
</dd>
<dt><strong>RAID 6</strong></dt>
<dd><p class="first">Es parecido a un <abbr title="Redundant Array of Independent Disks">RAID</abbr> 5, pero genera dos bloques de paridad y no uso sólo.
Por tanto, el número mínimo de discos para constituirlo es 4. En él, se
sacrifica la capacidad por el aumento de fiabilidad, ya que pueden fallar
hasta dos discos:</p>
<ul class="simple">
<li>Tolera que fallen hasta dos discos.</li>
<li>Aumenta la capacidad, hasta <span class="math notranslate nohighlight">\((n-2)*s\)</span>.</li>
<li>Presenta los mismos incovenientes de rendimiento que su primo hermano el
<abbr title="Redundant Array of Independent Disks">RAID</abbr>5: no mejora las operaciones de lectura y penaliza las de
escritura.</li>
</ul>
<img alt="../../_images/RAID6.png" class="last" src="../../_images/RAID6.png" />
</dd>
</dl>
<p class="rubric">Particularidades</p>
<p>Sea cuál sea la implementación y el nivel del <abbr title="Redundant Array of Independent Disks">RAID</abbr>, hay una serie de
particularidades que comparten todos los sistemas <abbr title="Redundant Array of Independent Disks">RAID</abbr>:</p>
<ol class="arabic simple">
<li>Al constituirlos es necesario que se creen una serie de <strong>estructuras de
metadatos</strong> a semejanza de lo que ocurre con los sistemas de ficheros.</li>
<li>Habilitan algún mecanismo para advertir al administrador de la <strong>rotura de
disco</strong>, a fin de que este sea diligente en su sustitución. Estos mecanismos
pueden ser muy variados (pitidos, leds), pero suelen incluir el envío de un
correo electrónico de aviso.</li>
<li>Al reemplazarse un dispositivo defectuoso por uno nuevo, se desencadena un
<strong>proceso de recuperación</strong> para volver a la situación previa a la rotura.</li>
<li id="hot-spare">Para minimizar el tiempo de sustitución de un disco defectuoso, algunos
sistemas incorporan un <strong>dispositivo de reserva</strong> (<em>hot spare</em>) que se
encuentra conectado pero inactivo, por lo que no forma parte efectiva del
<abbr title="Redundant Array of Independent Disks">RAID</abbr>. En el momento en que se detecta una avería, el disco de reserva se
incorpora al <abbr title="Redundant Array of Independent Disks">RAID</abbr> y comienza inmediatamente el <em>proceso de recuperación</em>.
La labor del administrador consistirá en añadir al sistema un nuevo disco de
reserva.</li>
</ol>
<p class="rubric">Técnicas de implementación</p>
<p>Hay tres estrategias para la implementación de un sistema <abbr title="Redundant Array of Independent Disks">RAID</abbr>:</p>
<dl class="docutils">
<dt>Mediante <strong>controladora hardware</strong></dt>
<dd><p class="first">Por lo general, a una tarjeta de expansión que hace las veces de controladora
de disco se le conectan los discos físicos que consituirán el <abbr title="Redundant Array of Independent Disks">RAID</abbr>. En este
caso, la configuración se establece mediante un firmware particular de la
propia controladora y se carga con anterioridad al arranque del sistema
operativo, por lo que para el sistema operativo sólo tiene conocimiento de la
existencia del dispositivo virtualizado.</p>
<p class="last">Es la solución más costosa, pero la más eficiente al dedicarse a ella
<em>hardware</em> específico.</p>
</dd>
<dt>Mediante <strong>firmware</strong></dt>
<dd><p class="first">También denominado <em class="dfn">RAID híbrido</em> o <em class="dfn">fakeRAID</em>, que es una solución
barata en la que no hay ninguna controladora específica dedicada a la
constitución del <abbr title="Redundant Array of Independent Disks">RAID</abbr>, sino que el chip de la controladora de disco
incluye <em>firmware</em> específico para la definición del <abbr title="Redundant Array of Independent Disks">RAID</abbr>. Como en el caso
anterior, la configuración del <abbr title="Redundant Array of Independent Disks">RAID</abbr> se hace con anterioridad a la carga del
sistema operativo, por la que éste sólo detecta el dispositivo virtual.</p>
<p class="last">Aunque aparentemente es una solución similiar, al no existir <em>hardware</em>
expecífico dedicado, su rendimiento es peor y, por lo general, es conveniente
una solución <em>software</em> pura.</p>
</dd>
<dt>Mediante <strong>software</strong></dt>
<dd><p class="first">esto es, mediante aplicaciones que provee el propio sistema operativo o
porque sea una característica que soporta el sistema de ficheros. En este
caso, el sistema operativo verá tanto los dispositivos físicos como el
dispositivo virtual resultado de haber constituido el <abbr title="Redundant Array of Independent Disks">RAID</abbr>.</p>
<p>Los sistemas operativos comunes traen herramientas para la creación de
<abbr title="Redundant Array of Independent Disks">RAID</abbr>s:</p>
<ul class="simple">
<li><em>MasOs</em>, <em>FreeBSD</em>, <em>NetBSD</em> o <em>OpenBSD</em> cada uno con sus respectivas
herramientas.</li>
<li><em>Windows</em> gracias a <a class="reference external" href="https://en.wikipedia.org/wiki/Logical_Disk_Manager">Logical Disk Manager</a> y en las versiones modernas
de servidor a <a class="reference external" href="https://en.wikipedia.org/wiki/Features_new_to_Windows_8#Storage">Sorage Spaces</a>.</li>
<li><em>Linux</em> mediante su herramienta <strong class="command">md</strong>, que será a la que dediquemos
el resto del epígrafe.</li>
</ul>
<p class="last">Por su parte, algunos sistemas de ficheros soportan directamente la
constitución de dispositivos <abbr title="Redundant Array of Independent Disks">RAID</abbr> como <abbr title="Zettavyte File System">ZFS</abbr> o <abbr title="B-TRee File System">BtrFS</abbr>.</p>
</dd>
</dl>
<p>Es importante tener presente que la constitución de un <abbr title="Redundant Array of Independent Disks">RAID</abbr> exige el
almacenamiento de los metadatos que lo definen. En los tres casos, esos
metadatos se almacenan en los propios dispositivos de almacenamiento<a class="footnote-reference" href="#id3" id="id1">[1]</a>. Es
conveniente, tener presente esto, sobre todo cuando sustuimos el <em>hardware</em> en
los dos primeros casos:</p>
<ul>
<li><p class="first">Si nuestra intención es ser capaz de leer datos, entonces necesitaremos
que el sistema sea capaz de entender tales metadatos:</p>
<ul class="simple">
<li>En el caso de los <abbr title="Redundant Array of Independent Disks">RAID</abbr> por <em>hardware</em>, el núcleo de linux dispone de
algunos <em>drivers</em> (véase <a class="reference external" href="https://wiki.debian.org/LinuxRaidForAdmins">esta página de la wiki de debian al respecto</a>).</li>
<li>En el caso de los fake<abbr title="Redundant Array of Independent Disks">RAID</abbr>, puede sacarnos del apuro <em class="manpage"><a class="manpage reference external" href="https://manpages.debian.org/dmraid(8)">dmraid(8)</a></em>.</li>
</ul>
</li>
<li><p class="first">Si nuestra intención es reaprovechar los discos sin preocuparnos por la
información, entonces deberemos asegurarnos de eliminar los metadatos. Para
ello, suele ser suficiente con sobrescrbir con ceros los primeros y los
últimos 512KiB:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> dd &lt; /dev/zero &gt; /dev/sdX <span class="nv">bs</span><span class="o">=</span><span class="m">512</span> <span class="nv">count</span><span class="o">=</span><span class="m">1024</span>
<span class="gp">#</span> dd &lt; /dev/zero &gt; /dev/sdX <span class="nv">bs</span><span class="o">=</span><span class="m">512</span> <span class="nv">seek</span><span class="o">=</span><span class="k">$((</span><span class="sb">`</span>blockdev --getsz /dev/sdX<span class="sb">`</span> <span class="o">-</span> <span class="m">1024</span><span class="k">))</span> <span class="nv">count</span><span class="o">=</span><span class="m">1024</span>
</pre></div>
</div>
</li>
</ul>
</div>
<div class="section" id="raids-en-linux">
<span id="raid-linux"></span><h2>5.4.2. <abbr title="Redundant Array of Independent Disks">RAID</abbr>s en <em>Linux</em><a class="headerlink" href="#raids-en-linux" title="Enlazar permanentemente con este título">¶</a></h2>
<div class="section" id="preliminares">
<h3>5.4.2.1. Preliminares<a class="headerlink" href="#preliminares" title="Enlazar permanentemente con este título">¶</a></h3>
<p>Es obvio que para nuestras pruebas necesitaremos los discos físicos que
constituyen el <abbr title="Redundant Array of Independent Disks">RAID</abbr>. Para evitarlos usaremos ficheros que emulen estos discos
físicos:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> truncate -s 500M disco1.raw
<span class="gp">#</span> losetup /dev/loop0 disco1.raw
<span class="gp">#</span> truncate -s 500M disco2.raw
<span class="gp">#</span> losetup /dev/loop1 disco1.raw
</pre></div>
</div>
<p>De modo que nuestros dispositivos físicos serán <code class="file docutils literal notranslate"><span class="pre">/dev/loop0</span></code> y
<code class="file docutils literal notranslate"><span class="pre">/dev/loop1</span></code> en vez de <code class="file docutils literal notranslate"><span class="pre">sda</span></code>, <code class="file docutils literal notranslate"><span class="pre">sdb</span></code>, etc.</p>
<div class="admonition warning">
<p class="first admonition-title">Advertencia</p>
<p class="last">Tenga presente que está manipulando directamente dispositivos de
disco, por lo que si confunde las unidades y realiza la operación sobre el
disco que contiene su sistema operativo, lo perderá todo. La guía utiliza
<code class="file docutils literal notranslate"><span class="pre">/dev/loop0</span></code> y <code class="file docutils literal notranslate"><span class="pre">/dev/loop1</span></code> entre otras cosas para evitar que un
<em>corta y pega</em> irreflexivo, provoque una catástrofe en su sistema.</p>
</div>
<p>No obstante, los preparativos no acaban aquí. En el <abbr title="Redundant Array of Independent Disks">RAID</abbr> no debemos incluir
dispositivos físicos, sino particiones, así que necesitamos particionar los
discos. Si pretendemos que nuestro disco contenga el sistema operativo y sea
arrancable, entonces tendremos que dejar el arranque fuera del <abbr title="Redundant Array of Independent Disks">RAID</abbr>.
Suponiendo que utilicemos particionado <abbr title="GUID Partition Table">GPT</abbr> y el disco sea compatible con
arranques <abbr title="Basic I/O System">BIOS</abbr> y <abbr title="Unified Extensible Firmware Interface">UEFI</abbr><a class="footnote-reference" href="#id4" id="id2">[2]</a>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> sgdisk -a <span class="m">8</span> -n <span class="s2">&quot;0:40:2047&quot;</span> -t <span class="s2">&quot;0:0xef02&quot;</span> -c <span class="s2">&quot;0:BOOTBIOS&quot;</span> <span class="se">\</span>
         -a <span class="m">2048</span> -n <span class="s2">&quot;0:2048:+50M&quot;</span> -t <span class="s2">&quot;0:0xef00&quot;</span> -c <span class="s2">&quot;0:EFI&quot;</span> <span class="se">\</span>
                 -N <span class="m">0</span> -c <span class="s2">&quot;3:RAID&quot;</span> -t <span class="s2">&quot;3:0xfd00&quot;</span> /dev/loop0
</pre></div>
</div>
<p>o bien:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> sgdisk -a <span class="m">8</span> -n <span class="s2">&quot;0:40:2047&quot;</span> -t <span class="s2">&quot;0:0xef02&quot;</span> -c <span class="s2">&quot;0:BOOTBIOS&quot;</span> <span class="se">\</span>
         -a <span class="m">2048</span> -n <span class="s2">&quot;0:2048:+50M&quot;</span> -t <span class="s2">&quot;0:0xef00&quot;</span> -c <span class="s2">&quot;0:EFI&quot;</span> <span class="se">\</span>
                 -N <span class="m">0</span> -c <span class="s2">&quot;3:LVM&quot;</span> -t <span class="s2">&quot;3:0x8e00&quot;</span> /dev/loop0
</pre></div>
</div>
<p>donde ambas tablas tienes dos particiones de arranque y una última partición
para sistemas y datos en la que sólo cambia el etiquetado y tipo dependiendo de
cuál se la implementación de linux (<a class="reference internal" href="01.mdadm.html#mdadm"><span class="std std-ref">mdadm</span></a> o <a class="reference internal" href="02.lvm.html#lvmraid"><span class="std std-ref">lvm</span></a>)
que pretendeamos usar.</p>
<div class="admonition warning">
<p class="first admonition-title">Advertencia</p>
<p class="last">Lo conveniente es que los discos sean del mismo tamaño. Es común,
sin embargo, que si los discos son de diferente fabricante no contengan
exactamente el mismo número de sectores. Asegúrese de hacer esta operación
sobre el disco con menos sectores.</p>
</div>
<p>Podemos llevar a cabo la misma operación sobre <code class="file docutils literal notranslate"><span class="pre">/dev/loop1</span></code>, pero es
más cómodo y más conveniente, simplemente, copiar la tabla de particiones en el
otro disco:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> sgdisk -R /dev/loop1 /dev/loop0
<span class="gp">#</span> sgdisk -G /dev/loop1
</pre></div>
</div>
<p>Hecho lo cual, ya podemos exponer las particiones de ambos discos:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> partx -a /dev/loop0
<span class="gp">#</span> partx -a /dev/loop1
</pre></div>
</div>
</div>
<div class="section" id="implementaciones">
<h3>5.4.2.2. Implementaciones<a class="headerlink" href="#implementaciones" title="Enlazar permanentemente con este título">¶</a></h3>
<p>El núcleo de linux dispone de un driver llamado <abbr title="Multiple Devices">MD</abbr> para el soporte de
volúmenes <abbr title="Redundant Array of Independent Disks">RAID</abbr>. Y, de hecho, como herramienta de bajo nivel existe
<em class="manpage"><a class="manpage reference external" href="https://manpages.debian.org/dmsetup(8)">dmsetup(8)</a></em>.  Sin embargo, es mejor usar herramientas de usuario
más sencillas para la creación y gestión de estos dispositivos, para lo cual
tenemos fundamentalmente dos posibilidades:</p>
<ul class="simple">
<li><a class="reference internal" href="01.mdadm.html#mdadm"><span class="std std-ref">mdadm</span></a>, que es una herramienta exclusiva para la gestión de
estos dispositivos y que nos permite un control más preciso sobre nuestra
configuración.</li>
<li><a class="reference internal" href="../01.division/03.virt.html#lvm"><span class="std std-ref">lvm</span></a> que, desde su versión 2, permite la definición de volúmenes
lógicos que sean a su vez dispositivos <abbr title="Redundant Array of Independent Disks">RAID</abbr>, para lo cual el grupo de
volúmenes deberá haberse construido sobre dos o mas volúmenes físicos,
obviamente.</li>
</ul>
<p>Estudiaremos ambas posibilidades.</p>
<div class="toctree-wrapper compound">
<ul>
<li class="toctree-l1"><a class="reference internal" href="01.mdadm.html">5.4.2.2.1. <strong class="command">mdadm</strong></a></li>
<li class="toctree-l1"><a class="reference internal" href="02.lvm.html">5.4.2.2.2. <abbr title="Logical Volume Management">LVM</abbr></a></li>
</ul>
</div>
<p class="rubric">Notas al pie</p>
<table class="docutils footnote" frame="void" id="id3" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td>Incluso en los <abbr title="Redundant Array of Independent Disks">RAID</abbr> por <em>hardware</em> y los fake<abbr title="Redundant Array of Independent Disks">RAID</abbr> en los que habría
cabido la posibilidad de que esos metadatos se hubieran registrado en memoria
<em>NVRAM</em> la contraladora controladora o de la placa base.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id4" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[2]</a></td><td>Véase la discusión sobre <a class="reference internal" href="../01.division/02.part.html#part-gpt-uefi"><span class="std std-ref">particionado GPT para UEFI</span></a>.</td></tr>
</tbody>
</table>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../../index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">5.4. <abbr title="Redundant Array of Independent Disks">RAID</abbr>s</a><ul>
<li><a class="reference internal" href="#introduccion-teorica">5.4.1. Introducción teórica</a></li>
<li><a class="reference internal" href="#raids-en-linux">5.4.2. <abbr title="Redundant Array of Independent Disks">RAID</abbr>s en <em>Linux</em></a><ul>
<li><a class="reference internal" href="#preliminares">5.4.2.1. Preliminares</a></li>
<li><a class="reference internal" href="#implementaciones">5.4.2.2. Implementaciones</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>Tema anterior</h4>
  <p class="topless"><a href="../04.copias/02.clona/index.html"
                        title="capítulo anterior">5.3.2. Clonaciones</a></p>
  <h4>Próximo tema</h4>
  <p class="topless"><a href="01.mdadm.html"
                        title="próximo capítulo">5.4.2.2.1. <strong class="command">mdadm</strong></a></p>
  <div role="note" aria-label="source link">
    <h3>Esta página</h3>
    <ul class="this-page-menu">
      <li><a href="../../_sources/05.discos/05.raid/index.rst.txt"
            rel="nofollow">Mostrar el código</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Búsqueda rápida</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Ir a" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navegación</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="Índice General"
             >índice</a></li>
        <li class="right" >
          <a href="01.mdadm.html" title="5.4.2.2.1. mdadm"
             >siguiente</a> |</li>
        <li class="right" >
          <a href="../04.copias/02.clona/index.html" title="5.3.2. Clonaciones"
             >anterior</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">documentación de ServidorLinux - 0.1.0</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" >5. Gestión de discos</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Derechos de autor 2016, José Miguel Sánchez Alés.
      Creado con <a href="http://sphinx-doc.org/">Sphinx</a> 1.8.5.
    </div>
  </body>
</html>