

<!DOCTYPE html>

<html lang="es" data-content_root="../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>5.6.2.1.1. mdadm &#8212; documentación de Linuxnomicón - rolling</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="../../_static/classic.css?v=514cf933" />
    <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
    
    <script src="../../_static/documentation_options.js?v=a621b78a"></script>
    <script src="../../_static/doctools.js?v=888ff710"></script>
    <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../_static/translations.js?v=efdbd0b9"></script>
    
    <link rel="index" title="Índice" href="../../genindex.html" />
    <link rel="search" title="Búsqueda" href="../../search.html" />
    <link rel="next" title="5.6.2.1.2. LVM" href="02.lvm.html" />
    <link rel="prev" title="5.6. RAIDs" href="index.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navegación</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="Índice General"
             accesskey="I">índice</a></li>
        <li class="right" >
          <a href="02.lvm.html" title="5.6.2.1.2. LVM"
             accesskey="N">siguiente</a> |</li>
        <li class="right" >
          <a href="index.html" title="5.6. RAIDs"
             accesskey="P">anterior</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">documentación de Linuxnomicón - rolling</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" ><span class="section-number">5. </span>Dispositivos de almacenamiento</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="index.html" accesskey="U"><span class="section-number">5.6. </span><abbr title="Redundant Array of Inexpensive Disks">RAID</abbr>s</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href=""><span class="section-number">5.6.2.1.1. </span><strong class="command">mdadm</strong></a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="index-0">
<span id="mdadm"></span><span id="id1"></span><h1><span class="section-number">5.6.2.1.1. </span><strong class="command">mdadm</strong><a class="headerlink" href="#index-0" title="Link to this heading">¶</a></h1>
<p>La herramienta permite la creación y gestión de <abbr title="Redundant Array of Inexpensive Disks">RAID</abbr>s de nivel 0, 1, 4, 5, 6
y 10. El resultado de su uso es la creación de un dispositivo virtual
<code class="file docutils literal notranslate"><span class="pre">/dev/md&lt;N&gt;</span></code> sobre el cual se pueden realizar las operaciones habituales
que se realizan sobre un disco físico: <a class="reference internal" href="../01.division/01.part.html#particionado"><span class="std std-ref">particionado</span></a> o
<a class="reference internal" href="../01.division/04.virt.html#lvm"><span class="std std-ref">particionado con volúmenes lógicos</span></a>. Bajo este epígrafe nos
limitaremos exclusivamente a la creación y gestión de este dispositivo virtual:
cómo se particione después es otro asunto.</p>
<section id="preliminares">
<h2><span class="section-number">5.6.2.1.1.1. </span>Preliminares<a class="headerlink" href="#preliminares" title="Link to this heading">¶</a></h2>
<p>En el <abbr title="Redundant Array of Inexpensive Disks">RAID</abbr> no debemos incluir dispositivos físicos, sino particiones, así que
necesitamos particionar los discos. Si pretendemos que nuestro disco contenga el
sistema operativo y sea arrancable, entonces tendremos que dejar el arranque
fuera del <abbr title="Redundant Array of Inexpensive Disks">RAID</abbr>.  Suponiendo que utilicemos particionado <abbr title="GUID Parition Table">GPT</abbr> y el disco sea
compatible con arranques <abbr title="Basic I/O System">BIOS</abbr> y <abbr title="Unified Extensible Firmware Interface">UEFI</abbr><a class="footnote-reference brackets" href="#id6" id="id2" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp"># </span>sgdisk<span class="w"> </span>-a<span class="w"> </span><span class="m">8</span><span class="w"> </span>-n<span class="w"> </span><span class="s2">&quot;0:40:2047&quot;</span><span class="w"> </span>-t<span class="w"> </span><span class="s2">&quot;0:0xef02&quot;</span><span class="w"> </span>-c<span class="w"> </span><span class="s2">&quot;0:BOOTBIOS&quot;</span><span class="w"> </span><span class="se">\</span>
<span class="w">         </span>-a<span class="w"> </span><span class="m">2048</span><span class="w"> </span>-n<span class="w"> </span><span class="s2">&quot;0:2048:+100M&quot;</span><span class="w"> </span>-t<span class="w"> </span><span class="s2">&quot;0:0xef00&quot;</span><span class="w"> </span>-c<span class="w"> </span><span class="s2">&quot;0:EFI&quot;</span><span class="w"> </span><span class="se">\</span>
<span class="w">                 </span>-N<span class="w"> </span><span class="m">0</span><span class="w"> </span>-c<span class="w"> </span><span class="s2">&quot;3:RAID&quot;</span><span class="w"> </span>-t<span class="w"> </span><span class="s2">&quot;3:0xfd00&quot;</span><span class="w"> </span>/dev/loop0
</pre></div>
</div>
<p>en donde hay dos particiones de arranque y una última partición que ocupa el
resto del disco para crear el <abbr title="Redundant Array of Inexpensive Disks">RAID</abbr>.</p>
<div class="admonition warning">
<p class="admonition-title">Advertencia</p>
<p>Lo conveniente es que los discos sean del mismo tamaño. Es común,
sin embargo, que si los discos son de diferente fabricante no contengan
exactamente el mismo número de sectores. Asegúrese de hacer esta operación
sobre el disco con menos sectores.</p>
</div>
<p>Podemos llevar a cabo la misma operación sobre <code class="file docutils literal notranslate"><span class="pre">/dev/loop1</span></code>, pero es
más cómodo y más conveniente, simplemente, copiar la tabla de particiones en el
otro disco:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp"># </span>sgdisk<span class="w"> </span>-R<span class="w"> </span>/dev/loop1<span class="w"> </span>/dev/loop0
<span class="gp"># </span>sgdisk<span class="w"> </span>-G<span class="w"> </span>/dev/loop1
</pre></div>
</div>
<p>Hecho lo cual, ya podemos exponer las particiones de ambos discos:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp"># </span>partx<span class="w"> </span>-a<span class="w"> </span>/dev/loop0
<span class="gp"># </span>partx<span class="w"> </span>-a<span class="w"> </span>/dev/loop1
</pre></div>
</div>
</section>
<section id="creacion">
<h2><span class="section-number">5.6.2.1.1.2. </span>Creación<a class="headerlink" href="#creacion" title="Link to this heading">¶</a></h2>
<p>Crearemos un <abbr title="Redundant Array of Inexpensive Disks">RAID</abbr> 1, ya que disponemos de dos discos. La creación de otros
tipos de <abbr title="Redundant Array of Inexpensive Disks">RAID</abbr> suele limitarse, simplemente, a cambiar el nivel:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp"># </span>mdadm<span class="w"> </span>--create<span class="w"> </span>/dev/md0<span class="w"> </span>--metadata<span class="o">=</span><span class="m">1</span><span class="w"> </span>--homehost<span class="o">=</span>any<span class="w"> </span>--name<span class="o">=</span><span class="m">0</span><span class="w"> </span>--verbose<span class="w"> </span><span class="se">\</span>
<span class="w">        </span>--level<span class="o">=</span><span class="m">1</span><span class="w"> </span>--raid-devices<span class="o">=</span><span class="m">2</span><span class="w"> </span>--assume-clean<span class="w"> </span>/dev/loop0p3<span class="w"> </span>/dev/loop1p3
</pre></div>
</div>
<p>Que creará un <abbr title="Redundant Array of Inexpensive Disks">RAID</abbr> 1 (<kbd class="kbd compound docutils literal notranslate"><kbd class="kbd docutils literal notranslate">-</kbd>-<kbd class="kbd docutils literal notranslate">level</kbd></kbd>) con dos dispositivos físicos. El
dispositivo virtual que representará al <abbr title="Redundant Array of Inexpensive Disks">RAID</abbr> hemos prescrito que se llame
<code class="file docutils literal notranslate"><span class="pre">/dev/md0</span></code>. Además, incluimos la opción <kbd class="kbd compound docutils literal notranslate"><kbd class="kbd docutils literal notranslate">-</kbd>-<kbd class="kbd docutils literal notranslate">assume</kbd>-<kbd class="kbd docutils literal notranslate">clean</kbd></kbd> para que el
<em>software</em> no intente sincronizar el contenido de ambos discos. En este caso,
la sincronización es una operación absurda, ya que creamos <em>ex novo</em> el <abbr title="Redundant Array of Inexpensive Disks">RAID</abbr>
y, en consecuencia, los discos físicos están vacíos.i</p>
<p class="rubric">Nombre del dispositivo virtual</p>
<p>Como hemos prescrito que sea <code class="file docutils literal notranslate"><span class="pre">/dev/md0</span></code> por esta vez se denominará así.
Sin embargo, cuando el sistema se monte automáticamente el nombre no tiene por
qué conservarse:</p>
<ul>
<li><p>En ausencia de configuración alguna, será <code class="file docutils literal notranslate"><span class="pre">/dev/md127</span></code><a class="footnote-reference brackets" href="#id7" id="id3" role="doc-noteref"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></a>.</p></li>
<li><p>Si se incluye la opción <kbd class="kbd compound docutils literal notranslate"><kbd class="kbd docutils literal notranslate">-</kbd>-<kbd class="kbd docutils literal notranslate">name</kbd></kbd> durante la creación y como valor se le
asigna un número, entonces se creará el dispositivo <code class="file docutils literal notranslate"><span class="pre">/dev/mdN</span></code> y el
enlace simbólico <code class="file docutils literal notranslate"><span class="pre">/dev/md/N</span></code>.</p></li>
<li><p>Ahora bien, la opción de creación <kbd class="kbd compound docutils literal notranslate"><kbd class="kbd docutils literal notranslate">-</kbd>-<kbd class="kbd docutils literal notranslate">homehost</kbd></kbd> determina cuál es el
nombre de la máquina que debe hospedar al <abbr title="Redundant Array of Inexpensive Disks">RAID</abbr>. Si su valor es <em>any</em> o
coincide con el nombre de la máquina, entonces se cumple lo indicado en el
punto anterior. En cambio, si no coincide, se utilizará el dispositivo
predeterminado (<code class="file docutils literal notranslate"><span class="pre">/dev/md127</span></code>) y se creará el enlace simbólico
<code class="file docutils literal notranslate"><span class="pre">/dev/md/nombre:N</span></code>. No indicar la opción durante la creación provoca
que <strong class="command">mdadm</strong> tome como valor el nombre actual de la máquina. Por
último, el nombre de la máquina es el que se puede obtener con la orden
<a class="reference internal" href="../../06.infraestructura/03.dns/02.clientes.html#hostname"><span class="std std-ref">hostname</span></a>, porque en el fichero de configuración
<code class="file docutils literal notranslate"><span class="pre">/etc/mdadm/mdadm.conf</span></code> así se prescribe:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>HOMEHOST &lt;system&gt;
</pre></div>
</div>
<p>Sin embargo puede fijarse otro nombre la configuración y ese será el nombre que tome
en consideración <strong class="command">mdadm</strong>.</p>
<div class="admonition warning">
<p class="admonition-title">Advertencia</p>
<p>Hay otro consecuencia de que no coincidan el nombre de la máquina
con el «<em>homehost</em>» del <abbr title="Redundant Array of Inexpensive Disks">RAID</abbr>: que el automontaje hará que el dispositivo
se monte en sólo lectura.</p>
</div>
</li>
<li><p>Con independencia de todo lo anterior, en <code class="file docutils literal notranslate"><span class="pre">/etc/mdadm/mdadm.conf</span></code> puede
establecerse cuál es el dispositivo que quiere asociarse al <abbr title="Redundant Array of Inexpensive Disks">RAID</abbr>. Para ello
basta con hacer:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp"># </span>mdadm<span class="w"> </span>--detail<span class="w"> </span>--scan
<span class="go">ARRAY /dev/md/xxx:1 metadata=1.2 name=xxx:1 UUID=58fb8eec:f831093a:f521de2d:9c6943a4</span>
</pre></div>
</div>
<p>añadir la salida al fichero y corregir el nombre del dispositivo para que
se ajuste a nuestro gusto (p.e. <code class="file docutils literal notranslate"><span class="pre">/dev/md/0</span></code>). De este modo, podemos
ahorrarnos el prever cómo denominará el <em>software</em> al <abbr title="Redundant Array of Inexpensive Disks">RAID</abbr>.</p>
</li>
</ul>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>Para forzar el montaje automático del <abbr title="Redundant Array of Inexpensive Disks">RAID</abbr> podemos pararlo:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp"># </span>mdadm<span class="w"> </span>--stop<span class="w"> </span>/dev/md0
</pre></div>
</div>
<p>y probar a ensamblarlo automáticamente:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp"># </span>mdadm<span class="w"> </span>--assemble<span class="w"> </span>--scan
</pre></div>
</div>
<p>Si esto no funciona, aún podemos hacer desaparecer las particiones que forman
el <abbr title="Redundant Array of Inexpensive Disks">RAID</abbr> y hacerlas aparecer de nuevo:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp"># </span>partx<span class="w"> </span>-d<span class="w"> </span>/dev/loop0
<span class="gp"># </span>partx<span class="w"> </span>-d<span class="w"> </span>/dev/loop1
<span class="gp"># </span>partx<span class="w"> </span>-a<span class="w"> </span>/dev/loop0
<span class="gp"># </span>partx<span class="w"> </span>-a<span class="w"> </span>/dev/loop1
</pre></div>
</div>
</div>
<p class="rubric" id="raid1-hot-spare">Disco de reserva (<em>hot spare</em>)</p>
<p>Podemos también crear el <abbr title="Redundant Array of Inexpensive Disks">RAID</abbr> incorporando un <a class="reference internal" href="index.html#hot-spare"><span class="std std-ref">disco de reserva</span></a>. Así, suponiendo que hubiéramos creado un fichero-disco más y
lo hubiéramos asociado a <code class="file docutils literal notranslate"><span class="pre">/dev/loop2</span></code>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp"># </span>mdadm<span class="w"> </span>--create<span class="w"> </span>/dev/md0<span class="w"> </span>--metadata<span class="o">=</span><span class="m">1</span><span class="w"> </span>--homehost<span class="o">=</span>any<span class="w"> </span>--name<span class="o">=</span><span class="m">0</span><span class="w"> </span>--verbose<span class="w"> </span><span class="se">\</span>
<span class="w">        </span>--level<span class="o">=</span><span class="m">1</span><span class="w"> </span>--raid-devices<span class="o">=</span><span class="m">2</span><span class="w"> </span>--spare-devices<span class="o">=</span><span class="m">1</span><span class="w"> </span>--assume-clean
<span class="go">        /dev/loop0p3 /dev/loop1p3 /dev/loop2p3</span>
</pre></div>
</div>
<p>De esta forma dos discos formarán el <abbr title="Redundant Array of Inexpensive Disks">RAID</abbr> espejo y el tercero quedará en
reserva esperando a que uno de los otros falle. En cuanto esto ocurra, se
añadirça automática al <abbr title="Redundant Array of Inexpensive Disks">RAID</abbr> sincronizándose con el disco sobreviviente.</p>
<p class="rubric"><abbr title="Redundant Array of Inexpensive Disks">RAID</abbr> 1 sin redundancia</p>
<p>Es posible forzar a <strong class="command">mdadm</strong> a crear un <abbr title="Redundant Array of Inexpensive Disks">RAID</abbr> 1 con un único disco lo
cual es, en principio, absurdo, ya que no existe redundancia. Sin embargo, es
una buena forma de comenzar a instalar un sistema que se prevé que acabe
funcionado sobre un <abbr title="Redundant Array of Inexpensive Disks">RAID</abbr>. De esta forma, las estructuras ya están creadas y
sólo es necesario modificar el <abbr title="Redundant Array of Inexpensive Disks">RAID</abbr> para añadir otros ficheros:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp"># </span>mdadm<span class="w"> </span>--create<span class="w"> </span>/dev/md0<span class="w"> </span>--metadata<span class="o">=</span><span class="m">1</span><span class="w"> </span>--homehost<span class="o">=</span>any<span class="w"> </span>--name<span class="o">=</span><span class="m">0</span><span class="w"> </span>--verbose<span class="w"> </span><span class="se">\</span>
<span class="w">        </span>--level<span class="o">=</span><span class="m">1</span><span class="w"> </span>--raid-devices<span class="o">=</span><span class="m">1</span><span class="w"> </span>--force<span class="w"> </span>--assume-clean<span class="w"> </span>/dev/loop0p3
</pre></div>
</div>
</section>
<section id="consulta">
<h2><span class="section-number">5.6.2.1.1.3. </span>Consulta<a class="headerlink" href="#consulta" title="Link to this heading">¶</a></h2>
<p>El modo más simple de consultar el funcionamiento de un <abbr title="Redundant Array of Inexpensive Disks">RAID</abbr>, es mirar el
contenido de <code class="file docutils literal notranslate"><span class="pre">/proc/mdstat</span></code>. Por ejemplo, en el caso del <abbr title="Redundant Array of Inexpensive Disks">RAID</abbr> 1 con dos
discos, veremos:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp"># </span>cat<span class="w"> </span>/proc/mdstat
<span class="go">Personalities : [raid1] [linear] [multipath] [raid0] [raid6] [raid5] [raid4] [raid10]</span>
<span class="hll"><span class="go">md0 : active raid1 loop1p3[1] loop0p3[0]</span>
</span><span class="hll"><span class="go">      458688 blocks super 1.2 [2/2] [UU]</span>
</span></pre></div>
</div>
<p>En cuya salida podemos ver nuestro <abbr title="Redundant Array of Inexpensive Disks">RAID</abbr> de nivel <strong>1</strong> constituido por dos
dispositivos perfectamente sincronizados (ambos <strong>U</strong>[pdated]). En el caso del
<abbr title="Redundant Array of Inexpensive Disks">RAID</abbr> 1 sin redundancia, la salida sería esta:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp"># </span>cat<span class="w"> </span>/proc/mdstat
<span class="go">Personalities : [raid1] [linear] [multipath] [raid0] [raid6] [raid5] [raid4] [raid10]</span>
<span class="go">md0 : active raid1 loop0p3[0]</span>
<span class="go">      458688 blocks super 1.2 [1/1] [U]</span>
</pre></div>
</div>
<p>Y en el caso del <abbr title="Redundant Array of Inexpensive Disks">RAID</abbr> 1 de dos discos con otro de reserva:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp"># </span>cat<span class="w"> </span>/proc/mdstat
<span class="go">Personalities : [raid1] [linear] [multipath] [raid0] [raid6] [raid5] [raid4] [raid10]</span>
<span class="go">md0 : active raid1 loop2p3[2](S) loop1p3[1] loop0p3[0]</span>
<span class="go">      458688 blocks super 1.2 [2/2] [UU]</span>
</pre></div>
</div>
<p>Además, de ser muy ilustrativa, lo interesante de esta salida es que, cuando el
<abbr title="Redundant Array of Inexpensive Disks">RAID</abbr> se encuentra sincronizando discos (p.e. tras incorporar uno nuevo al
<abbr title="Redundant Array of Inexpensive Disks">RAID</abbr>), nos informará de ello y de cuál es su porcentaje de sincronización. Más
adelante, al manipular los <abbr title="Redundant Array of Inexpensive Disks">RAID</abbr> volveremos sobre esta salida.</p>
<p>Otras consultas más detalladas son:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp"># </span>mdadm<span class="w"> </span>--detail<span class="w"> </span>/dev/md0
<span class="go">/dev/md0:</span>
<span class="go">           Version : 1.2</span>
<span class="go">     Creation Time : Mon Dec  9 22:08:29 2019</span>
<span class="go">        Raid Level : raid1</span>
<span class="go">        Array Size : 458688 (447.94 MiB 469.70 MB)</span>
<span class="go">     Used Dev Size : 458688 (447.94 MiB 469.70 MB)</span>
<span class="go">      Raid Devices : 2</span>
<span class="go">     Total Devices : 2</span>
<span class="go">       Persistence : Superblock is persistent</span>

<span class="go">       Update Time : Mon Dec  9 22:08:29 2019</span>
<span class="go">             State : clean</span>
<span class="go">    Active Devices : 2</span>
<span class="go">   Working Devices : 2</span>
<span class="go">    Failed Devices : 0</span>
<span class="go">     Spare Devices : 0</span>

<span class="go">Consistency Policy : resync</span>

<span class="go">              Name : any:0</span>
<span class="go">              UUID : 8597a136:4199ae3e:897e9269:97cd0c37</span>
<span class="go">            Events : 0</span>

<span class="go">    Number   Major   Minor   RaidDevice State</span>
<span class="go">       0     259        2        0      active sync   /dev/loop0p3</span>
<span class="go">       1     259        5        1      active sync   /dev/loop1p3</span>
</pre></div>
</div>
<p>o <kbd class="kbd compound docutils literal notranslate"><kbd class="kbd docutils literal notranslate">-</kbd>-<kbd class="kbd docutils literal notranslate">examine</kbd></kbd> que permite consultar cada componente del <abbr title="Redundant Array of Inexpensive Disks">RAID</abbr>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp"># </span>mdadm<span class="w"> </span>--examine<span class="w"> </span>/dev/loop0p3
<span class="go">/dev/loop0p3:</span>
<span class="go">          Magic : a92b4efc</span>
<span class="go">        Version : 1.2</span>
<span class="go">    Feature Map : 0x0</span>
<span class="go">     Array UUID : 8597a136:4199ae3e:897e9269:97cd0c37</span>
<span class="go">           Name : any:0</span>
<span class="go">  Creation Time : Mon Dec  9 22:08:29 2019</span>
<span class="go">     Raid Level : raid1</span>
<span class="go">   Raid Devices : 2</span>

<span class="go"> Avail Dev Size : 917471 (447.98 MiB 469.75 MB)</span>
<span class="go">     Array Size : 458688 (447.94 MiB 469.70 MB)</span>
<span class="go">  Used Dev Size : 917376 (447.94 MiB 469.70 MB)</span>
<span class="go">    Data Offset : 2048 sectors</span>
<span class="go">   Super Offset : 8 sectors</span>
<span class="go">   Unused Space : before=1968 sectors, after=95 sectors</span>
<span class="go">          State : clean</span>
<span class="go">    Device UUID : 4a4685b3:2d2c868d:674d24ad:f76d4eea</span>

<span class="go">    Update Time : Mon Dec  9 22:08:29 2019</span>
<span class="go">  Bad Block Log : 512 entries available at offset 16 sectors</span>
<span class="go">       Checksum : 8e14dfe2 - correct</span>
<span class="go">         Events : 0</span>


<span class="go">   Device Role : Active device 0</span>
<span class="go">   Array State : AA (&#39;A&#39; == active, &#39;.&#39; == missing, &#39;R&#39; == replacing)</span>
</pre></div>
</div>
</section>
<section id="ensamblaje">
<h2><span class="section-number">5.6.2.1.1.4. </span>Ensamblaje<a class="headerlink" href="#ensamblaje" title="Link to this heading">¶</a></h2>
<p>Para ensamblar a mano un <abbr title="Redundant Array of Inexpensive Disks">RAID</abbr> que no ha sido ensamblado automáticamente, basta
con:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp"># </span>mdadm<span class="w"> </span>--assemble<span class="w"> </span>/dev/md0<span class="w"> </span>/dev/loop0p3<span class="w"> </span>/dev/loop1p3
</pre></div>
</div>
<p>y para desensamblarlo, basta usar <kbd class="kbd compound docutils literal notranslate"><kbd class="kbd docutils literal notranslate">-</kbd>-<kbd class="kbd docutils literal notranslate">stop</kbd></kbd> haciendo referencia al
dispositivo virtual que representa al <abbr title="Redundant Array of Inexpensive Disks">RAID</abbr>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp"># </span>mdadm<span class="w"> </span>--stop<span class="w"> </span>/dev/md0
</pre></div>
</div>
</section>
<section id="desconexion">
<h2><span class="section-number">5.6.2.1.1.5. </span>Desconexión<a class="headerlink" href="#desconexion" title="Link to this heading">¶</a></h2>
<p>Tendremos que desconectar un disco del <abbr title="Redundant Array of Inexpensive Disks">RAID</abbr> cuando falle. Supongamos que hemos
configurado un <a class="reference external" href="raid1-hot-spare">RAID 1 con un disco de reserva</a>, con lo cual,
en ausencia de fallo, veríamos lo siguiente:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp"># </span>cat<span class="w"> </span>/proc/mdstat
<span class="go">Personalities : [raid1] [linear] [multipath] [raid0] [raid6] [raid5] [raid4] [raid10]</span>
<span class="go">md0 : active raid1 loop2p3[2](S) loop1p3[1] loop0p3[0]</span>
<span class="go">      458688 blocks super 1.2 [2/2] [UU]</span>
</pre></div>
</div>
<p>Si en un determinado momento falla el disco 0<a class="footnote-reference brackets" href="#id8" id="id4" role="doc-noteref"><span class="fn-bracket">[</span>3<span class="fn-bracket">]</span></a>, lo cual podemos simular
marcándo el dispositivo como erróneo:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp"># </span>mdadm<span class="w"> </span>--fail<span class="w"> </span>/dev/md0<span class="w"> </span>/dev/loop0p3
</pre></div>
</div>
<p>se incorporá automáticamente al <abbr title="Redundant Array of Inexpensive Disks">RAID</abbr> el disco de reserva:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp"># </span>cat<span class="w"> </span>/proc/mdstat
<span class="go">Personalities : [raid1] [linear] [multipath] [raid0] [raid6] [raid5] [raid4] [raid10]</span>
<span class="go">md0 : active raid1 loop2p3[2] loop1p3[1] loop0p3[0](F)</span>
<span class="go">      458688 blocks super 1.2 [2/1] [_U]</span>
<span class="go">      [=====&gt;...............]  recovery = 25.0% (114688/458688) finish=0.0min speed=114688K/sec</span>
</pre></div>
</div>
<p>La incorporación supone que haya que sincronizar el disco con el disco 1, por lo
que la consulta muestra el proceso. En esta situación es muy útil el uso de
<a class="reference internal" href="../../02.conbas/02.informacion/03.ficheros.html#watch"><span class="std std-ref">watch</span></a>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp"># </span>watch<span class="w"> </span>-n1<span class="w"> </span><span class="s2">&quot;cat /proc/mdstat&quot;</span>
</pre></div>
</div>
<p>que permitirá que veamos progresar la barra. Hasta que se complete el proceso,
el <abbr title="Redundant Array of Inexpensive Disks">RAID</abbr> no es tolerante a fallos. La ventaja de haber dispuesto un disco de
reserva, es que se minimiza el tiempo de no-redundancia, que se reduce
exclusivamente al tiempo de sincronización. Finalmente:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp"># </span>cat<span class="w"> </span>/proc/mdstat
<span class="go">Personalities : [raid1] [linear] [multipath] [raid0] [raid6] [raid5] [raid4] [raid10]</span>
<span class="go">md0 : active raid1 loop2p3[2] loop1p3[1] loop0p3[0](F)</span>
<span class="go">      458688 blocks super 1.2 [2/2] [UU]</span>
</pre></div>
</div>
<p>Volveremos a tener un <abbr title="Redundant Array of Inexpensive Disks">RAID</abbr> de dos discos, pero sin reserva, puesto que el
tercer disco está roto. Para extraerlo:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp"># </span>mdadm<span class="w"> </span>--remove<span class="w"> </span>/dev/md0<span class="w"> </span>/dev/loop0p3
<span class="gp"># </span>cat<span class="w"> </span>/proc/mdstat
<span class="go">Personalities : [raid1] [linear] [multipath] [raid0] [raid6] [raid5] [raid4] [raid10]</span>
<span class="go">md1 : active raid1 loop2p3[2] loop1p3[1]</span>
<span class="go">      458688 blocks super 1.2 [2/2] [UU]</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>El disco roto, si realmente lo estuviera, habria que desecharlo. Como
no lo está, podriamos reengancharlo:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp"># </span>mdadm<span class="w"> </span>--re-add<span class="w"> </span>/dev/md0<span class="w"> </span>/dev/loop0p3
</pre></div>
</div>
<p>en cuyo caso, pasará a ser un disco de reserva, porque el <abbr title="Redundant Array of Inexpensive Disks">RAID</abbr> lo definimos
como de dos discos y esta característica no se ha modificado. Otra
alternativa es limpiar todas las estrcuturas de metadatos:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp"># </span>mdadm<span class="w"> </span>--zero-superblock<span class="w"> </span>/dev/loop0p3
</pre></div>
</div>
<p>y dedicar el disco a otra cosa.</p>
</div>
<p class="rubric">Sustitución de disco</p>
<p>Como corolario a la desconexión, podemos describir las pautas que deben seguirse
cuando se sustituye un disco. Para lo cual, partiendo del último supuesto en que
tenemos el <abbr title="Redundant Array of Inexpensive Disks">RAID</abbr> 1 con dos dispositivos (el disco 1 y el disco 2) y sin disco
de reserva, suponemos que se rompe el disco 2 y que lo sustituimos por el disco
0 (que ahora mismo tenemos libre). Antes de empezar, el proceso tenemos que
dejar sin metadatos el disco 0 (para que luego no incordie) y simular el fallo
del disco 2:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp"># </span>mdadm<span class="w"> </span>--zero-superblock<span class="w"> </span>/dev/loop0p3
<span class="gp"># </span>mdadm<span class="w"> </span>--fail<span class="w"> </span>/dev/md0<span class="w"> </span>/dev/loop2p3
</pre></div>
</div>
<p>Lo adecuado es que, cuando se produzca un fallo, se envíe un aviso al
administrador del sistema. Este aviso es un correo elecrónico dirigido a:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp"># </span>grep<span class="w"> </span>^MAILADDR<span class="w"> </span>/etc/mdadm/mdadm.conf
<span class="go">MAILADDR root</span>
</pre></div>
</div>
<p>a la cuenta del administrador. Podemos incluir aquí cualquier otra dirección de
correo válida, pero se usará el servidor de correo local para enviarla, por lo
que es indispensable que este esté convenientemente configurado.</p>
<div class="admonition seealso">
<p class="admonition-title">Ver también</p>
<p>Tiene información sobre <a class="reference internal" href="../../07.serre/03.mail/02-smtp/index.html#smtp"><span class="std std-ref">cómo configurar un servidor de correo</span></a>.</p>
</div>
<p>En la situación descrita tenemos el <abbr title="Redundant Array of Inexpensive Disks">RAID</abbr> en precario:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp"># </span>cat<span class="w"> </span>/proc/mdstat
<span class="go">Personalities : [raid1] [linear] [multipath] [raid0] [raid6] [raid5] [raid4] [raid10]</span>
<span class="go">md1 : active (auto-read-only) raid1 loop2p3[2](F) loop1p3[1]</span>
<span class="go">      458688 blocks super 1.2 [2/1] [_U]</span>
</pre></div>
</div>
<p>y habrá que retirar del <abbr title="Redundant Array of Inexpensive Disks">RAID</abbr> el disco defectuoso:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp"># </span>mdadm<span class="w"> </span>--remove<span class="w"> </span>/dev/md0<span class="w"> </span>/dev<span class="p">&amp;</span>loop2p3
</pre></div>
</div>
<p>Para a continuación añadir el nuevo disco. Si embargo, esta acción no es
inmediata, ya que antes hay que preparar sus particiones, para lo cual copiamos
la del disco superviviente del <abbr title="Redundant Array of Inexpensive Disks">RAID</abbr><a class="footnote-reference brackets" href="#id9" id="id5" role="doc-noteref"><span class="fn-bracket">[</span>4<span class="fn-bracket">]</span></a>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp"># </span>sgdisk<span class="w"> </span>-R<span class="w"> </span>/dev/loop0<span class="w"> </span>/dev/loop1
<span class="gp"># </span>sgdisk<span class="w"> </span>-G<span class="w"> </span>/dev/loop1
<span class="gp"># </span>mdadm<span class="w"> </span>--add<span class="w"> </span>/dev/md0<span class="w"> </span>/dev/loop0p3
<span class="gp"># </span>cat<span class="w"> </span>/proc/mdstat
<span class="go">Personalities : [raid1] [linear] [multipath] [raid0] [raid6] [raid5] [raid4] [raid10]</span>
<span class="go">md1 : active raid1 loop0p3[3] loop2p3[2](F) loop1p3[1]</span>
<span class="go">      458688 blocks super 1.2 [2/1] [_U]</span>
<span class="go">      [==&gt;..................]  recovery = 12.5% (57344/458688) finish=0.1min speed=57344K/sec</span>
</pre></div>
</div>
<p>Y esperamos a que acabe la sincronización.</p>
</section>
<section id="modificacion">
<h2><span class="section-number">5.6.2.1.1.6. </span>Modificación<a class="headerlink" href="#modificacion" title="Link to this heading">¶</a></h2>
<p>Un <abbr title="Redundant Array of Inexpensive Disks">RAID</abbr> ya definido podemos modificarlo de diferentes formas:</p>
<ul class="simple">
<li><p>Añadiendo un disco de reserva.</p></li>
<li><p>Añadiendo un disco.</p></li>
<li><p>Eliminando un disco.</p></li>
<li><p>Aumentando la capacidad del <abbr title="Redundant Array of Inexpensive Disks">RAID</abbr>.</p></li>
<li><p>Modificando el nivel del <abbr title="Redundant Array of Inexpensive Disks">RAID</abbr>.</p></li>
</ul>
<p class="rubric">Adición de un disco de reserva</p>
<p>Es necesario preparar las particiones del disco copiando en él la tabla de
particiones de otro disco que ya pertenezca al <abbr title="Redundant Array of Inexpensive Disks">RAID</abbr> y después, simplemente,
añadirlo:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp"># </span>sgdisk<span class="w"> </span>-R<span class="w"> </span>/dev/loop2<span class="w"> </span>/dev/loop0
<span class="gp"># </span>sgdisk<span class="w"> </span>-G<span class="w"> </span>/dev/loop2
<span class="gp"># </span>mdadm<span class="w"> </span>--add-spare<span class="w"> </span>/dev/md0<span class="w"> </span>/dev/loop2p3
</pre></div>
</div>
<p class="rubric">Adición de un disco</p>
<p>En este caso, no basta con añadir el disco, sino que hay que aumentar el número
de discos. Por tanto, a lo anterior, debemos añadir:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp"># </span>mdadm<span class="w"> </span>--grow<span class="w"> </span>/dev/md0<span class="w"> </span>--raid-devices<span class="o">=</span><span class="m">3</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>Existe también la opción <kbd class="kbd compound docutils literal notranslate"><kbd class="kbd docutils literal notranslate">-</kbd>-<kbd class="kbd docutils literal notranslate">add</kbd></kbd>, pero esta sólo añade el disco
al <abbr title="Redundant Array of Inexpensive Disks">RAID</abbr> si el <abbr title="Redundant Array of Inexpensive Disks">RAID</abbr> tiene más dispositivos (los definidos con
<kbd class="kbd compound docutils literal notranslate"><kbd class="kbd docutils literal notranslate">raid</kbd>-<kbd class="kbd docutils literal notranslate">devices</kbd></kbd>) que los que ya tiene correctamente en funcionamiento. Si
no es así, <kbd class="kbd compound docutils literal notranslate"><kbd class="kbd docutils literal notranslate">-</kbd>-<kbd class="kbd docutils literal notranslate">add</kbd></kbd> tiene el efecto de añadir discos de reserva.</p>
</div>
<p class="rubric">Eliminación de disco</p>
<p>Ya se visto el procedimiento: el disco debe marcarse como defectuoso antes de
ser eliminado:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp"># </span>mdadm<span class="w"> </span>--fail<span class="w"> </span>/dev/md0<span class="w"> </span>/dev/loop2p3
<span class="gp"># </span>mdadm<span class="w"> </span>--remove<span class="w"> </span>/dev/md0<span class="w"> </span>/dev/loop2p3
</pre></div>
</div>
<p>Ahora bien, si el proceso se deja aquí el <abbr title="Redundant Array of Inexpensive Disks">RAID</abbr>, aunque tenga suficientes
discos para asegurar la redundancia, quedará cojo y así lo mostrará
<code class="file docutils literal notranslate"><span class="pre">/proc/mdstat</span></code>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp"># </span>cat<span class="w"> </span>/proc/mdstat
<span class="go">Personalities : [raid1] [linear] [multipath] [raid0] [raid6] [raid5] [raid4] [raid10]</span>
<span class="go">md0 : active raid1 loop2p3[2](F) loop1p3[1] loop0p3[0]</span>
<span class="go">      458688 blocks super 1.2 [3/2] [UU_]</span>
</pre></div>
</div>
<p>Es necesario, además, redefinir el número de dispositivos:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp"># </span>mdadm<span class="w"> </span>--grow<span class="w"> </span>/dev/md0<span class="w"> </span>--raid-devices<span class="o">=</span><span class="m">2</span>
</pre></div>
</div>
</section>
<section id="raid-en-discos-arrancables">
<h2><span class="section-number">5.6.2.1.1.7. </span><abbr title="Redundant Array of Inexpensive Disks">RAID</abbr> en discos arrancables<a class="headerlink" href="#raid-en-discos-arrancables" title="Link to this heading">¶</a></h2>
<p>Cuando el <abbr title="Redundant Array of Inexpensive Disks">RAID</abbr> es un <abbr title="Redundant Array of Inexpensive Disks">RAID</abbr> <em>hardware</em> o un fake<abbr title="Redundant Array of Inexpensive Disks">RAID</abbr>, cada disco en toda
su extensión, desde su principio a su final, forma parte del <abbr title="Redundant Array of Inexpensive Disks">RAID</abbr> y en
consecuencia la redundancia incluye también los metadatos del disco (<abbr title="Master Boot Record">MRB</abbr>,
tablas de particiones, particiones de arranque, etc.). En cambio, con los <abbr title="Redundant Array of Inexpensive Disks">RAID</abbr>
por <em>software</em> no ocurre esto y, en el caso que hemos descrito nosotros, sólo la
tercera partición de cada disco constituía parte del <abbr title="Redundant Array of Inexpensive Disks">RAID</abbr>. Esa es la razón por
la que antes de incluir un disco en el <abbr title="Redundant Array of Inexpensive Disks">RAID</abbr> debemos copiar previamente la
tabla de particiones y esa misma es la razón por la que, si añadimos discos sólo
preocupándonos por copiar la tabla de particiones y no el resto de información,
el sistema dejará de ser arrancable cuando el disco que falle sea aquel sobre el
que se instaló el arranque.</p>
<p>Conceptualmente, la solución para que el sistema sea siempre arranque es simple:
además de la tabla de particiones, copiar manualmente en todos los dispositivos
la parte del disco que queda fuera del <abbr title="Redundant Array of Inexpensive Disks">RAID</abbr>: en particiones <abbr title="Disk Operation System">DOS</abbr>, el <abbr title="Master Boot Record">MRB</abbr> y
el espacio sin particionar inmediatamente posterior; y en particiones <abbr title="Globally Unique Identified">GUID</abbr>,
las particiones de arranque (<em>BIOSBOOT</em>, <abbr title="EFI System Partition">ESP</abbr>). Sin embargo, dado que usamos un
<em>software</em> de <em>Linux</em>, nuestro <abbr title="Redundant Array of Inexpensive Disks">RAID</abbr> sólo puede contener sistemas <em>Linux</em> por
lo que el arranque es más que probable que lo hagamos con <abbr title="GRand Unified Bootloader">GRUB</abbr>. En este caso,
la solución es mucho más simple: basta con que nos aseguremos de haber instalado
el gestor en todos los dispositivos. Así, si hemos instalado un sistema en un
<abbr title="Redundant Array of Inexpensive Disks">RAID</abbr> 1 de dos discos, el gestor se habrá instalado en <code class="file docutils literal notranslate"><span class="pre">/dev/sda</span></code>. En ese
caso, lo primero que deberíamos hacer al entrar en el sistema, es instalarlo en
<code class="file docutils literal notranslate"><span class="pre">/dev/sdb</span></code>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp"># </span>grub-install<span class="w"> </span>/dev/sdb
</pre></div>
</div>
<p>De manera semejante deberíamos proceder cada vez que incorporamos un disco nuevo
al <abbr title="Redundant Array of Inexpensive Disks">RAID</abbr>.</p>
<p class="rubric">Notas al pie</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id6" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id2">1</a><span class="fn-bracket">]</span></span>
<p>Véase la discusión sobre <a class="reference internal" href="../01.division/02.boot/06.grub.html#part-gpt-efi"><span class="std std-ref">particionado GPT para UEFI</span></a>.</p>
</aside>
<aside class="footnote brackets" id="id7" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id3">2</a><span class="fn-bracket">]</span></span>
<p>Supuesto libre, en caso contrario se usará <code class="file docutils literal notranslate"><span class="pre">/dev/md126</span></code> y así
sucesivamente hasta encontrar el primero libre.</p>
</aside>
<aside class="footnote brackets" id="id8" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id4">3</a><span class="fn-bracket">]</span></span>
<p>En un sistema real para saber cuál es el disco físico que falla, si ambos son
distintos, podemos recurrir a <a class="reference internal" href="../../02.conbas/02.informacion/04.devices.html#disk-model"><span class="std std-ref">lsblk</span></a>.</p>
</aside>
<aside class="footnote brackets" id="id9" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id5">4</a><span class="fn-bracket">]</span></span>
<p>Estamos usando particionado <abbr title="GUID Parition Table">GPT</abbr> por lo que copiamos la tabla de
particiones usando <a class="reference internal" href="../01.division/03.pract.html#sgdisk"><span class="std std-ref">sgdisk</span></a>. Si el particionado fuera <abbr title="Disk Operation System">DOS</abbr>,
entonces deberíamos usar <a class="reference internal" href="../01.division/03.pract.html#sfdisk"><span class="std std-ref">sfdisk</span></a>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp"># </span>sfdisk<span class="w"> </span>-d<span class="w"> </span>/dev/loop0<span class="w"> </span><span class="p">|</span><span class="w"> </span>sfdisk<span class="w"> </span>/dev/loop1
</pre></div>
</div>
</aside>
</aside>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <div>
    <h3><a href="../../index.html">Tabla de contenido</a></h3>
    <ul>
<li><a class="reference internal" href="#">5.6.2.1.1. <strong class="command">mdadm</strong></a><ul>
<li><a class="reference internal" href="#preliminares">5.6.2.1.1.1. Preliminares</a></li>
<li><a class="reference internal" href="#creacion">5.6.2.1.1.2. Creación</a></li>
<li><a class="reference internal" href="#consulta">5.6.2.1.1.3. Consulta</a></li>
<li><a class="reference internal" href="#ensamblaje">5.6.2.1.1.4. Ensamblaje</a></li>
<li><a class="reference internal" href="#desconexion">5.6.2.1.1.5. Desconexión</a></li>
<li><a class="reference internal" href="#modificacion">5.6.2.1.1.6. Modificación</a></li>
<li><a class="reference internal" href="#raid-en-discos-arrancables">5.6.2.1.1.7. <abbr title="Redundant Array of Inexpensive Disks">RAID</abbr> en discos arrancables</a></li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>Tema anterior</h4>
    <p class="topless"><a href="index.html"
                          title="capítulo anterior"><span class="section-number">5.6. </span><abbr title="Redundant Array of Inexpensive Disks">RAID</abbr>s</a></p>
  </div>
  <div>
    <h4>Próximo tema</h4>
    <p class="topless"><a href="02.lvm.html"
                          title="próximo capítulo"><span class="section-number">5.6.2.1.2. </span><abbr title="Logical Volume Management">LVM</abbr></a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>Esta página</h3>
    <ul class="this-page-menu">
      <li><a href="../../_sources/05.discos/06.raid/01.mdadm.rst.txt"
            rel="nofollow">Mostrar el código</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Búsqueda rápida</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Ir a" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navegación</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="Índice General"
             >índice</a></li>
        <li class="right" >
          <a href="02.lvm.html" title="5.6.2.1.2. LVM"
             >siguiente</a> |</li>
        <li class="right" >
          <a href="index.html" title="5.6. RAIDs"
             >anterior</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">documentación de Linuxnomicón - rolling</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" ><span class="section-number">5. </span>Dispositivos de almacenamiento</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="index.html" ><span class="section-number">5.6. </span><abbr title="Redundant Array of Inexpensive Disks">RAID</abbr>s</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href=""><span class="section-number">5.6.2.1.1. </span><strong class="command">mdadm</strong></a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
    &#169; Copyright CC BY 4.0, 2016-2024, José Miguel Sánchez Alés.
      Creado usando <a href="https://www.sphinx-doc.org/">Sphinx</a> 7.2.6.
    </div>
  </body>
</html>