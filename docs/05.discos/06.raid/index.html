


<!DOCTYPE html>

<html lang="es">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>5.6. RAIDs &#8212; documentación de Linuxnomicón - rolling</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/classic.css" />
    <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
    
    <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/translations.js"></script>
    <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    
    <link rel="index" title="Índice" href="../../genindex.html" />
    <link rel="search" title="Búsqueda" href="../../search.html" />
    <link rel="next" title="5.6.2.1.1. mdadm" href="01.mdadm.html" />
    <link rel="prev" title="5.5.3. Instalaciones desatendidas" href="../05.copias/03.unattended.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navegación</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="Índice General"
             accesskey="I">índice</a></li>
        <li class="right" >
          <a href="01.mdadm.html" title="5.6.2.1.1. mdadm"
             accesskey="N">siguiente</a> |</li>
        <li class="right" >
          <a href="../05.copias/03.unattended.html" title="5.5.3. Instalaciones desatendidas"
             accesskey="P">anterior</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">documentación de Linuxnomicón - rolling</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" accesskey="U"><span class="section-number">5. </span>Dispositivos de almacenamiento</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href=""><span class="section-number">5.6. </span><abbr title="Redundant Array of Inexpensive Disks">RAID</abbr>s</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="raids">
<span id="raid"></span><h1><span class="section-number">5.6. </span><abbr title="Redundant Array of Inexpensive Disks">RAID</abbr>s<a class="headerlink" href="#raids" title="Enlazar permanentemente con este título">¶</a></h1>
<section id="introduccion-teorica">
<h2><span class="section-number">5.6.1. </span>Introducción teórica<a class="headerlink" href="#introduccion-teorica" title="Enlazar permanentemente con este título">¶</a></h2>
<p>Un <abbr title="Redundant Array of Inexpensive Disks">RAID</abbr> puede definirse como un sistema de almacenamiento que, mediante
técnicas <em>hardware</em> o <em>software</em>, utiliza de manera conjunta varios discos para
distribuir los datos entre todos ellos con la finalidad, respecto al uso de un
único disco. de:</p>
<ul>
<li><p>Introducir <strong>redundancia</strong> para hacer el sistema más tolerante a fallos, de
manera que, aunque falle algún disco, el sistema pueda seguir accediendo a los
datos sin interrupciones. El grado de tolerancia a los fallos puede medirse
calculando la <strong>probabilidad de fallo irrecuperable</strong>.</p>
<p>Téngase en cuenta que cuando hay redundancia más importante que el hecho de
que fallen los discos es el hecho de que lo hagan varios casi simultáneamente.
Por ese motivo, algunos consideran buena idea mezclar discos de distinto
fabricante o discos de un mismo fabricante, pero de distinto lote. Pero, por
otro lado, puede no ser una buena idea mezclar discos con distinto
rendimiento.</p>
</li>
<li><p>Aumentar la <strong>capacidad</strong> de almacenamiento, esto es, constituir una unidad de
almacenamiento mayor que la de un disco individual. Es conveniente tener en
cuenta que en los discos que constituyen un <abbr title="Redundant Array of Inexpensive Disks">RAID</abbr> es aprovechable la
capacidad de cada uno sólo hasta la capacidad del más pequeño, por lo que para
no desaprovechar espacio de disco lo óptimo es que todos los discos sean del
mismo tamaño.</p></li>
<li><p>Aumentar el <strong>rendimiento</strong> en las operaciones de lectura y escritura.</p></li>
</ul>
<p>El grado de consecución de estos propósitos depende de cuál sea el tipo de
<abbr title="Redundant Array of Inexpensive Disks">RAID</abbr> que se implemente; y el resultado aparente de la implementación será la
creación de un dispositivo virtual sobre el que el sistema operativo podrá crear
particiones y sistemas de archivos.</p>
<p class="rubric">Tipos de <abbr title="Redundant Array of Inexpensive Disks">RAID</abbr>s</p>
<p>Antes de pasar a describir los más comunes, es preciso fijar la siguiente
<strong>nomenclatura</strong>:</p>
<ul class="simple">
<li><p><span class="var">s</span> es la capacidad del disco físico más pequeño.</p></li>
<li><p><span class="var">n</span> es el número de discos físicos que constituye el <abbr title="Redundant Array of Inexpensive Disks">RAID</abbr>.</p></li>
<li><p><span class="var">p</span> es la probabilidad de que se rompa un disco en un periodo de tiempo
determinado. Se supondrá la misma para todos los discos. Para estimarla
podemos guiarnos por las estadísticas que publica la compañía <a class="reference external" href="https://www.backblaze.com">Backblaze</a>
basada en los fallos de sus propios discos duros. Para 2019, <a class="reference external" href="https://www.backblaze.com/blog/hard-drive-stats-for-2019/">estos fueron los
datos</a>.</p></li>
<li><p>En <abbr title="Redundant Array of Inexpensive Disks">RAID</abbr>s anidados, <span class="var">g</span> es el número de grupos de discos.</p></li>
<li><p>En <abbr title="Redundant Array of Inexpensive Disks">RAID</abbr>s anidados, <span class="var">m</span> es el número de discos del grupo anidado. Por
tanto, <span class="math notranslate nohighlight">\(n = g*m\)</span>.</p></li>
<li><p><span class="math notranslate nohighlight">\(P^n_{rX}(p)\)</span> es la probabilidad de fallo irrecuperable de un <abbr title="Redundant Array of Inexpensive Disks">RAID</abbr> <strong>X</strong>
constituido por <span class="var">n</span> discos cuya probabilidad individual de fallo es <span class="var">p</span>.
Cuando el <abbr title="Redundant Array of Inexpensive Disks">RAID</abbr> es anidado, el número de discos se notará <span class="math notranslate nohighlight">\(n,m\)</span>. Por
ejemplo, <span class="math notranslate nohighlight">\(P^{6,2}_{r10}(1\%)\)</span> es la probabilidad de fallo irrecuperable de
un <abbr title="Redundant Array of Inexpensive Disks">RAID</abbr> 10 de seis discos con tres divisiones de dos discos y una
probabilidad de fallo individual de disco del 1%.</p></li>
</ul>
<dl>
<dt><strong>No RAID</strong></dt><dd><p>Antes de entrar en los tipos de <abbr title="Redundant Array of Inexpensive Disks">RAID</abbr> es conveniente citar agrupaciones de
discos que, aunque no lo son, suelen ser permitidas por las soluciones para
crear <abbr title="Redundant Array of Inexpensive Disks">RAID</abbr>s.</p>
<p>Por una parte, suele usarse el término <abbr title="Just a Bunch Of Drives">JBOD</abbr> (acrónimo en inglés de <em>un mero
puñado de discos</em>) para identificar a un conjunto de discos del que se
preserva la independencia de cada uno. En cambio, cuando estos discos definen
un único disco virtual que es la concatenación de todos los discos que lo
constituyen, se habla de <em>span</em> o <em>big</em><a class="footnote-reference brackets" href="#id5" id="id1">1</a>. El <em>software</em>, simplemente, se
limita a crear el dispositivo virtual e ir rellenado con datos sucesivamente
los discos, de modo que cuando acaba de llenar uno, sigue con el siguiente.</p>
<img alt="../../_images/JBOD.png" src="../../_images/JBOD.png" />
<p>En este segundo caso, de concatenación:</p>
<ul class="simple">
<li><p>El sistema no es tolerante a fallos, puesto que no existe redundancia.
Ahora bien, la rotura de un disco implica únicamente la pérdida de los
archivos almacenados en él.</p></li>
<li><p>La probabilidad de que el sistema falle parcialmente es de
<span class="math notranslate nohighlight">\(P^n_{r0}(p) = 1-(1-p)^n\)</span>.</p></li>
<li><p>La capacidad del conjunto es la suma de todas las capacidades, esto es,
<span class="math notranslate nohighlight">\(n*s\)</span>, aunque en este caso no es necesario siquiera que los discos
tengan la misma capacidad.</p></li>
<li><p>No hay mejora alguna en el rendimiento.</p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>En realidad, esto podría ser, simplemente, un <em>grupo de volúmenes</em>
de <a class="reference internal" href="../01.division/04.virt.html#lvm"><span class="std std-ref">LVM</span></a> o, lo que hemos denominado, <em>disco virtual</em> en nuestra
<a class="reference internal" href="../01.division/index.html#disk-div"><span class="std std-ref">introducción teórica</span></a>.</p>
</div>
</dd>
<dt><strong>RAID 0</strong> (o <strong>Volumen dividido</strong>)</dt><dd><p>Se forma con dos o más discos entre los cuales se distribuye equitativamente
la información sin incluir información redundante.</p>
<img alt="../../_images/RAID0.png" src="../../_images/RAID0.png" />
<p>En lo referente a los propósitos de <abbr title="Redundant Array of Inexpensive Disks">RAID</abbr>:</p>
<ul class="simple">
<li><p>El sistema no es tolerante a fallos, puesto que no existe redundancia. En
consecuencia, no puede romperse ningún disco. Y es más, cuanto mayor sea el
número de discos, menos fiabilidad tendrá el sistema, ya que aumenta la
probabilidad de que uno de ellos falle y se desbarate toda la información.</p></li>
<li><p>La probabilidad de que el sistema falle es de <span class="math notranslate nohighlight">\(P^n_{r0}(p) = 1-(1-p)^n\)</span>.</p></li>
<li><p>La capacidad del conjunto es <span class="math notranslate nohighlight">\(n*s\)</span>.</p></li>
<li><p>Mejora el rendimiento tanto en la lectura como en la escritura, ya que se
puede leer y escribir simultáneamente en los discos.</p></li>
</ul>
</dd>
<dt><strong>RAID 1</strong> (o <strong>Espejo</strong>)</dt><dd><p>Se forma con dos o más discos de modo que lo que se escribe en uno se
replica en todos los demás.</p>
<img alt="../../_images/RAID1.png" src="../../_images/RAID1.png" />
<p>En este caso, el conjunto es altamente redundante tanto más cuantos más
discos haya, a costa de sacrificar capacidad:</p>
<ul class="simple">
<li><p>El sistema es capaz de soportar la ruptura de <span class="math notranslate nohighlight">\(n-1\)</span> discos sin que se
produzca pérdida de información.</p></li>
<li><p>La probabilidad de que el sistema falle es de <span class="math notranslate nohighlight">\(P^n_{r1}(p) = p^n\)</span>.</p></li>
<li><p>No aumenta la capacidad del conjunto que seguirá siendo la capacidad
individual de uno de los discos, <span class="math notranslate nohighlight">\(s\)</span>.</p></li>
<li><p>Aumenta el rendimiento de las lecturas, ya que pueden realizarse lecturas
simultáneas, pero no el de escritura.</p></li>
</ul>
</dd>
<dt><strong>RAID 5</strong></dt><dd><p>Es un sistema de al menos tres discos físicos, de manera que la información
se distribuye en todos ellos, excepto en uno en el que se incluye información
de paridad, por lo que es posible recuperar la información ante el fallo de
uno de los discos. La base del cálculo de la paridad es la operación lógica
<em>XOR</em> que se caracteriza porque cuando el número de <strong>1</strong> en los operandos es
impar el resultado es <strong>1</strong> y, cuando es par, <strong>0</strong>. En consecuencia,
suponiendo que los operandos sean <em>bits</em>, obtenemos la siguiente tabla:</p>
<table class="xor docutils align-default">
<colgroup>
<col style="width: 11%" />
<col style="width: 11%" />
<col style="width: 11%" />
<col style="width: 68%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>O1</p></th>
<th class="head"><p>O2</p></th>
<th class="head"><p>O2</p></th>
<th class="head"><p>O1⊕O2⊕O3</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0</p></td>
<td><p>0</p></td>
<td><p>0</p></td>
<td><p>0</p></td>
</tr>
<tr class="row-odd"><td><p>0</p></td>
<td><p>0</p></td>
<td><p>1</p></td>
<td><p>1</p></td>
</tr>
<tr class="row-even"><td><p>0</p></td>
<td><p>1</p></td>
<td><p>0</p></td>
<td><p>1</p></td>
</tr>
<tr class="row-odd"><td><p>0</p></td>
<td><p>1</p></td>
<td><p>1</p></td>
<td><p>0</p></td>
</tr>
<tr class="row-even"><td><p>1</p></td>
<td><p>0</p></td>
<td><p>0</p></td>
<td><p>1</p></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p>0</p></td>
<td><p>1</p></td>
<td><p>0</p></td>
</tr>
<tr class="row-even"><td><p>1</p></td>
<td><p>1</p></td>
<td><p>0</p></td>
<td><p>0</p></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p>1</p></td>
<td><p>1</p></td>
<td><p>1</p></td>
</tr>
</tbody>
</table>
<p>en la que podremos darnos cuenta, que tapemos la columna que tapemos, podemos
deducir sus valores aplicando la operación <em>XOR</em> a los valores de las
columnas aún visibles. En un <abbr title="Redundant Array of Inexpensive Disks">RAID</abbr> 5 el cálculo de la paridad es más
complejo, ya que tal cálculo  se hace a nivel de bloques y el bloque de
paridad se distribuye equitativamente entre todos los discos físicos.</p>
<img alt="../../_images/RAID5.png" src="../../_images/RAID5.png" />
<p>En este tipo:</p>
<ul class="simple">
<li><p>Es tolerante a fallos en la medida, en que la paridad permite que se pueda
estropear un único disco.</p></li>
<li><p>La probabilidad de que el sistema falle es la probabilidad de que falle
un <abbr title="Redundant Array of Inexpensive Disks">RAID</abbr> 0 menos la probabilidad de que sólo se rompa un disco, ya que en
este caso el <abbr title="Redundant Array of Inexpensive Disks">RAID</abbr> 0 sí falla, pero el <abbr title="Redundant Array of Inexpensive Disks">RAID</abbr> 5, no. Por tanto:
<span class="math notranslate nohighlight">\(P^n_{r5}(p) = P^n_{r0} - n*p*(1-p)^{n-1}\)</span>.</p></li>
<li><p>Aumenta la capacidad, ya que la paridad sólo ocupa el equivalente a un
disco físico. Por tanto, obtendremos una capacidad de <span class="math notranslate nohighlight">\((n-1)*s\)</span>.</p></li>
<li><p>Hay mejora en el rendimiento de las lecturas, pero hay una penalización
en las escrituras, ya que una escritura implica leer datos del resto de
discos para generar la paridad y escribir ésta. Esta bajada en el
rendimiento en las escrituras es su principal defecto.</p></li>
</ul>
<p>Variantes de este nivel son:</p>
<ul class="simple">
<li><p>El <abbr title="Redundant Array of Inexpensive Disks">RAID</abbr> 4 en que la información de paridad se almacena siempre en el
mismo disco.</p></li>
<li><p>El <abbr title="Redundant Array of Inexpensive Disks">RAID</abbr> 3 en que ocurre lo mismo, pero, además, los datos se dividen en
<em>bytes</em> y no en bloques.</p></li>
<li><p>El <abbr title="Redundant Array of Inexpensive Disks">RAID</abbr> Z, que es implementado por el sistema de archivos <abbr title="Zettabyte File System">ZFS</abbr> y es
semejante al <abbr title="Redundant Array of Inexpensive Disks">RAID</abbr> 5, pero que añade variantes para mejorar el rendimiento
en las escrituras.</p></li>
</ul>
</dd>
<dt><strong>RAID 6</strong></dt><dd><p>Es parecido a un <abbr title="Redundant Array of Inexpensive Disks">RAID</abbr> 5, pero genera dos bloques de paridad y no uso sólo.
Por tanto, el número mínimo de discos para constituirlo es 4. En él, se
sacrifica la capacidad por el aumento de fiabilidad, ya que pueden fallar
hasta dos discos:</p>
<ul class="simple">
<li><p>Tolera que fallen hasta dos discos.</p></li>
<li><p>La probabilidad de que el sistema falle es la probabilidad de que falle un
<abbr title="Redundant Array of Inexpensive Disks">RAID</abbr> 5 menos la probabilidad de que fallen dos discos, ya que en este
caso un <abbr title="Redundant Array of Inexpensive Disks">RAID</abbr> 5 falla, pero un <abbr title="Redundant Array of Inexpensive Disks">RAID</abbr> 6, no. Por tanto:
<span class="math notranslate nohighlight">\(P^n_{r6}(p) = P^n_{r5}(p) - n*(n-1)*p^2*(1-p)^{n-2}\)</span>.</p></li>
<li><p>Aumenta la capacidad, hasta <span class="math notranslate nohighlight">\((n-2)*s\)</span>.</p></li>
<li><p>Presenta unas características de rendimiento semejantes a la de su primo
hermano el <abbr title="Redundant Array of Inexpensive Disks">RAID</abbr>5, aunque respecto a éste no mejora el rendimiento en
las lecturas y empeora el de las escrituras.</p></li>
</ul>
<img alt="../../_images/RAID6.png" src="../../_images/RAID6.png" />
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>El sistema de archivos <abbr title="Zettabyte File System">ZFS</abbr> implementa también su propia versión
con mejor rendimiento de escritura frente el <abbr title="Redundant Array of Inexpensive Disks">RAID</abbr>6, a la que
denomina <abbr title="Redundant Array of Inexpensive Disks">RAID</abbr> Z2.</p>
</div>
</dd>
</dl>
<p>Hay, además, sistemas <abbr title="Redundant Array of Inexpensive Disks">RAID</abbr>s que se constituyen <strong>anidando</strong> dos o más
niveles de <abbr title="Redundant Array of Inexpensive Disks">RAID</abbr>. Los más utilizados son:</p>
<dl>
<dt><strong>RAID 0+1</strong> (o <strong>Espejo de divisiones</strong> o <strong>RAID 01</strong>):</dt><dd><p>Es un sistema híbrido formado con un mínimo de cuatro discos, en los que los
<span class="var">n</span> discos se agrupan en <span class="var">g</span> grupos de <span class="var">m</span> cada uno. Cada
grupo de <span class="var">m</span> discos constituye un <abbr title="Redundant Array of Inexpensive Disks">RAID</abbr> 0 y con todos los grupos se
forma un <abbr title="Redundant Array of Inexpensive Disks">RAID</abbr> 1.  Si tenemos cuatro discos y los agrupamos de 2 en 2, este
será el resultado:</p>
<img alt="../../_images/RAID0+1.png" src="../../_images/RAID0+1.png" />
<p>Con esta disposición:</p>
<ul class="simple">
<li><p>Hay tolerancia a fallos, ya que el sistema falla sólo cuando falla al menos
un mismo disco de todos los grupos en <abbr title="Redundant Array of Inexpensive Disks">RAID</abbr> 0.</p></li>
<li><p>La probabilidad de que falle irremediable el sistema<a class="footnote-reference brackets" href="#id6" id="id2">2</a> es <span class="math notranslate nohighlight">\(P^{n,m}_{r01}(p) = P^{n/m}_{r1}(P^m_{r0}(p)) = (1 - (1 - p)^m)^{n/m}\)</span></p></li>
<li><p>Aumenta la capacidad hasta <span class="math notranslate nohighlight">\(m * s\)</span>.</p></li>
<li><p>Hay mejora en el rendimiento de lecturas y escrituras.</p></li>
</ul>
</dd>
<dt><strong>RAID 1+0</strong> (o <strong>Divisiones en espejo</strong> o <strong>RAID 10</strong>):</dt><dd><p>El sistema es parecido al anterior, pero se invierten los niveles: cada grupo
de <span class="var">m</span> discos forma un <abbr title="Redundant Array of Inexpensive Disks">RAID</abbr> 1 y con todos los grupos se forma un
<abbr title="Redundant Array of Inexpensive Disks">RAID</abbr> 0. Como en el caso anterior se requieren al menos cuatro discos:</p>
<img alt="../../_images/RAID1+0.png" src="../../_images/RAID1+0.png" />
<p>Esta disposición supone:</p>
<ul class="simple">
<li><p>Hay tolerancia a fallos, ya que el sistema falla cuando fallan
todos los discos de una misma división.</p></li>
<li><p>La probabilidad de que el sistema falle es de <span class="math notranslate nohighlight">\(P^{n,m}_{r10}(p) = P^{n/m}_{0}(P^m_{r1}(p)) = 1-(1-p^m)^\frac{n}{m}\)</span>.</p></li>
<li><p>Aumenta la capacidad hasta <span class="math notranslate nohighlight">\(\frac{n}{m}*s\)</span>.</p></li>
<li><p>Hay mejora en el rendimiento de las lecturas y las escrituras,</p></li>
</ul>
</dd>
<dt><strong>RAID 5+0</strong> (o <strong>RAID 50</strong>)</dt><dd><p>Como el anterior, pero el nivel del <abbr title="Redundant Array of Inexpensive Disks">RAID</abbr> anidado es un <abbr title="Redundant Array of Inexpensive Disks">RAID</abbr>5, por lo
que el mínimo de discos para constituirlo es <strong>6</strong>:</p>
<img alt="../../_images/RAID5+0.png" src="../../_images/RAID5+0.png" />
<ul class="simple">
<li><p>Hay tolerancia a fallos, ya que el sistema falla cuando falla uno
de los <abbr title="Redundant Array of Inexpensive Disks">RAID</abbr>s 5 que constituye cualquiera de las divisiones, esto es
que fallen dos discos de una misma división.</p></li>
<li><p>La probabilidad de que el sistema falle es de <span class="math notranslate nohighlight">\(P^{n.m}_{r50}(p) = P^{n/m}_{0}(P^m_{r5}(p))\)</span>.</p></li>
<li><p>Aumenta la capacidad hasta <span class="math notranslate nohighlight">\((n - \frac{n}{m})*s\)</span>.</p></li>
<li><p>Mejora el rendimiento en lectura y escritura respecto al <abbr title="Redundant Array of Inexpensive Disks">RAID</abbr> 5.</p></li>
</ul>
</dd>
</dl>
<p>También son comunes las anidaciones en tres niveles del <abbr title="Redundant Array of Inexpensive Disks">RAID</abbr> 100 y el <abbr title="Redundant Array of Inexpensive Disks">RAID</abbr>
101.</p>
<p class="rubric">Consideraciones</p>
<p>Sea cual sea la implementación y el nivel del <abbr title="Redundant Array of Inexpensive Disks">RAID</abbr>, hay una serie de
consideraciones a tener en cuenta:</p>
<ol class="arabic simple">
<li><p>Al constituirlos es necesario que se creen una serie de <strong>estructuras de
metadatos</strong> a semejanza de lo que ocurre con los sistemas de ficheros. Este
hecho, <a class="reference internal" href="#raid-metadatos"><span class="std std-ref">puede darnos problemas</span></a>.</p></li>
<li><p>Debe habilitarse algún mecanismo para advertir al administrador del <strong>fallo
de disco</strong>, a fin de que sea diligente en su sustitución. Estos mecanismos
pueden ser muy variados (pitidos, leds, apunte en el registro), pero es
conveniente que incluyan el envío de un correo electrónico de aviso (o
cualquier otro método de teleaviso).</p></li>
<li><p>Al reemplazarse un dispositivo defectuoso por uno nuevo, se desencadena un
<strong>proceso de recuperación</strong> para volver a la situación previa a la rotura.</p>
</li>
<li id="hot-spare"><p>Para minimizar el tiempo de sustitución de un disco defectuoso, algunos
sistemas incorporan un <strong>dispositivo de reserva</strong> (<em>hot spare</em>) que se
encuentra conectado pero inactivo, por lo que no forma parte efectiva del
<abbr title="Redundant Array of Inexpensive Disks">RAID</abbr>. Al surgir un fallo en algún disco, éste se inhabilita y
automáticamente el disco de reserva ocupa su lugar en el <abbr title="Redundant Array of Inexpensive Disks">RAID</abbr>, por lo que
comienza inmediatamente el <em>proceso de recuperación</em>. La labor del
administrador consistirá en añadir al sistema un nuevo disco de reserva para
la próxima vez que se produzca una rotura.</p></li>
<li><p>Tenga presente que, si el sistema sólo tenía un grado de redundancia (p.e. un
<abbr title="Redundant Array of Inexpensive Disks">RAID</abbr> 5 o un <abbr title="Redundant Array of Inexpensive Disks">RAID</abbr> 1 de dos discos), durante el proceso de reconstrucción
el sistema es vulnerable  por lo que cualquier nuevo fallo provoca la pérdida
irrecuperable de los datos. Además, este proceso requiere muchas lecturas
sobre los discos supervivientes, lo que los sobrecarga de trabajo y hace al
sistema especialmente propenso a un nuevo fallo, esta vez fatal. Por eso,
algunos administradores consideran que tras un fallo lo mejor es proceder a
un <em>backup</em> de los datos antes de la reconstrucción; y rechazan como buena
la idea de habilitar discos de reserva (véase, por ejemplo, <a class="reference external" href="https://blog.open-e.com/why-a-hot-spare-hard-disk-is-a-bad-idea/">este artículo</a>).</p></li>
</ol>
<p class="rubric">Técnicas de implementación</p>
<p>Hay tres estrategias para la implementación de un sistema <abbr title="Redundant Array of Inexpensive Disks">RAID</abbr>:</p>
<dl>
<dt>Mediante <strong>controladora hardware</strong></dt><dd><p>Por lo general, a una tarjeta de expansión que hace las veces de controladora
de disco se le conectan los discos físicos que constituirán el <abbr title="Redundant Array of Inexpensive Disks">RAID</abbr>. En este
caso, la configuración se establece mediante un firmware particular de la
propia controladora y se carga con anterioridad al arranque del sistema
operativo, por lo que para el sistema operativo sólo tiene conocimiento de la
existencia del dispositivo virtualizado.</p>
<p>Es la solución más costosa, pero la más eficiente al dedicarse a ella
<em>hardware</em> específico.</p>
</dd>
<dt>Mediante <strong>firmware</strong></dt><dd><p>También denominado <em class="dfn">RAID híbrido</em> o <em class="dfn">fakeRAID</em>, que es una solución
barata en la que no hay ninguna controladora específica dedicada a la
constitución del <abbr title="Redundant Array of Inexpensive Disks">RAID</abbr>, sino que el chip de la controladora de disco
incluye <em>firmware</em> específico para la definición del <abbr title="Redundant Array of Inexpensive Disks">RAID</abbr>. Como en el caso
anterior, la configuración del <abbr title="Redundant Array of Inexpensive Disks">RAID</abbr> se hace con anterioridad a la carga del
sistema operativo, por la que éste sólo muestra el dispositivo virtual, pero
será el procesador el encargado de procesar todo lo necesario, como en el
caso posterior.</p>
<p>Aunque aparentemente es una solución similar, al no existir <em>hardware</em>
específico dedicado y delegar todos los cálculos en el procesador, su
rendimiento es peor y, por lo general, es conveniente una solución <em>software</em>
pura.</p>
</dd>
<dt>Mediante <strong>software</strong></dt><dd><p>esto es, mediante aplicaciones que provee el propio sistema operativo o
porque sea una característica que soporta el sistema de ficheros. En este
caso, el sistema operativo verá tanto los dispositivos físicos como el
dispositivo virtual resultado de haber constituido el <abbr title="Redundant Array of Inexpensive Disks">RAID</abbr>.</p>
<p>Los sistemas operativos comunes traen herramientas para la creación de
<abbr title="Redundant Array of Inexpensive Disks">RAID</abbr>s:</p>
<ul class="simple">
<li><p><em>MasOs</em>, <em>FreeBSD</em>, <em>NetBSD</em> o <em>OpenBSD</em> cada uno con sus respectivas
herramientas.</p></li>
<li><p><em>Windows</em> gracias a <a class="reference external" href="https://en.wikipedia.org/wiki/Logical_Disk_Manager">Logical Disk Manager</a> y en las versiones modernas
de servidor a <a class="reference external" href="https://en.wikipedia.org/wiki/Features_new_to_Windows_8#Storage">Storage Spaces</a>.</p></li>
<li><p><em>Linux</em> mediante su módulo <strong class="command">md</strong>, que será al que dediquemos
el resto del epígrafe.</p></li>
</ul>
<p>Por su parte, algunos sistemas de ficheros soportan directamente la
constitución de dispositivos <abbr title="Redundant Array of Inexpensive Disks">RAID</abbr> como <abbr title="Zettabyte File System">ZFS</abbr> o <abbr title="B-TRee File System">BtrFS</abbr>.</p>
<table class="raid-zfs docutils align-default" id="id8">
<caption><span class="caption-text">Equivalencias con <abbr title="Zettabyte File System">ZFS</abbr></span><a class="headerlink" href="#id8" title="Enlace permanente a esta tabla">¶</a></caption>
<colgroup>
<col style="width: 23%" />
<col style="width: 77%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Nivel</p></th>
<th class="head"><p>Nombre en <abbr title="Zettabyte File System">ZFS</abbr></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0</p></td>
<td><p>Striped Vdev</p></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p>Mirrored Vdev</p></td>
</tr>
<tr class="row-even"><td><p>5</p></td>
<td><p>Z</p></td>
</tr>
<tr class="row-odd"><td><p>6</p></td>
<td><p>Z2</p></td>
</tr>
<tr class="row-even"><td><p>10</p></td>
<td><p>Striped mirrored Vdev</p></td>
</tr>
<tr class="row-odd"><td><p>50, 60</p></td>
<td><p>Striped RaidZ Zpool</p></td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="admonition-title">Ver también</p>
<p>Puede consultar una breve descripción de cada <abbr title="Redundant Array of Inexpensive Disks">RAID</abbr>
en <a class="reference external" href="http://www.zfsbuild.com/2010/05/26/zfs-raid-levels/">este artículo sobre ZFS</a>.</p>
</div>
</dd>
</dl>
<p id="raid-metadatos">Es importante tener presente que la constitución de un <abbr title="Redundant Array of Inexpensive Disks">RAID</abbr> exige el
almacenamiento de los metadatos que lo definen. En los tres casos, esos
metadatos se almacenan en los propios dispositivos de almacenamiento<a class="footnote-reference brackets" href="#id7" id="id3">3</a>. Es
conveniente, tener presente esto, sobre todo cuando sustituimos el <em>hardware</em> en
los dos primeros casos:</p>
<ul>
<li><p>Si nuestra intención es ser capaz de leer datos, entonces necesitaremos
que el sistema sea capaz de entender tales metadatos:</p>
<ul class="simple">
<li><p>En el caso de los <abbr title="Redundant Array of Inexpensive Disks">RAID</abbr> por <em>hardware</em>, el núcleo de linux dispone de
algunos <em>drivers</em> (véase <a class="reference external" href="https://wiki.debian.org/LinuxRaidForAdmins">esta página de la wiki de debian al respecto</a>).</p></li>
<li><p>En el caso de los fake<abbr title="Redundant Array of Inexpensive Disks">RAID</abbr>, puede sacarnos del apuro <em class="manpage"><a class="manpage reference external" href="https://manpages.debian.org/dmraid(8)">dmraid(8)</a></em>.</p></li>
</ul>
</li>
<li><p>Si nuestra intención es reaprovechar los discos sin preocuparnos por la
información, entonces deberemos asegurarnos de eliminar los metadatos. Para
ello, suele ser suficiente con sobrescribir con ceros los primeros y los
últimos 512KiB de cada dispositivo:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> dd &lt; /dev/zero &gt; /dev/sdX <span class="nv">bs</span><span class="o">=</span><span class="m">512</span> <span class="nv">count</span><span class="o">=</span><span class="m">1024</span>
<span class="gp">#</span> dd &lt; /dev/zero &gt; /dev/sdX <span class="nv">bs</span><span class="o">=</span><span class="m">512</span> <span class="nv">seek</span><span class="o">=</span><span class="k">$((</span><span class="sb">`</span>blockdev --getsz /dev/sdX<span class="sb">`</span> <span class="o">-</span> <span class="m">1024</span><span class="k">))</span> <span class="nv">count</span><span class="o">=</span><span class="m">1024</span>
</pre></div>
</div>
</li>
</ul>
</section>
<section id="raids-en-linux">
<span id="raid-linux"></span><h2><span class="section-number">5.6.2. </span><abbr title="Redundant Array of Inexpensive Disks">RAID</abbr>s en <em>Linux</em><a class="headerlink" href="#raids-en-linux" title="Enlazar permanentemente con este título">¶</a></h2>
<p>Ilustraremos la creación y manipulación de <abbr title="Redundant Array of Inexpensive Disks">RAID</abbr> implementando un <abbr title="Redundant Array of Inexpensive Disks">RAID</abbr> 1,
porque no entraña excesiva dificultad crear <abbr title="Redundant Array of Inexpensive Disks">RAID</abbr>s de otros niveles. Es obvio
que para ello necesitaremos los discos físicos que
constituyen el <abbr title="Redundant Array of Inexpensive Disks">RAID</abbr>. Para evitarlos usaremos ficheros que emulen estos discos
físicos:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> truncate -s 500M /tmp/0.disk
<span class="gp">#</span> losetup /dev/loop0 /tmp/0.disk
<span class="gp">#</span> truncate -s 500M /tmp/1.disk
<span class="gp">#</span> losetup /dev/loop1 /tmp/1.disk
</pre></div>
</div>
<p>De modo que nuestros dispositivos físicos serán <code class="file docutils literal notranslate"><span class="pre">/dev/loop0</span></code> y
<code class="file docutils literal notranslate"><span class="pre">/dev/loop1</span></code> en vez de <code class="file docutils literal notranslate"><span class="pre">sda</span></code>, <code class="file docutils literal notranslate"><span class="pre">sdb</span></code>, etc.</p>
<div class="admonition warning">
<p class="admonition-title">Advertencia</p>
<p>Tenga presente que está manipulando directamente dispositivos de
disco, por lo que si confunde las unidades y realiza la operación sobre el
disco que contiene su sistema operativo, lo perderá todo. La guía utiliza
<code class="file docutils literal notranslate"><span class="pre">/dev/loop0</span></code> y <code class="file docutils literal notranslate"><span class="pre">/dev/loop1</span></code> entre otras cosas para evitar que un
<em>corta y pega</em> irreflexivo, provoque una catástrofe en su sistema.</p>
</div>
<section id="implementaciones">
<h3><span class="section-number">5.6.2.1. </span>Implementaciones<a class="headerlink" href="#implementaciones" title="Enlazar permanentemente con este título">¶</a></h3>
<p>El núcleo de linux dispone de un driver llamado <abbr title="Multiple Devices">MD</abbr> para el soporte de
volúmenes <abbr title="Redundant Array of Inexpensive Disks">RAID</abbr>. Y, de hecho, como herramienta de bajo nivel existe
<em class="manpage"><a class="manpage reference external" href="https://manpages.debian.org/dmsetup(8)">dmsetup(8)</a></em>.  Sin embargo, es mejor usar herramientas de usuario
más sencillas para la creación y gestión de estos dispositivos, para lo cual
tenemos fundamentalmente dos posibilidades:</p>
<ul class="simple">
<li><p><a class="reference internal" href="01.mdadm.html#mdadm"><span class="std std-ref">mdadm</span></a>, que es una herramienta exclusiva para la gestión de
estos dispositivos y que nos permite un control más preciso sobre nuestra
configuración.</p></li>
<li><p><a class="reference internal" href="../01.division/04.virt.html#lvm"><span class="std std-ref">lvm</span></a> que, desde su versión 2, permite la definición de volúmenes
lógicos que sean a su vez dispositivos <abbr title="Redundant Array of Inexpensive Disks">RAID</abbr>, para lo cual el grupo de
volúmenes deberá haberse construido sobre dos o más volúmenes físicos,
obviamente.</p></li>
</ul>
<p>Estudiaremos ambas posibilidades.</p>
<div class="toctree-wrapper compound">
<ul>
<li class="toctree-l1"><a class="reference internal" href="01.mdadm.html">5.6.2.1.1. <strong class="command">mdadm</strong></a></li>
<li class="toctree-l1"><a class="reference internal" href="02.lvm.html">5.6.2.1.2. <abbr title="Logical Volume Management">LVM</abbr></a></li>
</ul>
</div>
</section>
</section>
<section id="pruebas-de-rendimiento">
<h2><span class="section-number">5.6.3. </span>Pruebas de rendimiento<a class="headerlink" href="#pruebas-de-rendimiento" title="Enlazar permanentemente con este título">¶</a></h2>
<div class="admonition-todo admonition" id="id4">
<p class="admonition-title">Por hacer</p>
<p>Proponer pruebas de lectura y escritura con alguna de las
herramientas sogeridas en <a class="reference external" href="https://linuxhint.com/benchmark_hard_disks_linux/">este artículo de Linuxhint</a>.</p>
</div>
<p class="rubric">Notas al pie</p>
<dl class="footnote brackets">
<dt class="label" id="id5"><span class="brackets"><a class="fn-backref" href="#id1">1</a></span></dt>
<dd><p>Aunque puede llegarse a utilizar también el término <abbr title="Just a Bunch Of Drives">JBOD</abbr>.</p>
</dd>
<dt class="label" id="id6"><span class="brackets"><a class="fn-backref" href="#id2">2</a></span></dt>
<dd><p>Para el cálculo se está suponiendo que no pueden recomponerse los datos
tomando discos de dos grupos distintos. Si esto puede hacerse, entonces la
probabilidad será menor. ¿Puede hacerse?</p>
</dd>
<dt class="label" id="id7"><span class="brackets"><a class="fn-backref" href="#id3">3</a></span></dt>
<dd><p>Incluso en los <abbr title="Redundant Array of Inexpensive Disks">RAID</abbr> por <em>hardware</em> y los fake<abbr title="Redundant Array of Inexpensive Disks">RAID</abbr> en los que habría
cabido la posibilidad de que esos metadatos se hubieran registrado en memoria
<em>NVRAM</em> de la controladora o de la placa base.</p>
</dd>
</dl>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../../index.html">Tabla de contenido</a></h3>
  <ul>
<li><a class="reference internal" href="#">5.6. <abbr title="Redundant Array of Inexpensive Disks">RAID</abbr>s</a><ul>
<li><a class="reference internal" href="#introduccion-teorica">5.6.1. Introducción teórica</a></li>
<li><a class="reference internal" href="#raids-en-linux">5.6.2. <abbr title="Redundant Array of Inexpensive Disks">RAID</abbr>s en <em>Linux</em></a><ul>
<li><a class="reference internal" href="#implementaciones">5.6.2.1. Implementaciones</a></li>
</ul>
</li>
<li><a class="reference internal" href="#pruebas-de-rendimiento">5.6.3. Pruebas de rendimiento</a></li>
</ul>
</li>
</ul>

  <h4>Tema anterior</h4>
  <p class="topless"><a href="../05.copias/03.unattended.html"
                        title="capítulo anterior"><span class="section-number">5.5.3. </span>Instalaciones desatendidas</a></p>
  <h4>Próximo tema</h4>
  <p class="topless"><a href="01.mdadm.html"
                        title="próximo capítulo"><span class="section-number">5.6.2.1.1. </span><strong class="command">mdadm</strong></a></p>
  <div role="note" aria-label="source link">
    <h3>Esta página</h3>
    <ul class="this-page-menu">
      <li><a href="../../_sources/05.discos/06.raid/index.rst.txt"
            rel="nofollow">Mostrar el código</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Búsqueda rápida</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Ir a" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navegación</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="Índice General"
             >índice</a></li>
        <li class="right" >
          <a href="01.mdadm.html" title="5.6.2.1.1. mdadm"
             >siguiente</a> |</li>
        <li class="right" >
          <a href="../05.copias/03.unattended.html" title="5.5.3. Instalaciones desatendidas"
             >anterior</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">documentación de Linuxnomicón - rolling</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" ><span class="section-number">5. </span>Dispositivos de almacenamiento</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href=""><span class="section-number">5.6. </span><abbr title="Redundant Array of Inexpensive Disks">RAID</abbr>s</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Derechos de autor CC BY 4.0, 2016-2022, José Miguel Sánchez Alés.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 4.3.2.
    </div>
  </body>
</html>