


<!DOCTYPE html>

<html lang="es">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>5.1.2. Arranque &#8212; documentación de Linuxnomicón - rolling</title>
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
    
    <script id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/translations.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <link rel="index" title="Índice" href="../../genindex.html" />
    <link rel="search" title="Búsqueda" href="../../search.html" />
    <link rel="next" title="5.1.2.2.1. rEFInd" href="02.boot/01.refind.html" />
    <link rel="prev" title="5.1.1. Particiones" href="01.part.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navegación</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="Índice General"
             accesskey="I">índice</a></li>
        <li class="right" >
          <a href="02.boot/01.refind.html" title="5.1.2.2.1. rEFInd"
             accesskey="N">siguiente</a> |</li>
        <li class="right" >
          <a href="01.part.html" title="5.1.1. Particiones"
             accesskey="P">anterior</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">documentación de Linuxnomicón - rolling</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" ><span class="section-number">5. </span>Dispositivos de almacenamiento</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="index.html" accesskey="U"><span class="section-number">5.1. </span>División del disco</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href=""><span class="section-number">5.1.2. </span>Arranque</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="arranque">
<span id="id1"></span><h1><span class="section-number">5.1.2. </span>Arranque<a class="headerlink" href="#arranque" title="Enlazar permanentemente con este título">¶</a></h1>
<p>El primer <em>software</em> que carga un ordenador al iniciarse es el <em>firmware</em>
almacenado en la placa base. que cumple cuatro funciones fundamentalmente:</p>
<ul>
<li><p>Analizar el <em>hardware</em> presente en el ordenador con un proceso conocido como
<abbr title="Power On Self Test">POST</abbr>. El análisis puede no detectar problemas irresolubles (lo que
generalmente se señala con un breve pitido) y encontrar algún defecto que
impida el funcionamiento del equipo y para el arranque. De cuál sea en
particular el defecto se informa mediante un código constituido por una
combinación de pitidos breves y largos, cada una de las cuales identifica un
problema distintos.</p>
<p>El proceso de arranque que contiene esta comprobación se denominan
<em class="dfn">arranque en frío</em>, frente al <em class="dfn">arranque en calente</em> que carece de
ella. La regla es que los <em>arranques en frío</em> se producen cuando se enciende
un ordenador apagado y los <em>arranques en caliente</em>, cuando se reinicia un
ordenador.</p>
</li>
<li><p>Proporcionar una gestión básica de E/S para que al menos el usuario pueda
utilizar el teclado.</p></li>
<li><p>Permitir la reconfiguración del firmware con el fin de que se pueda cambiar el
comportamiento del <em>firmware</em> (p.e. para aligerar el proceso <abbr title="Power On Self Test">POST</abbr> o
cambiar cuál será el cargador de arranque que se lanzará posteriormente).</p></li>
<li><p>Cargar un programa posterior al que se le ceda el control, el cual
habitualmente es el núcleo de un sistema operativo.</p></li>
</ul>
<p>Hay dos <strong>estándares</strong> fundamentales:</p>
<ul class="simple">
<li><p>Desde los años 70, el antiguo <abbr title="Basic I/O System">BIOS</abbr> de 16 bits.</p></li>
<li><p>A partir de 2005, <abbr title="Extensible Firmware Interface">EFI</abbr> o <abbr title="Unified Extensible Firmware Interface">UEFI</abbr><a class="footnote-reference brackets" href="#id12" id="id2">1</a> de 32 <em>bits</em> (arquitectura <em>x86</em>) ó 64
<em>bits</em> (arquitectura <em>x86_64</em>).</p></li>
</ul>
<p>No existe en principio retrocompatibilidad entre ambos sistemas y a fecha de
2020 la situación es la siguiente:</p>
<ol class="loweralpha simple">
<li><p>Pueden existir aún equipos muy antiguos que disponen de <abbr title="Basic I/O System">BIOS</abbr>.</p></li>
<li><p>Muchos equipos incluyen <abbr title="Extensible Firmware Interface">EFI</abbr>, pero añaden un modo de comopatibilidad
(normalmente denominado <em class="dfn">modo legacy</em>) que permite a la placa base
buscar un cargador de arranque de 16 <em>bits</em> para <abbr title="Basic I/O System">BIOS</abbr> o un
cargador de arranque de 32 ó 64 <em>bits</em> para <abbr title="Extensible Firmware Interface">EFI</abbr>. Muy comúnmente, se puede
tener habilitado el modo compatibilidad a la vez que el modo normal.</p></li>
<li><p>Algunos de los equopos más recientes traen un <em>firmware</em> <abbr title="Extensible Firmware Interface">EFI</abbr>, que carece
de <em>modo legacy</em>; y es de esperar que en el futuro el número de equipos sin
la compatibilidad aumente<a class="footnote-reference brackets" href="#id13" id="id3">2</a>.</p></li>
</ol>
<p>Como en todo estado de transición, es indispensable conocer ambas tecnologías,
que es en lo que afanará este epígrafe.</p>
<div class="section" id="proceso-de-arranque">
<h2><span class="section-number">5.1.2.1. </span>Proceso de arranque<a class="headerlink" href="#proceso-de-arranque" title="Enlazar permanentemente con este título">¶</a></h2>
<p>Sea cual sea el estándar usado, en el proceso de arranque podemos distinguir las
siguientes fases:</p>
<ol class="arabic">
<li><p>Proceso <abbr title="Power On Self Test">POST</abbr> de comprobación del <em>hardware</em>. Durante esta fase, el
<em>firmware</em> mediante pulsación de ciertas teclas<a class="footnote-reference brackets" href="#id14" id="id4">3</a>, brinda al usuario la
posibilidad de pausar el proceso para:</p>
<ul class="simple">
<li><p>Reconfigurar el <em>firmware</em>, que es lo que vulgarmente se conoce como
«entrar en la bios». Si se hace esto, se presenta un entorno donde el
usuario puede cambiar parámetros del <em>firmware</em> que se almacenan en memoria
<abbr title="Non-Volatile RAM">NVRAM</abbr> (o <a class="reference external" href="https://es.wikipedia.org/wiki/RAM-CMOS">CMOS</a> en equipos antiguos). Al término de la configuración, se
escoja o no salvar los cambios, se inicia un proceso de <em>arranque en
caliente</em>.</p></li>
<li><p>Presentar un menú para seleccionar qué programa o dispositivo se desea
arrancar. Los ítem de este menú son los ítem de la <em>secuencia de arranque</em>
y el interesado podrá escoger cualquiera de ellos para alterar sólo en ese
arranque la secuencia y que ese ítem pase a ser el primero.</p></li>
</ul>
<p>Aunque esta primera fase sólo está presente en un <em>arranque en frío</em>,
generalmente en un <em>arranque en caliente</em> , si se es rápido pulsando la tecla
apropiada se puede entrar en la configuración del <em>firmware</em> o el <em>menú de
arranque</em>.</p>
</li>
<li><p>Arranque de algún programa siguiendo la <em class="dfn">secuencia de arranque</em>, que es
una lista ordenada de todos los dispositivos detectados que se comprueban
secuencialmente a fin de encontrar en ellos un programa de arranque válido.
En cuanto se encuentre uno, se arranca y el <em>firmware</em> cede el control. Como
ya veremos, en el caso de <abbr title="Unified Extensible Firmware Interface">UEFI</abbr><a class="footnote-reference brackets" href="#id15" id="id5">4</a>.  esa lista puede contener, además de
dispositivos, programas concretos.</p></li>
</ol>
</div>
<div class="section" id="cargador-de-arranque">
<span id="boot-loader"></span><h2><span class="section-number">5.1.2.2. </span>Cargador de arranque<a class="headerlink" href="#cargador-de-arranque" title="Enlazar permanentemente con este título">¶</a></h2>
<p>Ya hemos establecido que el <em>firmware</em> de placa base se encarga de ceder el
control a un programa ulterior para que habitualmente a la postre acabe por
cargarse en memoria un sistema operativo. Un <em class="dfn">cargador de arranque</em> es
cualquier programa que se carga antes del sistema operativo principal y
atendiendo a esta definición el propio <em>firmware</em> puede considerarse un
<em>cargador de arranque</em>. Todos los <em>cargadores de arranque</em>, no obstante, no
tienen la misma funcionalidad:</p>
<ul>
<li><p>Algunos tiene la función de cargar en memoria el núcleo de un sistema
operativo y cederle el control de la máquina. Un ejemplo de cargador de
arranque puro es <a class="reference external" href="https://wiki.archlinux.org/index.php/EFISTUB">EFIStub</a>, el cargador de arranque para <abbr title="Extensible Firmware Interface">EFI</abbr> incluido en el
propio núcleo de <em>Linux</em><a class="footnote-reference brackets" href="#id16" id="id6">5</a>. Con él podremos cargar un <em>Linux</em> sin
necesidad de usar <abbr title="GRand Unified Bootloader">GRUB</abbr>.</p></li>
<li><p>Otros son programas que se limitan a realizar una función muy concreta como es
el caso de <a class="reference external" href="https://www.memtest.org/">memtest</a> (que comprueba la integridad de la memoria <abbr title="Random Access Memory">RAM</abbr>) o <a class="reference external" href="https://wiki.syslinux.org/wiki/index.php?title=Hdt_(Hardware_Detection_Tool)">hdt</a>
(que nos identifica el <em>hardware</em> de nuestro ordenador). En este caso, son
programas terminales y no se pretende acabar cargando el sistema operativo.</p>
</li>
<li id="boot-manager"><p>Por último, hay cargadores cuyo propósito es, simplemente, cargar en cadena
otro cargador de arranque. Dentro de este clase de cargadores destaca el
<em class="dfn">gestor de arranque</em>, cuyo propósito es permitir escoger entre
múltiples cargadores de arranque y, por tanto, brindarle al usuario la
posibilidad de arrancar distintos sistemas operativos o programas como los del
ítem anterior.</p>
<p>Un <em>gestor de arranque</em> puede:</p>
<ul class="simple">
<li><p>ser <em>puro</em> y limitarse a cumplir el propósito descrito, por lo que todas
las entradas de su menú deberán ser cargadores de arranque externos. Son
gestores puros el <em>gestor de arranque</em> incluido dentro del propio <abbr title="Extensible Firmware Interface">EFI</abbr> o
<a class="reference external" href="http://www.rodsbooks.com/refind/">rEFInd</a>.</p></li>
<li><p>incluir cargadores de arranque para arrancar con ellos algunos sistemas
operativos. Son ejemplos de este tipo de gestores <abbr title="GRand Unified Bootloader">GRUB</abbr> (que permite
arrancar sistemas <em>Linux</em> sin que el núcleo de éstos incluya <a class="reference external" href="https://wiki.archlinux.org/index.php/EFISTUB">EFIStub</a>), o
<abbr title="NT LoaDeR">NTLDR</abbr> o <em>Windows Boot Manager</em>, que arrancan sistemas <em>Windows</em>.</p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>Tenga presente que entre los cargadores opcionales entre los que
deja escoger un gestor de arranque puede encontrarse otro gestor de arranque
(que al fin es un tipo de cargador). Esto se denomina <em class="dfn">carga en
cadena</em> (<em>chain loading</em>) y es la técnica que usa <abbr title="GRand Unified Bootloader">GRUB</abbr> para cargar
<em>Windows</em>. Como <abbr title="GRand Unified Bootloader">GRUB</abbr> no incluye cargador de arranque para <em>Windows</em> lo
que hace es cargar <em>Windows Boot Manager</em></p>
</div>
</li>
</ul>
<p class="rubric">Gestores de arranque</p>
<div class="toctree-wrapper compound">
<ul>
<li class="toctree-l1"><a class="reference internal" href="02.boot/01.refind.html">5.1.2.2.1. rEFInd</a></li>
<li class="toctree-l1"><a class="reference internal" href="02.boot/06.grub.html">5.1.2.2.2. <abbr title="GRand Unified Bootloader">GRUB</abbr>.</a></li>
</ul>
</div>
<div class="admonition seealso">
<p class="admonition-title">Ver también</p>
<p><strong class="program">syslinux</strong> es otro gestor de arranque que <a class="reference internal" href="../../07.serre/06.pxe/02.nbp.html#syslinux"><span class="std std-ref">se
describe al tratar PXE</span></a>.</p>
</div>
</div>
<div class="section" id="estandares">
<h2><span class="section-number">5.1.2.3. </span>Estándares<a class="headerlink" href="#estandares" title="Enlazar permanentemente con este título">¶</a></h2>
<p>Analicemos las particularidades de cada estándar.</p>
<table class="uefi-bios docutils align-default" id="id22">
<caption><span class="caption-text">Comparativa <abbr title="Unified Extensible Firmware Interface">UEFI</abbr>/<abbr title="Basic I/O System">BIOS</abbr></span><a class="headerlink" href="#id22" title="Enlace permanente a esta tabla">¶</a></caption>
<colgroup>
<col style="width: 29%" />
<col style="width: 26%" />
<col style="width: 45%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Características</p></th>
<th class="head"><p><abbr title="Basic I/O System">BIOS</abbr></p></th>
<th class="head"><p><abbr title="Unified Extensible Firmware Interface">UEFI</abbr></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Arquitectura</p></td>
<td><p>16bits</p></td>
<td><p>32 ó 64 bits</p></td>
</tr>
<tr class="row-odd"><td><p>Compatibilidad</p></td>
<td><p>No</p></td>
<td><p>A extinguir</p></td>
</tr>
<tr class="row-even"><td><p>Arranque</p></td>
<td><p>Dispositivos</p></td>
<td><div class="line-block">
<div class="line">Dispotivos</div>
<div class="line">Cargadores de arranque</div>
</div>
</td>
</tr>
<tr class="row-odd"><td><p>Seguridad</p></td>
<td><p>Ninguna</p></td>
<td><p>Secure boot</p></td>
</tr>
<tr class="row-even"><td><p>Gestor externo</p></td>
<td><p>Necesario</p></td>
<td><p>Opcional</p></td>
</tr>
</tbody>
</table>
<div class="section" id="bios">
<h3><span class="section-number">5.1.2.3.1. </span><abbr title="Basic I/O System">BIOS</abbr><a class="headerlink" href="#bios" title="Enlazar permanentemente con este título">¶</a></h3>
<p>Es un sistema antiguo y bastante básico que para ceder el control se limita a
intentar cargar el código del <abbr title="Master Boot Record">MBR</abbr><a class="footnote-reference brackets" href="#id17" id="id7">6</a>. Si no encuentra código en el <abbr title="Master Boot Record">MBR</abbr> de
un dispositivo pasa al siguiente dispositivo de la secuencia y así continua
hasta que encuentra un <abbr title="Master Boot Record">MBR</abbr> con cargador de arranque. Cuando esto ocurre,
delega el control en ese código y ese código es el encargado de aviárselas con
los sistemas y particiones que pueda contener el dispositivo. Es importante,
pues, tener presente que este <em>firmware</em> no entiende de particiones ni sistemas
de archivos; y, por tanto, su sistema de arranque lee el comienzo del disco (los
primeros 446 bytes concretamente) y es totalmente ajeno al sistema de
particionado que se haya utilizado.</p>
<p>Aunque en un arranque <abbr title="Basic I/O System">BIOS</abbr> suele existir una tecla cuya pulsación nos
presenta un menú con el cual podemos seleccionar el dispositivo de arranque,
esto no es propiamente un gestor de arranque en el sentido de que no podemos
añadir y eliminar a voluntad entradas en él. Sí lo es, en cambio, en el sentido
de que nos poermite seleccionar distintos cargadores de arranque: aquellos
cargadores que ocupen los respectivos <abbr title="Master Boot Record">MBR</abbr> de los distintos dispositivos
detectados. Por tanto, si instalamos dos sistemas en dos dispositivos
diferentes, podremos con este mínimo gestor escoger entre uno y otro, pero si
los dos sistemas se encuentran instalados en un mismo dispositivo, no es
posible; y se requiere instalar en el <abbr title="Master Boot Record">MBR</abbr> de ese disco un gestor de arranque
como <abbr title="GRand Unified Bootloader">GRUB</abbr>. Sin embargo, los cargadores de arranque suelen ser más grandes que
los escasos 446 <em>bytes</em> que caben en el espacio dedicado en el <abbr title="Master Boot Record">MBR</abbr> por lo que
este código alojado suele ser tan sólo una pequeña parte encargada de saber
dónde debe seguir leyendo el resto del cargador.</p>
<p>Lo habitual con <em>firmware</em> <abbr title="Basic I/O System">BIOS</abbr> es que el sistema de particiones sea <abbr title="Disk Operating System">DOS</abbr>,
aunque no es absolutamente necesario<a class="footnote-reference brackets" href="#id18" id="id8">7</a>, puesto que, al cabo, <abbr title="Basic I/O System">BIOS</abbr> sólo se
preocupa de leer al comienzo del dispositivo. Así pues, los condicionantes para
conseguir que un dispositivo sea arrancable son:</p>
<ul class="simple">
<li><p>Un particionado <abbr title="Disk Operating System">DOS</abbr> (matizable, pero que daremos como verdadero).</p></li>
<li><p>Un gestor de arranque en el <abbr title="Master Boot Record">MBR</abbr>, como <abbr title="GRand Unified Bootloader">GRUB</abbr> o <em>Windows Boot Manager</em>, que
posibilite el arranque de los distintos sistemas almacenados en disco.</p></li>
</ul>
<p>Nótese que, cada vez que se instala un sistema operativo, el programa instalador
sobrescribe el <abbr title="Master Boot Record">MBR</abbr> con el cargador/gestor que incluya el nuevo sistema, por lo
que es responsabilidad de este último gestor incluir en sus entradas el nuevo
sistema y todos los que ya estén instalados en otras particiones de
instalaciones previas. Como <em>Windows Boot Manager</em> sólo se cuida de detectar y
arrancar sistemas <em>Windows</em>, y <abbr title="GRand Unified Bootloader">GRUB</abbr>, sin embargo, sí busca todo tipo de
sistemas; si planteamos instalar varios sistemas operativos en un mismo disco
es preferible instalar primero los sistemas <em>Windows</em> (por orden de antigüedad,
porque las versiones antiguas pueden tener problemas en detectar <em>Windows</em> más
recientes) y después los sistemas <em>Linux</em>. Si no se sigue este orden, aún será
posible reparar el arranque, pero nos tocará utilizar herramientas para ello.</p>
</div>
<div class="section" id="uefi">
<span id="boot-uefi"></span><h3><span class="section-number">5.1.2.3.2. </span><abbr title="Unified Extensible Firmware Interface">UEFI</abbr><a class="headerlink" href="#uefi" title="Enlazar permanentemente con este título">¶</a></h3>
<p>Al contrario del sistema anterior, <abbr title="Unified Extensible Firmware Interface">UEFI</abbr> es capaz de entender una tabla de
particiones <abbr title="GUID Partition Table">GPT</abbr> y algunos sistemas de archivos (obligatoriamente <abbr title="File allocation Table">FAT</abbr> y, para
dispositivos ópticos, CDFS), y dispone de un <a class="reference internal" href="#boot-manager"><span class="std std-ref">gestor de arranque</span></a> básico. No es preciso, pues, un gestor de arranque externo,
aunque es muy común que se instale también. <em>Windows</em>, de hecho, necesita
<em>Windows Boot Manager</em> para su arranque, así que de instalar un sistema
<em>Windows</em> forzosamente requeriremos este gestor externo. En cambio, si sólo
instaláremos distintos sistemas <em>Linux</em> podríamos arrancarlos todos sin
necesidad de <abbr title="GRand Unified Bootloader">GRUB</abbr> (aunque lo habitual es que también se insale)</p>
<p>El gestor de arranque integrado es capaz de almacenar en memoria <abbr title="Non-Volatile RAM">NVRAM</abbr><a class="footnote-reference brackets" href="#id19" id="id9">8</a>
entradas ordenadas de arranque. Cada entrada recibe un nombre (p.e. «Debian») y
refiere la ruta a un archivo contenida en la partición <abbr title="Globally Unique Identifier">GUID</abbr> de un determinado
dispositivo. Cuáles sean la ruta, la partición y el dispositivo es lo de menos
con tal de que el archivo sea un cargador de arranque. La única condición es que
la partición esté formateada con un sistema de archivos inteligible por el
<em>firmware</em>. Por tanto, para arrancar un sistema opèrativo basta con que haya una
partición adecuada para albergar su cargador de arranque y que la referencia a
este cargador se haya incluido como entrada. De este modo, las entradas en el
gestor integrado no son referencias a un dispositivo, como pasa con <abbr title="Basic I/O System">BIOS</abbr>, sino
a un cargador concreto, por lo que podemos tener conviviendo en un único disco
arranques de distintos sistemas operativos sin necesidad de ningún gestor
externo. A pesar de esto, nos podemos encontrar en una secuencia de arranque
<abbr title="Extensible Firmware Interface">EFI</abbr> una o varias entradas que refieren dispositivos. Estas entradas en
realidad lo que hacen es buscar un archivo (un cargador de arranque) en una ruta
predefinida dentro de ese dispositivo. Desvaleremos más adelante cuál.</p>
<img alt="../../_images/bootmanager-efi.png" src="../../_images/bootmanager-efi.png" />
<p>Además, a las entradas ya almacenadas en la <abbr title="Non-Volatile RAM">NVRAM</abbr>, el <em>firmware</em> añade
dinámicamente una entrada por cada dispositivo extraíble detectado en la fase
<abbr title="Power On Self Test">POST</abbr> y que no estuviera presente ya en la secuencia. De este modo, es posible
arrancar desde una memoria <abbr title="Universal Serial Bus">USB</abbr> que se haya pinchado circunstancialmente.</p>
<p>Aunque los cargadores de arranque podrían estar almacenados en distintas
particiones de distintos dispositivos y en rutas arbitrarias, en la práctica
esto se hace con ciertos criterios que acatan los instaladores de los sistemas
operativos:</p>
<ul>
<li><p>En el particionado <abbr title="GUID Partition Table">GPT</abbr> de un disco se crea una partición formateada con
sistema de archivos <abbr title="File allocation Table">FAT</abbr>32 y de tipo <abbr title="EFI System Partition">ESP</abbr> (código simplificado <em>EF00</em><a class="footnote-reference brackets" href="#id20" id="id10">9</a>), Si disponemnos de varios discos, basta que esta partición esté en uno
de ellos:</p>
<img alt="../../_images/part-gpt-uefi.png" src="../../_images/part-gpt-uefi.png" />
</li>
<li id="efi-archivos"><p>Dentro de esa partición se crea una estructura de directorios con este aspecto:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>/
+-- EFI/
     +-- debian/
     +-- Windows Boot Manager/
     +-- etc.
     +-- Boot/
          +-- bootx64.efi
</pre></div>
</div>
<p>esto es, un directorio <code class="file docutils literal notranslate"><span class="pre">EFI</span></code> dentro del cual cada sistema operativo crea
un subdirectorio con los archivos oportunos para el arranque o para al menos
comenzar el arranque. Uno de esos archivos será el que deba cargar el
<em>firmware</em> <abbr title="Extensible Firmware Interface">EFI</abbr>, por lo que su ruta será la que se añada como entrada en la
secuencia de arranque.</p>
</li>
</ul>
<p>Como se deduce, todo está perfectamente estructurado y, por tanto, mientras
exista espacio suficiente (habitualmente con <strong>100</strong> MiB hay más que de sobra)
no hay riesgo de que el arranque de un sistema operativo interfiera con el de
otros, como sí ocurre en <abbr title="Basic I/O System">BIOS</abbr> en que cómo sólo hay un punto de arranque por
dispositivo (su <abbr title="Master Boot Record">MBR</abbr>) el arranque de un sistema instalado sobrescribirá el
código que en el <abbr title="Master Boot Record">MBR</abbr> pudiera haber escrito la instalación de un sistema
operativo instalado anteriormente.</p>
<p>Lo normal, sin embargo, es que, al registrar un sistema operativo la entrada
para su arranque, la registre como la primera en la secuencia, lo que determina
que se cargue con preferencia en detrimento del resto de sistemas operativos que
se hubieran podido instalar antes. Si este arranque es respetuoso con el resto y
consiste en un gestor de arranque que también permite la carga de los demás,
como es el caso de <abbr title="GRand Unified Bootloader">GRUB</abbr>, este hecho no es relevante, ya que este gestor
externo nos brindará la posibilidad de seguir arrancando el que queramos. Si en
cambio el gestor no es tan gentil (como es el caso de <em>Windows Boot Manager</em>),
aparentemente dejaremos de poder arrancar el resto de sistemas no <em>Windows</em>;
pero sólo aparentemente, porque bastará con pulsar la tecla apropiada que nos
muestre todas las entradas del gestor <abbr title="Extensible Firmware Interface">EFI</abbr> integrado para que podamos escoger
cualquier otra distinta de la primera.</p>
<p>Además de poder escoger entrada a voluntad en cada arranque, también es posible
cambiar la secuencia de arranque para reordenar sus entradas. Hay diversas vías:</p>
<ul class="simple">
<li><p>Quizás algún método gráfico en la configuración del <em>firmware</em>.</p></li>
<li><p>Quizás alguna <em>shell</em> de comandos proporcionada por el propio <em>firmware</em>. Esta
<em>shell</em> disponde de la orden <strong class="command">bcfg</strong>, que permite manipular la
secuencia e incluso, añadir y borrar entradas.</p></li>
<li><p>Herramientas ejecutadas desde el sistema operativo. En <em>Linux</em>, este
comando es <strong class="command">efibootmgr</strong><a class="footnote-reference brackets" href="#id21" id="id11">10</a>.</p></li>
</ul>
<p>Peso a lo anterior, lo que ahorra más trabajo es seguir la misma regla ya
enunciada al tratar <abbr title="Basic I/O System">BIOS</abbr> para organizar la instalación de sistemas operativos:
sistemas <em>Windows</em> de más antiguo a más nuevo y sistemas <em>Linux</em> después.</p>
<p>Volvamos para terminar a un aspecto que dejamos en suspenso: la adición dinámica
de entradas para arrancar dispositivos extraíbles. De hecho, en un equipo virgen
siin nada instalado aún, éstas serán las únicas entradas disponibles. Ya hemos
explicado cómo el <em>firmware</em> <abbr title="Extensible Firmware Interface">EFI</abbr> intenta cargar la ruta especificada en cada
una de las entradas de la secuencia. En este caso, sin embargo, el sistema
operativo del disposivo extraíble no ha sido instalado por un instalador que
haya manipulado la <abbr title="Non-Volatile RAM">NVRAM</abbr> para registrar la ruta al cargador, por lo que la
única solución es que la entrada que representa al dispositivo siempre busque lo
mismo: la primera partición del dispositivo de tipo <abbr title="EFI System Partition">ESP</abbr> y dentro de ella la
ruta <code class="file docutils literal notranslate"><span class="pre">/EFI/Boot/bootx64.efi</span></code>. Si tal cosa existe, el dispositivo extraíble
arrancará.</p>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>Si se revisa el <a class="reference internal" href="#efi-archivos"><span class="std std-ref">esquema de archivos de la partición EFI</span></a>, se comprobará que esa ruta predefinida también se ha
incluido. Por lo general, la ocupa con su arranque el último sistema
instalado (aparte de haber creado su directorio particular), por lo que una
entrada en la secuencia de arranque que refiera a secas el dispositivo de
disco, cargará el arranque del último sustema operativo instalado.</p>
</div>
<p class="rubric" id="secure-boot">¿Qué es Secure Boot?</p>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>Para la perfecta compresión de este apartado es forzoso que al menos
se entiendan los fundamentos del <a class="reference internal" href="../../09.apendice/01.cryto/02.algo.html#asimetrico"><span class="std std-ref">cifrado asimétrico</span></a>.</p>
</div>
<p>Para evitar la carga de <em>software</em> malicioso (p.e. <a class="reference external" href="https://www.kaspersky.com/resource-center/definitions/boot-sector-virus">virus del sector de arranque</a>) la
especificación <abbr title="Unified Extensible Firmware Interface">UEFI</abbr> introduce la posibilidad de cargar sólo <em>software</em> fiable,
esto es, <em>software</em> firmado. Para ello existe una cadena de confianza:</p>
<ul class="simple">
<li><p>El fabricante del <em>hardware</em> dispone una clave pública, llamada clave de
plataforma (<abbr title="Platform Key">PK</abbr>).</p></li>
<li><p>Sólo el fabricante (que posee la clave privada correspondiente a la <abbr title="Platform Key">PK</abbr>)
podrá añadir claves públicas a la lista de <abbr title="Key Exchange Key">KEK</abbr>s.</p></li>
<li><p>Los propietarios de las claves públicas anteriores (<abbr title="Key Exchange Key">KEK</abbr>) son los únicos
capaces de añadir claves públicas a la base de firmas (<strong>db</strong>) o a la base de
firmas prohibidas (<strong>dbx</strong>).</p></li>
<li><p>La <strong>db</strong> es la lista de claves autorizadas para firmar cargadores de
arranque.</p></li>
<li><p>La <strong>dbx</strong> es la lista de claves vetadas: ningún cargador firmado con
alguna de estas claves podrá ser cargado por el <em>firmware</em> <abbr title="Extensible Firmware Interface">EFI</abbr>.</p></li>
<li><p>El primer cargador contiene a su vez una lista de claves que autorizan
al <em>software</em> subsiguiente.</p></li>
</ul>
<p><abbr title="Platform Key">PK</abbr>, <abbr title="Key Exchange Key">KEK</abbr>, <strong>db</strong> y <strong>dbx</strong> vienen incluidas en el propio <em>firmware</em> de la
placa y en la práctica los fabricantes de <em>hardware</em> convencional sólo incluyen
en la lista de <abbr title="Key Exchange Key">KEK</abbr>s y en la <strong>db</strong> sendas claves propiedad de <em>Microsoft</em>,
por lo que sólo <em>Microsoft</em> tiene capacidad para firmar el primer cargador tras
<abbr title="Extensible Firmware Interface">EFI</abbr>. Por este motivo algunas distribuciones de <em>Linux</em> (<em>Debian</em> entre ellas)
incluyen un <a class="reference external" href="https://github.com/rhboot/shim">cargador llamado shim</a>
(paquete <a class="reference external" href="https://packages.debian.org/stable/shim-signed">shim-signed</a>) cuyo ejecutable ha pedido cada cual a <em>Microsoft</em>
que firme con la «Microsoft Corporation UEFI CA» y en el que han incluido su
propia clave para poder firmar a su vez ya ellas mismas el <abbr title="GRand Unified Bootloader">GRUB</abbr> (paquete
<a class="reference external" href="https://packages.debian.org/stable/grub-efi-amd64-signed">grub-efi-amd64-signed</a>) que se carga después que a su vez se encargara de
comprobar la firma del núcleo de <em>Linux</em> finalmente cargado.</p>
<p>Puede también optarse por deshabilitar <em>Secure Boot</em> en cuyo caso el cargador de
arranque no requerirá estar firmado.</p>
<p class="rubric">Enlaces de interés</p>
<ul class="simple">
<li><p>La wiki de Archlinux tiene un muy completo <a class="reference external" href="https://wiki.archlinux.org/index.php/Unified_Extensible_Firmware_Interface_(Espa%C3%B1ol)">artículo sobre UEFI</a>.</p></li>
<li><p>La entrada <a class="reference external" href="https://blog.uncooperative.org/blog/2014/02/06/the-efi-system-partition/">The EFI System Partition and the Default Boot Behavior</a>,
del blog <a class="reference external" href="https://blog.uncooperative.org/">The Uncoöperative Organization</a>.</p></li>
</ul>
<p class="rubric">Notas al pie</p>
<dl class="footnote brackets">
<dt class="label" id="id12"><span class="brackets"><a class="fn-backref" href="#id2">1</a></span></dt>
<dd><p>Intel publicó la especificación con el nombre de <abbr title="Extensible Firmware Interface">EFI</abbr>. Al ser  adoptada
en 2005 por la industria en general pasó a llamarse <abbr title="Unified Extensible Firmware Interface">UEFI</abbr>. Así pues, ambos
términos son sinónimos y debemos entender lo mismo por ellos.</p>
</dd>
<dt class="label" id="id13"><span class="brackets"><a class="fn-backref" href="#id3">2</a></span></dt>
<dd><p>Intel, por ejemplo, ha anunciado que dejará de dar soporte a <abbr title="Basic I/O System">BIOS</abbr> a
partir de 2020 (puede leer <a class="reference external" href="https://www.genbeta.com/actualidad/se-acerca-el-fin-de-bios-intel-eliminara-el-soporte-en-2020">este artículo al respecto</a>).</p>
</dd>
<dt class="label" id="id14"><span class="brackets"><a class="fn-backref" href="#id4">3</a></span></dt>
<dd><p>Las teclas varían sea cual sea el fabricante del <em>firmware</em>, por lo que
no se puede indicar cuáles son exactamente.Habitualmente suelen escogerse
<kbd class="kbd docutils literal notranslate">Suprimir</kbd>, <kbd class="kbd docutils literal notranslate">F2</kbd>, <kbd class="kbd docutils literal notranslate">F8</kbd>, <kbd class="kbd docutils literal notranslate">F10</kbd>, <kbd class="kbd docutils literal notranslate">F11</kbd> o <kbd class="kbd docutils literal notranslate">F12</kbd>.</p>
</dd>
<dt class="label" id="id15"><span class="brackets"><a class="fn-backref" href="#id5">4</a></span></dt>
<dd><p>En <abbr title="Unified Extensible Firmware Interface">UEFI</abbr> es posible porque este firmware sí entiende de particiones y es
capaz de leer archivos dentro de un sistema FAT32.</p>
</dd>
<dt class="label" id="id16"><span class="brackets"><a class="fn-backref" href="#id6">5</a></span></dt>
<dd><p>Para que un kernel de linux pueda arrancarse directamente es necesario
que se compile con la opción <a class="reference external" href="https://wiki.archlinux.org/index.php/EFISTUB">EFIStub</a>, disponible desde la versión 3.3.0.</p>
</dd>
<dt class="label" id="id17"><span class="brackets"><a class="fn-backref" href="#id7">6</a></span></dt>
<dd><p>Es cierto que los <em>floppy</em> no disponen de <abbr title="Master Boot Record">MBR</abbr> (véase <a class="reference external" href="https://thestarman.pcministry.com/asm/mbr/DOS50FDB.htm">esta explicación</a>), pero dado lo
anticuado del dispositivo, podemos obviarlo por completo.</p>
</dd>
<dt class="label" id="id18"><span class="brackets"><a class="fn-backref" href="#id8">7</a></span></dt>
<dd><p>De hecho, con <abbr title="GRand Unified Bootloader">GRUB</abbr> puede arrancarse un sistema <abbr title="Basic I/O System">BIOS</abbr> y particionado
<abbr title="GUID Partition Table">GPT</abbr>.</p>
</dd>
<dt class="label" id="id19"><span class="brackets"><a class="fn-backref" href="#id9">8</a></span></dt>
<dd><p>En la implementación <abbr title="Unified Extensible Firmware Interface">UEFI</abbr> que traen algunos <em>softwares</em> de
virtualización (<a class="reference external" href="https://github.com/tianocore/tianocore.github.io/wiki/OVMF">OVMF</a>), la <abbr title="Non-Volatile RAM">NVRAM</abbr> se emula almacenando en el directorio
<code class="file docutils literal notranslate"><span class="pre">EFI</span></code> un fichero llamado <code class="file docutils literal notranslate"><span class="pre">NvVars</span></code>.</p>
</dd>
<dt class="label" id="id20"><span class="brackets"><a class="fn-backref" href="#id10">9</a></span></dt>
<dd><p>En realidad, el código identificativo de esta partición es mucho más
largo (<code class="docutils literal notranslate"><span class="pre">C12A7328-F81F-11D2-BA4B-00A0C93EC93B</span></code>). <code class="docutils literal notranslate"><span class="pre">EF00</span></code> es el código
simplificado que usa la utilidad <a class="reference internal" href="03.pract.html#gdisk-i"><span class="std std-ref">gdisk</span></a>. Sin embargo,
la especificación <abbr title="Unified Extensible Firmware Interface">UEFI</abbr> ni siquiera exige que la partición este marcada
con este código, ya que las entradas que se almacenan en la <abbr title="Non-Volatile RAM">NVRAM</abbr> indican
cuál es la partición de disco donde se encuentra el fichero que constituye el
cargador de arranque. Lo único necesario. pues, es que el sistema de archivos
sea comprensible, esto es, que sea <abbr title="File allocation Table">FAT</abbr>32.</p>
</dd>
<dt class="label" id="id21"><span class="brackets"><a class="fn-backref" href="#id11">10</a></span></dt>
<dd><p>Por ejemplo, esta orden añade una nueva entrada:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> efibootmgr --create --disk /dev/sda --part <span class="m">2</span> --loader /EFI/so/bootx64.efi <span class="se">\</span>
   --label <span class="s2">&quot;Mi primer arranque UEFI&quot;</span>
</pre></div>
</div>
<p>en la que se intenta cargar el fichero <code class="file docutils literal notranslate"><span class="pre">/EFI/so/bootx64.efi</span></code> y la que
se supone que la partición <abbr title="EFI System Partition">ESP</abbr> es la segunda del disco.</p>
</dd>
</dl>
</div>
</div>
</div>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../../index.html">Tabla de contenido</a></h3>
  <ul>
<li><a class="reference internal" href="#">5.1.2. Arranque</a><ul>
<li><a class="reference internal" href="#proceso-de-arranque">5.1.2.1. Proceso de arranque</a></li>
<li><a class="reference internal" href="#cargador-de-arranque">5.1.2.2. Cargador de arranque</a></li>
<li><a class="reference internal" href="#estandares">5.1.2.3. Estándares</a><ul>
<li><a class="reference internal" href="#bios">5.1.2.3.1. <abbr title="Basic I/O System">BIOS</abbr></a></li>
<li><a class="reference internal" href="#uefi">5.1.2.3.2. <abbr title="Unified Extensible Firmware Interface">UEFI</abbr></a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>Tema anterior</h4>
  <p class="topless"><a href="01.part.html"
                        title="capítulo anterior"><span class="section-number">5.1.1. </span>Particiones</a></p>
  <h4>Próximo tema</h4>
  <p class="topless"><a href="02.boot/01.refind.html"
                        title="próximo capítulo"><span class="section-number">5.1.2.2.1. </span>rEFInd</a></p>
  <div role="note" aria-label="source link">
    <h3>Esta página</h3>
    <ul class="this-page-menu">
      <li><a href="../../_sources/05.discos/01.division/02.boot.rst.txt"
            rel="nofollow">Mostrar el código</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Búsqueda rápida</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Ir a" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navegación</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="Índice General"
             >índice</a></li>
        <li class="right" >
          <a href="02.boot/01.refind.html" title="5.1.2.2.1. rEFInd"
             >siguiente</a> |</li>
        <li class="right" >
          <a href="01.part.html" title="5.1.1. Particiones"
             >anterior</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">documentación de Linuxnomicón - rolling</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" ><span class="section-number">5. </span>Dispositivos de almacenamiento</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="index.html" ><span class="section-number">5.1. </span>División del disco</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href=""><span class="section-number">5.1.2. </span>Arranque</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Derechos de autor CC BY 4.0, 2016-2021, José Miguel Sánchez Alés.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 3.4.3.
    </div>
  </body>
</html>