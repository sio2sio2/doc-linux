


<!DOCTYPE html>

<html lang="es">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />

    <title>5.1.4. Volúmenes lógicos &#8212; documentación de Linuxnomicón - rolling</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/classic.css" />
    <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
    
    <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/sphinx_highlight.js"></script>
    <script src="../../_static/translations.js"></script>
    
    <link rel="index" title="Índice" href="../../genindex.html" />
    <link rel="search" title="Búsqueda" href="../../search.html" />
    <link rel="next" title="5.2. Acceso a datos" href="../02.seguridad/index.html" />
    <link rel="prev" title="5.1.3. Aplicacion práctica" href="03.pract.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navegación</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="Índice General"
             accesskey="I">índice</a></li>
        <li class="right" >
          <a href="../02.seguridad/index.html" title="5.2. Acceso a datos"
             accesskey="N">siguiente</a> |</li>
        <li class="right" >
          <a href="03.pract.html" title="5.1.3. Aplicacion práctica"
             accesskey="P">anterior</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">documentación de Linuxnomicón - rolling</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" ><span class="section-number">5. </span>Dispositivos de almacenamiento</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="index.html" accesskey="U"><span class="section-number">5.1. </span>División del disco</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href=""><span class="section-number">5.1.4. </span>Volúmenes lógicos</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="volumenes-logicos">
<span id="lvm"></span><h1><span class="section-number">5.1.4. </span>Volúmenes lógicos<a class="headerlink" href="#volumenes-logicos" title="Enlace permanente a este encabezado">¶</a></h1>
<p>A diferencia de otros como <a class="reference external" href="https://es.wikipedia.org/wiki/ZFS_(sistema_de_archivos)">zfs</a> o <a class="reference external" href="https://es.wikipedia.org/wiki/Btrfs">btrfs</a>, <em>ext4</em> no soporta nativamente la
gestión de volúmenes lógicos. Sin embargo, podemos manejar discos y particiones
virtuales, ayudándonos de un <em>software</em> adicional llamado <abbr title="Logical Volume Management">LVM</abbr>. Las
<strong>ventajas</strong> de su uso, ya se han establecido en epígrafes anteriores:</p>
<ul>
<li><p>Permite agrandar indiscriminadamente el disco: basta con comprar un nuevo
disco físico e incluirlo como integrante del disco virtual.</p>
<img alt="../../_images/1%2B1disks.png" src="../../_images/1%2B1disks.png" />
</li>
<li><p>Permite agrandar indiscriminadamente las particiones sin cuidarse de que el
espacio que constituye la partición deba ser contiguo. Cuando tratamos
particiones físicas, ampliar una partición es todo un engorro, sobre todo si
está encajonada entre otras dos particiones. Por ejemplo, ampliar en el
siguiente gráfico <code class="file docutils literal notranslate"><span class="pre">sda3</span></code>, implica también mover <code class="file docutils literal notranslate"><span class="pre">sda4</span></code>:</p>
<img alt="../../_images/ampl-part.png" src="../../_images/ampl-part.png" />
</li>
</ul>
<p>Logramos, por tanto, muchísima más versatilidad que usando particiones fisicas.
En contraprestación, hay una <strong>desventaja</strong> evidente: las particiones lógicas
sólo son visibles con el <em>software</em> de <abbr title="Logical Volume Management">LVM</abbr>.</p>
<p class="rubric">Definiciones</p>
<p>Antes de pasar a exponer cómo crear y manejar volúmenes lógicos, es pertinente
fijar el significado de algunos términos que se usarán en la exposición:</p>
<dl class="simple">
<dt><strong>Volúmen físico</strong> (<abbr title="Physical Volume">PV</abbr>)</dt><dd><p>Son las particiones físicas o incluso discos físicos completos sobre las que
se definen los discos virtuales.</p>
</dd>
<dt><strong>Grupo de volúmenes</strong> (<abbr title="Volume Group">PV</abbr>)</dt><dd><p>Es el conjunto de volúmenes físicos que conforma un disco virtual.</p>
</dd>
<dt><strong>Volúmenes lógicos</strong> (<abbr title="Logical Volume">LV</abbr>)</dt><dd><p>Es el dispoitivo virtual de bloques que alberga un sistemas de ficheros, esto
es, lo que hemos venido definiendo como <em>partición virtual</em> a lo largo de
nuestra exposición.</p>
</dd>
</dl>
<p>En la tarea de constituir volúmenes lógicos:</p>
<ul class="simple">
<li><p>Deben definirse cuáles son los volúmenes físicos.</p></li>
<li><p>Deben definirse cómo se agrupan esos volúmenes físicos en grupos de volúmenes.
Lo habitual es que haya un grupo de volúmenes.</p></li>
<li><p>Debe particionarse cada grupo de volúmenes en volúmenes logicos.</p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>Es importante tener presente que <abbr title="GRand Unified Bootloader">GRUB</abbr> soporta <abbr title="Logical Volume Management">LVM</abbr> y, por tanto, es
capaz de arrancar un <em>Linux</em> aunque los ficheros de su fase 3 y el kernel se
encuentren dentro de volúmenes lógicos.</p>
</div>
<p>Es muy probable que el <em>software</em> para gestionar volúmenes lógicos ya se
encuentre instalado, pero si no es así:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp"># </span>apt<span class="w"> </span>install<span class="w"> </span>lvm2
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p><abbr title="Logical Volume Management">LVM</abbr> permite también la creación de <abbr title="Redundant Array of Inexpensive Disks">RAID</abbr>s, pero no es
propósito de este apartado, tratarlo. Bajo el epígrafe dedicado a <a class="reference internal" href="../06.raid/index.html#raid"><span class="std std-ref">RAUDs</span></a> hay <a class="reference internal" href="../06.raid/02.lvm.html#lvmraid"><span class="std std-ref">todo un apartado dedicado a la creación de RAIDs con LVM</span></a>.</p>
</div>
<span class="target" id="lvcreate"><span id="vgcreate"></span><span id="pvcreate"></span></span><section id="creacion">
<span id="index-0"></span><h2><span class="section-number">5.1.4.1. </span>Creación<a class="headerlink" href="#creacion" title="Enlace permanente a este encabezado">¶</a></h2>
<p>Dentro del grupo de volúmenes podemos incluir todas las particiones que deseemos
crear, excepto aquellas necesarias para el arranque del disco. Por tanto, un
particionado físico del disco apropiado para crear volúmenes lógicos puede ser
el siguiente:</p>
<img alt="../../_images/part-lvm.png" src="../../_images/part-lvm.png" />
<p>que usando <a class="reference internal" href="03.pract.html#sgdisk"><span class="std std-ref">sgdisk</span></a> puede realizarse de esta forma:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>sgdisk<span class="w"> </span>-a<span class="w"> </span><span class="m">8</span><span class="w"> </span>-n<span class="w"> </span><span class="s2">&quot;0:40:2047&quot;</span><span class="w"> </span>-t<span class="w"> </span><span class="s2">&quot;0:0xef02&quot;</span><span class="w"> </span>-c<span class="w"> </span><span class="s2">&quot;0:BOOTBIOS&quot;</span><span class="w"> </span><span class="se">\</span>
<span class="w">         </span>-a<span class="w"> </span><span class="m">2048</span><span class="w"> </span>-n<span class="w"> </span><span class="s2">&quot;0:2048:+100M&quot;</span><span class="w"> </span>-t<span class="w"> </span><span class="s2">&quot;0:0xef00&quot;</span><span class="w"> </span>-c<span class="w"> </span><span class="s2">&quot;0:EFI&quot;</span><span class="w"> </span><span class="se">\</span>
<span class="w">         </span>-N<span class="w"> </span><span class="m">0</span><span class="w"> </span>-t<span class="w"> </span><span class="s2">&quot;3:0x8e00&quot;</span><span class="w"> </span>-c<span class="w"> </span><span class="s2">&quot;3:LVM&quot;</span><span class="w"> </span>/tmp/0.disk
</pre></div>
</div>
<p>de forma que creamos las dos particiones necesarias para el arranque aparte,
y una tercera partición destinanda a ser el volumen físico que constituya el
grupo de volúmenes. La partición destinada para este fin se nota con el código
<em>0x8E00</em>.</p>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>Por supuesto, podemos crear volúmenes lógicos partiendo también de un
particionado <abbr title="Disk Operating System">DOS</abbr></p>
</div>
<p>Como estamos particionando un fichero, no podemos acceder
directamente a sus particiones como sí sería posible si particionáramos un disco
(p.e. de <code class="file docutils literal notranslate"><span class="pre">/dev/sda</span></code> aparecerían <code class="file docutils literal notranslate"><span class="pre">/dev/sda1</span></code>, file:<cite>/dev/sda2</cite>,
etc.). Para hacerlas accesibles es necesario asegurarse de que está cargado el
módulo <em>loop</em>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp"># </span>modprobe<span class="w"> </span>loop
</pre></div>
</div>
<p>y usar <strong class="command">losetup</strong> para asociar/desasociar el fichero a un dispositivo de
bucle:</p>
<span class="target" id="losetup"></span><div class="highlight-console notranslate" id="index-1"><div class="highlight"><pre><span></span><span class="gp"># </span>losetup<span class="w"> </span>/dev/loop0<span class="w"> </span>/tmp/0.disk
<span class="gp"># </span>losetup
<span class="go">NAME       SIZELIMIT OFFSET AUTOCLEAR RO BACK-FILE      DIO LOG-SEC</span>
<span class="go">/dev/loop0         0      0         0  0 /tmp/0.disk   0     512</span>
<span class="gp"># </span>losetup<span class="w"> </span>-d<span class="w"> </span>/dev/loop0
</pre></div>
</div>
<p>Con todo, asociar el fichero al dispositivo no provoca que aparezcan las
particiones, para ello es necesario usar <strong class="command">partx</strong></p>
<span class="target" id="partx"></span><div class="highlight-console notranslate" id="index-2"><div class="highlight"><pre><span></span><span class="gp"># </span>partx<span class="w"> </span>-a<span class="w"> </span>/dev/loop0
<span class="gp"># </span>ls<span class="w"> </span>-1<span class="w"> </span>/dev/loop0*
<span class="go">/dev/loop0</span>
<span class="go">/dev/loop0p1</span>
<span class="go">/dev/loop0p2</span>
<span class="go">/dev/loop0p3</span>
<span class="gp"># </span>partx<span class="w"> </span>-d<span class="w"> </span>/dev/loop0
<span class="gp"># </span>ls<span class="w"> </span>-1<span class="w"> </span>/dev/loop0*
<span class="go">/dev/loop0</span>
</pre></div>
</div>
<p>Hecho el particionado y expuestas las particiones, lo primero es declarar que la
tercera partición es un volumen físico<a class="footnote-reference brackets" href="#id5" id="id1" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp"># </span>pvcreate<span class="w"> </span>/dev/loop0p3
</pre></div>
</div>
<p>tras lo cual ya puede constituirse un grupo de volúmenes llamado «VGtest» con
este volumen físico:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp"># </span>vgcreate<span class="w"> </span>VGtest<span class="w"> </span>/dev/loop0p3
<span class="gp"># </span>vgs<span class="w"> </span>VGtest
<span class="go">  VG       #PV #LV #SN Attr   VSize    VFree</span>
<span class="go">  VGtest   1   0   0 wz--n-  &lt;19,95g &lt;19,95g</span>
</pre></div>
</div>
<p>Esta última acción permite empezar a crear particiones lógicas con la orden
<strong class="command">lvcreate</strong>. Por ejemplo:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp"># </span>lvcreate<span class="w"> </span>-L<span class="w"> </span>2G<span class="w"> </span>VGtest<span class="w"> </span>-n<span class="w"> </span>primera
<span class="gp"># </span>lvcreate<span class="w"> </span>-L<span class="w"> </span>5G<span class="w"> </span>VGtest<span class="w"> </span>-n<span class="w"> </span>segunda
<span class="gp"># </span>vgs<span class="w"> </span>VGtest
<span class="go">  VG       #PV #LV #SN Attr   VSize    VFree</span>
<span class="go">  VGtest   1   0   0 wz--n-  &lt;19,95g &lt;12,95g</span>
<span class="gp"># </span>lvs<span class="w"> </span>VGtest
<span class="go">  LV      VG    Attr       LSize Pool Origin Data%  Meta%  Move Log Cpy%Sync Convert</span>
<span class="go">  primera VGxxx -wi-a----- 2,00g</span>
<span class="go">  segunda VGxxx -wi-a----- 5,00g</span>
</pre></div>
</div>
<p>Estas acciones han particionado 7 de los 20GB del grupo de volúmenes y crean dos
dispostivos virtuales, <code class="file docutils literal notranslate"><span class="pre">/dev/VGtest/primera</span></code> y
<code class="file docutils literal notranslate"><span class="pre">/dev/VGtest/segunda</span></code> que podemos tratar como si de particiones fisicas
se tratasen. Por ejemplo, podemos dotarlas de un sistema de ficheros:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp"># </span>mkfs.ext4<span class="w"> </span>-L<span class="w"> </span>PRIMERA<span class="w"> </span>/dev/VGtest/primera
<span class="gp"># </span>mkfs.ext4<span class="w"> </span>-L<span class="w"> </span>SEGUNDA<span class="w"> </span>/dev/VGtest/primera
</pre></div>
</div>
</section>
<section id="disponibilidad">
<h2><span class="section-number">5.1.4.2. </span>Disponibilidad<a class="headerlink" href="#disponibilidad" title="Enlace permanente a este encabezado">¶</a></h2>
<p>Habitualmente la aparición de los volúmenes lógicos es automática al hacer
disponibles los volúmenes que constituyen el grupo de volúmenes. Si no es así,
pueden habilitar con la orden:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp"># </span>vgchange<span class="w"> </span>-ay<span class="w"> </span>VGtest
</pre></div>
</div>
<p>Lo que es más útil es deshabilitar los volúmenes lógicos:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp"># </span>vgchange<span class="w"> </span>-an<span class="w"> </span>VGtest
</pre></div>
</div>
<p>ya que es indispensable hacerlo si queremos hacer desaparecer los volúmenes
físicos sobre los que se asientan. Por ejemplo, para el caso que nos ocupa, en
que hacemos pruebas con un fichero, la única forma de usar <a class="reference internal" href="#losetup"><span class="std std-ref">partx</span></a> y
<a class="reference internal" href="#losetup"><span class="std std-ref">losetup</span></a> para desasociar el fichero al dispositivo de bucle es
deshabilitar los volúmenes lógicos porque de lo contrario, fallará:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp"># </span>partx<span class="w"> </span>-d<span class="w"> </span>/dev/loop
</pre></div>
</div>
<p>al encontrar la partición <code class="file docutils literal notranslate"><span class="pre">/dev/loop03</span></code> ocupada.</p>
<span class="target" id="lvs"><span id="vgs"></span><span id="pvs"></span></span></section>
<section id="consulta">
<span id="index-3"></span><h2><span class="section-number">5.1.4.3. </span>Consulta<a class="headerlink" href="#consulta" title="Enlace permanente a este encabezado">¶</a></h2>
<p>Hay tres tipos de entidades (volúmenes físicos, grupos de volúmenes y volúmenes
lógicos) y dos tipos de consultas sobre ellas: la resumida y la extensa, por lo
que podemos llegar a hacer seis consultas distintas. En los seis casos, puede
añadirse como argumento una entidad concreta (<abbr title="Physical Volume">PV</abbr>, <abbr title="Volume Group">PV</abbr> o <abbr title="Logical Volume">LV</abbr>) para recibir
información exclusivamente de ella o no añadir ninguna y recibir información de
todas.</p>
<p>Para volúmenes físicos, las órdenes son:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp"># </span>pvs
<span class="go">  PV           VG       Fmt  Attr PSize   PFree</span>
<span class="go">  /dev/sdc2    vgdebian lvm2 a--  &lt;465,70g  79,39g</span>
<span class="go">  /dev/loop0p3 VGtest   lvm2 a--  &lt;19,95g &lt;12,95g</span>
<span class="gp"># </span>pvdisplay<span class="w"> </span>/dev/loop0p3
<span class="go">  --- Physical volume ---</span>
<span class="go">  PV Name               /dev/loop0p3</span>
<span class="go">  VG Name               VGtest</span>
<span class="go">  PV Size               19,95 GiB / not usable 4,98 MiB</span>
<span class="go">  Allocatable           yes</span>
<span class="go">  PE Size               4,00 MiB</span>
<span class="go">  Total PE              5106</span>
<span class="go">  Free PE               3314</span>
<span class="go">  Allocated PE          1792</span>
<span class="go">  PV UUID               36SmEX-lPxG-qFW2-iMGl-1c5T-CLlb-LqLY1</span>
</pre></div>
</div>
<p>Para grupos de volúmenes:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp"># </span>vgs
<span class="go">  VG       #PV #LV #SN Attr   VSize    VFree</span>
<span class="go">  VGtest     1   2   0 wz--n-  &lt;19,95g &lt;12,95g</span>
<span class="go">  vgdebian   1   4   0 wz--n- &lt;465,70g  79,39g</span>

<span class="gp"># </span>vgdisplay<span class="w"> </span>VGtest
<span class="go">  --- Volume group ---</span>
<span class="go">  VG Name               VGtest</span>
<span class="go">  System ID</span>
<span class="go">  Format                lvm2</span>
<span class="go">  Metadata Areas        1</span>
<span class="go">  Metadata Sequence No  3</span>
<span class="go">  VG Access             read/write</span>
<span class="go">  VG Status             resizable</span>
<span class="go">  MAX LV                0</span>
<span class="go">  Cur LV                2</span>
<span class="go">  Open LV               0</span>
<span class="go">  Max PV                0</span>
<span class="go">  Cur PV                1</span>
<span class="go">  Act PV                1</span>
<span class="go">  VG Size               &lt;19,95 GiB</span>
<span class="go">  PE Size               4,00 MiB</span>
<span class="go">  Total PE              5106</span>
<span class="go">  Alloc PE / Size       1792 / 7,00 GiB</span>
<span class="go">  Free  PE / Size       3314 / &lt;12,95 GiB</span>
<span class="go">  VG UUID               P3dDgq-AeHA-7Vur-Jy48-fzlm-wnC1-jf0x85</span>
</pre></div>
</div>
<p>Y para volúmenes lógicos:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp"># </span>lvs
<span class="go">  LV      VG       Attr       LSize   Pool Origin Data%  Meta%  Move Log Cpy%Sync Convert</span>
<span class="go">  primera VGtest   -wi-a-----   2,00g</span>
<span class="go">  segunda VGtest   -wi-a-----   5,00g</span>
<span class="go">  home    vgdebian -wi-a----- 370,00g</span>
<span class="go">  lxc     vgdebian -wi-a-----   2,00g</span>
<span class="go">  raiz    vgdebian -wi-a----- &lt;12,45g</span>
<span class="go">  swap    vgdebian -wc-a-----  &lt;1,86g</span>

<span class="gp"># </span>lvdisplay<span class="w"> </span>/dev/VGtest/primera
<span class="go">  --- Logical volume ---</span>
<span class="go">  LV Path                /dev/VGtest/primera</span>
<span class="go">  LV Name                primera</span>
<span class="go">  VG Name                VGtest</span>
<span class="go">  LV UUID                KBMwih-Mctp-rOcv-W3aK-iqTG-2vXo-KlpQxs</span>
<span class="go">  LV Write Access        read/write</span>
<span class="go">  LV Creation host, time choquereta, 2019-11-27 07:40:59 +0100</span>
<span class="go">  LV Status              available</span>
<span class="gp">  # </span>open<span class="w">                 </span><span class="m">0</span>
<span class="go">  LV Size                2,00 GiB</span>
<span class="go">  Current LE             512</span>
<span class="go">  Segments               1</span>
<span class="go">  Allocation             inherit</span>
<span class="go">  Read ahead sectors     auto</span>
<span class="go">  - currently set to     256</span>
<span class="go">  Block device           253:4</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">Ver también</p>
<p>El significado de los atributos indicados por <strong class="command">lvs</strong> puede
consultarse <a class="reference external" href="https://github.com/UnderV/py3tools/wiki/LVM-Attributes-Explained">en esta página de Github</a>.</p>
</div>
<span class="target" id="vgreduce"><span id="lvreduce"></span><span id="lvextend"></span><span id="vgextend"></span></span></section>
<section id="modificacion">
<span id="index-4"></span><h2><span class="section-number">5.1.4.4. </span>Modificación<a class="headerlink" href="#modificacion" title="Enlace permanente a este encabezado">¶</a></h2>
<p>La ventaja fundamental de las volúmenes lógicos es que podemos ampliarlos a
voluntad sin que el espacio tenga que ser contiguo. Por ejemplo:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp"># </span>lvextend<span class="w"> </span>-L<span class="w"> </span>3G<span class="w"> </span>/dev/VGtest/primera
</pre></div>
</div>
<p>Aumenta hasta 3GiB el primer volumen lógico, aunque no el sistema de ficheros
contenido, por lo que el espacio ocupable seguirá siendo de 2GiB. Para ampliar
también el sistema de fichero es necesario, en este caso:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp"># </span>resize2fs<span class="w"> </span>/dev/Vgtest/primera
</pre></div>
</div>
<p>No obstante, podemos incluir la opción <kbd class="kbd docutils literal notranslate">-r</kbd> y <strong class="command">lvextend</strong> se
encargará de comprobar cuál el sistema de ficheros y aplicar el comando
adecuando para que éste colonice el nuevo espacio disponible. En consecuencia
las dos órdenes anteriores son equivalente a:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp"># </span>lvextend<span class="w"> </span>-r<span class="w"> </span>-L<span class="w"> </span>3G<span class="w"> </span>/dev/VGtest/primera
</pre></div>
</div>
<p>También puede indicarse, en vez de el nuevo tamaño, el incremento. Esta orden:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp"># </span>lvextend<span class="w"> </span>-r<span class="w"> </span>-L<span class="w"> </span>+1G<span class="w"> </span>/dev/VGtest/segunda
</pre></div>
</div>
<p>aumenta hasta los 6GiB el volumen lógico cuyo anterior tamaño era 5GiB. Es
posible también usar porcentajes en vez de tamaños o incrementos absolutos a
través de la opción <kbd class="kbd docutils literal notranslate">-l</kbd><a class="footnote-reference brackets" href="#id6" id="id2" role="doc-noteref"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></a>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp"># </span>lvcreate<span class="w"> </span>-l<span class="w"> </span><span class="m">100</span>%FREE<span class="w"> </span>VGtest<span class="w"> </span>-n<span class="w"> </span>tercera
</pre></div>
</div>
<p>De esta manera, la nueva partición ocupará todo el espacio libre que uqede en el
grupo de volúmenes. El disco físico se ha acabado, pero si «compráramos» otro,
podríamos añadirlo como volumen lógico a <em>VGtest</em> y volveríamos a disponer de
espacio libre:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp"># </span>truncate<span class="w"> </span>-s<span class="w"> </span>10G<span class="w"> </span>/tmp/1.disk
<span class="gp"># </span>losetup<span class="w"> </span>/dev/loop1<span class="w"> </span>/tmp/1.disk
<span class="gp"># </span>pvcreate<span class="w"> </span>/dev/loop1
<span class="gp"># </span>vgextend<span class="w"> </span>VGtest<span class="w"> </span>/dev/loop1
<span class="gp"># </span>vgs<span class="w"> </span>VGtest
<span class="go">  VG     #PV #LV #SN Attr   VSize  VFree</span>
<span class="go">  VGtest   2   2   0 wz--n- 29,94g  9,94g</span>
</pre></div>
</div>
<p>Ahora el grupo de volúmenes tiene 30GiB, ya que hemos añadido 10GiB más.</p>
<p>Todas estas operaciones son de incremento y no requieren siquiera que
desmontemos los sistemas de ficheros para ser llevadas a cabo. En cambio, las
operaciones de reducción son más traumáticas ya que, por lo general, requieren
dejar hueco y en el caso de reducir particiones lógicas, desmontar previamente
el sistema de ficheros que contiene. Por lo demás, el procedimiento es
semejante:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp"># </span>lvresize<span class="w"> </span>-r<span class="w"> </span>-L<span class="w"> </span>-2G<span class="w"> </span>/dev/VGtest/segunda
<span class="gp"># </span>lvs<span class="w"> </span>/dev/VGtest/segunda
<span class="go">  LV      VG     Attr       LSize Pool Origin Data%  Meta%  Move Log Cpy%Sync Convert</span>
<span class="go">  segunda VGtest -wi-a----- 4,00g</span>
<span class="gp"># </span>lvreduce<span class="w"> </span>-r<span class="w"> </span>-l<span class="w"> </span>-25%LV<span class="w"> </span>/dev/VGtest/segunda
<span class="gp"># </span>lvs<span class="w"> </span>/dev/VGtest/segunda
<span class="go">  LV      VG     Attr       LSize Pool Origin Data%  Meta%  Move Log Cpy%Sync Convert</span>
<span class="go">  segunda VGtest -wi-a----- 3,00g</span>
</pre></div>
</div>
</section>
<section id="aprovisionamiento-fino">
<span id="lvm-aprovisionamiento"></span><h2><span class="section-number">5.1.4.5. </span>Aprovisionamiento fino<a class="headerlink" href="#aprovisionamiento-fino" title="Enlace permanente a este encabezado">¶</a></h2>
<p>El <em class="dfn">aprovisionamiento fino</em> (<em>thin provisioning</em>, en inglés) consiste en
reservar para un volumen lógico más espacio de disco del que realmente tiene
disponible. Es un concepto muy comúnmente usando en virtualización para cuyas
máquinas virtuales podemos usar discos de un tamaño mucho mayor del que
realmente ocupa su fichero correspondiente. Algo parecido se logra con la orden
<a class="reference internal" href="03.pract.html#truncate"><span class="std std-ref">truncate</span></a>. Se contrapone al <em class="dfn">aprovisionamiento grueso</em>, que
consiste en justo lo contrario, esto es, en reservar exactamente el tamaño del
volumen. Hasta ahora, hemos practicado con <abbr title="Logical Volume Management">LVM</abbr> este último tipo de
aprovisionamiento.</p>
<p>Sin embargo, <abbr title="Logical Volume Management">LVM</abbr> soporta <em>aprovisionamiento fino</em> que, en principio, puede
servir para dos propósitos distintos:</p>
<ul class="simple">
<li><p>Ajustar el tamaño máximo de varios volúmenes lógicos a parte (o todo)
del tamaño del grupo de volúmenes. Si no tenemos claro, cuáles van a ser las
necesidades de crecimiento de estos volúmenes, esto puede ahorrarnos la
necesidad de hacerlos excesivamente pequeños y, según sea la evolución
posterior, tener después que aumentarles progresivamente el tamaño.</p></li>
<li><p>Si instalamos sobre un disco pequeño con intención de que el sistema acabe
corriendo sobre un disco mayor, crear los volúmenes lógicos con el tamaño
que tendrán en el disco final. Usaremos esto al plantear la <a class="reference internal" href="../99.instalacion/index.html#inst-servidor"><span class="std std-ref">instalación
del servidor</span></a>.</p></li>
</ul>
<p>Lo primero, antes de empezar, es asegurarse de que está instalado el paquete
<strong>thin-provisioning-tools</strong>, hecho lo cual, podemos hacer pruebas con un nuevo
disco:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp"># </span>truncate<span class="w"> </span>-s<span class="w"> </span>500M<span class="w"> </span><span class="m">0</span>.disk
<span class="gp"># </span>losetup<span class="w"> </span>/dev/loop0<span class="w"> </span><span class="m">0</span>.disk
<span class="gp"># </span>vgcreate<span class="w"> </span>VGtest<span class="w"> </span>/dev/loop0
</pre></div>
</div>
<p>Para probar el concepto crearemos dos volúmenes lógicos: el primero normal y el
segundo un «<em>pool</em>», esto es, un volumen en el que encerraremos los volúmenes
para los que deseamos <em>aprovisionamiento fino</em>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp"># </span>lvcreate<span class="w"> </span>-L<span class="w"> </span>100m<span class="w"> </span>-n<span class="w"> </span>fuera<span class="w"> </span>VGtest
<span class="gp"># </span>lvcreate<span class="w"> </span>--thinpool<span class="w"> </span>pool<span class="w"> </span>-l<span class="w"> </span><span class="m">100</span>%FREE<span class="w"> </span>VGtest
<span class="gp"># </span>lvs<span class="w"> </span>VGtest
<span class="go">  LV    VG     Attr       LSize   Pool Origin Data%  Meta%  Move Log Cpy%Sync Convert</span>
<span class="go">  fuera VGtest -wi-a----- 100,00m</span>
<span class="go">  pool  VGtest twi-a-tz-- 388,00m             0,00   10,84</span>
</pre></div>
</div>
<p>El primero es un volumen de 100MiB y, además, no podrá cambiar su tamaño a menos
que agrandemos el grupo de volúmenes con, por ejemplo, otro disco. El segundo es
el <em>pool</em> dentro del que podemos crear volúmenes lógicos con aparentemente
cualquier tamaño:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp"># </span>lvcreate<span class="w"> </span>-T<span class="w"> </span>-n<span class="w"> </span>tvol1<span class="w"> </span>-V<span class="w"> </span>1G<span class="w"> </span>VGtest/pool
<span class="gp"># </span>lvcreate<span class="w"> </span>-T<span class="w"> </span>-n<span class="w"> </span>tvol2<span class="w"> </span>-V<span class="w"> </span>2G<span class="w"> </span>VGtest/pool
<span class="gp"># </span>lvs<span class="w"> </span>VGtest
<span class="go">  LV    VG     Attr       LSize   Pool Origin Data%  Meta%  Move Log Cpy%Sync Convert</span>
<span class="go">  fuera VGtest -wi-a----- 100,00m</span>
<span class="go">  pool  VGtest twi-aotz-- 388,00m             0,00   11,04</span>
<span class="go">  tvol1 VGtest Vwi-a-tz--   1,00g pool        0,00</span>
<span class="go">  tvol2 VGtest Vwi-a-tz--   2,00g pool        0,00</span>
</pre></div>
</div>
<p>Al crear ambos volúmenes, se nos refiere la opción
<kbd class="kbd docutils literal notranslate">activation/thin_pool_autoextend_threshold</kbd>, porque su valor es 100:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp"># </span>lvm<span class="w"> </span>dumpconfig<span class="w"> </span>activation/thin_pool_autoextend_threshold
<span class="go">thin_pool_autoextend_threshold=100</span>
</pre></div>
</div>
<p>La variable fija el tanto por cierto de ocupación del <em>pool</em> para el que una vez
alcanzado se incrementa el tamaño en un porcentaje fijado por:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp"># </span>lvm<span class="w"> </span>dumpconfig<span class="w"> </span>activation/thin_pool_autoextend_percent
<span class="go">thin_pool_autoextend_percent=20</span>
</pre></div>
</div>
<p>pero justamente un valor de 100% deshabilita la posibilidad. Si ponemos un valor
más bajo (p.e el 85%), sí se llevará a cabo la ampliación automática… si se
puede, que no es nuestro caso, ya que el grupo de volúmenes está completamente
lleno.</p>
<p>Si probamos a dar formato a uno de los volúmenes del <em>pool</em>, comprobaremos el
sistema de ficheros participa de la ficción del tamaño:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp"># </span>mkfs.ext4<span class="w"> </span>-L<span class="w"> </span>TVOL2<span class="w"> </span>/dev/VGtest/tvol2
<span class="gp"># </span>mount<span class="w"> </span>/dev/VGtest/tvol2<span class="w"> </span>/mnt/
<span class="gp"># </span>df<span class="w"> </span>-h<span class="w"> </span>/mnt/
<span class="go">S.ficheros               Tamaño Usados  Disp Uso% Montado en</span>
<span class="go">/dev/mapper/VGtest-tvol2   2,0G   6,0M  1,8G   1% /mnt</span>
</pre></div>
</div>
<p>Sin embargo, el espacio real es el que ocupa el <em>pool</em>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp"># </span>lvs<span class="w"> </span>VGtest/pool
<span class="go">  LV   VG     Attr       LSize   Pool Origin Data%  Meta%  Move Log Cpy%Sync Convert</span>
<span class="go">  pool VGtest twi-aotz-- 388,00m             25,14  12,21</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>No soportan aprovisionamiento fino ni el <a class="reference external" href="https://wiki.debian.org/DebianInstaller">instalador de debian</a>, ni <abbr title="GRand Unified Bootloader">GRUB</abbr>, lo cual dificulta
enormemente meter el sistema de ficheros raíz en un volumen de este tipo.
Lo primero impide crear o aprovechar volúmenes de aprovisionamiento fino
durante el proceso de instalación; y
lo segundo obliga a no incluir dentro de ellos el núcleo y el sistema
de ficheros inicial (<em>initrd</em>), lo cual se traduce en montar  <code class="file docutils literal notranslate"><span class="pre">/boot</span></code>
aparte o en copiar <a class="reference internal" href="03.pract.html#efi-arranque-directo"><span class="std std-ref">ambos ficheros en la partición ESP</span></a>.</p>
</div>
</section>
<section id="instantaneas">
<span id="lvm-snapshots"></span><h2><span class="section-number">5.1.4.6. </span>Instantáneas<a class="headerlink" href="#instantaneas" title="Enlace permanente a este encabezado">¶</a></h2>
<p>Una <em class="dfn">instantánea</em> consiste en el almacenamiento del estado del sistema de
archivos en el momento de llevarla a cabo. Para ello, no se hace una copia del
sistema (lo cual es costoso en tiempo y equivaldría a una copia de seguridad),
sino que al modificarse por primera vez tras la creación de la instantánea el
contenido de un fichero, se guarda en la instantánea una copia de éste sin la
modificación. De esta forma, el estado de la instantánea es la suma de los
archivos que no han llegado a ser modificados, guardados en el volumen original,
más la copia de los archivos sí modificados, guardados en la instantánea.</p>
<p>Las instantáneas reparan las pérdidas por modificación o borrado no deseados,
papel que también puede cumplir una copia de seguridad, pero a diferencia de
éstas, no sirven como medida contra los fallos de disco o la corrupción de
datos, ya que requieren el sistema original y pueden estar almacenadas sobre el
mismo dispositivo físico.</p>
<p>Hay dos mecanismos para la creación de instantáneas:</p>
<ul class="simple">
<li><p>Mediante el uso de sistemas de ficheros que las soporten nativamente como
<abbr title="Zettabyte File System">ZFS</abbr> o <abbr title="B-tree File System">BtrFS</abbr>.</p></li>
<li><p>Mediante <em>software</em> adicional que se encargue de hacer las instantáneas como
el <em>software</em> que nos ocupa en <em>Linux</em> o la restauración del sistema en los
sistemas <em>Windows</em>.</p></li>
</ul>
<p>Para llevar a cabo instantáneas con <abbr title="Logical Volume Management">LVM</abbr> el procedimiento es simple: basta con
crear un volumen lógico que se declare que sirve para almacenar la instantánea
de otro volumen lógico. Por ejemplo, vamos a dar formato a uno de los volúmenes
lógicos y a escribir dentro de él:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp"># </span>mkfs.ext4<span class="w"> </span>-L<span class="w"> </span>PRIMERA<span class="w"> </span>/dev/VGtest/primera
<span class="gp"># </span>mkdir<span class="w"> </span>/tmp/<span class="o">{</span>original,snap<span class="o">}</span>
<span class="gp"># </span>mount<span class="w"> </span>/dev/VGtest/primera<span class="w"> </span>/tmp/original
<span class="gp"># </span><span class="nb">echo</span><span class="w"> </span><span class="s2">&quot;Hola&quot;</span><span class="w"> </span>&gt;<span class="w"> </span>/tmp/original/saluto.txt
</pre></div>
</div>
<p>Hecho lo cual, podemos crear una instantánea del estado actual de «primera»:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp"># </span>lvcreate<span class="w"> </span>-s<span class="w"> </span>-n<span class="w"> </span>primera_snap<span class="w"> </span>-L<span class="w"> </span>50M<span class="w"> </span>/dev/VGtest/primera
</pre></div>
</div>
<p>donde es importante tener presente que el tamaño como máximo puede ser el tamaño
del volumen original<a class="footnote-reference brackets" href="#id7" id="id3" role="doc-noteref"><span class="fn-bracket">[</span>3<span class="fn-bracket">]</span></a> (<kbd class="kbd compound docutils literal notranslate"><kbd class="kbd docutils literal notranslate">-l</kbd> <kbd class="kbd docutils literal notranslate">100%ORIGIN</kbd></kbd>). También se puede añadir un
parámetro adicional para indicar sobre qué volumen físico de los que integran el
grupo de volúmenes se quiere definir la instantánea. Hecho esto, podemos
practicar dos estrategias:</p>
<ol class="loweralpha simple">
<li><p>La obvia que es continuar trabajando sobre el volumen original y, si en algún
momento decidimos revertir los cambios, recuperar la instantánea. Un ejemplo
en que es una buena opción esta estrategia es ante una actualización. Si
sospechamos que algo puede ir mal, podemos hacer antes una instantánea y
dependiendo del resultado, revertir al estado anterior a la instalación o
desechar la instantánea.</p></li>
<li><p>Trabajar sobre la instantánea sin alterar el volumen original, ya que si
<em>recuperamos</em> la instantánea lo que haremos será aplicar los cambios de la
instantánea sobre el volumen original. Esta opción es adecuada en los casos en
que queremos que el sistema siga funcionando en producción del mismo modo,
mientras nosotros introducimos cambios (p.e. en algunos <em>scripts</em>). De nuevo,
podrá darse el caso de que decidamos aplicar los cambios (recuperando la
instantánea) o desecharlos (borrándola).</p></li>
</ol>
<p class="rubric">Trabajando sobre el propio volumen</p>
<p>Para nuestro ejemplo, podemos hacer algunos cambios simples:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp"># </span><span class="nb">echo</span><span class="w"> </span><span class="s2">&quot;Adios&quot;</span><span class="w"> </span>&gt;&gt;<span class="w"> </span>/tmp/original/saludo.txt
<span class="gp"># </span>cp<span class="w"> </span>/etc/resolv.conf<span class="w"> </span>/tmp/original
</pre></div>
</div>
<p>Con estas acciones la instantánea debería ir paulatimente incrementando su
ocupación (ya que necesita almacenar las copias de los ficheros) y es
conveniente vigilar este dato, ya que malograremos la instantánea, si
superamos la capacidad máxima:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp"># </span>lvs<span class="w"> </span>-o<span class="w"> </span>data_percent<span class="w"> </span>/dev/VGtest/primera_snap
<span class="go">Data%</span>
<span class="go">0.09</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>Si comprobamos que la ocupación se aproxima al 100%, podemos usar
<a class="reference internal" href="#lvextend"><span class="std std-ref">lvextend</span></a> como se hace en los volúmenes lógicos normales.</p>
</div>
<p>Dependiendo de si los cambios sobre el volumen son aceptables o no, tocará
desechar la instantánea:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp"># </span>lvremove<span class="w"> </span>/dev/VGtest/primera_snap
</pre></div>
</div>
<p>o revertir los cambios sobre el volumen:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp"># </span>umount<span class="w"> </span>/tmp/original
<span class="gp"># </span>lvconvert<span class="w"> </span>--merge<span class="w"> </span>/dev/VGtest/primera_snap
</pre></div>
</div>
<p>cuyo efecto será que el volumen vuelta al estado de la instantánea y que el
volumen con la instantánea desaparezca automáticamente.</p>
<div class="admonition warning">
<p class="admonition-title">Advertencia</p>
<p>Es importante que tanto el volumen original como el de la
instantánea se encuentren desmontados en el momento de hacer la fusión.</p>
</div>
<p class="rubric">Trabajando sobre la instantánea</p>
<p>Alternativamente, podemos trabajar sobre la instantánea y dejar sin alterar el
volumen original. Para ello, basta con montar la instantánea:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp"># </span>mount<span class="w"> </span>/dev/VGtest/primera_snap<span class="w"> </span>/tmp/snap
</pre></div>
</div>
<p>y realizar los cambios sobre ella:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp"># </span><span class="nb">echo</span><span class="w"> </span><span class="s2">&quot;Adios&quot;</span><span class="w"> </span>&gt;&gt;<span class="w"> </span>/tmp/snap/saludo.txt
<span class="gp"># </span>cp<span class="w"> </span>/etc/resolv.conf<span class="w"> </span>/tmp/snap
</pre></div>
</div>
<p>En este caso, las operaciones para desechar o revertir los cambios son justamente
las opuestas. Si deseamos aplicar los cambios sobre el volumen, necesitamos
fusionar con la instantánea:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp"># </span>umount<span class="w"> </span>/tmp/<span class="o">{</span>original,snap<span class="o">}</span>
<span class="gp"># </span>lvconvert<span class="w"> </span>--merge<span class="w"> </span>/dev/VGtest/primera_snap
</pre></div>
</div>
<p>y, si deseamos desecharlos, eliminar el volumen de la instantánea:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp"># </span>umount<span class="w"> </span>/tmp/snap
<span class="gp"># </span>lvremove<span class="w"> </span>/dev/VGtest/primera_snap
</pre></div>
</div>
<p>Obsérvese que si nuestra intención fuera tener varias instantáneas de un mismo
volumen lógico, entonces tendríamos que crear un volumen de instantánea para
cada una de ellos, lo que resultaría en la reserva (y malgasto) de una ingente
cantidad de espacio en el grupo de volúmenes. La solución es utilizar el
<a class="reference internal" href="#lvm-aprovisionamiento"><span class="std std-ref">aprovisionamiento fino</span></a> para almacenar los
volúmenes de instantánea.</p>
<p class="rubric" id="lvm-aprovisionamiento-snapshots">Instantáneas con aprovisionamiento fino</p>
<p>Dado que el aprovisionamiento fino permite crear múltiples volúmenes lógicos sin
que realmente exista el espacio ocupado por todos ellos, es muy útil combinarlo
con las <a class="reference internal" href="#lvm-snapshots"><span class="std std-ref">capacidades de instantánea de LVM</span></a> para tener un
sistema de archivos con varios puntos de restauración.</p>
<p>Puede utilizarse una volumen lógico fuera del «<em>pool</em>» como volumen original
(véase <a class="reference external" href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/6/html/logical_volume_manager_administration/thinly_provisioned_snapshot_creation">esta documentación de RedHat</a>),
pero dado que este volumen original debe quedar como de sólo lectura y
desactivo, planteemos que el volumen original está dentro del propio «<em>pool</em>».
Para ilustrarlo partamos del siguiente disco ficticio al que definimos un grupo
de volúmenes:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp"># </span>truncate<span class="w"> </span>-s<span class="w"> </span>1G<span class="w"> </span><span class="m">0</span>.disk
<span class="gp"># </span>losetup<span class="w"> </span>/dev/loop0<span class="w"> </span><span class="m">0</span>.disk
<span class="gp"># </span>vgcreate<span class="w"> </span>VGtest<span class="w"> </span>/dev/loop0
</pre></div>
</div>
<p>y un «<em>pool</em>» para albergar un volumen y sus instantáneas:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp"># </span>lvcreate<span class="w"> </span>--thinpool<span class="w"> </span>pool<span class="w"> </span>-L<span class="w"> </span>500M<span class="w"> </span>VGtest
</pre></div>
</div>
<p>y el propio volumen:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp"># </span>lvcreate<span class="w"> </span>-T<span class="w"> </span>-n<span class="w"> </span>original<span class="w"> </span>-V<span class="w"> </span>350M<span class="w"> </span>VGtest/pool
<span class="gp"># </span>mkfs.ext4<span class="w"> </span>-L<span class="w"> </span>ORIGINAL<span class="w"> </span>/dev/VGtest/original
<span class="gp"># </span>mount<span class="w"> </span>/dev/VGtest/original<span class="w"> </span>/mnt
</pre></div>
</div>
<p>A partir de este momento podemos ir generando instantáneas que almacenen
distintos estados del sistema de archivos. Por ejemplo, si inmediatamente
generamos una instantánea, tendremos el estado en el que el sistema estaba
vacío:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp"># </span>lvcreate<span class="w"> </span>-s<span class="w"> </span>-n<span class="w"> </span>0snap<span class="w"> </span>VGtest/original
</pre></div>
</div>
<p>Podemos crear, borrar y modificar archivos:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp"># </span><span class="nb">echo</span><span class="w"> </span><span class="s2">&quot;Primer archivo&quot;</span><span class="w"> </span>&gt;<span class="w"> </span>/mnt/uno.txt
</pre></div>
</div>
<p>y estos cambios se aplicarán a la partición original, ya que es esta la que se
encuentra activa:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp"># </span>lvs<span class="w"> </span>VGtest
<span class="go">  LV       VG     Attr       LSize   Pool Origin   Data%  Meta%  Move Log Cpy%Sync Convert</span>
<span class="hll"><span class="go">  0snap    VGtest Vwi---tz-k 352,00m pool original</span>
</span><span class="hll"><span class="go">  original VGtest Vwi-aotz-- 352,00m pool          7,79</span>
</span><span class="go">  pool     VGtest twi-aotz-- 500,00m               5,57   11,72</span>
</pre></div>
</div>
<p>En un estado posterior, podremos generar una nueva instantánea, que fijará estos cambios:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp"># </span>lvcreate<span class="w"> </span>-s<span class="w"> </span>-n<span class="w"> </span>1snap<span class="w"> </span>VGtest/original
</pre></div>
</div>
<p>Todas las instantáneas que generemos de este modo están inactivas (no aparece
la <kbd class="kbd docutils literal notranslate">a</kbd> entre sus atributos) y, además, no se activarán aunque así lo
ordenemos (atributo <kbd class="kbd docutils literal notranslate">k</kbd>). Si nuestra intención fuera recuperar algún
archivo de ellas deberíamos corregir esto, hacer las operaciones pertinentes y
volver a dejar todo como estaba. Por ejemplo, si por error perdemos <code class="file docutils literal notranslate"><span class="pre">uno.txt</span></code>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp"># </span>rm<span class="w"> </span>-f<span class="w"> </span>/mnt/uno.txt
</pre></div>
</div>
<p>aún podremos recuperarlo de la instantánea «1snap», para lo cual deberemos hacer:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp"># </span>lvchange<span class="w"> </span>-kn<span class="w"> </span>-ay<span class="w"> </span>-pr<span class="w"> </span>VGtest/1snap
</pre></div>
</div>
<p>que permite la activación (<kbd class="kbd compound docutils literal notranslate"><kbd class="kbd docutils literal notranslate">-k</kbd> <kbd class="kbd docutils literal notranslate">n</kbd></kbd>), activa el volumen (<kbd class="kbd compound docutils literal notranslate"><kbd class="kbd docutils literal notranslate">-a</kbd> <kbd class="kbd docutils literal notranslate">y</kbd></kbd>) y, por
precaución, hace el volumen de sólo lectura (<kbd class="kbd compound docutils literal notranslate"><kbd class="kbd docutils literal notranslate">-p</kbd> <kbd class="kbd docutils literal notranslate">r</kbd></kbd>). Hecho esto, podemos
montar el volumen sobre otro punto:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp"># </span>mount<span class="w"> </span>/dev/VGtest/1snap<span class="w"> </span>/tmp/mnt
</pre></div>
</div>
<p>recuperar el archivo perdido:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp"># </span>cp<span class="w"> </span>/tmp/mnt/uno.txt<span class="w"> </span>/mnt
</pre></div>
</div>
<p>y dejar todo como estaba en un principio:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp"># </span>umount<span class="w"> </span>/tmp/mnt
<span class="gp"># </span>lvchange<span class="w"> </span>-an<span class="w"> </span>-ky<span class="w"> </span>-prw<span class="w"> </span>Vgtest/1snap
</pre></div>
</div>
<p>Hay, no obstante, un modo más cómodo de gestionar todo esto, que veremos
justamente a continuación:</p>
<span class="target" id="snapper"></span><p class="rubric" id="index-5">snapper</p>
<p><em class="manpage"><a class="manpage reference external" href="https://manpages.debian.org/snapper">snapper</a></em> es un programita de la línea de comandos que nos permite
hacer y mantener instantáneas de una manera bastante cómoda. Además, gestiona
tanto instantáneas basadas en aprovisionamiento fino de <abbr title="Logical Volume Management">LVM</abbr> como basadas en
<abbr title="B-tree File System">BtrFS</abbr>, lo cual permite usar una misma interfaz de usuario para ambos tipos de
instantáneas<a class="footnote-reference brackets" href="#id8" id="id4" role="doc-noteref"><span class="fn-bracket">[</span>4<span class="fn-bracket">]</span></a>.</p>
<p>Partamos del supuesto anterior:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp"># </span>truncate<span class="w"> </span>-s<span class="w"> </span>1G<span class="w"> </span><span class="m">0</span>.disk
<span class="gp"># </span>losetup<span class="w"> </span>/dev/loop0<span class="w"> </span><span class="m">0</span>.disk
<span class="gp"># </span>vgcreate<span class="w"> </span>VGtest<span class="w"> </span>/dev/loop0
<span class="gp"># </span>lvcreate<span class="w"> </span>--thinpool<span class="w"> </span>pool<span class="w"> </span>-L<span class="w"> </span>500M<span class="w"> </span>VGtest
<span class="gp"># </span>lvcreate<span class="w"> </span>-T<span class="w"> </span>-n<span class="w"> </span>original<span class="w"> </span>-V<span class="w"> </span>350M<span class="w"> </span>VGtest/pool
<span class="gp"># </span>mkfs.ext4<span class="w"> </span>-L<span class="w"> </span>ORIGINAL<span class="w"> </span>/dev/VGtest/original
<span class="gp"># </span>mount<span class="w"> </span>/dev/VGtest/original<span class="w"> </span>/mnt
</pre></div>
</div>
<p>en que ya hemos preparado el volumen lógico con un sistema de archivos y lo
hemos montado. A partir de este momento, podemos centrarnos en que el sistema de
archivos está montado sobre <code class="file docutils literal notranslate"><span class="pre">/mnt</span></code> y usar <em class="manpage"><a class="manpage reference external" href="https://manpages.debian.org/snapper">snapper</a></em> olvidádonos
de los comandos propios de <abbr title="Logical Volume Management">LVM</abbr>. Lo primero es crear una configuración asociada
al punto de montaje que nos sirva para generar las instantáneas:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp"># </span>snapper<span class="w"> </span>-c<span class="w"> </span>misnap<span class="w"> </span>create-config<span class="w"> </span>-f<span class="w"> </span><span class="s2">&quot;lvm(ext4)&quot;</span><span class="w"> </span>/mnt
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>Si utilizáramos <strong class="command">snapper</strong> para gestionar las instantáneas de
un sistema de archivos <abbr title="B-tree File System">BtrFS</abbr>, la única diferencia sería la declaración del
sistema (-f «btrfs»), todo lo demás sería idéntico y las órdenes a partir de
ésta las mismas.</p>
</div>
<p>Creada la configuración con nombre «misnap», podemos consultar las instantáneas
que en este punto hay creadas:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp"># </span>snapper<span class="w"> </span>-c<span class="w"> </span>misnap<span class="w"> </span>list
<span class="gp"> # </span><span class="p">|</span><span class="w"> </span>Tipo<span class="w">   </span><span class="p">|</span><span class="w"> </span>Pre<span class="w"> </span>número<span class="w"> </span><span class="p">|</span><span class="w"> </span>Fecha<span class="w"> </span><span class="p">|</span><span class="w"> </span>Usuario<span class="w"> </span><span class="p">|</span><span class="w"> </span>Limpieza<span class="w"> </span><span class="p">|</span><span class="w"> </span>Descripción<span class="w"> </span><span class="p">|</span><span class="w"> </span>Información<span class="w"> </span>del<span class="w"> </span>usuario
<span class="go">---+--------+------------+-------+---------+----------+-------------+------------------------</span>
<span class="go">0  | single |            |       | root    |          | current     |</span>
</pre></div>
</div>
<p>Ahora mismo sólo hay un estado del sistema de archivos montado sobre
<code class="file docutils literal notranslate"><span class="pre">/mnt</span></code>, el <strong>0</strong>, lo cual es normal, porque aún no hemos creado ninguna
instantánea. Esta instantánea <strong>0</strong> siempre representará el estado en
funcionamiento, este es, siempre será el estado sobre el que se reflejen los
cambios cuando hagamos operaciones sobre el sistema de archivos.</p>
<p>Aunque podemos olvidarnos de qué es lo que ocurre por debajo (o sea, cómo se
comporta <abbr title="Logical Volume Management">LVM</abbr>) e incluso desconocerlo, podemos echarle un ojo, visto que
acabamos aprender cómo gestionar las instantáneas directamente:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp"># </span>lvm<span class="w"> </span>vgtest
<span class="go">  lv                 vg     attr       lsize   pool origin   data%  meta% move log cpy%sync convert</span>
<span class="go">  original           vgtest vwi-aotz-- 352,00m pool          5,68</span>
<span class="go">  pool               vgtest twi-aotz-- 500,00m               4,06 11,43</span>
</pre></div>
</div>
<p>Como es natural, al no haberse generado ninguna instantánea, no se ha creado
ningún volumen nuevo. Generemos una primera instantáne que refleje el estado
inicial del sistema de archivos (completamente vacío):</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp"># </span>snapper<span class="w"> </span>-c<span class="w"> </span>misnap<span class="w"> </span>create<span class="w"> </span>--description<span class="w"> </span><span class="s2">&quot;Estado inicial&quot;</span>
</pre></div>
</div>
<p>lo cual debe provocar la aparición de una primera instantánea:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp"># </span>snapper<span class="w"> </span>-c<span class="w"> </span>misnap<span class="w"> </span>list
<span class="gp"> # </span><span class="p">|</span><span class="w"> </span>Tipo<span class="w">   </span><span class="p">|</span><span class="w"> </span>Pre<span class="w"> </span>número<span class="w"> </span><span class="p">|</span><span class="w"> </span>Fecha<span class="w">                    </span><span class="p">|</span><span class="w"> </span>Usuario<span class="w"> </span><span class="p">|</span><span class="w"> </span>Limpieza<span class="w"> </span><span class="p">|</span><span class="w"> </span>Descripción<span class="w">    </span><span class="p">|</span><span class="w"> </span>Información<span class="w"> </span>del<span class="w"> </span>usuario
<span class="go">---+--------+------------+--------------------------+---------+----------+----------------+------------------------</span>
<span class="go">0  | single |            |                          | root    |          | current        |</span>
<span class="go">1  | single |            | vie 15 oct 2021 17:20:11 | root    |          | Estado inicial |</span>
</pre></div>
</div>
<p>representada por el identificador <strong>1</strong>. Internamente, es obvio que ha surgido
un nuevo volumen de aprovisionamiento fino:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp"># </span>lvm<span class="w"> </span>vgtest
<span class="go">  lv                 vg     attr       lsize   pool origin   data%  meta% move log cpy%sync convert</span>
<span class="go">  original           vgtest vwi-aotz-- 352,00m pool          5,68</span>
<span class="go">  original-snapshot1 vgtest vri---tz-k 352,00m pool original</span>
<span class="go">  pool               vgtest twi-aotz-- 500,00m               4,06 11,43</span>
</pre></div>
</div>
<p>y el comportamiento es idéntico al que se producía cuando operábamos
directamente con <abbr title="Logical Volume Management">LVM</abbr>. Operemos un cambio sobre el sistema de archivos:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp"># </span><span class="nb">echo</span><span class="w"> </span><span class="s2">&quot;1&quot;</span><span class="w"> </span>&gt;<span class="w"> </span>/mnt/uno.txt
</pre></div>
</div>
<p>La ventaja de usar <strong class="command">snapper</strong> es que es mucho más cómodo ver y recuperar
estados antiguos. Por ejemplo, para comprobar qué diferencia hay entre el estado
actual (el <strong>0</strong>) y el inicial (el <strong>1</strong>):</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp"># </span>snapper<span class="w"> </span>-c<span class="w"> </span>misnap<span class="w"> </span>status<span class="w"> </span><span class="m">1</span>..0
<span class="go">+..... /mnt/uno.txt</span>
</pre></div>
</div>
<p>O sea, <strong>0</strong> ha añadido (»<kbd class="kbd docutils literal notranslate">+</kbd>») el archivo indicado al estado representado
con <strong>1</strong>. Lo contrario (ha perdido un archivo), se representa con «<kbd class="kbd docutils literal notranslate">-</kbd>» y
el cambio en el contenido de un archivo con una «<kbd class="kbd docutils literal notranslate">c</kbd>». Si queremos guardar
este nuevo estado:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp"># </span>snapper<span class="w"> </span>-c<span class="w"> </span>misnap<span class="w"> </span>create<span class="w"> </span>--description<span class="w"> </span><span class="s2">&quot;Estado 1º&quot;</span>
<span class="gp"># </span>snapper<span class="w"> </span>-c<span class="w"> </span>misnap<span class="w"> </span>list
<span class="gp"> # </span><span class="p">|</span><span class="w"> </span>Tipo<span class="w">   </span><span class="p">|</span><span class="w"> </span>Pre<span class="w"> </span>número<span class="w"> </span><span class="p">|</span><span class="w"> </span>Fecha<span class="w">                    </span><span class="p">|</span><span class="w"> </span>Usuario<span class="w"> </span><span class="p">|</span><span class="w"> </span>Limpieza<span class="w"> </span><span class="p">|</span><span class="w"> </span>Descripción<span class="w">    </span><span class="p">|</span><span class="w"> </span>Información<span class="w"> </span>del<span class="w"> </span>usuario
<span class="go">---+--------+------------+--------------------------+---------+----------+----------------+------------------------</span>
<span class="go">0  | single |            |                          | root    |          | current        |</span>
<span class="go">1  | single |            | vie 15 oct 2021 17:20:11 | root    |          | Estado inicial |</span>
<span class="go">2  | single |            | vie 15 oct 2021 17:34:31 | root    |          | Estado 1º      |</span>
</pre></div>
</div>
<p>Supongamos ahora que cometemos un desliz y cambias equivocadamente el contenido del archivo:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp"># </span><span class="nb">echo</span><span class="w"> </span><span class="s2">&quot;&quot;</span><span class="w"> </span>&gt;<span class="w"> </span>/mnt/uno.txt
<span class="gp"># </span>snapper<span class="w"> </span>-c<span class="w"> </span>misnap<span class="w"> </span>status<span class="w"> </span><span class="m">2</span>..0
<span class="go">c..... /mnt/uno.txt</span>
<span class="gp"># </span>snapper<span class="w"> </span>-c<span class="w"> </span>misnap<span class="w"> </span>status<span class="w"> </span><span class="m">1</span>..2
<span class="go">+..... /mnt/uno.txt</span>
</pre></div>
</div>
<p>Podemos comprobar cuál es el cambio muy fácilmente:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp"># </span>snapper<span class="w"> </span>-c<span class="w"> </span>misnap<span class="w"> </span>diff<span class="w"> </span><span class="m">2</span>..0<span class="w"> </span>/mnt/uno.txt
<span class="go">--- /mnt/.snapshots/2/snapshot/uno.txt  2021-10-15 17:27:26.000000000 +0200</span>
<span class="go">+++ /mnt/uno.txt        2021-10-15 17:37:07.000000000 +0200</span>
<span class="go">@@ -1 +1 @@</span>
<span class="go">-1</span>
<span class="go">+</span>
</pre></div>
</div>
<p>que muestra la diferencia haciendo uso de la orden <a class="reference internal" href="../../02.conbas/10.texto/02.busqueda.html#diff"><span class="std std-ref">diff</span></a>. Si
hubiéramos prescindido del archivo concreto, la orden <strong class="command">diff</strong> se hubiera
ejecutado para cada uno de los archivos distintos entre ambos estados. También
podemos recuperar una versión antigua del archivo en el estado actual:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp"># </span>snapper<span class="w"> </span>-c<span class="w"> </span>misnap<span class="w"> </span>undochange<span class="w"> </span><span class="m">2</span>..0<span class="w"> </span>/mnt/uno.txt
<span class="go">crear:0 modificar:1 eliminar:0</span>
<span class="gp"># </span>cat<span class="w"> </span>/mnt/uno.txt
<span class="go">1</span>
</pre></div>
</div>
<p>que devolverá el archivo al estado que tenía cuando se hizo la instantánea
<strong>2</strong>. También pueden eliminarse instantáneas con la suborden <kbd class="kbd docutils literal notranslate">delete</kbd>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp"># </span>snapper<span class="w"> </span>-c<span class="w"> </span>misnap<span class="w"> </span>delete<span class="w"> </span><span class="m">2</span>
</pre></div>
</div>
<p>Las instantáneas generadas con <strong class="command">snapper</strong> no se limitan a esto. La
configuración creada inicialmente determina su comportamiento:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp"># </span>snapper<span class="w"> </span>-c<span class="w"> </span>misnap<span class="w"> </span>get-config
<span class="go">Clave                  | Valor</span>
<span class="go">-----------------------+----------</span>
<span class="go">ALLOW_GROUPS           |</span>
<span class="go">ALLOW_USERS            |</span>
<span class="go">BACKGROUND_COMPARISON  | yes</span>
<span class="go">EMPTY_PRE_POST_CLEANUP | yes</span>
<span class="go">EMPTY_PRE_POST_MIN_AGE | 1800</span>
<span class="go">FREE_LIMIT             | 0.2</span>
<span class="go">FSTYPE                 | lvm(ext4)</span>
<span class="go">NUMBER_CLEANUP         | yes</span>
<span class="go">NUMBER_LIMIT           | 50</span>
<span class="go">NUMBER_LIMIT_IMPORTANT | 10</span>
<span class="go">NUMBER_MIN_AGE         | 1800</span>
<span class="go">QGROUP                 |</span>
<span class="go">SPACE_LIMIT            | 0.5</span>
<span class="go">SUBVOLUME              | /mnt</span>
<span class="go">SYNC_ACL               | no</span>
<span class="go">TIMELINE_CLEANUP       | yes</span>
<span class="go">TIMELINE_CREATE        | yes</span>
<span class="go">TIMELINE_LIMIT_DAILY   | 10</span>
<span class="go">TIMELINE_LIMIT_HOURLY  | 10</span>
<span class="go">TIMELINE_LIMIT_MONTHLY | 10</span>
<span class="go">TIMELINE_LIMIT_WEEKLY  | 0</span>
<span class="go">TIMELINE_LIMIT_YEARLY  | 10</span>
<span class="go">TIMELINE_MIN_AGE       | 1800</span>
</pre></div>
</div>
<p>El significado de estas variables puede consultar en la página del manual
<em class="manpage"><a class="manpage reference external" href="https://manpages.debian.org/snapper-configs">snapper-configs</a></em>. Por ejemplo, la generación automática de
instantáneas está habilitada por defecto y un algoritmo (<em>cleanup</em>) que
determina qué instantáneas periódicas conservar. De hecho, como nos hemos
demorado un poco al escribir este epígrafe, al programa le ha dado tiempo ha
hacer una instantánea automática:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp"># </span>snapper<span class="w"> </span>-c<span class="w"> </span>misnap<span class="w"> </span>list
<span class="gp"> # </span><span class="p">|</span><span class="w"> </span>Tipo<span class="w">   </span><span class="p">|</span><span class="w"> </span>Pre<span class="w"> </span>número<span class="w"> </span><span class="p">|</span><span class="w"> </span>Fecha<span class="w">                    </span><span class="p">|</span><span class="w"> </span>Usuario<span class="w"> </span><span class="p">|</span><span class="w"> </span>Limpieza<span class="w"> </span><span class="p">|</span><span class="w"> </span>Descripción<span class="w">    </span><span class="p">|</span><span class="w"> </span>Información<span class="w"> </span>del<span class="w"> </span>usuario
<span class="go">---+--------+------------+--------------------------+---------+----------+----------------+------------------------</span>
<span class="go">0  | single |            |                          | root    |          | current        |</span>
<span class="go">1  | single |            | vie 15 oct 2021 17:20:11 | root    |          | Estado inicial |</span>
<span class="go">2  | single |            | vie 15 oct 2021 17:34:31 | root    |          | Estado 1º      |</span>
<span class="go">3  | single |            | vie 15 oct 2021 18:00:32 | root    | timeline | timeline       |</span>
</pre></div>
</div>
<p>Obsérvese que hay instantáneas generadas manualmente y otras generadas
automáticamente; y en las variables de configuración éstas refieren las
limitaciones en el número de unas y otras. Al generar una instantánea manualmente
se pueden marcar como importante del siguiente modo:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp"># </span>snapper<span class="w"> </span>-c<span class="w"> </span>misnap<span class="w"> </span>create<span class="w"> </span>-d<span class="w"> </span><span class="s2">&quot;Estado 3º&quot;</span><span class="w"> </span>-u<span class="w"> </span><span class="s2">&quot;important=yes&quot;</span>
</pre></div>
</div>
<p>lo cual hace que el algoritmo de limpieza de las instantáneas manuales las trate
de un modo especial. En cualquier caso, si se quiere gestionar las instantáneas
de forma totalmente manual, basta con cambiar la configuración:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp"># </span>snapper<span class="w"> </span>-c<span class="w"> </span>misnap<span class="w"> </span>set-config<span class="w"> </span><span class="s2">&quot;TIMELINE_CREATE=no&quot;</span><span class="w"> </span><span class="s2">&quot;NUMBER_CLEANUP=no&quot;</span>
</pre></div>
</div>
<p>y se deshabilitará la creación de instantáneas automáticas y la limpieza de
instantáneas antiguas (de lo que tendremos que encargarnos nosotros usando la
suborden <kbd class="kbd docutils literal notranslate">delete</kbd>).</p>
<p class="rubric">Notas al pie</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id5" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id1">1</a><span class="fn-bracket">]</span></span>
<p>En las versiones más recientes, esto no es ya necesario y al incluir un
disco  o partición en un grupo de volúmenes, se define ya como volumen físico
automáticamente.</p>
</aside>
<aside class="footnote brackets" id="id6" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id2">2</a><span class="fn-bracket">]</span></span>
<p>Los porcentajes puede referirse al espacio libre (<kbd class="kbd docutils literal notranslate">FREE</kbd>) en el grupo
de volúmenes, al espacio del volumen lógico (<kbd class="kbd docutils literal notranslate">LV</kbd>), al espacio del grupo
de volúmenes (<kbd class="kbd docutils literal notranslate">VG</kbd>) y, para instantáneas, <kbd class="kbd docutils literal notranslate">ORIGIN</kbd> que refiere al tamaño
del volumen original.</p>
</aside>
<aside class="footnote brackets" id="id7" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id3">3</a><span class="fn-bracket">]</span></span>
<p>De hecho, si se hace la instantánea del tamaño del volumen original jamás
tendremos el problema de que la instantánea sea incapaz de albergar las
copias de los ficheros originales y se malogre.</p>
</aside>
<aside class="footnote brackets" id="id8" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id4">4</a><span class="fn-bracket">]</span></span>
<p>Crear y gestionar instantáneas con aprovisionamiento fino de <abbr title="Logical Volume Management">LVM</abbr> lo
acabamos de ver; para lo propio con <abbr title="B-tree File System">BtrFS</abbr>, podemos consultar <a class="reference external" href="https://fedoramagazine.org/btrfs-snapshots-backup-incremental/">este
artículo en Fedora Magazine</a> o <a class="reference external" href="https://linuxhint.com/use-btrfs-snapshots/">este
otro de linuxhint.com</a>.</p>
</aside>
</aside>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <div>
    <h3><a href="../../index.html">Tabla de contenido</a></h3>
    <ul>
<li><a class="reference internal" href="#">5.1.4. Volúmenes lógicos</a><ul>
<li><a class="reference internal" href="#creacion">5.1.4.1. Creación</a></li>
<li><a class="reference internal" href="#disponibilidad">5.1.4.2. Disponibilidad</a></li>
<li><a class="reference internal" href="#consulta">5.1.4.3. Consulta</a></li>
<li><a class="reference internal" href="#modificacion">5.1.4.4. Modificación</a></li>
<li><a class="reference internal" href="#aprovisionamiento-fino">5.1.4.5. Aprovisionamiento fino</a></li>
<li><a class="reference internal" href="#instantaneas">5.1.4.6. Instantáneas</a></li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>Tema anterior</h4>
    <p class="topless"><a href="03.pract.html"
                          title="capítulo anterior"><span class="section-number">5.1.3. </span>Aplicacion práctica</a></p>
  </div>
  <div>
    <h4>Próximo tema</h4>
    <p class="topless"><a href="../02.seguridad/index.html"
                          title="próximo capítulo"><span class="section-number">5.2. </span>Acceso a datos</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>Esta página</h3>
    <ul class="this-page-menu">
      <li><a href="../../_sources/05.discos/01.division/04.virt.rst.txt"
            rel="nofollow">Mostrar el código</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Búsqueda rápida</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Ir a" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navegación</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="Índice General"
             >índice</a></li>
        <li class="right" >
          <a href="../02.seguridad/index.html" title="5.2. Acceso a datos"
             >siguiente</a> |</li>
        <li class="right" >
          <a href="03.pract.html" title="5.1.3. Aplicacion práctica"
             >anterior</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">documentación de Linuxnomicón - rolling</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" ><span class="section-number">5. </span>Dispositivos de almacenamiento</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="index.html" ><span class="section-number">5.1. </span>División del disco</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href=""><span class="section-number">5.1.4. </span>Volúmenes lógicos</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Derechos de autor CC BY 4.0, 2016-2023, José Miguel Sánchez Alés.
      Creado usando <a href="https://www.sphinx-doc.org/">Sphinx</a> 5.3.0.
    </div>
  </body>
</html>