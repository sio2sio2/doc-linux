


<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" lang="es">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>5.1.3. Volúmenes lógicos &#8212; documentación de ServidorLinux - 0.1.0</title>
    <link rel="stylesheet" href="../../_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../_static/custom.css" />
    
    <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../_static/language_data.js"></script>
    <script type="text/javascript" src="../../_static/translations.js"></script>
    <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <link rel="index" title="Índice" href="../../genindex.html" />
    <link rel="search" title="Búsqueda" href="../../search.html" />
    <link rel="next" title="5.2. Seguridad de la información" href="../02.seguridad/index.html" />
    <link rel="prev" title="5.1.2. Particiones" href="02.part.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navegación</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="Índice General"
             accesskey="I">índice</a></li>
        <li class="right" >
          <a href="../02.seguridad/index.html" title="5.2. Seguridad de la información"
             accesskey="N">siguiente</a> |</li>
        <li class="right" >
          <a href="02.part.html" title="5.1.2. Particiones"
             accesskey="P">anterior</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">documentación de ServidorLinux - 0.1.0</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" >5. Dispositivos de almacenamiento</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="index.html" accesskey="U">5.1. División del disco</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="volumenes-logicos">
<span id="lvm"></span><h1>5.1.3. Volúmenes lógicos<a class="headerlink" href="#volumenes-logicos" title="Enlazar permanentemente con este título">¶</a></h1>
<p>A diferencia de otros como <a class="reference external" href="https://es.wikipedia.org/wiki/ZFS_(sistema_de_archivos)">zfs</a> o <a class="reference external" href="https://es.wikipedia.org/wiki/Btrfs">btrfs</a>, <em>ext4</em> no soporta nativamente la
gestión de volúmenes lógicos. Sin embargo, podemos manejar discos y particiones
virtuales, ayudándonos de un <em>software</em> adicional llamado <abbr title="Logical Volume Management">LVM</abbr>. Las
<strong>ventajas</strong> de su uso, ya se han establecido en epígrafes anteriores:</p>
<ul>
<li><p class="first">Permite agrandar indiscriminadamente el disco: basta con comprar un nuevo
disco físico e incluirlo como integrante del disco virtual.</p>
<img alt="../../_images/1+1disks.png" src="../../_images/1+1disks.png" />
</li>
<li><p class="first">Permite agrandar indiscriminadamente las particiones sin cuidarse de que el
espacio que constituye la partición deba ser contiguo. Cuando tratamos
particiones físicas, ampliar una partición es todo un engorro, sobre todo si
está encajonada entre otras dos particiones. Por ejemplo, ampliar en el
siguiente gráfico <code class="file docutils literal notranslate"><span class="pre">sda3</span></code>, implica también mover <code class="file docutils literal notranslate"><span class="pre">sda4</span></code>:</p>
<img alt="../../_images/ampl-part.png" src="../../_images/ampl-part.png" />
</li>
</ul>
<p>Logramos, por tanto, muchísima más versatilidad que usando particiones fisicas.
En contraprestación, hay una <strong>desventaja</strong> evidente: las particiones lógicas
sólo son visibles con el <em>software</em> de <abbr title="Logical Volume Management">LVM</abbr>.</p>
<p class="rubric">Definiciones</p>
<p>Antes de pasar a exponer cómo crear y manejar volúmenes lógicos, es pertinente
fijar el significado de algunos términos que se usarán en la exposición:</p>
<dl class="docutils">
<dt><strong>Volúmen físico</strong> (<abbr title="Physical Volume">PV</abbr>)</dt>
<dd>Son las particiones físicas o incluso discos físicos completos sobre las que
se definen los discos virtuales.</dd>
<dt><strong>Grupo de volúmenes</strong> (<abbr title="Volume Group">PV</abbr>)</dt>
<dd>Es el conjunto de volúmenes físicos que conforma un disco virtual.</dd>
<dt><strong>Volúmenes lógicos</strong> (<abbr title="Logical Volume">LV</abbr>)</dt>
<dd>Es el dispoitivo virtual de bloques que alberga un sistemas de ficheros, esto
es, lo que hemos venido definiendo como <em>partición virtual</em> a lo largo de
nuestra exposición.</dd>
</dl>
<p>En la tarea de constituir volúmenes lógicos:</p>
<ul class="simple">
<li>Deben definirse cuáles son los volúmenes físicos.</li>
<li>Deben definirse cómo se agrupan esos volúmenes físicos en grupos de volúmenes.
Lo habitual es que haya un grupo de volúmenes.</li>
<li>Debe particionarse cada grupo de volúmenes en volúmenes logicos.</li>
</ul>
<div class="admonition note">
<p class="first admonition-title">Nota</p>
<p class="last">Es importante tener presente que <abbr title="GRand Unified Bootloader">GRUB</abbr> soporta <abbr title="Logical Volume Management">LVM</abbr> y, por tanto, es
capaz de arrancar un <em>Linux</em> aunque los ficheros de su fase 3 y el kernel se
encuentren dentro de volúmenes lógicos.</p>
</div>
<p>Es muy probable que el <em>software</em> para gestionar volúmenes lógicos ya se
encuentre instalado, pero si no es así:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> apt install lvm2
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Nota</p>
<p class="last"><abbr title="Logical Volume Management">LVM</abbr> permite también la creación de <abbr title="Redundant Array of Inexpensive Disks">RAID</abbr>s, pero no es
propósito de este apartado, tratarlo. Bajo el epígrafe dedicado a <a class="reference internal" href="../05.raid/index.html#raid"><span class="std std-ref">RAUDs</span></a> hay <a class="reference internal" href="../05.raid/02.lvm.html#lvmraid"><span class="std std-ref">todo un apartado dedicado a la creación de RAIDs con LVM</span></a>.</p>
</div>
<span class="target" id="lvcreate"><span id="vgcreate"></span><span id="pvcreate"></span></span><div class="section" id="creacion">
<span id="index-0"></span><h2>5.1.3.1. Creación<a class="headerlink" href="#creacion" title="Enlazar permanentemente con este título">¶</a></h2>
<p>Dentro del grupo de volúmenes podemos incluir todas las particiones que deseemos
crear, excepto aquellas necesarias para el arranque del disco. Por tanto, un
particionado físico del disco apropiado para crear volúmenes lógicos puede ser
el siguiente:</p>
<img alt="../../_images/part-lvm.png" src="../../_images/part-lvm.png" />
<p>que usando <a class="reference internal" href="02.part.html#sgdisk"><span class="std std-ref">sgdisk</span></a> puede realizarse de esta forma:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> sgdisk -a <span class="m">8</span> -n <span class="s2">&quot;0:40:2047&quot;</span> -t <span class="s2">&quot;0:0xef02&quot;</span> -c <span class="s2">&quot;0:BOOTBIOS&quot;</span> <span class="se">\</span>
         -a <span class="m">2048</span> -n <span class="s2">&quot;0:2048:+100M&quot;</span> -t <span class="s2">&quot;0:0xef00&quot;</span> -c <span class="s2">&quot;0:EFI&quot;</span> <span class="se">\</span>
         -N <span class="m">0</span> -t <span class="s2">&quot;3:0x8e00&quot;</span> -c <span class="s2">&quot;3:LVM&quot;</span> /tmp/0.disk
</pre></div>
</div>
<p>de forma que creamos las dos particiones necesarias para el arranque aparte,
y una tercera partición destinanda a ser el volumen físico que constituya el
grupo de volúmenes. La partición destinada para este fin se nota con el código
<em>0x8E00</em>.</p>
<div class="admonition note">
<p class="first admonition-title">Nota</p>
<p class="last">Por supuesto, podemos crear volúmenes lógicos partiendo también de un
particionado <abbr title="Disk Operating System">DOS</abbr></p>
</div>
<p>Como estamos particionando un fichero, no podemos acceder
directamente a sus particiones como sí sería posible si particionáramos un disco
(p.e. de <code class="file docutils literal notranslate"><span class="pre">/dev/sda</span></code> aparecerían <code class="file docutils literal notranslate"><span class="pre">/dev/sda1</span></code>, file:<cite>/dev/sda2</cite>,
etc.). Para hacerlas accesibles es necesario asegurarse de que está cargado el
módulo <em>loop</em>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> modprobe loop
</pre></div>
</div>
<p>y usar <strong class="command">losetup</strong> para asociar/desasociar el fichero a un dispositivo de
bucle:</p>
<span class="target" id="losetup"></span><div class="highlight-console notranslate" id="index-1"><div class="highlight"><pre><span></span><span class="gp">#</span> losetup /dev/loop0 /tmp/0.disk
<span class="gp">#</span> losetup
<span class="go">NAME       SIZELIMIT OFFSET AUTOCLEAR RO BACK-FILE      DIO LOG-SEC</span>
<span class="go">/dev/loop0         0      0         0  0 /tmp/0.disk   0     512</span>
<span class="gp">#</span> losetup -d /dev/loop0
</pre></div>
</div>
<p>Con todo, asociar el fichero al dispositivo no provoca que aparezcan las
particiones, para ello es necesario usar <strong class="command">partx</strong></p>
<span class="target" id="partx"></span><div class="highlight-console notranslate" id="index-2"><div class="highlight"><pre><span></span><span class="gp">#</span> partx -a /dev/loop0
<span class="gp">#</span> ls -1 /dev/loop0*
<span class="go">/dev/loop0</span>
<span class="go">/dev/loop0p1</span>
<span class="go">/dev/loop0p2</span>
<span class="go">/dev/loop0p3</span>
<span class="gp">#</span> partx -d /dev/loop0
<span class="gp">#</span> ls -1 /dev/loop0*
<span class="go">/dev/loop0</span>
</pre></div>
</div>
<p>Hecho el particionado y expuestas las particiones, lo primero es declarar que la
tercera partición es un volumen físico<a class="footnote-reference" href="#id4" id="id1">[1]</a>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> pvcreate /dev/loop0p3
</pre></div>
</div>
<p>tras lo cual ya puede constituirse un grupo de volúmenes llamado «VGtest» con
este volumen físico:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> vgcreate VGtest /dev/loop0p3
<span class="gp">#</span> vgs VGtest
<span class="go">  VG       #PV #LV #SN Attr   VSize    VFree</span>
<span class="go">  VGtest   1   0   0 wz--n-  &lt;19,95g &lt;19,95g</span>
</pre></div>
</div>
<p>Esta última acción permite empezar a crear particiones lógicas con la orden
<strong class="command">lvcreate</strong>. Por ejemplo:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> lvcreate -L 2G VGtest -n primera
<span class="gp">#</span> lvcreate -L 5G VGtest -n segunda
<span class="gp">#</span> vgs VGtest
<span class="go">  VG       #PV #LV #SN Attr   VSize    VFree</span>
<span class="go">  VGtest   1   0   0 wz--n-  &lt;19,95g &lt;12,95g</span>
<span class="gp">#</span> lvs VGtest
<span class="go">  LV      VG    Attr       LSize Pool Origin Data%  Meta%  Move Log Cpy%Sync Convert</span>
<span class="go">  primera VGxxx -wi-a----- 2,00g</span>
<span class="go">  segunda VGxxx -wi-a----- 5,00g</span>
</pre></div>
</div>
<p>Estas acciones han particionado 7 de los 20GB del grupo de volúmenes y crean dos
dispostivos virtuales, <code class="file docutils literal notranslate"><span class="pre">/dev/VGtest/primera</span></code> y
<code class="file docutils literal notranslate"><span class="pre">/dev/VGtest/segunda</span></code> que podemos tratar como si de particiones fisicas
se tratasen. Por ejemplo, podemos dotarlas de un sistema de ficheros:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> mkfs.ext4 -L PRIMERA /dev/VGtest/primera
<span class="gp">#</span> mkfs.ext4 -L SEGUNDA /dev/VGtest/primera
</pre></div>
</div>
</div>
<div class="section" id="disponibilidad">
<h2>5.1.3.2. Disponibilidad<a class="headerlink" href="#disponibilidad" title="Enlazar permanentemente con este título">¶</a></h2>
<p>Habitualmente la aparición de los volúmenes lógicos es automática al hacer
disponibles los volúmenes que constituyen el grupo de volúmenes. Si no es así,
pueden habilitar con la orden:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> vgchange -ay VGtest
</pre></div>
</div>
<p>Lo que es más útil es deshabilitar los volúmenes lógicos:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> vgchange -an VGtest
</pre></div>
</div>
<p>ya que es indispensable hacerlo si queremos hacer desaparecer los volúmenes
físicos sobre los que se asientan. Por ejemplo, para el caso que nos ocupa, en
que hacemos pruebas con un fichero, la única forma de usar <a class="reference internal" href="#losetup"><span class="std std-ref">partx</span></a> y
<a class="reference internal" href="#losetup"><span class="std std-ref">losetup</span></a> para desasociar el fichero al dispositivo de bucle es
deshabilitar los volúmenes lógicos porque de lo contrario, fallará:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> partx -d /dev/loop
</pre></div>
</div>
<p>al encontrar la partición <code class="file docutils literal notranslate"><span class="pre">/dev/loop03</span></code> ocupada.</p>
<span class="target" id="lvs"><span id="vgs"></span><span id="pvs"></span></span></div>
<div class="section" id="consulta">
<span id="index-3"></span><h2>5.1.3.3. Consulta<a class="headerlink" href="#consulta" title="Enlazar permanentemente con este título">¶</a></h2>
<p>Hay tres tipos de entidades (volúmenes físicos, grupos de volúmenes y volúmenes
lógicos) y dos tipos de consultas sobre ellas: la resumida y la extensa, por lo
que podemos llegar a hacer seis consultas distintas. En los seis casos, puede
añadirse como argumento una entidad concreta (<abbr title="Physical Volume">PV</abbr>, <abbr title="Volume Group">PV</abbr> o <abbr title="Logical Volume">LV</abbr>) para recibir
información exclusivamente de ella o no añadir ninguna y recibir información de
todas.</p>
<p>Para volúmenes físicos, las órdenes son:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> pvs
<span class="go">  PV           VG       Fmt  Attr PSize   PFree</span>
<span class="go">  /dev/sdc2    vgdebian lvm2 a--  &lt;465,70g  79,39g</span>
<span class="go">  /dev/loop0p3 VGtest   lvm2 a--  &lt;19,95g &lt;12,95g</span>
<span class="gp">#</span> pvdisplay /dev/loop0p3
<span class="go">  --- Physical volume ---</span>
<span class="go">  PV Name               /dev/loop0p3</span>
<span class="go">  VG Name               VGtest</span>
<span class="go">  PV Size               19,95 GiB / not usable 4,98 MiB</span>
<span class="go">  Allocatable           yes</span>
<span class="go">  PE Size               4,00 MiB</span>
<span class="go">  Total PE              5106</span>
<span class="go">  Free PE               3314</span>
<span class="go">  Allocated PE          1792</span>
<span class="go">  PV UUID               36SmEX-lPxG-qFW2-iMGl-1c5T-CLlb-LqLY1</span>
</pre></div>
</div>
<p>Para grupos de volúmenes:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> vgs
<span class="go">  VG       #PV #LV #SN Attr   VSize    VFree</span>
<span class="go">  VGtest     1   2   0 wz--n-  &lt;19,95g &lt;12,95g</span>
<span class="go">  vgdebian   1   4   0 wz--n- &lt;465,70g  79,39g</span>

<span class="gp">#</span> vgdisplay VGtest
<span class="go">  --- Volume group ---</span>
<span class="go">  VG Name               VGtest</span>
<span class="go">  System ID</span>
<span class="go">  Format                lvm2</span>
<span class="go">  Metadata Areas        1</span>
<span class="go">  Metadata Sequence No  3</span>
<span class="go">  VG Access             read/write</span>
<span class="go">  VG Status             resizable</span>
<span class="go">  MAX LV                0</span>
<span class="go">  Cur LV                2</span>
<span class="go">  Open LV               0</span>
<span class="go">  Max PV                0</span>
<span class="go">  Cur PV                1</span>
<span class="go">  Act PV                1</span>
<span class="go">  VG Size               &lt;19,95 GiB</span>
<span class="go">  PE Size               4,00 MiB</span>
<span class="go">  Total PE              5106</span>
<span class="go">  Alloc PE / Size       1792 / 7,00 GiB</span>
<span class="go">  Free  PE / Size       3314 / &lt;12,95 GiB</span>
<span class="go">  VG UUID               P3dDgq-AeHA-7Vur-Jy48-fzlm-wnC1-jf0x85</span>
</pre></div>
</div>
<p>Y para volúmenes lógicos:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> lvs
<span class="go">  LV      VG       Attr       LSize   Pool Origin Data%  Meta%  Move Log Cpy%Sync Convert</span>
<span class="go">  primera VGtest   -wi-a-----   2,00g</span>
<span class="go">  segunda VGtest   -wi-a-----   5,00g</span>
<span class="go">  home    vgdebian -wi-a----- 370,00g</span>
<span class="go">  lxc     vgdebian -wi-a-----   2,00g</span>
<span class="go">  raiz    vgdebian -wi-a----- &lt;12,45g</span>
<span class="go">  swap    vgdebian -wc-a-----  &lt;1,86g</span>

<span class="gp">#</span> lvdisplay /dev/VGtest/primera
<span class="go">  --- Logical volume ---</span>
<span class="go">  LV Path                /dev/VGtest/primera</span>
<span class="go">  LV Name                primera</span>
<span class="go">  VG Name                VGtest</span>
<span class="go">  LV UUID                KBMwih-Mctp-rOcv-W3aK-iqTG-2vXo-KlpQxs</span>
<span class="go">  LV Write Access        read/write</span>
<span class="go">  LV Creation host, time choquereta, 2019-11-27 07:40:59 +0100</span>
<span class="go">  LV Status              available</span>
<span class="gp">  #</span> open                 <span class="m">0</span>
<span class="go">  LV Size                2,00 GiB</span>
<span class="go">  Current LE             512</span>
<span class="go">  Segments               1</span>
<span class="go">  Allocation             inherit</span>
<span class="go">  Read ahead sectors     auto</span>
<span class="go">  - currently set to     256</span>
<span class="go">  Block device           253:4</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">Ver también</p>
<p class="last">El significado de los atributos indicados por <strong class="command">lvs</strong> puede
consultarse <a class="reference external" href="https://github.com/UnderV/py3tools/wiki/LVM-Attributes-Explained">en esta página de Github</a>.</p>
</div>
<span class="target" id="vgreduce"><span id="lvreduce"></span><span id="lvextend"></span><span id="vgextend"></span></span></div>
<div class="section" id="modificacion">
<span id="index-4"></span><h2>5.1.3.4. Modificación<a class="headerlink" href="#modificacion" title="Enlazar permanentemente con este título">¶</a></h2>
<p>La ventaja fundamental de las volúmenes lógicos es que podemos ampliarlos a
voluntad sin que el espacio tenga que ser contiguo. Por ejemplo:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> lvextend -L 3G /dev/VGtest/primera
</pre></div>
</div>
<p>Aumenta hasta 3GiB el primer volumen lógico, aunque no el sistema de ficheros
contenido, por lo que el espacio ocupable seguirá siendo de 2GiB. Para ampliar
también el sistema de fichero es necesario, en este caso:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> resize2fs /dev/Vgtest/primera
</pre></div>
</div>
<p>No obstante, podemos incluir la opción <kbd class="kbd docutils literal notranslate">-r</kbd> y <strong class="command">lvextend</strong> se
encargará de comprobar cuál el sistema de ficheros y aplicar el comando
adecuando para que éste colonice el nuevo espacio disponible. En consecuencia
las dos órdenes anteriores son equivalente a:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> lvextend -r -L 3G /dev/VGtest/primera
</pre></div>
</div>
<p>También puede indicarse, en vez de el nuevo tamaño, el incremento. Esta orden:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> lvextend -r -L +1G /dev/VGtest/segunda
</pre></div>
</div>
<p>aumenta hasta los 6GiB el volumen lógico cuyo anterior tamaño era 5GiB. Es
posible también usar porcentajes en vez de tamaños o incrementos absolutos a
través de la opción <kbd class="kbd docutils literal notranslate">-l</kbd><a class="footnote-reference" href="#id5" id="id2">[2]</a>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> lvcreate -l <span class="m">100</span>%FREE VGtest -n tercera
</pre></div>
</div>
<p>De esta manera, la nueva partición ocupará todo el espacio libre que uqede en el
grupo de volúmenes. El disco físico se ha acabado, pero si «compráramos» otro,
podríamos añadirlo como volumen lógico a <em>VGtest</em> y volveríamos a disponer de
espacio libre:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> truncate -s 10G /tmp/1.disk
<span class="gp">#</span> losetup /dev/loop1 /tmp/1.disk
<span class="gp">#</span> pvcreate /dev/loop1
<span class="gp">#</span> vgextend VGtest /dev/loop1
<span class="gp">#</span> vgs VGtest
<span class="go">  VG     #PV #LV #SN Attr   VSize  VFree</span>
<span class="go">  VGtest   2   2   0 wz--n- 29,94g  9,94g</span>
</pre></div>
</div>
<p>Ahora el grupo de volúmenes tiene 30GiB, ya que hemos añadido 10GiB más.</p>
<p>Todas estas operaciones son de incremento y no requieren siquiera que
desmontemos los sistemas de ficheros para ser llevadas a cabo. En cambio, las
operaciones de reducción son más traumáticas ya que, por lo general, requieren
dejar hueco y en el caso de reducir particiones lógicas, desmontar previamente
el sistema de ficheros que contiene. Por lo demás, el procedimiento es
semejante:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> lvresize -r -L -2G /dev/VGtest/segunda
<span class="gp">#</span> lvs /dev/VGtest/segunda
<span class="go">  LV      VG     Attr       LSize Pool Origin Data%  Meta%  Move Log Cpy%Sync Convert</span>
<span class="go">  segunda VGtest -wi-a----- 4,00g</span>
<span class="gp">#</span> lvreduce -r -l -25%LV /dev/VGtest/segunda
<span class="gp">#</span> lvs /dev/VGtest/segunda
<span class="go">  LV      VG     Attr       LSize Pool Origin Data%  Meta%  Move Log Cpy%Sync Convert</span>
<span class="go">  segunda VGtest -wi-a----- 3,00g</span>
</pre></div>
</div>
</div>
<div class="section" id="instantaneas">
<span id="lvm-snapshots"></span><h2>5.1.3.5. Instántaneas<a class="headerlink" href="#instantaneas" title="Enlazar permanentemente con este título">¶</a></h2>
<p>Una <em class="dfn">instantánea</em> consiste en el almacenamiento del estado del sistema de
archivos en el momento de llevarla a cabo. Para ello, no se hace una copia del
sistema (lo cual es costoso en tiempo y equivaldría a una copia de seguridad),
sino que al modificarse por primera vez tras la creación de la instantánea el
contenido de un fichero, se guarda en la instantánea una copia de éste sin la
modificación. De esta forma, el estado de la instantánea es la suma de los
archivos que no han llegado a ser modificados, guardados en el volumen original,
más la copia de los archivos sí modificados, guardados en la instantánea.</p>
<p>Las instantáneas reparan las pérdidas por modificación o borrado no deseados,
papel que también puede cumplir una copia de seguridad, pero a diferencia de
éstas, no sirven como medida contra los fallos de disco o la corrupción de
datos, ya que requieren el sistema original y pueden estar almacenadas sobre el
mismo dispositivo físico.</p>
<p>Hay dos mecanismos para la creación de instantáneas:</p>
<ul class="simple">
<li>Mediante el uso de sistemas de ficheros que las soporten nativamente como
<abbr title="Zettabyte File System">ZFS</abbr> o <abbr title="B-tree File System">BtrFS</abbr>.</li>
<li>Mediante <em>software</em> adicional que se encargue de hacer las instantáneas como
el <em>software</em> que nos ocupa en <em>Linux</em> o la restauración del sistema en los
sistemas <em>Windows</em>.</li>
</ul>
<p>Para llevar a cabo instantáneas con <abbr title="Logical Volume Management">LVM</abbr> el procedimiento es simple: basta con
crear un volúmen lógico que se declare que sirve para almacenar la instantánea
de otro volumen lógico. Por ejemplo, vamos a dar formato a uno de los volúmenes
lógicos y a escribir dentro de él:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> mkfs.ext4 -L PRIMERA /dev/VGtest/primera
<span class="gp">#</span> mkdir /tmp/<span class="o">{</span>original,snap<span class="o">}</span>
<span class="gp">#</span> mount /dev/VGtest/primera /tmp/original
<span class="gp">#</span> <span class="nb">echo</span> <span class="s2">&quot;Hola&quot;</span> &gt; /tmp/original/saluto.txt
</pre></div>
</div>
<p>Hecho lo cual, podemos crear una instatánea del estado actual de «primera»:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> lvcreate -s -n primera_snap -L 50M /dev/VGtest/primera
</pre></div>
</div>
<p>donde es importante tener presente que el tamaño como máximo puede ser el tamaño
del volumen original<a class="footnote-reference" href="#id6" id="id3">[3]</a> (<kbd class="kbd docutils literal notranslate">-l 100%ORIGIN</kbd>). También se puede añadir un
parámetro adicional para indicar sobre qué volumen físico de los que integran el
grupo de volúmenes se quiere definir la instantánea. Hecho esto, podemos
practicar dos estrategias:</p>
<ol class="loweralpha simple">
<li>La obvia que es continuar trabajando sobre el volumen original y, si en algún
momento decidimos revertir los cambios, recuperar la instantánea. Un ejemplo
en que es una buena opción esta estrategia es ante una actualización. Si
sospechamos que algo puede ir mal, podemos hacer antes una instantánea y
dependiendo del resultado, revertir al estado anterior a la instalación o
desechar la instantánea.</li>
<li>Trabajar sobre la instantánea sin alterar el volumen original, ya que si
<em>recuperamos</em> la instantánea lo que haremos será aplicar los cambios de la
instánea sobre el volumen original. Esta opción es adecuada en los casos en
que queremos que el sistema siga funcionando en producción del mismo modo,
mientras nosotros introducimos cambios (p.e. en algunos <em>scripts</em>). De nuevo,
podrá darse el caso de que decidamos aplicar los cambios (recuperando la
instantánea) o desecharlos (borrándola).</li>
</ol>
<p class="rubric">Trabajando sobre el propio volumen</p>
<p>Para nuestro ejemplo, podemos hacer algunos cambios simples:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> <span class="nb">echo</span> <span class="s2">&quot;Adios&quot;</span> &gt;&gt; /tmp/original/saludo.txt
<span class="gp">#</span> cp /etc/resolv.conf /tmp/original
</pre></div>
</div>
<p>Con estas acciones la instantánea debería ir paulatimente incrementando su
ocupación (ya que necesita almacenar las copias de los ficheros) y es
conveniente vigilar este dato, ya que malograremos la instantánea, si
superamos la capacidad máxima:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> lvs -o data_percent /dev/VGtest/primera_snap
<span class="go">Data%</span>
<span class="go">0.09</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Nota</p>
<p class="last">Si comprobamos que la ocupación se aproxima al 100%, podemos usar
<a class="reference internal" href="#lvextend"><span class="std std-ref">lvextend</span></a> como se hace en los volúmenes lógicos normales.</p>
</div>
<p>Dependiendo de si los cambios sobre el volumen son aceptables o no, tocará
desechar la instantánea:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> lvremote /dev/VGtest/primera_snap
</pre></div>
</div>
<p>o revertir los cambios sobre el volumen:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> umount /tmp/original
<span class="gp">#</span> lvconvert --merge /dev/VGtest/primera_snap
</pre></div>
</div>
<p>cuyo efecto será que el volumen vuelta al estado de la instantánea y que el
volumen con la instantánea desaparezca automáticamente.</p>
<div class="admonition warning">
<p class="first admonition-title">Advertencia</p>
<p class="last">Es importante que tanto el volumen original como el de la
instantánea se encuentren desmontados en el momento de hacer la fusión.</p>
</div>
<p class="rubric">Trabajando sobre la instantánea</p>
<p>Alternativamente, podemos trabajar sobre la instantánea y dejar sin alterar el
volumen original. Para ello, basta con montar la instantánea:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> mount /dev/VGtest/primera_snap /tmp/snap
</pre></div>
</div>
<p>y realizar los cambios sobre ella:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> <span class="nb">echo</span> <span class="s2">&quot;Adios&quot;</span> &gt;&gt; /tmp/snap/saludo.txt
<span class="gp">#</span> cp /etc/resolv.conf /tmp/snap
</pre></div>
</div>
<p>En este caso, la operaciones para desechar o revertir los cambios son justamente
las opuestas. Si deseamos aplicar los cambios sobre el volumen, necesitamos
fusionar con la instantánea:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> umount /tmp/<span class="o">{</span>original,snap<span class="o">}</span>
<span class="gp">#</span> lvconvert --merge /dev/VGtest/primera_snap
</pre></div>
</div>
<p>y, si deseamos desecharlos, eliminar el volumen de la instantánea:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> umount /tmp/snap
<span class="gp">#</span> lvremote /dev/VGtest/primera_snap
</pre></div>
</div>
</div>
<div class="section" id="aprovisionamiento-fino">
<span id="lvm-aprovisionamiento"></span><h2>5.1.3.6. Aprovisionamiento fino<a class="headerlink" href="#aprovisionamiento-fino" title="Enlazar permanentemente con este título">¶</a></h2>
<p>El <em class="dfn">aprovisionamiento fino</em> (<em>thin provisioning</em>, en inglés) consiste en
reservar para un volumen lógico más espacio de disco del que realmente tiene
disponible. Es un concepto muy comúnmente usando en virtualización para cuyas
máquinas virtuales podemos usar discos de un tamaño mucho mayor del que
realmente ocupa su fichero correspondiente. Algo parecido se logra con la orden
<a class="reference internal" href="02.part.html#truncate"><span class="std std-ref">truncate</span></a>. Se contrapone al <em class="dfn">aprovisionamiento grueso</em>, que
consiste en justo lo contrario, esto es, en reservar exactamente el tamaño del
volumen. Hasta ahora, hemos practicado con <abbr title="Logical Volume Management">LVM</abbr> este último tipo de
aprovisionamiento.</p>
<p>Sin embargo, <abbr title="Logical Volume Management">LVM</abbr> soporta <em>aprovisionamiento fino</em> que, en principio, puede
servir para dos propósitos distintos:</p>
<ul class="simple">
<li>Ajustar el tamaño máximo de varios volúmenes lógicos a parte (o todo)
del tamaño del grupo de volúmenes. Si no tenemos claro, cuáles van a ser las
necesidades de crecimiento de estos volúmenes, esto puede ahorrarnos la
necesidad de hacerlos excesivamente pequeños y, según sea la evolución
posterior, tener después que aumentarles progresivamente el tamaño.</li>
<li>Si instalamos sobre un disco pequeño con intención de que el sistema acabe
corriendo sobre un disco mayor, crear los volúmenes lógicos con el tamaño
que tendrán en el disco final. Usaremos esto al plantear la <a class="reference internal" href="../10.instalacion/index.html#inst-servidor"><span class="std std-ref">instalación
del servidor</span></a>.</li>
</ul>
<p>Lo primero, antes de empezar, es asegurarse de que está instalado el paquete
<strong>thin-provisioning-tools</strong>, hecho lo cual, podemos hacer pruebas con un nuevo
disco:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> truncate -s 500M <span class="m">0</span>.disk
<span class="gp">#</span> losetup /dev/loop0 <span class="m">0</span>.disk
<span class="gp">#</span> vgcreate VGtest /dev/loop0
</pre></div>
</div>
<p>Para probar el concepto crearemos dos volúmenes lógicos: el primero normal y el
segundo un «<em>pool</em>», esto es, un volumen en el que encerraremos los volúmenes
para los que deseamos <em>aprovisionamiento fino</em>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> lvcreate -L 100m -n fuera VGtest
<span class="gp">#</span> lvcreate --thinpool pool -l <span class="m">100</span>%FREE VGtest
<span class="gp">#</span> lvs VGtest
<span class="go">  LV    VG     Attr       LSize   Pool Origin Data%  Meta%  Move Log Cpy%Sync Convert</span>
<span class="go">  fuera VGtest -wi-a----- 100,00m</span>
<span class="go">  pool  VGtest twi-a-tz-- 388,00m             0,00   10,84</span>
</pre></div>
</div>
<p>El primero es un volumen de 100MiB y, además, no podrá cambiar su tamaño a menos
que agrandemos el grupo de volúmenes con, por ejemplo, otro disco. El segundo es
el <em>pool</em> dentro del que podemos crear volúmenes lógicos con aparentemente
cualquier tamaño:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> lvcreate -T -n tvol1 -V 1G VGtest/pool
<span class="gp">#</span> lvcreate -T -n tvol2 -V 2G VGtest/pool
<span class="gp">#</span> lvs VGtest
<span class="go">  LV    VG     Attr       LSize   Pool Origin Data%  Meta%  Move Log Cpy%Sync Convert</span>
<span class="go">  fuera VGtest -wi-a----- 100,00m</span>
<span class="go">  pool  VGtest twi-aotz-- 388,00m             0,00   11,04</span>
<span class="go">  tvol1 VGtest Vwi-a-tz--   1,00g pool        0,00</span>
<span class="go">  tvol2 VGtest Vwi-a-tz--   2,00g pool        0,00</span>
</pre></div>
</div>
<p>Al crear ambos volúmenes, se nos refiere la opción
<kbd class="kbd docutils literal notranslate">activation/thin_pool_autoextend_threshold</kbd>, porque su valor es 100:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> lvm dumpconfig activation/thin_pool_autoextend_threshold
<span class="go">thin_pool_autoextend_threshold=100</span>
</pre></div>
</div>
<p>La variable fija el tanto por cierto de ocupación del <em>pool</em> para el que una vez
alcanzado se incrementa el tamaño en un porcentaje fijado por:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> lvm dumpconfig activation/thin_pool_autoextend_percent
<span class="go">thin_pool_autoextend_percent=20</span>
</pre></div>
</div>
<p>pero justamente un valor de 100% deshabilita la posibilidad. Si ponemos un valor
más bajo (p.e el 85%), sí se llevará a cabo la ampliación automática… si se
puede, que no es nuestro caso, ya que el grupo de volúmenes está completamente
lleno.</p>
<p>Si probamos a dar formato a uno de los volúmenes del <em>pool</em>, comprobaremos el
sistema de ficheros participa de la ficción del tamaño:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> mkfs.ext4 -L TVOL2 /dev/VGtest/tvol2
<span class="gp">#</span> mount /dev/VGtest/tvol2 /mnt/
<span class="gp">#</span> df -h /mnt/
<span class="go">S.ficheros               Tamaño Usados  Disp Uso% Montado en</span>
<span class="go">/dev/mapper/VGtest-tvol2   2,0G   6,0M  1,8G   1% /mnt</span>
</pre></div>
</div>
<p>Sin embargo, el espacio real es el que ocupa el <em>pool</em>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> lvs VGtest/pool
<span class="go">  LV   VG     Attr       LSize   Pool Origin Data%  Meta%  Move Log Cpy%Sync Convert</span>
<span class="go">  pool VGtest twi-aotz-- 388,00m             25,14  12,21</span>
</pre></div>
</div>
<p>El aprovisionamiento fino es especialmente propicio para <a class="reference internal" href="#lvm-snapshots"><span class="std std-ref">las instantáneas</span></a>, ya que permite que la instantánea comparta el <em>pool</em> del
volumen original. Además, no es necesario indicar tamaño, ya que por defecto se
crerará un volumen con el tamaño del volumen original:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> lvcreate -s -n tvol1_s VGtest/tvol1
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Nota</p>
<p class="last">No soportan aprovisionamiento fino ni el <a class="reference external" href="https://wiki.debian.org/DebianInstaller">instalador de debian</a>, ni <abbr title="GRand Unified Bootloader">GRUB</abbr>, lo cual dificulta
enormemente meter el sistema de ficheros raíz en un volumen de este tipo.
Lo primero impide crear o aprovechar volúmenes de aprovisionamiento fino
durante el proceso de instalación; y
lo segundo obliga a no incluir dentro de ellos el núcleo y el sistema
de ficheros inicial (<em>initrd</em>), lo cual se traduce en montar  <code class="file docutils literal notranslate"><span class="pre">/boot</span></code>
aparte o en copiar <a class="reference internal" href="02.part.html#efi-arranque-directo"><span class="std std-ref">ambos ficheros en la partición ESP</span></a>.</p>
</div>
<p class="rubric">Notas al pie</p>
<table class="docutils footnote" frame="void" id="id4" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td>En las versiones más recientes, esto no es ya necesario y al incluir un
disco  o partición en un grupo de volúmenes, se define ya como volumen físico
automáticamente.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id5" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[2]</a></td><td>Los porcentajes puede referise al espacio libre (<kbd class="kbd docutils literal notranslate">FREE</kbd>) en el grupo
de volúmenes, al espacio del volúmen lógico (<kbd class="kbd docutils literal notranslate">LV</kbd>), al espacio del grupo
de volúmenes (<kbd class="kbd docutils literal notranslate">VG</kbd>) y, para instantáneas, <kbd class="kbd docutils literal notranslate">ORIGIN</kbd> que refiere al tamaño
del volumen original.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id6" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3">[3]</a></td><td>De hecho, si se hace la instantánea del tamaño del volumen original jamás
tendremos el problema de que la instantánea sea incapaz de albergar las
copias de los ficheros originales y se malogre.</td></tr>
</tbody>
</table>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../../index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">5.1.3. Volúmenes lógicos</a><ul>
<li><a class="reference internal" href="#creacion">5.1.3.1. Creación</a></li>
<li><a class="reference internal" href="#disponibilidad">5.1.3.2. Disponibilidad</a></li>
<li><a class="reference internal" href="#consulta">5.1.3.3. Consulta</a></li>
<li><a class="reference internal" href="#modificacion">5.1.3.4. Modificación</a></li>
<li><a class="reference internal" href="#instantaneas">5.1.3.5. Instántaneas</a></li>
<li><a class="reference internal" href="#aprovisionamiento-fino">5.1.3.6. Aprovisionamiento fino</a></li>
</ul>
</li>
</ul>

  <h4>Tema anterior</h4>
  <p class="topless"><a href="02.part.html"
                        title="capítulo anterior">5.1.2. Particiones</a></p>
  <h4>Próximo tema</h4>
  <p class="topless"><a href="../02.seguridad/index.html"
                        title="próximo capítulo">5.2. Seguridad de la información</a></p>
  <div role="note" aria-label="source link">
    <h3>Esta página</h3>
    <ul class="this-page-menu">
      <li><a href="../../_sources/05.discos/01.division/03.virt.rst.txt"
            rel="nofollow">Mostrar el código</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Búsqueda rápida</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Ir a" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navegación</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="Índice General"
             >índice</a></li>
        <li class="right" >
          <a href="../02.seguridad/index.html" title="5.2. Seguridad de la información"
             >siguiente</a> |</li>
        <li class="right" >
          <a href="02.part.html" title="5.1.2. Particiones"
             >anterior</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">documentación de ServidorLinux - 0.1.0</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" >5. Dispositivos de almacenamiento</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="index.html" >5.1. División del disco</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Derechos de autor 2016, José Miguel Sánchez Alés.
      Creado con <a href="http://sphinx-doc.org/">Sphinx</a> 1.8.5.
    </div>
  </body>
</html>