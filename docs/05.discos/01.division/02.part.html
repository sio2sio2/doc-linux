


<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" lang="es">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>5.1.2. Particiones &#8212; documentación de Linuxnomicón - rolling</title>
    <link rel="stylesheet" href="../../_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../_static/custom.css" />
    
    <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../_static/language_data.js"></script>
    <script type="text/javascript" src="../../_static/translations.js"></script>
    <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <link rel="index" title="Índice" href="../../genindex.html" />
    <link rel="search" title="Búsqueda" href="../../search.html" />
    <link rel="next" title="5.1.3. Volúmenes lógicos" href="03.virt.html" />
    <link rel="prev" title="5.1.1.4.2. GRand Unified Bootloader" href="01.boot/06.grub.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navegación</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="Índice General"
             accesskey="I">índice</a></li>
        <li class="right" >
          <a href="03.virt.html" title="5.1.3. Volúmenes lógicos"
             accesskey="N">siguiente</a> |</li>
        <li class="right" >
          <a href="01.boot/06.grub.html" title="5.1.1.4.2. GRand Unified Bootloader"
             accesskey="P">anterior</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">documentación de Linuxnomicón - rolling</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" >5. Dispositivos de almacenamiento</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="index.html" accesskey="U">5.1. División del disco</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="particiones">
<span id="particionado"></span><h1>5.1.2. Particiones<a class="headerlink" href="#particiones" title="Enlazar permanentemente con este título">¶</a></h1>
<p>Hay dos sistemas principales de particionado:</p>
<ul class="simple">
<li>El particionado <abbr title="Disk Operating System">DOS</abbr> basado en el <abbr title="Master Boot Record">MBR</abbr>.</li>
<li>El particionado <abbr title="GUID Partition Table">GPT</abbr> introducido por la especificación <abbr title="Unified Extensible Firmware Interface">UEFI</abbr>.</li>
</ul>
<p>Un firmware <abbr title="Unified Extensible Firmware Interface">UEFI</abbr> exige este segundo particionado, mientras que con <abbr title="Basic I/O System">BIOS</abbr> es
posible usar ambos.</p>
<table border="1" class="herr-part docutils" id="id31">
<caption><span class="caption-text">Herramientas de particionado</span><a class="headerlink" href="#id31" title="Enlace permanente a esta tabla">¶</a></caption>
<colgroup>
<col width="14%" />
<col width="18%" />
<col width="11%" />
<col width="11%" />
<col width="46%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head" rowspan="2">Suite</th>
<th class="head" rowspan="2">Ejecutable</th>
<th class="head" colspan="2">Soporte</th>
<th class="head" rowspan="2">Interfaz</th>
</tr>
<tr class="row-even"><th class="head"><abbr title="Disk Operating System">DOS</abbr></th>
<th class="head"><abbr title="GUID Partition Table">GPT</abbr></th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-odd"><td rowspan="3">fdisk</td>
<td>fdisk</td>
<td>Sí</td>
<td>Sí</td>
<td>Interactiva con menús.</td>
</tr>
<tr class="row-even"><td>sfdisk</td>
<td>Sí</td>
<td>Sí</td>
<td>Desasistida.</td>
</tr>
<tr class="row-odd"><td>cfdisk</td>
<td>Sí</td>
<td>Sí</td>
<td>Interactiva con ncurses.</td>
</tr>
<tr class="row-even"><td rowspan="3"><a class="reference internal" href="#gdisk-i"><span class="std std-ref">gdisk</span></a></td>
<td>gdisk</td>
<td>Sí</td>
<td>Sí</td>
<td>Interactiva con menús.</td>
</tr>
<tr class="row-odd"><td>sgdisk</td>
<td>Sí</td>
<td>Sí</td>
<td>Desasistida.</td>
</tr>
<tr class="row-even"><td>cgdisk</td>
<td>Sí</td>
<td>Sí</td>
<td>Interactiva con ncurses.</td>
</tr>
<tr class="row-odd"><td rowspan="2"><a class="reference external" href="https://www.gnu.org/software/parted/manual/parted.html">parted</a></td>
<td>parted</td>
<td>Sí</td>
<td>Sí</td>
<td>Interactiva, desasistida.</td>
</tr>
<tr class="row-even"><td>gparted</td>
<td>Sí</td>
<td>Sí</td>
<td>Gráfica.</td>
</tr>
</tbody>
</table>
<p>El epígrafe desarrolla una descripción de:</p>
<ul class="simple">
<li>El particionado <abbr title="Disk Operating System">DOS</abbr>.</li>
<li>El particionado <abbr title="GUID Partition Table">GPT</abbr>, si el arranque es <abbr title="Basic I/O System">BIOS</abbr>.</li>
<li>El particionado <abbr title="GUID Partition Table">GPT</abbr>, si el arranque es <abbr title="Unified Extensible Firmware Interface">UEFI</abbr>.</li>
</ul>
<div class="section" id="dos">
<span id="part-dos"></span><h2>5.1.2.1. <abbr title="Disk Operating System">DOS</abbr><a class="headerlink" href="#dos" title="Enlazar permanentemente con este título">¶</a></h2>
<p>Antes de pasar propiamente a describir el particionado <abbr title="Disk Operating System">DOS</abbr> es conveniente
entender cómo actúa el <abbr title="Basic I/O System">BIOS</abbr> al comenzar el proceso de carga del disco duro.</p>
<div class="section" id="el-bios-y-el-mbr">
<h3>5.1.2.1.1. El <abbr title="Basic I/O System">BIOS</abbr> y el <abbr title="Master Boot Record">MBR</abbr><a class="headerlink" href="#el-bios-y-el-mbr" title="Enlazar permanentemente con este título">¶</a></h3>
<p>El <abbr title="Basic I/O System">BIOS</abbr> se limita en cargar el código que encuentre en el <abbr title="Master Boot Record">MBR</abbr>, por lo que
en el caso de este arranque el punto de carga es único para cada disco. En
principio, por tanto, sólo es posible arrancar un único sistema operativo del
disco.</p>
<p>Para salvar esta limitación es indispensable utilizar un <em class="dfn">cargador de
arranque</em> como <abbr title="LInux LOader">LILO</abbr>, <abbr title="NT Loader">NTLDR</abbr>. <abbr title="GRand Unified Bootloader">GRUB</abbr> o <strong class="program">Windows Boot Manager</strong>, que es
el programa cargado a través del <em>firware</em> de la placa base, que se encarga de
dar acceso al arranque de los distintos sistemas operativos instalados.
Adicionalmente puede servir para cargar un mismo sistema operativo con
distintos parámetros de arranque (p.e. un modo normal y un modo de pruebas) o
aplicaciones para labores muy específicas que no requieren sistema operativo
como <a class="reference external" href="https://www.memtest.org/">memtest86+</a> o <a class="reference external" href="https://wiki.syslinux.org/wiki/index.php?title=Hdt_(Hardware_Detection_Tool)">HDT (Hardware Detection Tool)</a>.</p>
<p>Como lo habitual es que el sistema disponga de varios dispositivos de
almacenamiento (sean de estado sólido, magnéticos u ópticos), además de poderse
definir la secuencia con la que se comprueba si el <abbr title="Master Boot Record">MBR</abbr> de cada disco contiene
un código de arranque, también es posible escoger durante cada arranque cuál es
el dispositivo que se quiere arrancar en esa ocasión<a class="footnote-reference" href="#id17" id="id1">[1]</a>.</p>
<p>El <abbr title="Master Boot Record">MBR</abbr> es el primer sector del disco y contiene lo siguiente:</p>
<img alt="../../_images/mbr.png" src="../../_images/mbr.png" />
<ul class="simple">
<li>Los primeros 446 <em>bytes</em> contiene el código de arranque que carga el <abbr title="Basic I/O System">BIOS</abbr>.</li>
<li>Los 64 <em>bytes</em> siguientes sirven para definir la tabla de particiones del disco.</li>
<li>los dos últimos <em>bytes</em> son una marca de arranque que contiene siempre
<code class="docutils literal notranslate"><span class="pre">55AA</span></code>.</li>
</ul>
</div>
<div class="section" id="descripcion">
<h3>5.1.2.1.2. Descripción<a class="headerlink" href="#descripcion" title="Enlazar permanentemente con este título">¶</a></h3>
<p>En el particionado <abbr title="Disk Operating System">DOS</abbr>, la tabla de particiones se define en los 64 <em>bytes</em>
del <abbr title="Master Boot Record">MBR</abbr>.</p>
<p>La <em class="dfn">tabla de particiones</em> define cuáles son las particiones del disco y
requiere 16 <em>bytes</em> para cada uno, lo cual implica que, en principio, sólo sea
posible definir cuatro particiones. La información para cada partición es la
siguiente:</p>
<table border="1" class="info-part-dos docutils">
<colgroup>
<col width="19%" />
<col width="81%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Tamaño (bytes)</th>
<th class="head">Descripción</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>1</td>
<td>Marca de activa (<em>0x80</em> es el valor para indicar que es activa).</td>
</tr>
<tr class="row-odd"><td>3</td>
<td>Cilindro, Cabezal, Sector de comienzo.</td>
</tr>
<tr class="row-even"><td>1</td>
<td>Tipo de partición (informa de su contenido).</td>
</tr>
<tr class="row-odd"><td>3</td>
<td>Cilindro, Cabezal, Sector de final.</td>
</tr>
<tr class="row-even"><td>4</td>
<td>Direccionamiento de bloque lógico<a class="footnote-reference" href="#id18" id="id2">[2]</a> de su sector de arranque.</td>
</tr>
<tr class="row-odd"><td>4</td>
<td>Longitud de la partición en sectores.</td>
</tr>
</tbody>
</table>
<p>A estos datos se pueden hacer algunas aclaraciones y apostillas:</p>
<ul class="simple">
<li>Sólo puede haber una partición marcada como <em>activa</em>. El resto deberán tener
todas ese <em>byte</em> a <em>0</em>.</li>
<li>Se pueden identificar <a class="reference external" href="https://en.wikipedia.org/wiki/Partition_type#List_of_partition_IDs">256 tipos de sistemas de ficheros</a> distintos.</li>
</ul>
<ul id="tam-max-part-dos">
<li><p class="first">Como para el direccionamiento se usan 4 <em>bytes</em> (32 <em>bits</em>) y cada sector es
de 512 <em>bytes</em>, esto determina cuál es el <strong>tamaño máximo</strong> del disco si se usa
este particionado:</p>
<div class="math notranslate nohighlight">
\[2^{32}*512 \mathit{B} = 2*2^{40} \mathit{B} =2 \mathit{TB}\]</div>
</li>
<li><p class="first">El tamaño máximo de una partición, por la misma razón, coincide con el tamaño
máximo de disco.</p>
</li>
</ul>
<div class="admonition note">
<p class="first admonition-title">Nota</p>
<p class="last">A la partición cuya información se recoge en la tabla de
particiones se la denomina <em class="dfn">partición primaria</em>.</p>
</div>
</div>
<div class="section" id="arranque">
<h3>5.1.2.1.3. Arranque<a class="headerlink" href="#arranque" title="Enlazar permanentemente con este título">¶</a></h3>
<p>El <abbr title="Basic I/O System">BIOS</abbr> de la placa base ejecuta el código del <abbr title="Master Boot Record">MBR</abbr> que, en principio,
debería, simplemente, remitir al sector de arranque (<abbr title="Volume Boot Record">VBR</abbr>) de la partición
marcada como activa. Ahí ya se encontrará el código específico para lograr
arrancar el sistema operativo.</p>
<p>En cambio, algunos gestores de arranque, como <abbr title="LInux LOader">LILO</abbr> o <abbr title="GRand Unified Bootloader">GRUB</abbr>, incluyen en el
<abbr title="Master Boot Record">MBR</abbr> el código necesario para continuar cargando más código, ya que los 446
<em>bytes</em> son escasos, y no atienden a cuál sea la partición marcada como activa.</p>
<p><abbr title="GRand Unified Bootloader">GRUB</abbr>, en particular, divide su ejecución en tres fases:</p>
<ul class="simple">
<li>La primera que comprende la ejecución del código incluido en el <abbr title="Master Boot Record">MBR</abbr>.</li>
<li>La segunda que comprende la ejecución del código almacenado en el espacio
libre que queda entre el <abbr title="Master Boot Record">MBR</abbr> y el comienzo de la primera partición.</li>
<li>La tercera que comprende la ejecución del resto del código que se encuentra
dentro del directorio <code class="file docutils literal notranslate"><span class="pre">/boot/grub</span></code> del <em>Linux</em> que haya instalado <abbr title="GRand Unified Bootloader">GRUB</abbr>
en disco.</li>
</ul>
</div>
<div class="section" id="tipos-de-particiones">
<h3>5.1.2.1.4. Tipos de particiones<a class="headerlink" href="#tipos-de-particiones" title="Enlazar permanentemente con este título">¶</a></h3>
<div class="section" id="particiones-primarias">
<h4>5.1.2.1.4.1. Particiones primarias<a class="headerlink" href="#particiones-primarias" title="Enlazar permanentemente con este título">¶</a></h4>
<p>Si consideramos todo lo expuesto hasta ahora y que, por ejemplo, se hayan
definido tres particiones en la tabla de particiones del <abbr title="Master Boot Record">MBR</abbr>, esquemáticamente
podríamos representar el estado de las particiones así:</p>
<img alt="../../_images/particiones-pri-dos.png" src="../../_images/particiones-pri-dos.png" />
<p>En principio, aún podría definirse una cuarta partición que debería ocupar todo el
espacio libre, porque de no hacerlo, el que quedara fuera no sería aprovechable
al no poderse definir más particiones.</p>
<div class="admonition note">
<p class="first admonition-title">Nota</p>
<p class="last">Para nombrar las particiones se ha usado la nomenclatura de <em>Linux</em>
<code class="file docutils literal notranslate"><span class="pre">sda</span></code> por fingir que nos encontramos ante el primer disco y un número
correlativo para cada partición.</p>
</div>
<div class="admonition warning">
<p class="first admonition-title">Advertencia</p>
<p class="last">En sistemas antiguos, la primera partición empezaba al comienzo del
segundo cabezal<a class="footnote-reference" href="#id19" id="id3">[3]</a>, o sea, en el sector <strong>63</strong>, por lo que el espacio
entre ésta y el <abbr title="Master Boot Record">MBR</abbr> era de 62 sectores. Ese espacio es insuficiente para
almacenar el código de la segunda fase de <abbr title="GRand Unified Bootloader">GRUB</abbr>. Las herramientas modernas
suelen hacer que el tamaño de las particiones sea múltiplo de 2048 sectores,
esto es, 1MiB, por lo que la primera partición empieza en el sector <strong>2048</strong>.
<a class="reference external" href="http://jdebp.eu./FGA/disc-partition-alignment.html">Este artículo</a> de
2011 afirma que basta con que las particiones estén alineadas en
múltiplos de 4KiB. La <a class="reference external" href="https://linux.die.net/man/8/sgdisk">página de manual de sgdisk</a>, por su parte, sostiene que la
alineación en múltiplos de 1MiB es necesaria para optimizar el rendimiento
de la tecnología <a class="reference external" href="https://en.wikipedia.org/wiki/Advanced_Format">Advanced Format</a>
de <em>Western Digital</em>, de algunos <abbr title="Redundant Array of Inexpensive Disks">RAID</abbr>s y de los dispositivos <abbr title="Solid-State Drive">SSD</abbr>.</p>
</div>
</div>
<div class="section" id="particiones-logicas">
<h4>5.1.2.1.4.2. Particiones lógicas<a class="headerlink" href="#particiones-logicas" title="Enlazar permanentemente con este título">¶</a></h4>
<p>Dos son las limitaciones fundamentales del particionado <abbr title="Disk Operating System">DOS</abbr>:</p>
<ul class="simple">
<li>El tamaño máximo de <em>2TiB</em> para discos y de particiones que es insalvable,
aunque sólo ha empezado a cobrar importancia en fechas recientes.</li>
<li>La limitación de sólo poder crear cuatro particiones.</li>
</ul>
<p>Para paliar esta segunda limitación, <em>Microsoft</em> se inventó el concepto de
partición extendida, como una partición primaria destinada no a contener un
sistema de ficheros, sino más particiones: en teoría, un número ilimitado. Toda
partición contenida dentro de una partición extendida se denomina
<em class="dfn">partición lógica</em>. En cada disco sólo puede haber una partición primaria
marcada como partición extendida.</p>
<img alt="../../_images/particiones-ext-dos.png" src="../../_images/particiones-ext-dos.png" />
<p>En este caso, hay definidas tres particiones primarias (<em>sda1</em>, <em>sda2</em> y
<em>sda3</em>), la última de las cuales está marcada como extendida. En consecuencia,
dentro de ella pueden definirse particiones lógicas (<em>sda5</em>, <em>sda6</em>, <em>sda7</em>). En
el espacio sin asignar de la extendida se podrán aún definir una cantidad
ilimitado de particiones lógicas; y en el espacio libre fuera de ella una única
partición primaria más (la <em>sda4</em>).</p>
<p>Aunque irrelevantes a efectos prácticos, la partición extendida se implementa
del siguiente modo:</p>
<ul class="simple">
<li>La partición primaria que hará de partición extendida se marca como de tipo
<em>0x05</em>.</li>
<li>El primer sector de la partición extendida (su <abbr title="Volume Boot Record">VBR</abbr>) se denomina <abbr title="Entended Boot Record">EBR</abbr> y
tiene la misma estructura que un <abbr title="Master Boot Record">MBR</abbr>. En su tabla de particiones se incluyen
dos entradas:<ul>
<li>La primera entrada refiere la descripción de la partición lógica contigua
(la primera).</li>
<li>La segunda entrada refiere el sector en el que empieza el segundo <abbr title="Entended Boot Record">EBR</abbr>, que
se situará a continuación de la primera partición lógica.</li>
<li>Las dos restantes entradas no se usan.</li>
</ul>
</li>
<li>El segundo <abbr title="Entended Boot Record">EBR</abbr> es como el primero, pero describiendo la segunda partición
lógica y el comienzo del tercer <abbr title="Entended Boot Record">EBR</abbr> y así sucesivamente. En caso de que no
existan más particiones lógicas la segunda entrada estará a 0.</li>
</ul>
<img alt="../../_images/part-ext-ebr.png" src="../../_images/part-ext-ebr.png" />
<p>En resumen:</p>
<ul class="simple">
<li>Una tabla de particiones <abbr title="Disk Operating System">DOS</abbr> es sólo capaz de registrar hasta cuatro
particiones primarias.</li>
<li>La definición de todas las particiones primarias se encuentra en el <abbr title="Master Boot Record">MBR</abbr>.</li>
<li>Una de las particiones primarias puede marcarse como extendida, lo cual la
habilita para contener dentro de ella un número ilimitado de particiones
lógicas.</li>
<li>La definición de las particiones lógicas se encuentra distribuida a lo largo
de la partición extendida que las contiene.</li>
</ul>
</div>
</div>
<div class="section" id="limitaciones">
<h3>5.1.2.1.5. Limitaciones<a class="headerlink" href="#limitaciones" title="Enlazar permanentemente con este título">¶</a></h3>
<p>Concentremos juntas las limitaciones de este sistema de particionado:</p>
<ol class="arabic simple">
<li>Los escasos 64 <em>bytes</em> para codificar toda la tabla de particiones, provocan
que en principio sólo se puedan definir 4 particiones.</li>
<li>Para burlar la limitación anterior, se idea la argucia de la partición
extendida, pero no deja de ser un remiendo que provoca que la definición de la
tabla de particiones no esté concentrada en un solo punto, sino desperdigada a
lo largo de todo el disco.</li>
<li>Sólo se usa un <em>byte</em> para codificar el tipo de partición, lo que ha
propiciado que algunos sistemas de ficheros estén identificados por un mismo
código. Por ejemplo, <em>0x07</em> identifica a <abbr title="NT File System">NTFS</abbr>, pero también al <abbr title="High Performance File System">HPFS</abbr> de
OS/2.</li>
<li>Por <a class="reference internal" href="#tam-max-part-dos"><span class="std std-ref">lo ya expuesto</span></a>, los discos no pueden ser
mayores a <em>2TiB</em>.</li>
</ol>
</div>
<div class="section" id="practica">
<h3>5.1.2.1.6. Práctica<a class="headerlink" href="#practica" title="Enlazar permanentemente con este título">¶</a></h3>
<p>Para llevar a cabo el particionado de disco con <em>Linux</em>, podemos usar distintas
herramientas:</p>
<ul class="simple">
<li><strong class="command">fdisk</strong>, que es la herramienta tradicional interactiva para interfaz
de texto. Es bastante sencilla de utilizar.</li>
<li><strong class="command">sfdisk</strong>. otra herramienta para línea de órdenes que permite su uso
desasistido y, en consecuencia, se presta a su inclusión en <em>scripts</em>.</li>
<li><a class="reference external" href="https://www.gnu.org/software/parted/manual/parted.html">parted</a>, que puede ser usada desde línea de órdenes, pero que habitualmente
se utiliza a través de su interfaz para <abbr title="Gimp ToolKit">GTK</abbr> <a class="reference external" href="https://gparted.org/">gparted</a>. No la trataremos en
esta guía.</li>
</ul>
<p class="rubric">Preliminares</p>
<span class="target" id="truncate"></span><p id="index-0">Es probable que, para hacer pruebas, no deseemos usar un disco real. En ese
caso, lo más cómo es crear un fichero y trabajar sobre él<a class="footnote-reference" href="#id20" id="id4">[4]</a>. Por ejemplo:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> truncate -s 20G <span class="m">0</span>.disk
</pre></div>
</div>
<p>Esto creará un <a class="reference external" href="https://es.wikipedia.org/wiki/Archivo_disperso">fichero disperso</a> de 20G, que ocupa de forma
efectiva sólo el espacio que ocupe su contenido (en principio, nada).</p>
<p>Otro aspecto a tener presente son los permisos de los dispositivos.
Habitualmente son estos:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> ls -l /dev/sda
<span class="go">brw-rw---- 1 root disk 8, 0 nov 17 11:49 /dev/sda</span>
</pre></div>
</div>
<p>En consecuencia, sólo el administrador o un usuario que pertenezca al grupo
<em>disk</em> será capaz de leer y escribir directamente sobre ellos.</p>
<div class="admonition warning">
<p class="first admonition-title">Advertencia</p>
<p class="last">Para ilustrar el uso de las órdenes usaremos un usuario sin
privilegios y el fichero creado anteriormente y no un dispositivo de
almacenamiento. Tenga presente que lo habitual es usar <code class="file docutils literal notranslate"><span class="pre">/dev/sda</span></code>,
<code class="file docutils literal notranslate"><span class="pre">/dev/sdb</span></code>, etc. y que esta labor la lleve a cabo directamente el
administrador.</p>
</div>
<p class="rubric">Consulta</p>
<div class="admonition note">
<p class="first admonition-title">Nota</p>
<p class="last">Las herramientas son también válidas, aunque utilicemos particionado
<abbr title="GUID Partition Table">GPT</abbr>.</p>
</div>
<p>Antes de manipular los dispositivos, es útil saber qué herramientas de consulta
tenemos para conocer cómo se encuentra dividido el disco. Es preciso, además,
hacer una aclaración: el sistema carga las particiones en memoria y procura
actualizarlas cuando se produce un cambio. En ocasiones, esta actualización no
se produce, bien porque el sistema es incapaz de hacerla, bien porque se ha
llevado a cabo de una manera poco ortodoxa, como por ejemplo, copiando con
<a class="reference internal" href="../../02.conbas/02.informacion/04.devices.html#dd"><span class="std std-ref">dd</span></a> el <abbr title="Master Boot Record">MBR</abbr> de otro disco.</p>
<p>La primera de ellas es, simplemente, consultar cuáles son las particiones
registradas en el fichero <code class="file docutils literal notranslate"><span class="pre">/proc/particions</span></code>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> cat /proc/particions
<span class="go">major minor  #blocks  name</span>

<span class="go">   8        0  117220824 sda</span>
<span class="go">   8        1      32098 sda1</span>
<span class="go">   8        2   62109696 sda2</span>
<span class="go">   8        3          1 sda3</span>
<span class="go">   8        5   20971520 sda5</span>
<span class="go">   8        6    2097152 sda6</span>
<span class="go">   8        7   32006616 sda7</span>
<span class="go">   8       16  976762584 sdb</span>
<span class="go">   8       17  976759808 sdb1</span>
</pre></div>
</div>
<p>La consulta puede llevarla a cabo cualquier usuario y muestra las particiones
físicas (no los volúmenes lógicos) registrados por el sistema.</p>
<span class="target" id="lsblk"></span><p id="index-1">Una alternativa es <strong class="command">lsblk</strong> que muestra más información e incluye
volúmenes lógicos y el punto de montaje, en caso de que su sistema de ficheros
esté montado:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> /sbin/lsblk /dev/sda
<span class="go">NAME              MAJ:MIN RM   SIZE RO TYPE MOUNTPOINT</span>
<span class="go">sda                 8:0    0 111,8G  0 disk</span>
<span class="go">├─sda1              8:1    0  31,4M  0 part /boot/grub</span>
<span class="go">├─sda2              8:2    0  59,2G  0 part</span>
<span class="go">├─sda3              8:3    0     1K  0 part</span>
<span class="go">├─sda5              8:5    0    20G  0 part /</span>
<span class="go">├─sda6              8:6    0     2G  0 part [SWAP]</span>
<span class="go">└─sda7              8:7    0  30,5G  0 part /home</span>
</pre></div>
</div>
<span class="target" id="blkid"></span><p id="index-2">También puede usarse, aunque como administrador, <strong class="command">blkid</strong> que sirve para
obtener más información de los sistemas de ficheros de cada división:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> blkid /dev/sda*
<span class="go">/dev/sda: PTUUID=&quot;b94dda9b&quot; PTTYPE=&quot;dos&quot;</span>
<span class="go">/dev/sda1: LABEL=&quot;GRUB&quot; UUID=&quot;0bdcc04e-e267-4aa4-b8ec-1bea18e83f87&quot; TYPE=&quot;ext4&quot; PARTUUID=&quot;b94dda9b-01&quot;</span>
<span class="go">/dev/sda2: UUID=&quot;B0007B1D007AEA2C&quot; TYPE=&quot;ntfs&quot; PARTUUID=&quot;b94dda9b-02&quot;</span>
<span class="go">/dev/sda3: PTTYPE=&quot;dos&quot; PARTUUID=&quot;b94dda9b-03&quot;</span>
<span class="go">/dev/sda5: LABEL=&quot;BASE&quot; UUID=&quot;38c84f19-da83-4132-9c0c-e8dbd0763d7c&quot; TYPE=&quot;ext4&quot; PARTUUID=&quot;b94dda9b-05&quot;</span>
<span class="go">/dev/sda6: UUID=&quot;4b34fe7e-f7fb-4fd5-8e64-49d0d7f9418a&quot; TYPE=&quot;swap&quot; PARTUUID=&quot;b94dda9b-06&quot;</span>
<span class="go">/dev/sda7: LABEL=&quot;HOME&quot; UUID=&quot;2bee799a-740b-4106-90ad-d9a155d85afe&quot; TYPE=&quot;ext4&quot; PARTUUID=&quot;b94dda9b-07&quot;</span>
</pre></div>
</div>
<p>Si no se especifican las divisiones, mostrará todos. La orden, además, permite
filtrar por valores y manipular la salida. Por ejemplo, la orden:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> blkid -t <span class="nv">TYPE</span><span class="o">=</span>ext4 -s LABEL -o value /dev/sda*
<span class="go">GRUB</span>
<span class="go">BASE</span>
<span class="go">HOME</span>
</pre></div>
</div>
<p>muestra de los dispositivos formateados en <em>ext4</em>, el valor de su etiqueta.
Consulte la página del manual para más información.</p>
<span class="target" id="blockdev"></span><p id="index-3">Complementaria de las anteriores es <strong class="command">blockdev</strong>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> blockdev --report /dev/sda*
<span class="go">RO    RA   SSZ   BSZ   PrimerSec           Tam.   Dispo.</span>
<span class="go">rw   256   512  4096          0    120034123776   /dev/sda</span>
<span class="go">rw   256   512  1024         63        32868864   /dev/sda1</span>
<span class="go">rw   256   512  4096      65536     63600328704   /dev/sda2</span>
<span class="go">rw   256   512  1024  124286974            1024   /dev/sda3</span>
<span class="go">rw   256   512  4096  124286976     21474836480   /dev/sda5</span>
<span class="go">rw   256   512  4096  166232064      2147483648   /dev/sda6</span>
<span class="go">rw   256   512  4096  170428416     32774774784   /dev/sda7</span>
</pre></div>
</div>
<p>que, como la anterior, permite definir la salida. Por ejemplo:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> blockdev --getsize64 /dev/sda
<span class="go">120034123776</span>
</pre></div>
</div>
<p>devuelve el tamaño del disco en <em>bytes</em>. También es útil para forzar al kernel
a releer la tabla de particiones del dispositivo<a class="footnote-reference" href="#id21" id="id5">[5]</a>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> blockdev --rereadpt /dev/sda
</pre></div>
</div>
<p>La última posibilidad es usar las herramientas de manipulación de la tabla de
particiones (<a class="reference internal" href="#fdisk"><span class="std std-ref">fdisk</span></a> o <a class="reference internal" href="#gdisk-i"><span class="std std-ref">gdisk</span></a>) para leerla:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> fdisk -l /dev/sda
<span class="go">Disco /dev/sda: 111,81 GiB, 120034123776 bytes, 234441648 sectores</span>
<span class="go">Modelo de disco: Intenso  SSD Sat</span>
<span class="go">Unidades: sectores de 1 * 512 = 512 bytes</span>
<span class="go">Tamaño de sector (lógico/físico): 512 bytes / 512 bytes</span>
<span class="go">Tamaño de E/S (mínimo/óptimo): 512 bytes / 512 bytes</span>
<span class="hll"><span class="go">Tipo de etiqueta de disco: dos</span>
</span><span class="go">Identificador del disco: 0xb94dda9b</span>

<span class="go">Disposit.  Inicio  Comienzo     Final  Sectores Tamaño Id Tipo</span>
<span class="go">/dev/sda1                63     64259     64197  31,4M 83 Linux</span>
<span class="hll"><span class="go">/dev/sda2  *          65536 124284927 124219392  59,2G  7 HPFS/NTFS/exFAT</span>
</span><span class="go">/dev/sda3         124286974 234441647 110154674  52,5G  5 Extendida</span>
<span class="go">/dev/sda5         124286976 166230015  41943040    20G 83 Linux</span>
<span class="go">/dev/sda6         166232064 170426367   4194304     2G 82 Linux swap / Solaris</span>
<span class="go">/dev/sda7         170428416 234441647  64013232  30,5G 83 Linux</span>
</pre></div>
</div>
<p>con la que podemos comprobar que <code class="file docutils literal notranslate"><span class="pre">sda</span></code> utliza particionado <abbr title="Disk Operating System">DOS</abbr>.</p>
<span class="target" id="fdisk"></span><p class="rubric" id="index-4">fdisk</p>
<p><strong class="command">fdisk</strong> es la orden tradicional para el particionado de discos. Es
interactiva y exige que el usuario vaya escogiendo qué acción en la que quiere
hacer. Pese a ello, se puede consultar directamente la tabla de particiones sin
entrar en su entorno:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> /sbin/fdisk -l <span class="m">0</span>.disk
<span class="go">Disco 0.disk: 20 GiB, 21474836480 bytes, 41943040 sectores</span>
<span class="go">Unidades: sectores de 1 * 512 = 512 bytes</span>
<span class="go">Tamaño de sector (lógico/físico): 512 bytes / 512 bytes</span>
<span class="go">Tamaño de E/S (mínimo/óptimo): 512 bytes / 512 bytes</span>
</pre></div>
</div>
<p>Nuestro disco (disco-fichero, en realidad) está completamente vacío, por lo que
no dispone siquiera de una tabla de particiones.</p>
<p>Para manipular las particiones (crearlas en este caso) basta con indicar el
disco sobre el que se quiere actuar:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> /sbin/fdisk <span class="m">0</span>.disk
<span class="go">[...]</span>
<span class="go">Orden (m para obtener ayuda):</span>
</pre></div>
</div>
<p>El uso es bastante sencillo, ya que es totalmente guiado. Creemos una única
partición que ocupe todo el disco:</p>
<script id="asciicast-89vbH0bhb6NmVsoh7ctooVxIO"
src="https://asciinema.org/a/89vbH0bhb6NmVsoh7ctooVxIO.js" async></script><span class="target" id="sfdisk"></span><p class="rubric" id="index-5">sfdisk</p>
<p>A diferencia de la orden anterior, <strong class="command">sfdisk</strong> se usa directamente
incorporando argumentos en línea o pasando la tabla de particiones por la
entrada estándar. Para consultar la tabla de particiones, se utiliza la misma
sintaxis que <a class="reference internal" href="#fdisk"><span class="std std-ref">fdisk</span></a>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> /sbin/sfdisk -l <span class="m">0</span>.disk
</pre></div>
</div>
<p>La forma más sencilla de crear una tabla de particiones es copiar una ya
existente de otro disco:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> sfdisk -d /dev/sda <span class="p">|</span> sfdisk /dev/sdb
</pre></div>
</div>
<p>Es posible también crear una tabla <em>ex novo</em>. Para ello basta con saber que se
puede incluir líneas iniciales que indican las características del particionado
y líneas posteriores que definen cada partición. Las iniciales tienen el formato
«campo: valor»; y las siguientes, cuatro campos separados por espacios o comas:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>sector_inicial,tamaño_en_sectores,codigo_tipo_ficheros,[*|-]
</pre></div>
</div>
<p>El valor predeterminado para el sector inicial es utilizar el primer sector
disponible; el del tamaño, ocupar el máximo posible; el valor para el tipo, «L»
(un alias para partición tipo linux); y el valor para activa, que no lo sea. Por
ejemplo:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> /sbin/sfdisk <span class="m">0</span>.disk &lt;&lt;EOF
<span class="go">label: dos</span>
<span class="go">,$((32*1024**2/512)),L,*</span>
<span class="go">,,E</span>
<span class="go">,$((2*1024**3/512)),7</span>
<span class="go">,$((1*1024**3/512)),82</span>
<span class="go">,,L</span>
<span class="go">EOF</span>
</pre></div>
</div>
<p>Lo que hemos hecho es:</p>
<ul>
<li><p class="first">Generar una primera partición de 32MB de tipo <em>Linux</em> que es la activa. Como
la alineación es de 1MB y no se ha especificado el sector inicial, este será el
2048, que deja justamente 1MB antes.</p>
</li>
<li><p class="first">A continuación, se crea una partición extendida («E» es un alias para el código
correspondiente) que ocupa el resto del disco.</p>
</li>
<li><p class="first">Lo siguiente es una partición lógica de 2GB de tipo NTFS.</p>
<div class="admonition note">
<p class="first admonition-title">Nota</p>
<p>Para saber cuáles son los códigos de los tipos de partición puede
hacerse:</p>
<div class="last highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> /sbin/sfdisk -TXdos
</pre></div>
</div>
</div>
</li>
<li><p class="first">Una partición de 1GB para swap.</p>
</li>
<li><p class="first">Una partición de <em>Linux</em> que ocupa el resto de la extendida (o sea, el resto
del disco).</p>
</li>
</ul>
<p>La salida de la orden nos debería mostrar las particiones resultantes.</p>
<p>Además, de crear tablas completas, podemos modificar la ya existente gracias a
la opción <kbd class="kbd docutils literal notranslate">-N</kbd>. Por ejemplo, la orden:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> <span class="nb">echo</span> <span class="s2">&quot;,,L,-&quot;</span> <span class="p">|</span> /sbin/sfdisk -N1 <span class="m">0</span>.disk
</pre></div>
</div>
<p>deja todo como está, pero desactivando la partición. También es posible añadir
más particiones usando como argumento de <kbd class="kbd docutils literal notranslate">-N</kbd> índices de particiones que no
existan.</p>
<div class="admonition note">
<p class="first admonition-title">Nota</p>
<p>Como las últimas versiones de las órdenes <strong class="command">*fdisk</strong> soportan
particionado <abbr title="GUID Partition Table">GPT</abbr>, <strong class="command">sfdisk</strong> puede usarse también para crear una
tabla de particiones de este tipo:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> /sbin/sfdisk <span class="m">0</span>.disk &lt;&lt;EOF
<span class="go">label: gpt</span>
<span class="go">,$((50*1024**2/512)),U,</span>
<span class="go">,$((2*1024**3/512)),L,</span>
<span class="go">,$((1*1024**3/512)),0657FD6D-A4AB-43C4-84E5-0933C84B4F4F,</span>
<span class="go">,,EBD0A0A2-B9E5-4433-87C0-68B6B72699C7,</span>
<span class="go">EOF</span>
</pre></div>
</div>
<p class="last">Ciertamente los códigos en particiones <abbr title="GUID Partition Table">GPT</abbr> son bastante complicados. No
daremos más explicaciones porque aún no hemos discutido cómo son estas
particiones.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Nota</p>
<p class="last">En las operaciones anteriores de modificación de la tabla de particiones,
podemos incluir la opción <code class="docutils literal notranslate"><span class="pre">-b</span></code> para hacer una copia de los sectores
afectados por nuestras modificaciones. Si algo saliera mal, podríamos volver
al estado anterior con <a class="reference internal" href="../../02.conbas/02.informacion/04.devices.html#dd"><span class="std std-ref">dd</span></a><a class="footnote-reference" href="#id22" id="id6">[6]</a>.</p>
</div>
</div>
</div>
<div class="section" id="gpt">
<span id="part-gpt"></span><h2>5.1.2.2. <abbr title="GUID Partition Table">GPT</abbr><a class="headerlink" href="#gpt" title="Enlazar permanentemente con este título">¶</a></h2>
<div class="admonition note">
<p class="first admonition-title">Nota</p>
<p class="last">En realidad, las particiones son particiones <abbr title="Globally Unique Identifier">GUID</abbr> y <abbr title="GUID Partition Table">GPT</abbr> es
acrónimo para referirse a la tabla de particiones: <em>GUID Partition Table</em>. En
el texto, se usa <em>incorrectamente</em> en ocasiones el término <abbr title="GUID Partition Table">GPT</abbr>.</p>
</div>
<p>Las particiones <abbr title="Globally Unique Identifier">GUID</abbr> se idearon para el firmware <abbr title="Unified Extensible Firmware Interface">UEFI</abbr>, aunque dada su versatilidad es posible usarlas aun cuando la placa base utilice <abbr title="Basic I/O System">BIOS</abbr>. Haremos
primero una descripción de este sistema de particionado y veremos después como aplicarlo tanto a <abbr title="Basic I/O System">BIOS</abbr> como a <abbr title="Unified Extensible Firmware Interface">UEFI</abbr>.</p>
<div class="section" id="id7">
<h3>5.1.2.2.1. Descripción<a class="headerlink" href="#id7" title="Enlazar permanentemente con este título">¶</a></h3>
<p>El particionado <abbr title="GUID Partition Table">GPT</abbr> lo compone:</p>
<ul>
<li><p class="first">Un <abbr title="Master Boot Record">MBR</abbr>, en principio, de mera protección, ya que no se utiliza en <abbr title="Unified Extensible Firmware Interface">UEFI</abbr>,
pero que se reserva por si un usuario maneja una herramienta de particionado
sin soporte para particiones <abbr title="Globally Unique Identifier">GUID</abbr>. La zona correspondiente al sector de
arranque no se usa, y la parte dedicada a la tabla de particiones <abbr title="Disk Operating System">DOS</abbr> define
una única partición de tipo <em>0xEE</em> (esto es, <abbr title="GUID Partition Table">GPT</abbr>) que ocupa todo el disco.
Esta información no tiene ninguna utilidad, pero pone en sobreaviso al
usuario: si usa una herramienta que ignora <abbr title="GUID Partition Table">GPT</abbr>, tal herramienta no verá un
<abbr title="Master Boot Record">MBR</abbr> con basura (código incomprensible) sino un tabla de particiones para él
válida.  Esto evita que nos sugiera crear un <abbr title="Master Boot Record">MBR</abbr> válido e impide que el
usuario inconscientemente se cargue un particionado ya hecho.</p>
</li>
<li><p class="first">El segundo sector compone la cabecera <abbr title="GUID Partition Table">GPT</abbr> en la que se inscribe un
identificador único para el disco, el número de particiones definidas y
algunos otros datos más.</p>
</li>
<li><p class="first">Los siguientes sectores se dedican a guardar la información sobre cada partición
a razón de cuatro particiones por cada sector. En consecuencia, la definición
de cada partición ocupa 128 <em>bytes</em>. Como mínimo se establece que la tabla de
particiones ocupe 16KiB, lo que significa que pueden almacenarse al menos
<span class="math notranslate nohighlight">\(16*2*4 = 128\)</span> particiones. No obstante, la tabla puede hacerse mayor,
en caso de que sean necesarias más particiones. En consecuencia, no hay límite
en el número de particiones y deja de tener sentido la distinción entre
particiones primarias y lógicas, ya que todas están definidas en la tabla de
particiones.</p>
<p>La definición de cada partición es la siguiente:</p>
<table border="1" class="part-gpt docutils">
<colgroup>
<col width="31%" />
<col width="69%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Tamaño (bytes)</th>
<th class="head">Descripción</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>16</td>
<td>Tipo de partición <abbr title="Globally Unique Identifier">GUID</abbr>.</td>
</tr>
<tr class="row-odd"><td>16</td>
<td>GUID único de partición.</td>
</tr>
<tr class="row-even"><td>8</td>
<td><abbr title="Logical Block Addressing">LBA</abbr> del primer sector.</td>
</tr>
<tr class="row-odd"><td>8</td>
<td><abbr title="Logical Block Addressing">LBA</abbr> del último sector.</td>
</tr>
<tr class="row-even"><td>8</td>
<td>Indicadores.</td>
</tr>
<tr class="row-odd"><td>72</td>
<td>Nombre de la partición (<abbr title="Unicode Transformation Format">UTF</abbr>-16).</td>
</tr>
</tbody>
</table>
</li>
<li><p class="first">La estructura se copia también al final del disco para que exista redundancia.</p>
</li>
<li><p class="first">La primera partición empezará en aquel sector que determine la alineación.
Como las herramientas suelen establecerla en 1MiB, la primera partición
habitualmente empieza en el sector <em>2048</em>.</p>
</li>
</ul>
<img alt="../../_images/gpt.png" src="../../_images/gpt.png" />
</div>
<div class="section" id="bios">
<span id="part-gpt-bios"></span><h3>5.1.2.2.2. <abbr title="Basic I/O System">BIOS</abbr><a class="headerlink" href="#bios" title="Enlazar permanentemente con este título">¶</a></h3>
<p>Para que este particionado funcione con <abbr title="Basic I/O System">BIOS</abbr> es necesario que el <abbr title="Master Boot Record">MBR</abbr>
contenga el código de arranque, lo cual es posible gracias a que <abbr title="Unified Extensible Firmware Interface">UEFI</abbr> tiene la
prevención de no usar ese primer sector. En consecuencia, un gestor de arranque
como <abbr title="GRand Unified Bootloader">GRUB</abbr> será capaz de gestionar un particionado <abbr title="GUID Partition Table">GPT</abbr> con un firmware
<abbr title="Basic I/O System">BIOS</abbr>. El <em>quid</em> del asunto está, básicamente, en la segunda fase del gestor:
en particionado <abbr title="Disk Operating System">DOS</abbr> se instala en el espacio entre el <abbr title="Master Boot Record">MBR</abbr> y la primera
partición; pero en este caso, aunque puede haber ese espacio según sea la
alineación, se debe definir una partición <abbr title="Globally Unique Identifier">GUID</abbr> específica que recibe el nombre
de «BIOS Boot Partition» cuyo identificador en las herramientas suele ser
<em>0xEF02</em><a class="footnote-reference" href="#id23" id="id8">[7]</a>.</p>
<div class="admonition note">
<p class="first admonition-title">Nota</p>
<p class="last">Forzar la alineación en las particiones se hace para mejorar el
rendimiento en las operaciones de lectura y escritura. Como esta partición
sólo se lee al arrancar el ordenador y rara vez se escribe, es una buena
argucia, forzar la herramienta de particionado para que se salte la
alineación predefinida al crear esta partición y situarla entre el final
de la <abbr title="GUID Partition Table">GPT</abbr> y el comienzo de la primera (segunda) partición sí alineada
(sector 2048). Esta será la estrategia que sigamos en esta guía.</p>
</div>
<p>En consecuencia, podemos definir una <abbr title="GUID Partition Table">GPT</abbr> así:</p>
<img alt="../../_images/part-gpt-bios.png" src="../../_images/part-gpt-bios.png" />
<p>donde <code class="file docutils literal notranslate"><span class="pre">sda1</span></code> es una partición «BIOS Boot Partition» entre el final de la
<abbr title="GUID Partition Table">GPT</abbr> y el comienzo de la segunda partición, a partir de la cuál sí alinearemos
siguiendo el criterio predeterminado de la herramienta (1MiB).</p>
<div class="admonition seealso">
<p class="first admonition-title">Ver también</p>
<p class="last">Si somo previsiones, es probable que queramos dejar preparado el
sistema para la conversión al arranque <abbr title="Unified Extensible Firmware Interface">UEFI</abbr>.sea lo menos traumática
posible.  Consulte, en la parte dedicada al <a class="reference internal" href="#hybrid-boot"><span class="std std-ref">arranque híbrido</span></a>.</p>
</div>
</div>
<div class="section" id="uefi">
<span id="part-gpt-uefi"></span><h3>5.1.2.2.3. <abbr title="Unified Extensible Firmware Interface">UEFI</abbr><a class="headerlink" href="#uefi" title="Enlazar permanentemente con este título">¶</a></h3>
<p>Esta <em>firmware</em> no utiliza el <abbr title="Master Boot Record">MBR</abbr>, sino que, como es capaz de entender el
particionado y algunos sistemas de ficheros, busca los arranques en una
partición de tipo <abbr title="Extensible Firmware Interface">EFI</abbr> (código <em>0xEF00</em>) que ha debido de ser creada para ese
fin y formateada como <abbr title="File Allocation Table">FAT</abbr><a class="footnote-reference" href="#id24" id="id9">[8]</a>. Para referirse a esta partición <abbr title="Extensible Firmware Interface">EFI</abbr> suele
utilizarse el acrónimo inglés <abbr title="EFI System Partition">ESP</abbr>.</p>
<p>La especificación establece que en dicha partición debe existir un directorio
llamado <code class="file docutils literal notranslate"><span class="pre">/EFI</span></code> dentro del cual cada sistema operativo instalado cree un
directorio con ficheros necesarios para llevar a cabo su propio arranque:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>/
+-- EFI/
     +-- debian/
     +-- Windows/
     +-- etc.
</pre></div>
</div>
<p>De este modo, los arranques de los distintos sistemas operativos pueden
coexistir sin problemas. Para que quepan es recomendable que tenga al menos
100MB. En la <abbr title="Non-Volatile RAM">NVRAM</abbr> del <em>firmware</em><a class="footnote-reference" href="#id25" id="id10">[9]</a> pueden irse añadiendo entradas a la
secuencia de arranque y definiendo el orden de tales entradas. Si instalamos un
nuevo sistema operativo es de prever que la propia instalación se encargue de
ello, pero manualmente puede manipularse esta secuencia:</p>
<ul class="simple">
<li>Quizás el entorno de configuración de <abbr title="Unified Extensible Firmware Interface">UEFI</abbr> permita la edición gráfica de
este fichero.</li>
<li>La <em>shell</em> de <abbr title="Unified Extensible Firmware Interface">UEFI</abbr> lo permite a través del comando <strong class="command">bcfg</strong>.</li>
<li>Desde el propio sistema operativo suele haber herramientas para manipular el
archivo. En linux, este comando es <strong class="command">efibootmgr</strong><a class="footnote-reference" href="#id26" id="id11">[10]</a>.</li>
</ul>
<p><abbr title="Unified Extensible Firmware Interface">UEFI</abbr>, como <abbr title="Basic I/O System">BIOS</abbr>, suele disponer si se pulsa la tecla adecuada durante el
arranque de un menú para escoger cuál es la entrada a probar primero. A
diferencia del menú <abbr title="Basic I/O System">BIOS</abbr> este arranque no se limita a ofrecer dispositivos,
sino que puede ofrecer directamente los arranques encontrados en la <abbr title="EFI System Partition">ESP</abbr>, que
pueden ser gestores de arranque o directamente sistemas operativos, si estos se
registraron en la <abbr title="Non-Volatile RAM">NVRAM</abbr>.</p>
<div class="admonition note">
<p class="first admonition-title">Nota</p>
<p class="last">Si una entrada indica que se arrancará por el dispositivo de disco
(como en los arranques <abbr title="Basic I/O System">BIOS</abbr>), <abbr title="Unified Extensible Firmware Interface">UEFI</abbr> intentará cargar en la <abbr title="EFI System Partition">ESP</abbr> el
fichero <code class="file docutils literal notranslate"><span class="pre">/EFI/Boot/bootx64.efi</span></code>.</p>
</div>
<p>Dadas las posibilidades que ofrece <abbr title="Unified Extensible Firmware Interface">UEFI</abbr>, podríamos prescindir del gestor de
arranque<a class="footnote-reference" href="#id27" id="id12">[11]</a> incluso aun cuando dispusiéramos de varios sistemas operativos en
un único dispositivo. Sin embargo, un gestor de arranque como <abbr title="GRand Unified Bootloader">GRUB</abbr> puede
seguirse usando: basta con que se instale como unos de los posibles arranques y
que se sitúe como el primero en el orden de arranque.</p>
<div class="admonition seealso">
<p class="first admonition-title">Ver también</p>
<p class="last">La wiki de Archlinux tiene un muy completo <a class="reference external" href="https://wiki.archlinux.org/index.php/Unified_Extensible_Firmware_Interface_(Espa%C3%B1ol)">artículo sobre UEFI</a>.</p>
</div>
<img alt="../../_images/part-gpt-uefi.png" src="../../_images/part-gpt-uefi.png" />
</div>
<div class="section" id="arranque-hibrido">
<span id="hybrid-boot"></span><h3>5.1.2.2.4. Arranque híbrido<a class="headerlink" href="#arranque-hibrido" title="Enlazar permanentemente con este título">¶</a></h3>
<p>No resulta excesivamente útil hacer que nuestro sistema de servidor sea capaz de
arrancar tanto en modo <abbr title="Unified Extensible Firmware Interface">UEFI</abbr> como en modo <abbr title="Basic I/O System">BIOS</abbr>, pero sí que un sistema
originalmente pensado para arrancar en <abbr title="Basic I/O System">BIOS</abbr> acabe arrancado en <abbr title="Unified Extensible Firmware Interface">UEFI</abbr>, por
ejemplo, por un cambio en el <em>hardware</em>. En este caso, un particionado previsor
es, simplemente, aquel que dispone las dos particiones de arranque: la «Bios Boot
Partition» (<em>0xef02</em>) y la EFI (<em>0xef00</em>). Como entre esta última y la anterior
existe espacio sin particionar de casi 1MiB de tamaño, podemos aprovecharlo para
incluirla ahí:</p>
<img alt="../../_images/part-hibrida.png" src="../../_images/part-hibrida.png" />
</div>
<div class="section" id="gdisk-i">
<span id="id13"></span><h3>5.1.2.2.5. Práctica<a class="headerlink" href="#gdisk-i" title="Enlazar permanentemente con este título">¶</a></h3>
<div class="section" id="aplicaciones-de-terminal">
<h4>5.1.2.2.5.1. Aplicaciones de terminal<a class="headerlink" href="#aplicaciones-de-terminal" title="Enlazar permanentemente con este título">¶</a></h4>
<div class="admonition warning">
<p class="first admonition-title">Advertencia</p>
<p class="last">Las particiones «<em>UNO</em>», «<em>DOS</em>», «<em>TRES</em>» que aparecen en los
ejemplos son absolutamente inútiles en un sistema real y sirven tan sólo para
ilustrar el uso de las herramiestas. Más allá de las particiones de arranque,
deberá ser usted quién decida cómo debe particionar el sistema. Una propuesta
se encuentra el el epígrafe dedicado a la <a class="reference internal" href="../10.instalacion/index.html#inst-servidor"><span class="std std-ref">instalación del servidor</span></a>.</p>
</div>
<p>Para manejar <abbr title="GUID Partition Table">GPT</abbr> usaremos las herramientas de las suite <strong class="program">gdisk</strong>,
aunque desde hace un tiempo las de la suite <strong class="program">fdisk</strong> también son
compatibles.</p>
<p class="rubric" id="index-6">gdisk</p>
<p>La herramienta es prácticamente clónica de <a class="reference internal" href="#fdisk"><span class="std std-ref">fdisk</span></a>, aunque incluye
algunas posibilidades más para <abbr title="GUID Partition Table">GPT</abbr> en las opciones avanzadas.</p>
<span class="target" id="sgdisk"></span><p class="rubric" id="index-7">sgdisk</p>
<p>El programa permite la creación y manipulación de tablas de particiones
utilizando argumentos en la línea de órdenes, por lo que su filosofia es la
misma que la de <a class="reference internal" href="#sfdisk"><span class="std std-ref">sfdisk</span></a>. Pese a ello, tiene una sintaxis
totalmente distinta.</p>
<p>Para ilustrar su uso, recrearemos tres veces la tabla de particiones que hicimos
con <a class="reference internal" href="#sfdisk"><span class="std std-ref">sfdisk</span></a>, aunque con algunas variantes:</p>
<ul class="simple">
<li>Una primera vez, prepararemos el disco para que sea arrancable mediante
<abbr title="Basic I/O System">BIOS</abbr>. Para ello añadiremos una primera partición de tipo «BIOS Boot
Particion» para que pueda instalarse <abbr title="GRand Unified Bootloader">GRUB</abbr>.  Por supuesto, no tiene sentido
la marca de activa, ni la partición extendida.</li>
<li>La segunda vez, prepararemos el disco para <abbr title="Unified Extensible Firmware Interface">UEFI</abbr> con lo que también tendremos
que añadir una primera partición, pero <abbr title="Extensible Firmware Interface">EFI</abbr> en este caso.</li>
<li>La ultima la tabla de particiones está preparada tanto para arrancar en modo
<abbr title="Basic I/O System">BIOS</abbr> como en modo <abbr title="Unified Extensible Firmware Interface">UEFI</abbr>, lo cual exige presentar ambas particiones.</li>
</ul>
<table border="1" class="tipos-arranques docutils">
<colgroup>
<col width="32%" />
<col width="35%" />
<col width="32%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Tipo</th>
<th class="head">BIOS Boot</th>
<th class="head"><abbr title="EFI System Partition">ESP</abbr></th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><abbr title="Basic I/O System">BIOS</abbr></td>
<td>Sí</td>
<td>No</td>
</tr>
<tr class="row-odd"><td><abbr title="Unified Extensible Firmware Interface">UEFI</abbr></td>
<td>No</td>
<td>Sí</td>
</tr>
<tr class="row-even"><td>Híbrido</td>
<td>Sí</td>
<td>Sí</td>
</tr>
</tbody>
</table>
<p>Empecemos, simplemente, por consultar la tabla de particiones<a class="footnote-reference" href="#id28" id="id14">[12]</a>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> /sbin/sgdisk -p /tmp/0.disk
<span class="go">Creating new GPT entries in memory.</span>
<span class="go">Disk /tmp/0.disk: 41943040 sectors, 20.0 GiB</span>
<span class="go">Sector size (logical): 512 bytes</span>
<span class="go">Disk identifier (GUID): 97F6B136-94D6-4393-9348-47F3F5DB70F6</span>
<span class="go">Partition table holds up to 128 entries</span>
<span class="go">Main partition table begins at sector 2 and ends at sector 33</span>
<span class="go">First usable sector is 34, last usable sector is 41943006</span>
<span class="go">Partitions will be aligned on 2048-sector boundaries</span>
<span class="go">Total free space is 41942973 sectors (20.0 GiB)</span>

<span class="go">Number  Start (sector)    End (sector)  Size       Code  Name</span>
</pre></div>
</div>
<p>El disco no tiene aún ninguna tabla, por lo que aparece vacía. Es interesante de
la información lo siguiente:</p>
<ul>
<li><p class="first"><strong class="command">sgdisk</strong> de crear una tabla la crearía del modo estándar que
describimos anteriormente por lo que será capaz de describir 128 particiones.</p>
</li>
<li><p class="first">Teóricamente el primer sector para incluirlo dentro de una partición es el 34,
ya que eso deja 17KiB por delante que es lo necesario para almacenar el <abbr title="Master Boot Record">MBR</abbr>
(512 <em>bytes</em>), la cabecera <abbr title="GUID Partition Table">GPT</abbr> (otros 512 <em>bytes</em>) y la propia <abbr title="GUID Partition Table">GPT</abbr>
(16KiB):</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> /sbin/sgdisk -f /tmp/0.disk
<span class="go">Creating new GPT entries in memory.</span>
<span class="go">34</span>
</pre></div>
</div>
</li>
<li><p class="first">La alineación si no se cambia, será de 1MiB (2048 sectores):</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> /sbin/sgdisk -D /tmp/0.disk
<span class="go">Creating new GPT entries in memory.</span>
<span class="go">2048</span>
</pre></div>
</div>
<p>lo que determina que en realidad la primera partición empiece en el sector
2048:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> /sbin/sgdisk -F /tmp/0.disk
<span class="go">Creating new GPT entries in memory.</span>
<span class="go">2048</span>
</pre></div>
</div>
</li>
</ul>
<p>En un dispositivos que queremos que sea arrancable, se nos pueden presentar tres
casos de particionado:</p>
<ol class="loweralpha">
<li><p class="first"><abbr title="GUID Partition Table">GPT</abbr> exclusivamente compatible con <abbr title="Basic I/O System">BIOS</abbr>, que podemos definir así:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> /sbin/sgdisk -a <span class="m">8</span> -n <span class="s2">&quot;0:40:2047&quot;</span> -t <span class="s2">&quot;0:0xef02&quot;</span> -c <span class="s2">&quot;0:BOOTBIOS&quot;</span> <span class="se">\</span>
               -a <span class="m">2048</span> -n <span class="s2">&quot;0:+0:+32M&quot;</span> -c <span class="s2">&quot;0:UNO&quot;</span> <span class="se">\</span>
                       -n <span class="s2">&quot;0:+0:+2G&quot;</span> -t <span class="s2">&quot;0:0x0700&quot;</span> -c <span class="s2">&quot;0:DOS&quot;</span> <span class="se">\</span>
                       -n <span class="s2">&quot;0:+0:+1G&quot;</span> -c <span class="s2">&quot;0:TRES&quot;</span> /tmp/0.disk
</pre></div>
</div>
<p>en donde:</p>
<ul>
<li><p class="first">Creamos la primera partición en el espacio entre el final de la <abbr title="GUID Partition Table">GPT</abbr> y
la segunda partición que realmente necesitamos y que sí estará
convenientemente alineada. Sólo se leerá esta primera partición al arrancar el
disco y se escribirá al reinstalar <abbr title="GRand Unified Bootloader">GRUB</abbr> con lo cual no es muy importante su
alineamiento. Aún así la hacemos cumpliendo la alineación de 4KiB. Para
cambiar la alineación usamos la opción <kbd class="kbd docutils literal notranslate">-a</kbd>.</p>
</li>
<li><p class="first">Se definen las particiones añadiendo sendas opciones <kbd class="kbd docutils literal notranslate">-n</kbd> para indicar el
comienzo y fin de la partición, <kbd class="kbd docutils literal notranslate">-c</kbd> para indicar un nombre de etiqueta
y, si la partición no es <em>Linux</em> (<em>0x8300</em>), <kbd class="kbd docutils literal notranslate">-t</kbd>.</p>
</li>
<li><p class="first">Las opciones anteriores necesitan que se especifique el número de la
partición, pero «0» representa el primer número disponible.</p>
</li>
<li><p class="first">Los números para comienzos y finales sin indicar unidad son sectores; y es
lícito anteponerles un signo «+» para representar número relativos al
anterior.</p>
</li>
<li><p class="first">Las definiciones no sobreescriben una tabla anterior, de modo que si
hiciéramos:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> /sbin/sgdisk -N <span class="m">0</span> -c <span class="s2">&quot;5:RESTO&quot;</span>
</pre></div>
</div>
<p>añadiríamos a continuación una quinta partición que ocuparía lo que quede de
disco, ya que <kbd class="kbd docutils literal notranslate">-N</kbd> tiene el efecto de ocupar el espacio restante. Ahora
bien, si utilizamos el número de una partición existente, entonces
redefiniremos esa partición:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> /sbin/sgdisk -c <span class="s2">&quot;3:TERCERA&quot;</span> -t <span class="s2">&quot;3:0x0700&quot;</span> /tmp/0.disk
</pre></div>
</div>
</li>
</ul>
<div class="admonition warning">
<p class="first admonition-title">Advertencia</p>
<p class="last">Sopese utilizar el esquema propuesto para que sea compatible
también con <abbr title="Unified Extensible Firmware Interface">UEFI</abbr>, por si se produce un cambio en el <em>hardware</em>.</p>
</div>
</li>
<li><p class="first">Tabla de particiones <abbr title="GUID Partition Table">GPT</abbr> exclusivamente compatible con <abbr title="Unified Extensible Firmware Interface">UEFI</abbr>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> /sbin/sgdisk -n <span class="s2">&quot;0:2048:+100M&quot;</span> -t <span class="s2">&quot;0:0xef00&quot;</span> -c <span class="s2">&quot;0:EFI&quot;</span> <span class="se">\</span>
               -n <span class="s2">&quot;0:+0:+32M&quot;</span> -c <span class="s2">&quot;0:UNO&quot;</span> <span class="se">\</span>
               -n <span class="s2">&quot;0:+0:+2G&quot;</span> -t <span class="s2">&quot;0:0x0700&quot;</span> -c <span class="s2">&quot;0:DOS&quot;</span> <span class="se">\</span>
               -n <span class="s2">&quot;0:+0:+1G&quot;</span> -c <span class="s2">&quot;0:TRES&quot;</span> /tmp/0.disk
</pre></div>
</div>
<p>En este caso, la partición <abbr title="Extensible Firmware Interface">EFI</abbr> debe ser lo suficientemente grande para
albergar los arranques de los sistemas operativos que pretendeamos instalar. En
principio, con 50M o 100M debería bastar. Dado el tamaño de esta partición, no
nos molestamos siquiera en aprovechar el espacio anterior al sector 2048.</p>
</li>
<li><p class="first">Tabla de particiones <abbr title="GUID Partition Table">GPT</abbr> compatible tanto con <abbr title="Basic I/O System">BIOS</abbr> como con <abbr title="Unified Extensible Firmware Interface">UEFI</abbr>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> /sbin/sgdisk -a <span class="m">8</span> -n <span class="s2">&quot;0:40:2047&quot;</span> -t <span class="s2">&quot;0:0xef02&quot;</span> -c <span class="s2">&quot;0:BOOTBIOS&quot;</span> <span class="se">\</span>
               -a <span class="m">2048</span> -n <span class="s2">&quot;0:2048:+100M&quot;</span> -t <span class="s2">&quot;0:0xef00&quot;</span> -c <span class="s2">&quot;0:EFI&quot;</span> <span class="se">\</span>
                       -n <span class="s2">&quot;0:+0:+32M&quot;</span> -c <span class="s2">&quot;0:UNO&quot;</span> <span class="se">\</span>
                       -n <span class="s2">&quot;0:+0:+2G&quot;</span> -t <span class="s2">&quot;0:0x0700&quot;</span> -c <span class="s2">&quot;0:DOS&quot;</span> <span class="se">\</span>
                       -n <span class="s2">&quot;0:+0:+1G&quot;</span> -c <span class="s2">&quot;0:TRES&quot;</span> /tmp/0.disk
</pre></div>
</div>
<p>En este caso, la finalidad no es tanto que el sistema sea capaz de arrancar
con ambos <em>firmwares</em> (cosa que también se puede hacer) como que arrancando
en <abbr title="Basic I/O System">BIOS</abbr> pueda hacer una migración sencilla a arranque <abbr title="Unified Extensible Firmware Interface">UEFI</abbr>. Para lograr
esto último, consulte el <a class="reference internal" href="#bios-uefi"><span class="std std-ref">último apartado sobre migración a UEFI</span></a>.</p>
</li>
</ol>
<p>Otras acciones recurrentes con <strong class="command">sgdisk</strong> son:</p>
<ol class="arabic">
<li><p class="first">Borrar una partición:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> /sbin/sgdisk -d <span class="m">5</span> /tmp/0.disk
</pre></div>
</div>
</li>
<li><p class="first">Intercambiar la entrada de una partición por la de otra:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> /sbin/sgdisk -r <span class="m">1</span>:3 /tmp/0.disk
</pre></div>
</div>
<p>En este caso la partición primera partición pasa a estar definida en la
tercera entrada de la <abbr title="GUID Partition Table">GPT</abbr>, y la tercera, en la primera.</p>
</li>
<li><p class="first">Copiar la <abbr title="GUID Partition Table">GPT</abbr> al final del disco, que puede sernos útil cuando hacemos una
copia cruda de un disco más pequeño en uno mayor:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> /sbin/sgdisk -e /tmp/0.disk
</pre></div>
</div>
</li>
<li><p class="first">Copiar la tabla de particiones en un nuevo disco:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> /sbin/sgdisk -R /tmp/1.disk /tmp/0.disk
<span class="gp">$</span> /sbin/sgdisk -G /tmp/1.disk
</pre></div>
</div>
<p>La segunda instrucción es necesaria para que cambien los UIDs de las
particiones en el segundo disco, ya que la copia que se hace de la <abbr title="GUID Partition Table">GPT</abbr> es
exacta.</p>
</li>
<li><p class="first">Copiar la <abbr title="GUID Partition Table">GPT</abbr> en un fichero llamado <code class="file docutils literal notranslate"><span class="pre">GPT</span></code>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> /sbin/sgdisk -b GPT /tmp/0.disk
</pre></div>
</div>
<p>Y si se quiere restaurar en disco:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> /sbin/sgdisk -l GPT /tmp/0.disk
</pre></div>
</div>
</li>
<li><p class="first">Borrar la tabla de particiones y la cabecera <abbr title="GUID Partition Table">GPT</abbr>, pero
respetando el <abbr title="Master Boot Record">MBR</abbr>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> /sbin/sgdisk -z /tmp/0.disk
</pre></div>
</div>
<p>o sin siquiera respetarlo:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> /sbin/sgdisk -Z /tmp/0.disk
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Nota</p>
<p class="last">En caso de que quisiéramos redefinir una tabla de particiones de cero,
sobre un disco que ya tuviera definidas particiones, <kbd class="kbd docutils literal notranslate">-z</kbd> podría ser
la primera opción antes de las demás que definan la nueva tabla.</p>
</div>
</li>
<li><p class="first">Convertir de <abbr title="Disk Operating System">DOS</abbr> a <abbr title="GUID Partition Table">GPT</abbr>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> /sbin/sgdisk -g /tmp/dos.disk
</pre></div>
</div>
</li>
<li><p class="first">Convertir de <abbr title="GUID Partition Table">GPT</abbr> a <abbr title="Disk Operating System">DOS</abbr>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> /sbin/sgdisk -m <span class="m">3</span>:4:5 /tmp/0.disk
</pre></div>
</div>
<p>En este caso, sólo se pasan la definición de las particiones 3, 4 y 5.</p>
</li>
</ol>
</div>
<div class="section" id="migracion-a-uefi">
<span id="bios-uefi"></span><h4>5.1.2.2.5.2. Migración a <abbr title="Unified Extensible Firmware Interface">UEFI</abbr><a class="headerlink" href="#migracion-a-uefi" title="Enlazar permanentemente con este título">¶</a></h4>
<p>Remataremos la exposición sobre particionado, describiendo cómo convertir
nuestro arranque <abbr title="Basic I/O System">BIOS</abbr> en arranque <abbr title="Unified Extensible Firmware Interface">UEFI</abbr> si tuvimos la previsión desde un
principio de crear particiones <abbr title="Globally Unique Identifier">GUID</abbr> e incluimos tanto la partición
«BIOS Boot Partiticion» como la <abbr title="EFI System Partition">ESP</abbr><a class="footnote-reference" href="#id29" id="id15">[13]</a>. Si no fue así, tendremos que
preparar nuestro particionado para llegar a este punto, lo cual muy
probablemente incluya:</p>
<ul class="simple">
<li>La conversión de un particionado en otro (tanto <a class="reference internal" href="#gdisk-i"><span class="std std-ref">gdisk</span></a> como
<a class="reference internal" href="#sgdisk"><span class="std std-ref">sgdisk</span></a> lo permiten).</li>
<li>La creación de la <abbr title="EFI System Partition">ESP</abbr>, lo cual, suponga hacer hueco redimensinando alguna de
las particiones.</li>
</ul>
<p>Sea como sea, llegamos al punto en que disponemos de un particionado <abbr title="GUID Partition Table">GPT</abbr> con
particiones «Bios Boot Partition» (la cual supondremos <code class="file docutils literal notranslate"><span class="pre">sda1</span></code>) y <abbr title="Extensible Firmware Interface">EFI</abbr>
(<code class="file docutils literal notranslate"><span class="pre">sda2</span></code>) y un sistema que se instaló en modo <abbr title="Basic I/O System">BIOS</abbr> y, en consecuencia,
tiene inoperativa aún la partición <abbr title="Extensible Firmware Interface">EFI</abbr>.</p>
<p>Un procedimiento medianmente sencillo para lograr hacer que el sistema arranque
en modo <abbr title="Extensible Firmware Interface">EFI</abbr> es el siguiente:</p>
<ol class="arabic">
<li><p class="first">Arrancar el sistema en modo <abbr title="Basic I/O System">BIOS</abbr> para:</p>
<ol class="loweralpha">
<li><p class="first">Preparar la <abbr title="EFI System Partition">ESP</abbr>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> apt install dosfstools
<span class="gp">#</span> mkfs.fat -F32 /dev/sda2
<span class="gp">#</span> mkdir /boot/efi
<span class="gp">#</span> <span class="nb">echo</span> <span class="s2">&quot;/dev/sda2 /boot/efi vfat defaults 0 2&quot;</span> &gt;&gt; /etc/fstab
</pre></div>
</div>
</li>
<li><p class="first">Instalar el grub compatible con <abbr title="Extensible Firmware Interface">EFI</abbr>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> apt install grub.efi
</pre></div>
</div>
</li>
</ol>
</li>
<li><p class="first">Reiniciar en modo <abbr title="Unified Extensible Firmware Interface">UEFI</abbr> usando un instalador moderno de debian y obtener una
consola:</p>
<ol class="loweralpha simple">
<li>Escoger «Opciones avanzadas» y dentro de ellas «Rescate».</li>
<li>Contestar las distintas preguntas y al llegar a la de elegir el sistema de
ficheros raíz, contestar que ninguno.</li>
<li>Escoger la opción para abrir la terminal.</li>
</ol>
</li>
<li><p class="first">Hacer un <span class="xref std std-ref">chroot</span> a la debian instalada en el disco duro,
preparando previamente el sistema:</p>
<ol class="loweralpha">
<li><p class="first">Si es necesario para nuestro sistema, preparar <abbr title="Redundant Array of Inexpensive Disks">RAID</abbr>s, cargar volúmenes
lógicos, descrifar sistemas cifrados, etc. En caso de que hayamos seguido
las recomendaciones para la <a class="reference internal" href="../10.instalacion/index.html#inst-servidor"><span class="std std-ref">instalación de un servidor</span></a>, deberemos hacer lo siguiente:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> mdadm --assemble /dev/md0 /dev/sda3
<span class="gp">#</span> vgchange -ay VGbuster
</pre></div>
</div>
</li>
<li><p class="first">Montar al menos el sistema raíz y la <abbr title="EFI System Partition">ESP</abbr>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> mount /dev/VGbuster/rauz /mnt
<span class="gp">#</span> mount /dev/sda2 /mnt/boot/efi
</pre></div>
</div>
<p>Si nuestro sistema se compone de otras particiones, podemos montarlas
también, aunque no es imprescindible. Por ejemplo, para nuestra propuesta
de servidor:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> mount /dev/VGbuster/log /mnt/var/log
<span class="gp">#</span> mount /dev/VGbuster/mysql /mnt/var/lib/mysql
<span class="gp">#</span> mount /dev/VGbuster/srv /mnt/srv
<span class="gp">#</span> mount /dev/VGbuster/home /mnt/home
</pre></div>
</div>
</li>
<li><p class="first">Montar los sistemas especiales sobre el sistema de disco:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> mount -t devtmpfs udev /mnt/dev
<span class="gp">#</span> mount -t devpts devpts /mnt/dev/pts
<span class="gp">#</span> mount -t proc proc /mnt/procs
<span class="gp">#</span> mount -t sysfs sysfs /mnt/sys
</pre></div>
</div>
</li>
<li><p class="first">Entrar en la jaula:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> chroot /mnt bash
</pre></div>
</div>
</li>
</ol>
</li>
<li><p class="first">Instalar grub para el arranque <abbr title="Extensible Firmware Interface">EFI</abbr>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> grub-install --recheck
</pre></div>
</div>
<p>Al estar montada la <abbr title="EFI System Partition">ESP</abbr> en <code class="file docutils literal notranslate"><span class="pre">/boot/efi</span></code>, <strong class="program">grub</strong> será capaz de
usarla sin necesidar de especiar nada más.</p>
</li>
<li><p class="first">Comprobar que la entrada para <abbr title="GRand Unified Bootloader">GRUB</abbr> aparece como primera opción de
arranque:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> efibootmgr
</pre></div>
</div>
</li>
<li><p class="first">Salir y reiniciar<a class="footnote-reference" href="#id30" id="id16">[14]</a>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> <span class="nb">exit</span>
<span class="gp">#</span> reboot
</pre></div>
</div>
</li>
</ol>
</div>
<div class="section" id="entradas">
<span id="efi-entradas-grub"></span><h4>5.1.2.2.5.3. Entradas<a class="headerlink" href="#entradas" title="Enlazar permanentemente con este título">¶</a></h4>
<p>Una instalación estándar de <em>debian</em> instala, simplemente, su <abbr title="GRand Unified Bootloader">GRUB</abbr> dentro de
<code class="file docutils literal notranslate"><span class="pre">/EFI/debian</span></code> y añade una entrada a la secuencia de arranque del
<em>firmware</em> con el identificado «<em>debian</em>». Podemos alterar la leyenda de la
secuencia de arranque, borrando la actual entrada «<em>debian</em>» y creando otra
distinta:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> efibootmgr        <span class="c1"># Y miramos cuál es índice de la entrada (p.e. 7)</span>
<span class="gp">#</span> efibootmgr -Bb7
<span class="gp">#</span> efibootmgr -cgL <span class="s2">&quot;Grub menu&quot;</span> -d /dev/sda -p <span class="m">2</span> -l <span class="s2">&quot;/EFI/debian/shimx64.efi&quot;</span>
</pre></div>
</div>
<p>Otra posibilidad, es hacer que la entrada en la secuencia para el
dispositivo de disco arranque nuestro <abbr title="GRand Unified Bootloader">GRUB</abbr>. Eso pasa porque se cree
<code class="file docutils literal notranslate"><span class="pre">/EFI/Boot/bootx64.efi</span></code> para lo cual podemos hacer:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> grub-install --no-nvram --force-extra-removable
</pre></div>
</div>
<p>Otra posibilidad es crear una entrada que arranque directamente el sistema, lo
cual dejaremos para epígrafe aparte.</p>
</div>
<div class="section" id="arranque-directo">
<span id="efi-arranque-directo"></span><h4>5.1.2.2.5.4. Arranque directo<a class="headerlink" href="#arranque-directo" title="Enlazar permanentemente con este título">¶</a></h4>
<p>El núcleo de <em>debian</em> tiene <a class="reference external" href="https://wiki.archlinux.org/index.php/EFISTUB">EFIStub</a>, esto es, la
capacidad de ser cargado como un ejecutable directamente por el firmware <abbr title="Unified Extensible Firmware Interface">UEFI</abbr>,
sin necsidad de usar <abbr title="GRand Unified Bootloader">GRUB</abbr> u otro gestor de arranque. Ello supone copiar el
núcleo y el sistema de ficheros inicial (<em>initrd</em>) en la partición <abbr title="EFI System Partition">ESP</abbr> y, si
queremos que tanto lo uno como lo otro se actualicen al actualizar el núcleo,
añadir un par de <em>scripts</em>.</p>
<ol class="arabic">
<li><p class="first">Crear el <em>script</em> para automatizar la copia del núcleo en la partición
<abbr title="EFI System Partition">ESP</abbr>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> cat &gt; /etc/kernel/postinst.d/zz-update-efistub
<span class="gp">#</span>!/bin/sh

<span class="go">cp /vmlinuz /boot/efi/EFI/debian/</span>
</pre></div>
</div>
</li>
<li><p class="first">Crear el <em>script</em> para automatizar la copia del <em>initrd</em> en la partición
<abbr title="EFI System Partition">ESP</abbr>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> mkdir -p /etc/initramfs/post-update.d
<span class="gp">#</span> cat &gt; /etc/initramfs/post-update.d/zz-update-efistub
<span class="gp">#</span>!/bin/sh

<span class="go">cp /initrd.img /boot/efi/EFI/debian/</span>
</pre></div>
</div>
</li>
<li><p class="first">Copiar manualmente el núcleo y la imagen <em>initrd</em>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> /etc/kernel/postinst.d/zz-update-efistub
<span class="gp">#</span> /etc/initramfs/post-update.d/zz-update-efistub
</pre></div>
</div>
</li>
<li><p class="first">Añadir una entrada al menú de arranque <abbr title="Unified Extensible Firmware Interface">UEFI</abbr>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> efibootmgr -c -g -L <span class="s2">&quot;Debian </span><span class="k">$(</span>/etc/debian_version<span class="k">)</span><span class="s2">&quot;</span> -d /dev/sda -p2 -l /EFI/debian/vmlinuz <span class="se">\</span>
   -u <span class="s2">&quot;root=/dev/VGbuster/raiz ro quiet rootfstype=ext4 add_efi_memmap initrd=/EFI/debian/initrd.img&quot;</span>
</pre></div>
</div>
<p>donde se ha supuesto que la partición <abbr title="EFI System Partition">ESP</abbr> es <code class="file docutils literal notranslate"><span class="pre">/dev/sda2</span></code> y la raíz
del sistema se encuentra en el volumen <code class="file docutils literal notranslate"><span class="pre">/dev/VGbuster/raiz</span></code>.</p>
</li>
</ol>
<p class="rubric">Notas al pie</p>
<table class="docutils footnote" frame="void" id="id17" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td>Bien es cierto que, esto último, sólo en <abbr title="Basic I/O System">BIOS</abbr> más modernas. En
ordenadores muy, muy antiguos la única posibilidad de cambiar el dispositivo
de arranque es redefinir la secuencia.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id18" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[2]</a></td><td>EL direccionamiento de bloque lógico (<abbr title="Logical Block Addressing">LBA</abbr> por sus siglas en ingles)
consiste simplemente en asignarle un índice consecutivo a cada sector del
disco, empezando por 0.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id19" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3">[3]</a></td><td>El direccionamiento en los discos antiguos era <abbr title="Cylinder-Head-Sector">CHS</abbr> y cada cabezal
contenía 63 sectores, por lo que el primer sector del segunda cabezal es el
<strong>63</strong> (se empieza a numerar en <strong>0</strong>). Échele un ojo si tiene curiosidad
a <a class="reference external" href="https://es.wikipedia.org/wiki/Unidad_de_disco_duro#Estructura_f%C3%ADsica">este artículo de la Wikipedia</a>.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id20" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id4">[4]</a></td><td><p class="first">Para crear un fichero de un tamaño determinado hay tres alternativas:</p>
<ul class="last simple">
<li><strong class="command">truncate</strong>, que es la más eficiente ya que hace un
<a class="reference internal" href="03.virt.html#lvm-aprovisionamiento"><span class="std std-ref">aprovisionamiento fino</span></a> del espacio.</li>
<li><em class="manpage"><a class="manpage reference external" href="https://manpages.debian.org/fallocate(1)">fallocate(1)</a></em>, que reserva efectivamente los bloqies necesarios,
pero que no escribe en disco.</li>
<li><a class="reference internal" href="../../02.conbas/02.informacion/04.devices.html#dd"><span class="std std-ref">dd</span></a>, que puede usarse para escribir el tamaño deseado de ceros
(tomándolos de <code class="file docutils literal notranslate"><span class="pre">/dev/zero</span></code>) y que es el método menos recomendable, ya
que, además de ocupar todo el espacio, escribe en el disco los ceros; y es,
por tanto, el más lento.</li>
</ul>
</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id21" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id5">[5]</a></td><td>Es posible que después de alterar la tabla de particiones con <a class="reference internal" href="#fdisk"><span class="std std-ref">fdisk</span></a> o <a class="reference internal" href="#gdisk-i"><span class="std std-ref">gdisk</span></a> el <em>kernel</em> no actualice la tabla de
particiones porque haya algún proceso que lo impida, por ejemplo, porque hay
un sistema de ficheros montado o un <abbr title="Redundant Array of Inexpensive Disks">RAID</abbr> ensamblado. En esos caso, es
preciso primero, parar tal proceso y a continuación intentar releer la tabla
de particiones.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id22" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id6">[6]</a></td><td>Hasta la versión <em>2.25</em>, el propio <strong class="command">sfdisk</strong> suministraba una
opción <kbd class="kbd docutils literal notranslate">-I</kbd> para deshacer los cambios.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id23" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id8">[7]</a></td><td>Los códigos de 4 dígitos hexadecimales son códigos internos de la
de la suite de particionado <a class="reference internal" href="#gdisk-i"><span class="std std-ref">gdisk</span></a>. Los identificadores, en
realidad, son mucho más largos.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id24" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id9">[8]</a></td><td>En realidad, la especificación <abbr title="Unified Extensible Firmware Interface">UEFI</abbr> ni siquiera exige que la partición
sea de tipo <abbr title="EFI System Partition">ESP</abbr> y se limita a buscar una partición que entienda (<abbr title="File Allocation Table">FAT</abbr>).
Además, las entradas que se almacenan en la <abbr title="Non-Volatile RAM">NVRAM</abbr> indican cuál es la
partición de disco donde se encuentra el fichero a leer.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id25" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id10">[9]</a></td><td>En la implementación <abbr title="Unified Extensible Firmware Interface">UEFI</abbr> que traen algunos <em>softwares</em> de
virtualización (<a class="reference external" href="https://github.com/tianocore/tianocore.github.io/wiki/OVMF">OVMF</a>), la <abbr title="Non-Volatile RAM">NVRAM</abbr> se emula almacenando en el directorio
<code class="file docutils literal notranslate"><span class="pre">EFI</span></code> un fichero llamado <code class="file docutils literal notranslate"><span class="pre">NvVars</span></code>.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id26" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id11">[10]</a></td><td><p class="first">Por ejemplo, esta orden añade una nueva entrada:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> efibootmgr --create --disk /dev/sda --part <span class="m">2</span> --loader /EFI/so/bootx64.efi <span class="se">\</span>
   --label <span class="s2">&quot;Mi primer arranque UEFI&quot;</span>
</pre></div>
</div>
<p class="last">en la que se intenta cargar el fichero <code class="file docutils literal notranslate"><span class="pre">/EFI/so/bootx64.efi</span></code> y la que
se supone que la partición <abbr title="EFI System Partition">ESP</abbr> es la segunda del disco.</p>
</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id27" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id12">[11]</a></td><td>Para que un kernel de linux pueda arrancarse directamente es necesario
que se compile con la opción <a class="reference external" href="https://wiki.archlinux.org/index.php/EFISTUB">EFIStub</a>, disponible desde la versión 3.3.0.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id28" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id14">[12]</a></td><td>Utilizaremos el fichero de 20G que propusimos crear anteriormente para
estas pruebas.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id29" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id15">[13]</a></td><td>En realidad, si nuestra intención es arrancar mediante <abbr title="Unified Extensible Firmware Interface">UEFI</abbr> y partimos
de un particionado <abbr title="Disk Operating System">DOS</abbr>, la «Bios Boot Partition» es ya absolutamente
irrelevante y podemos prescindir de ella.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id30" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id16">[14]</a></td><td>Al menos en la máquina virtual en la que se han hecho las pruebas (<a class="reference external" href="https://www.linux-kvm.org/page/Main_Page">kvm</a>
cuyo implementación de <abbr title="Unified Extensible Firmware Interface">UEFI</abbr> es la de <a class="reference external" href="https://github.com/tianocore/tianocore.github.io/wiki/OVMF">OVMF</a>), si el equipo se apaga
(<a class="reference internal" href="../../02.conbas/01.preliminares/index.html#poweroff"><span class="std std-ref">poweroff</span></a>) tras el cambio, no se guarda la nueva entrada.</td></tr>
</tbody>
</table>
</div>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../../index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">5.1.2. Particiones</a><ul>
<li><a class="reference internal" href="#dos">5.1.2.1. <abbr title="Disk Operating System">DOS</abbr></a><ul>
<li><a class="reference internal" href="#el-bios-y-el-mbr">5.1.2.1.1. El <abbr title="Basic I/O System">BIOS</abbr> y el <abbr title="Master Boot Record">MBR</abbr></a></li>
<li><a class="reference internal" href="#descripcion">5.1.2.1.2. Descripción</a></li>
<li><a class="reference internal" href="#arranque">5.1.2.1.3. Arranque</a></li>
<li><a class="reference internal" href="#tipos-de-particiones">5.1.2.1.4. Tipos de particiones</a><ul>
<li><a class="reference internal" href="#particiones-primarias">5.1.2.1.4.1. Particiones primarias</a></li>
<li><a class="reference internal" href="#particiones-logicas">5.1.2.1.4.2. Particiones lógicas</a></li>
</ul>
</li>
<li><a class="reference internal" href="#limitaciones">5.1.2.1.5. Limitaciones</a></li>
<li><a class="reference internal" href="#practica">5.1.2.1.6. Práctica</a></li>
</ul>
</li>
<li><a class="reference internal" href="#gpt">5.1.2.2. <abbr title="GUID Partition Table">GPT</abbr></a><ul>
<li><a class="reference internal" href="#id7">5.1.2.2.1. Descripción</a></li>
<li><a class="reference internal" href="#bios">5.1.2.2.2. <abbr title="Basic I/O System">BIOS</abbr></a></li>
<li><a class="reference internal" href="#uefi">5.1.2.2.3. <abbr title="Unified Extensible Firmware Interface">UEFI</abbr></a></li>
<li><a class="reference internal" href="#arranque-hibrido">5.1.2.2.4. Arranque híbrido</a></li>
<li><a class="reference internal" href="#gdisk-i">5.1.2.2.5. Práctica</a><ul>
<li><a class="reference internal" href="#aplicaciones-de-terminal">5.1.2.2.5.1. Aplicaciones de terminal</a></li>
<li><a class="reference internal" href="#migracion-a-uefi">5.1.2.2.5.2. Migración a <abbr title="Unified Extensible Firmware Interface">UEFI</abbr></a></li>
<li><a class="reference internal" href="#entradas">5.1.2.2.5.3. Entradas</a></li>
<li><a class="reference internal" href="#arranque-directo">5.1.2.2.5.4. Arranque directo</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>Tema anterior</h4>
  <p class="topless"><a href="01.boot/06.grub.html"
                        title="capítulo anterior">5.1.1.4.2. <abbr>GRand Unified Bootloader</abbr></a></p>
  <h4>Próximo tema</h4>
  <p class="topless"><a href="03.virt.html"
                        title="próximo capítulo">5.1.3. Volúmenes lógicos</a></p>
  <div role="note" aria-label="source link">
    <h3>Esta página</h3>
    <ul class="this-page-menu">
      <li><a href="../../_sources/05.discos/01.division/02.part.rst.txt"
            rel="nofollow">Mostrar el código</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Búsqueda rápida</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Ir a" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navegación</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="Índice General"
             >índice</a></li>
        <li class="right" >
          <a href="03.virt.html" title="5.1.3. Volúmenes lógicos"
             >siguiente</a> |</li>
        <li class="right" >
          <a href="01.boot/06.grub.html" title="5.1.1.4.2. GRand Unified Bootloader"
             >anterior</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">documentación de Linuxnomicón - rolling</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" >5. Dispositivos de almacenamiento</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="index.html" >5.1. División del disco</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Derechos de autor CC BY 4.0, 2016-2020, José Miguel Sánchez Alés.
      Creado con <a href="http://sphinx-doc.org/">Sphinx</a> 1.8.5.
    </div>
  </body>
</html>