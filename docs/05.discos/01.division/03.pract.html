


<!DOCTYPE html>

<html lang="es">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />

    <title>5.1.3. Aplicacion práctica &#8212; documentación de Linuxnomicón - rolling</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/classic.css" />
    <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
    
    <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/sphinx_highlight.js"></script>
    <script src="../../_static/translations.js"></script>
    
    <link rel="index" title="Índice" href="../../genindex.html" />
    <link rel="search" title="Búsqueda" href="../../search.html" />
    <link rel="next" title="5.1.4. Volúmenes lógicos" href="04.virt.html" />
    <link rel="prev" title="5.1.2.2.2. GRUB." href="02.boot/06.grub.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navegación</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="Índice General"
             accesskey="I">índice</a></li>
        <li class="right" >
          <a href="04.virt.html" title="5.1.4. Volúmenes lógicos"
             accesskey="N">siguiente</a> |</li>
        <li class="right" >
          <a href="02.boot/06.grub.html" title="5.1.2.2.2. GRUB."
             accesskey="P">anterior</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">documentación de Linuxnomicón - rolling</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" ><span class="section-number">5. </span>Dispositivos de almacenamiento</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="index.html" accesskey="U"><span class="section-number">5.1. </span>División del disco</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href=""><span class="section-number">5.1.3. </span>Aplicacion práctica</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="aplicacion-practica">
<h1><span class="section-number">5.1.3. </span>Aplicacion práctica<a class="headerlink" href="#aplicacion-practica" title="Enlace permanente a este encabezado">¶</a></h1>
<p>Vistas las bases del particionado y el arranque, podemos ahora poner en práctica
los conceptos teóricos. Las principales aplicaciones de particionado en <em>LInux</em>
son:</p>
<table class="herr-part docutils align-default" id="id13">
<caption><span class="caption-text">Herramientas de particionado</span><a class="headerlink" href="#id13" title="Enlace permanente a esta tabla">¶</a></caption>
<thead>
<tr class="row-odd"><th class="head" rowspan="2"><p>Suite</p></th>
<th class="head" rowspan="2"><p>Ejecutable</p></th>
<th class="head" colspan="2"><p>Soporte</p></th>
<th class="head" rowspan="2"><p>Interfaz</p></th>
</tr>
<tr class="row-even"><th class="head"><p><abbr title="Disk Operating System">DOS</abbr></p></th>
<th class="head"><p><abbr title="GUID Partition Table">GPT</abbr></p></th>
</tr>
</thead>
<tbody>
<tr class="row-odd"><td rowspan="3"><p>fdisk</p></td>
<td><p>fdisk</p></td>
<td><p>Sí</p></td>
<td><p>Sí</p></td>
<td><p>Interactiva con menús.</p></td>
</tr>
<tr class="row-even"><td><p>sfdisk</p></td>
<td><p>Sí</p></td>
<td><p>Sí</p></td>
<td><p>Desasistida.</p></td>
</tr>
<tr class="row-odd"><td><p>cfdisk</p></td>
<td><p>Sí</p></td>
<td><p>Sí</p></td>
<td><p>Interactiva con ncurses.</p></td>
</tr>
<tr class="row-even"><td rowspan="3"><p><a class="reference internal" href="#gdisk-i"><span class="std std-ref">gdisk</span></a></p></td>
<td><p>gdisk</p></td>
<td><p>Sí</p></td>
<td><p>Sí</p></td>
<td><p>Interactiva con menús.</p></td>
</tr>
<tr class="row-odd"><td><p>sgdisk</p></td>
<td><p>Sí</p></td>
<td><p>Sí</p></td>
<td><p>Desasistida.</p></td>
</tr>
<tr class="row-even"><td><p>cgdisk</p></td>
<td><p>Sí</p></td>
<td><p>Sí</p></td>
<td><p>Interactiva con ncurses.</p></td>
</tr>
<tr class="row-odd"><td rowspan="2"><p><a class="reference external" href="https://www.gnu.org/software/parted/manual/parted.html">parted</a></p></td>
<td><p>parted</p></td>
<td><p>Sí</p></td>
<td><p>Sí</p></td>
<td><p>Interactiva, desasistida.</p></td>
</tr>
<tr class="row-even"><td><p>gparted</p></td>
<td><p>Sí</p></td>
<td><p>Sí</p></td>
<td><p>Gráfica.</p></td>
</tr>
</tbody>
</table>
<section id="particionado-dos">
<h2><span class="section-number">5.1.3.1. </span>Particionado <abbr title="Disk Operating System">DOS</abbr><a class="headerlink" href="#particionado-dos" title="Enlace permanente a este encabezado">¶</a></h2>
<p>Para llevar a cabo el particionado de disco con <em>Linux</em>, podemos usar distintas
herramientas:</p>
<ul class="simple">
<li><p><strong class="command">fdisk</strong>, que es la herramienta tradicional interactiva para interfaz
de texto. Es bastante sencilla de utilizar.</p></li>
<li><p><strong class="command">sfdisk</strong>. otra herramienta para línea de órdenes que permite su uso
desasistido y, en consecuencia, se presta a su inclusión en <em>scripts</em>.</p></li>
<li><p><a class="reference external" href="https://www.gnu.org/software/parted/manual/parted.html">parted</a>, que puede ser usada desde línea de órdenes, pero que habitualmente
se utiliza a través de su interfaz para <abbr title="Gimp ToolKit">GTK</abbr> <a class="reference external" href="https://gparted.org/">gparted</a>. No la trataremos en
esta guía.</p></li>
</ul>
<p class="rubric">Preliminares</p>
<span class="target" id="truncate"></span><p id="index-0">Es probable que, para hacer pruebas, no deseemos usar un disco real. En ese
caso, lo más cómodo es crear un fichero y trabajar sobre él<a class="footnote-reference brackets" href="#id7" id="id1" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a>. Por ejemplo:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>truncate<span class="w"> </span>-s<span class="w"> </span>20G<span class="w"> </span><span class="m">0</span>.disk
</pre></div>
</div>
<p>Esto creará un <a class="reference external" href="https://es.wikipedia.org/wiki/Archivo_disperso">fichero disperso</a> de 20G, que ocupa de forma
efectiva sólo el espacio que ocupe su contenido (en principio, nada).</p>
<p>Otro aspecto a tener presente son los permisos de los dispositivos.
Habitualmente son estos:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>ls<span class="w"> </span>-l<span class="w"> </span>/dev/sda
<span class="go">brw-rw---- 1 root disk 8, 0 nov 17 11:49 /dev/sda</span>
</pre></div>
</div>
<p>En consecuencia, sólo el administrador o un usuario que pertenezca al grupo
<em>disk</em> será capaz de leer y escribir directamente sobre ellos.</p>
<div class="admonition warning">
<p class="admonition-title">Advertencia</p>
<p>Para ilustrar el uso de las órdenes usaremos un usuario sin
privilegios y el fichero creado anteriormente y no un dispositivo de
almacenamiento. Tenga presente que lo habitual es usar <code class="file docutils literal notranslate"><span class="pre">/dev/sda</span></code>,
<code class="file docutils literal notranslate"><span class="pre">/dev/sdb</span></code>, etc. y que esta labor la lleve a cabo directamente el
administrador.</p>
</div>
<p class="rubric">Consulta</p>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>Las herramientas son también válidas, aunque utilicemos particionado
<abbr title="GUID Partition Table">GPT</abbr>.</p>
</div>
<p>Antes de manipular los dispositivos, es útil saber qué herramientas de consulta
tenemos para conocer cómo se encuentra dividido el disco. Es preciso, además,
hacer una aclaración: el sistema carga las particiones en memoria y procura
actualizarlas cuando se produce un cambio. En ocasiones, esta actualización no
se produce, bien porque el sistema es incapaz de hacerla, bien porque se ha
llevado a cabo de una manera poco ortodoxa, como por ejemplo, copiando con
<a class="reference internal" href="../../02.conbas/02.informacion/04.devices.html#dd"><span class="std std-ref">dd</span></a> el <abbr title="Master Boot Record">MBR</abbr> de otro disco.</p>
<p>La primera de ellas es, simplemente, consultar cuáles son las particiones
registradas en el fichero <code class="file docutils literal notranslate"><span class="pre">/proc/particions</span></code>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>cat<span class="w"> </span>/proc/particions
<span class="go">major minor  #blocks  name</span>

<span class="go">   8        0  117220824 sda</span>
<span class="go">   8        1      32098 sda1</span>
<span class="go">   8        2   62109696 sda2</span>
<span class="go">   8        3          1 sda3</span>
<span class="go">   8        5   20971520 sda5</span>
<span class="go">   8        6    2097152 sda6</span>
<span class="go">   8        7   32006616 sda7</span>
<span class="go">   8       16  976762584 sdb</span>
<span class="go">   8       17  976759808 sdb1</span>
</pre></div>
</div>
<p>La consulta puede llevarla a cabo cualquier usuario y muestra las particiones
físicas (no los volúmenes lógicos) registrados por el sistema.</p>
<span class="target" id="lsblk"></span><p id="index-1">Una alternativa es <strong class="command">lsblk</strong> que muestra más información e incluye
volúmenes lógicos y el punto de montaje, en caso de que su sistema de ficheros
esté montado:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>/sbin/lsblk<span class="w"> </span>/dev/sda
<span class="go">NAME              MAJ:MIN RM   SIZE RO TYPE MOUNTPOINT</span>
<span class="go">sda                 8:0    0 111,8G  0 disk</span>
<span class="go">├─sda1              8:1    0  31,4M  0 part /boot/grub</span>
<span class="go">├─sda2              8:2    0  59,2G  0 part</span>
<span class="go">├─sda3              8:3    0     1K  0 part</span>
<span class="go">├─sda5              8:5    0    20G  0 part /</span>
<span class="go">├─sda6              8:6    0     2G  0 part [SWAP]</span>
<span class="go">└─sda7              8:7    0  30,5G  0 part /home</span>
</pre></div>
</div>
<span class="target" id="blkid"></span><p id="index-2">También puede usarse, aunque como administrador, <strong class="command">blkid</strong> que sirve para
obtener más información de los sistemas de ficheros de cada división:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp"># </span>blkid<span class="w"> </span>/dev/sda*
<span class="go">/dev/sda: PTUUID=&quot;b94dda9b&quot; PTTYPE=&quot;dos&quot;</span>
<span class="go">/dev/sda1: LABEL=&quot;GRUB&quot; UUID=&quot;0bdcc04e-e267-4aa4-b8ec-1bea18e83f87&quot; TYPE=&quot;ext4&quot; PARTUUID=&quot;b94dda9b-01&quot;</span>
<span class="go">/dev/sda2: UUID=&quot;B0007B1D007AEA2C&quot; TYPE=&quot;ntfs&quot; PARTUUID=&quot;b94dda9b-02&quot;</span>
<span class="go">/dev/sda3: PTTYPE=&quot;dos&quot; PARTUUID=&quot;b94dda9b-03&quot;</span>
<span class="go">/dev/sda5: LABEL=&quot;BASE&quot; UUID=&quot;38c84f19-da83-4132-9c0c-e8dbd0763d7c&quot; TYPE=&quot;ext4&quot; PARTUUID=&quot;b94dda9b-05&quot;</span>
<span class="go">/dev/sda6: UUID=&quot;4b34fe7e-f7fb-4fd5-8e64-49d0d7f9418a&quot; TYPE=&quot;swap&quot; PARTUUID=&quot;b94dda9b-06&quot;</span>
<span class="go">/dev/sda7: LABEL=&quot;HOME&quot; UUID=&quot;2bee799a-740b-4106-90ad-d9a155d85afe&quot; TYPE=&quot;ext4&quot; PARTUUID=&quot;b94dda9b-07&quot;</span>
</pre></div>
</div>
<p>Si no se especifican las divisiones, mostrará todos. La orden, además, permite
filtrar por valores y manipular la salida. Por ejemplo, la orden:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp"># </span>blkid<span class="w"> </span>-t<span class="w"> </span><span class="nv">TYPE</span><span class="o">=</span>ext4<span class="w"> </span>-s<span class="w"> </span>LABEL<span class="w"> </span>-o<span class="w"> </span>value<span class="w"> </span>/dev/sda*
<span class="go">GRUB</span>
<span class="go">BASE</span>
<span class="go">HOME</span>
</pre></div>
</div>
<p>muestra de los dispositivos formateados en <em>ext4</em>, el valor de su etiqueta.
Consulte la página del manual para más información.</p>
<span class="target" id="blockdev"></span><p id="index-3">Complementaria de las anteriores es <strong class="command">blockdev</strong>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp"># </span>blockdev<span class="w"> </span>--report<span class="w"> </span>/dev/sda*
<span class="go">RO    RA   SSZ   BSZ   PrimerSec           Tam.   Dispo.</span>
<span class="go">rw   256   512  4096          0    120034123776   /dev/sda</span>
<span class="go">rw   256   512  1024         63        32868864   /dev/sda1</span>
<span class="go">rw   256   512  4096      65536     63600328704   /dev/sda2</span>
<span class="go">rw   256   512  1024  124286974            1024   /dev/sda3</span>
<span class="go">rw   256   512  4096  124286976     21474836480   /dev/sda5</span>
<span class="go">rw   256   512  4096  166232064      2147483648   /dev/sda6</span>
<span class="go">rw   256   512  4096  170428416     32774774784   /dev/sda7</span>
</pre></div>
</div>
<p>que, como la anterior, permite definir la salida. Por ejemplo:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp"># </span>blockdev<span class="w"> </span>--getsize64<span class="w"> </span>/dev/sda
<span class="go">120034123776</span>
</pre></div>
</div>
<p>devuelve el tamaño del disco en <em>bytes</em>. También es útil para forzar al kernel
a releer la tabla de particiones del dispositivo<a class="footnote-reference brackets" href="#id8" id="id2" role="doc-noteref"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></a>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp"># </span>blockdev<span class="w"> </span>--rereadpt<span class="w"> </span>/dev/sda
</pre></div>
</div>
<p>La última posibilidad es usar las herramientas de manipulación de la tabla de
particiones (<a class="reference internal" href="#fdisk"><span class="std std-ref">fdisk</span></a> o <a class="reference internal" href="#gdisk-i"><span class="std std-ref">gdisk</span></a>) para leerla:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp"># </span>fdisk<span class="w"> </span>-l<span class="w"> </span>/dev/sda
<span class="go">Disco /dev/sda: 111,81 GiB, 120034123776 bytes, 234441648 sectores</span>
<span class="go">Modelo de disco: Intenso  SSD Sat</span>
<span class="go">Unidades: sectores de 1 * 512 = 512 bytes</span>
<span class="go">Tamaño de sector (lógico/físico): 512 bytes / 512 bytes</span>
<span class="go">Tamaño de E/S (mínimo/óptimo): 512 bytes / 512 bytes</span>
<span class="hll"><span class="go">Tipo de etiqueta de disco: dos</span>
</span><span class="go">Identificador del disco: 0xb94dda9b</span>

<span class="go">Disposit.  Inicio  Comienzo     Final  Sectores Tamaño Id Tipo</span>
<span class="go">/dev/sda1                63     64259     64197  31,4M 83 Linux</span>
<span class="hll"><span class="go">/dev/sda2  *          65536 124284927 124219392  59,2G  7 HPFS/NTFS/exFAT</span>
</span><span class="go">/dev/sda3         124286974 234441647 110154674  52,5G  5 Extendida</span>
<span class="go">/dev/sda5         124286976 166230015  41943040    20G 83 Linux</span>
<span class="go">/dev/sda6         166232064 170426367   4194304     2G 82 Linux swap / Solaris</span>
<span class="go">/dev/sda7         170428416 234441647  64013232  30,5G 83 Linux</span>
</pre></div>
</div>
<p>con la que podemos comprobar que <code class="file docutils literal notranslate"><span class="pre">sda</span></code> utliza particionado <abbr title="Disk Operating System">DOS</abbr>.</p>
<span class="target" id="fdisk"></span><p class="rubric" id="index-4">fdisk</p>
<p><strong class="command">fdisk</strong> es la orden tradicional para el particionado de discos. Es
interactiva y exige que el usuario vaya escogiendo qué acción en la que quiere
hacer. Pese a ello, se puede consultar directamente la tabla de particiones sin
entrar en su entorno:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>/sbin/fdisk<span class="w"> </span>-l<span class="w"> </span><span class="m">0</span>.disk
<span class="go">Disco 0.disk: 20 GiB, 21474836480 bytes, 41943040 sectores</span>
<span class="go">Unidades: sectores de 1 * 512 = 512 bytes</span>
<span class="go">Tamaño de sector (lógico/físico): 512 bytes / 512 bytes</span>
<span class="go">Tamaño de E/S (mínimo/óptimo): 512 bytes / 512 bytes</span>
</pre></div>
</div>
<p>Nuestro disco (disco-fichero, en realidad) está completamente vacío, por lo que
no dispone siquiera de una tabla de particiones.</p>
<p>Para manipular las particiones (crearlas en este caso) basta con indicar el
disco sobre el que se quiere actuar:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>/sbin/fdisk<span class="w"> </span><span class="m">0</span>.disk
<span class="go">[...]</span>
<span class="go">Orden (m para obtener ayuda):</span>
</pre></div>
</div>
<p>El uso es bastante sencillo, ya que es totalmente guiado. Creemos una única
partición que ocupe todo el disco:</p>
<script id="asciicast-89vbH0bhb6NmVsoh7ctooVxIO"
src="https://asciinema.org/a/89vbH0bhb6NmVsoh7ctooVxIO.js" async></script><span class="target" id="sfdisk"></span><p class="rubric" id="index-5">sfdisk</p>
<p>A diferencia de la orden anterior, <strong class="command">sfdisk</strong> se usa directamente
incorporando argumentos en línea o pasando la tabla de particiones por la
entrada estándar. Para consultar la tabla de particiones, se utiliza la misma
sintaxis que <a class="reference internal" href="#fdisk"><span class="std std-ref">fdisk</span></a>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>/sbin/sfdisk<span class="w"> </span>-l<span class="w"> </span><span class="m">0</span>.disk
</pre></div>
</div>
<p>La forma más sencilla de crear una tabla de particiones es copiar una ya
existente de otro disco:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp"># </span>sfdisk<span class="w"> </span>-d<span class="w"> </span>/dev/sda<span class="w"> </span><span class="p">|</span><span class="w"> </span>sfdisk<span class="w"> </span>/dev/sdb
</pre></div>
</div>
<p>Es posible también crear una tabla <em>ex novo</em>. Para ello basta con saber que se
puede incluir líneas iniciales que indican las características del particionado
y líneas posteriores que definen cada partición. Las iniciales tienen el formato
«campo: valor»; y las siguientes, cuatro campos separados por espacios o comas:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>sector_inicial,tamaño_en_sectores,codigo_tipo_ficheros,[*|-]
</pre></div>
</div>
<p>El valor predeterminado para el sector inicial es utilizar el primer sector
disponible; el del tamaño, ocupar el máximo posible; el valor para el tipo, «L»
(un alias para partición tipo linux); y el valor para activa, que no lo sea. Por
ejemplo:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>/sbin/sfdisk<span class="w"> </span><span class="m">0</span>.disk<span class="w"> </span>&lt;&lt;EOF
<span class="go">label: dos</span>
<span class="go">,$((32*1024**2/512)),L,*</span>
<span class="go">,,E</span>
<span class="go">,$((2*1024**3/512)),7</span>
<span class="go">,$((1*1024**3/512)),82</span>
<span class="go">,,L</span>
<span class="go">EOF</span>
</pre></div>
</div>
<p>Lo que hemos hecho es:</p>
<ul>
<li><p>Generar una primera partición de 32MB de tipo <em>Linux</em> que es la activa. Como
la alineación es de 1MB y no se ha especificado el sector inicial, este será el
2048, que deja justamente 1MB antes.</p></li>
<li><p>A continuación, se crea una partición extendida («E» es un alias para el código
correspondiente) que ocupa el resto del disco.</p></li>
<li><p>Lo siguiente es una partición lógica de 2GB de tipo NTFS.</p>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>Para saber cuáles son los códigos de los tipos de partición puede
hacerse:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>/sbin/sfdisk<span class="w"> </span>-TXdos
</pre></div>
</div>
</div>
</li>
<li><p>Una partición de 1GB para swap.</p></li>
<li><p>Una partición de <em>Linux</em> que ocupa el resto de la extendida (o sea, el resto
del disco).</p></li>
</ul>
<p>La salida de la orden nos debería mostrar las particiones resultantes.</p>
<p>Además, de crear tablas completas, podemos modificar la ya existente gracias a
la opción <kbd class="kbd docutils literal notranslate">-N</kbd>. Por ejemplo, la orden:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span><span class="nb">echo</span><span class="w"> </span><span class="s2">&quot;,,L,-&quot;</span><span class="w"> </span><span class="p">|</span><span class="w"> </span>/sbin/sfdisk<span class="w"> </span>-N1<span class="w"> </span><span class="m">0</span>.disk
</pre></div>
</div>
<p>deja todo como está, pero desactivando la partición. También es posible añadir
más particiones usando como argumento de <kbd class="kbd docutils literal notranslate">-N</kbd> índices de particiones que no
existan.</p>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>Como las últimas versiones de las órdenes <strong class="command">*fdisk</strong> soportan
particionado <abbr title="GUID Partition Table">GPT</abbr>, <strong class="command">sfdisk</strong> puede usarse también para crear una
tabla de particiones de este tipo:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>/sbin/sfdisk<span class="w"> </span><span class="m">0</span>.disk<span class="w"> </span>&lt;&lt;EOF
<span class="go">label: gpt</span>
<span class="go">,$((50*1024**2/512)),U,</span>
<span class="go">,$((2*1024**3/512)),L,</span>
<span class="go">,$((1*1024**3/512)),0657FD6D-A4AB-43C4-84E5-0933C84B4F4F,</span>
<span class="go">,,EBD0A0A2-B9E5-4433-87C0-68B6B72699C7,</span>
<span class="go">EOF</span>
</pre></div>
</div>
<p>Ciertamente los códigos en particiones <abbr title="GUID Partition Table">GPT</abbr> son bastante complicados. No
daremos más explicaciones porque aún no hemos discutido cómo son estas
particiones.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>En las operaciones anteriores de modificación de la tabla de particiones,
podemos incluir la opción <code class="docutils literal notranslate"><span class="pre">-b</span></code> para hacer una copia de los sectores
afectados por nuestras modificaciones. Si algo saliera mal, podríamos volver
al estado anterior con <a class="reference internal" href="../../02.conbas/02.informacion/04.devices.html#dd"><span class="std std-ref">dd</span></a><a class="footnote-reference brackets" href="#id9" id="id3" role="doc-noteref"><span class="fn-bracket">[</span>3<span class="fn-bracket">]</span></a>.</p>
</div>
</section>
<section id="particionado-gpt">
<span id="gdisk-i"></span><h2><span class="section-number">5.1.3.2. </span>Particionado <abbr title="GUID Partition Table">GPT</abbr><a class="headerlink" href="#particionado-gpt" title="Enlace permanente a este encabezado">¶</a></h2>
<section id="aplicaciones-de-terminal">
<h3><span class="section-number">5.1.3.2.1. </span>Aplicaciones de terminal<a class="headerlink" href="#aplicaciones-de-terminal" title="Enlace permanente a este encabezado">¶</a></h3>
<div class="admonition warning">
<p class="admonition-title">Advertencia</p>
<p>Las particiones «<em>UNO</em>», «<em>DOS</em>», «<em>TRES</em>» que aparecen en los
ejemplos son absolutamente inútiles en un sistema real y sirven tan sólo para
ilustrar el uso de las herramiestas. Más allá de las particiones de arranque,
deberá ser usted quién decida cómo debe particionar el sistema. Una propuesta
se encuentra el el epígrafe dedicado a la <a class="reference internal" href="../99.instalacion/index.html#inst-servidor"><span class="std std-ref">instalación del servidor</span></a>.</p>
</div>
<p>Para manejar <abbr title="GUID Partition Table">GPT</abbr> usaremos las herramientas de las suite <strong class="program">gdisk</strong>,
aunque desde hace un tiempo las de la suite <strong class="program">fdisk</strong> también son
compatibles.</p>
<p class="rubric" id="index-6">gdisk</p>
<p>La herramienta es prácticamente clónica de <a class="reference internal" href="#fdisk"><span class="std std-ref">fdisk</span></a>, aunque incluye
algunas posibilidades más para <abbr title="GUID Partition Table">GPT</abbr> en las opciones avanzadas.</p>
<span class="target" id="sgdisk"></span><p class="rubric" id="index-7">sgdisk</p>
<p>El programa permite la creación y manipulación de tablas de particiones
utilizando argumentos en la línea de órdenes, por lo que su filosofia es la
misma que la de <a class="reference internal" href="#sfdisk"><span class="std std-ref">sfdisk</span></a>. Pese a ello, tiene una sintaxis
totalmente distinta.</p>
<p>Para ilustrar su uso, recrearemos tres veces la tabla de particiones que hicimos
con <a class="reference internal" href="#sfdisk"><span class="std std-ref">sfdisk</span></a>, aunque con algunas variantes:</p>
<ul class="simple">
<li><p>Una primera vez, prepararemos el disco para que sea arrancable mediante
<abbr title="Basic I/O System">BIOS</abbr>. Para ello añadiremos una primera partición de tipo «BIOS Boot
Particion» para que pueda instalarse <abbr title="GRand Unified Bootloader">GRUB</abbr>.  Por supuesto, no tiene sentido
la marca de activa, ni la partición extendida.</p></li>
<li><p>La segunda vez, prepararemos el disco para <abbr title="Unified Extensible Firmware Interface">UEFI</abbr> con lo que también tendremos
que añadir una primera partición, pero <abbr title="Extensible Firmware Interface">EFI</abbr> en este caso.</p></li>
<li><p>La ultima la tabla de particiones está preparada tanto para arrancar en modo
<abbr title="Basic I/O System">BIOS</abbr> como en modo <abbr title="Unified Extensible Firmware Interface">UEFI</abbr>, lo cual exige presentar ambas particiones.</p></li>
</ul>
<table class="tipos-arranques docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Tipo</p></th>
<th class="head"><p>BIOS Boot</p></th>
<th class="head"><p><abbr title="EFI System Partition">ESP</abbr></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><abbr title="Basic I/O System">BIOS</abbr></p></td>
<td><p>Sí</p></td>
<td><p>No</p></td>
</tr>
<tr class="row-odd"><td><p><abbr title="Unified Extensible Firmware Interface">UEFI</abbr></p></td>
<td><p>No</p></td>
<td><p>Sí</p></td>
</tr>
<tr class="row-even"><td><p>Híbrido</p></td>
<td><p>Sí</p></td>
<td><p>Sí</p></td>
</tr>
</tbody>
</table>
<p>Empecemos, simplemente, por consultar la tabla de particiones<a class="footnote-reference brackets" href="#id10" id="id4" role="doc-noteref"><span class="fn-bracket">[</span>4<span class="fn-bracket">]</span></a>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>/sbin/sgdisk<span class="w"> </span>-p<span class="w"> </span>/tmp/0.disk
<span class="go">Creating new GPT entries in memory.</span>
<span class="go">Disk /tmp/0.disk: 41943040 sectors, 20.0 GiB</span>
<span class="go">Sector size (logical): 512 bytes</span>
<span class="go">Disk identifier (GUID): 97F6B136-94D6-4393-9348-47F3F5DB70F6</span>
<span class="go">Partition table holds up to 128 entries</span>
<span class="go">Main partition table begins at sector 2 and ends at sector 33</span>
<span class="go">First usable sector is 34, last usable sector is 41943006</span>
<span class="go">Partitions will be aligned on 2048-sector boundaries</span>
<span class="go">Total free space is 41942973 sectors (20.0 GiB)</span>

<span class="go">Number  Start (sector)    End (sector)  Size       Code  Name</span>
</pre></div>
</div>
<p>El disco no tiene aún ninguna tabla, por lo que aparece vacía. Es interesante de
la información lo siguiente:</p>
<ul>
<li><p><strong class="command">sgdisk</strong> de crear una tabla la crearía del modo estándar que
describimos anteriormente por lo que será capaz de describir 128 particiones.</p></li>
<li><p>Teóricamente el primer sector para incluirlo dentro de una partición es el 34,
ya que eso deja 17KiB por delante que es lo necesario para almacenar el <abbr title="Master Boot Record">MBR</abbr>
(512 <em>bytes</em>), la cabecera <abbr title="GUID Partition Table">GPT</abbr> (otros 512 <em>bytes</em>) y la propia <abbr title="GUID Partition Table">GPT</abbr>
(16KiB):</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>/sbin/sgdisk<span class="w"> </span>-f<span class="w"> </span>/tmp/0.disk
<span class="go">Creating new GPT entries in memory.</span>
<span class="go">34</span>
</pre></div>
</div>
</li>
<li><p>La alineación si no se cambia, será de 1MiB (2048 sectores):</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>/sbin/sgdisk<span class="w"> </span>-D<span class="w"> </span>/tmp/0.disk
<span class="go">Creating new GPT entries in memory.</span>
<span class="go">2048</span>
</pre></div>
</div>
<p>lo que determina que en realidad la primera partición empiece en el sector
2048:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>/sbin/sgdisk<span class="w"> </span>-F<span class="w"> </span>/tmp/0.disk
<span class="go">Creating new GPT entries in memory.</span>
<span class="go">2048</span>
</pre></div>
</div>
</li>
</ul>
<p>En un dispositivos que queremos que sea arrancable, se nos pueden presentar tres
casos de particionado:</p>
<ol class="loweralpha">
<li><p><abbr title="GUID Partition Table">GPT</abbr> exclusivamente compatible con <abbr title="Basic I/O System">BIOS</abbr>, que podemos definir así:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>/sbin/sgdisk<span class="w"> </span>-a<span class="w"> </span><span class="m">8</span><span class="w"> </span>-n<span class="w"> </span><span class="s2">&quot;0:40:2047&quot;</span><span class="w"> </span>-t<span class="w"> </span><span class="s2">&quot;0:0xef02&quot;</span><span class="w"> </span>-c<span class="w"> </span><span class="s2">&quot;0:BOOTBIOS&quot;</span><span class="w"> </span><span class="se">\</span>
<span class="w">               </span>-a<span class="w"> </span><span class="m">2048</span><span class="w"> </span>-n<span class="w"> </span><span class="s2">&quot;0:+0:+32M&quot;</span><span class="w"> </span>-c<span class="w"> </span><span class="s2">&quot;0:UNO&quot;</span><span class="w"> </span><span class="se">\</span>
<span class="w">                       </span>-n<span class="w"> </span><span class="s2">&quot;0:+0:+2G&quot;</span><span class="w"> </span>-t<span class="w"> </span><span class="s2">&quot;0:0x0700&quot;</span><span class="w"> </span>-c<span class="w"> </span><span class="s2">&quot;0:DOS&quot;</span><span class="w"> </span><span class="se">\</span>
<span class="w">                       </span>-n<span class="w"> </span><span class="s2">&quot;0:+0:+1G&quot;</span><span class="w"> </span>-c<span class="w"> </span><span class="s2">&quot;0:TRES&quot;</span><span class="w"> </span>/tmp/0.disk
</pre></div>
</div>
<p>en donde:</p>
<ul>
<li><p>Creamos la primera partición en el espacio entre el final de la <abbr title="GUID Partition Table">GPT</abbr> y
la segunda partición que realmente necesitamos y que sí estará
convenientemente alineada. Sólo se leerá esta primera partición al arrancar el
disco y se escribirá al reinstalar <abbr title="GRand Unified Bootloader">GRUB</abbr> con lo cual no es muy importante su
alineamiento. Aún así la hacemos cumpliendo la alineación de 4KiB. Para
cambiar la alineación usamos la opción <kbd class="kbd docutils literal notranslate">-a</kbd>.</p></li>
<li><p>Se definen las particiones añadiendo sendas opciones <kbd class="kbd docutils literal notranslate">-n</kbd> para indicar el
comienzo y fin de la partición, <kbd class="kbd docutils literal notranslate">-c</kbd> para indicar un nombre de etiqueta
y, si la partición no es <em>Linux</em> (<em>0x8300</em>), <kbd class="kbd docutils literal notranslate">-t</kbd>.</p></li>
<li><p>Las opciones anteriores necesitan que se especifique el número de la
partición, pero «0» representa el primer número disponible.</p></li>
<li><p>Los números para comienzos y finales sin indicar unidad son sectores; y es
lícito anteponerles un signo «+» para representar número relativos al
anterior.</p></li>
<li><p>Las definiciones no sobreescriben una tabla anterior, de modo que si
hiciéramos:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>/sbin/sgdisk<span class="w"> </span>-N<span class="w"> </span><span class="m">0</span><span class="w"> </span>-c<span class="w"> </span><span class="s2">&quot;5:RESTO&quot;</span>
</pre></div>
</div>
<p>añadiríamos a continuación una quinta partición que ocuparía lo que quede de
disco, ya que <kbd class="kbd docutils literal notranslate">-N</kbd> tiene el efecto de ocupar el espacio restante. Ahora
bien, si utilizamos el número de una partición existente, entonces
redefiniremos esa partición:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>/sbin/sgdisk<span class="w"> </span>-c<span class="w"> </span><span class="s2">&quot;3:TERCERA&quot;</span><span class="w"> </span>-t<span class="w"> </span><span class="s2">&quot;3:0x0700&quot;</span><span class="w"> </span>/tmp/0.disk
</pre></div>
</div>
</li>
</ul>
<div class="admonition warning">
<p class="admonition-title">Advertencia</p>
<p>Sopese utilizar el esquema propuesto para que sea compatible
también con <abbr title="Unified Extensible Firmware Interface">UEFI</abbr>, por si se produce un cambio en el <em>hardware</em>.</p>
</div>
</li>
<li><p>Tabla de particiones <abbr title="GUID Partition Table">GPT</abbr> exclusivamente compatible con <abbr title="Unified Extensible Firmware Interface">UEFI</abbr>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>/sbin/sgdisk<span class="w"> </span>-n<span class="w"> </span><span class="s2">&quot;0:2048:+100M&quot;</span><span class="w"> </span>-t<span class="w"> </span><span class="s2">&quot;0:0xef00&quot;</span><span class="w"> </span>-c<span class="w"> </span><span class="s2">&quot;0:EFI&quot;</span><span class="w"> </span><span class="se">\</span>
<span class="w">               </span>-n<span class="w"> </span><span class="s2">&quot;0:+0:+32M&quot;</span><span class="w"> </span>-c<span class="w"> </span><span class="s2">&quot;0:UNO&quot;</span><span class="w"> </span><span class="se">\</span>
<span class="w">               </span>-n<span class="w"> </span><span class="s2">&quot;0:+0:+2G&quot;</span><span class="w"> </span>-t<span class="w"> </span><span class="s2">&quot;0:0x0700&quot;</span><span class="w"> </span>-c<span class="w"> </span><span class="s2">&quot;0:DOS&quot;</span><span class="w"> </span><span class="se">\</span>
<span class="w">               </span>-n<span class="w"> </span><span class="s2">&quot;0:+0:+1G&quot;</span><span class="w"> </span>-c<span class="w"> </span><span class="s2">&quot;0:TRES&quot;</span><span class="w"> </span>/tmp/0.disk
</pre></div>
</div>
<p>En este caso, la partición <abbr title="Extensible Firmware Interface">EFI</abbr> debe ser lo suficientemente grande para
albergar los arranques de los sistemas operativos que pretendeamos instalar. En
principio, con 50M o 100M debería bastar. Dado el tamaño de esta partición, no
nos molestamos siquiera en aprovechar el espacio anterior al sector 2048.</p>
</li>
<li><p>Tabla de particiones <abbr title="GUID Partition Table">GPT</abbr> compatible tanto con <abbr title="Basic I/O System">BIOS</abbr> como con <abbr title="Unified Extensible Firmware Interface">UEFI</abbr>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>/sbin/sgdisk<span class="w"> </span>-a<span class="w"> </span><span class="m">8</span><span class="w"> </span>-n<span class="w"> </span><span class="s2">&quot;0:40:2047&quot;</span><span class="w"> </span>-t<span class="w"> </span><span class="s2">&quot;0:0xef02&quot;</span><span class="w"> </span>-c<span class="w"> </span><span class="s2">&quot;0:BOOTBIOS&quot;</span><span class="w"> </span><span class="se">\</span>
<span class="w">               </span>-a<span class="w"> </span><span class="m">2048</span><span class="w"> </span>-n<span class="w"> </span><span class="s2">&quot;0:2048:+100M&quot;</span><span class="w"> </span>-t<span class="w"> </span><span class="s2">&quot;0:0xef00&quot;</span><span class="w"> </span>-c<span class="w"> </span><span class="s2">&quot;0:EFI&quot;</span><span class="w"> </span><span class="se">\</span>
<span class="w">                       </span>-n<span class="w"> </span><span class="s2">&quot;0:+0:+32M&quot;</span><span class="w"> </span>-c<span class="w"> </span><span class="s2">&quot;0:UNO&quot;</span><span class="w"> </span><span class="se">\</span>
<span class="w">                       </span>-n<span class="w"> </span><span class="s2">&quot;0:+0:+2G&quot;</span><span class="w"> </span>-t<span class="w"> </span><span class="s2">&quot;0:0x0700&quot;</span><span class="w"> </span>-c<span class="w"> </span><span class="s2">&quot;0:DOS&quot;</span><span class="w"> </span><span class="se">\</span>
<span class="w">                       </span>-n<span class="w"> </span><span class="s2">&quot;0:+0:+1G&quot;</span><span class="w"> </span>-c<span class="w"> </span><span class="s2">&quot;0:TRES&quot;</span><span class="w"> </span>/tmp/0.disk
</pre></div>
</div>
<p>En este caso, la finalidad no es tanto que el sistema sea capaz de arrancar
con ambos <em>firmwares</em> (cosa que también se puede hacer) como que arrancando
en <abbr title="Basic I/O System">BIOS</abbr> pueda hacer una migración sencilla a arranque <abbr title="Unified Extensible Firmware Interface">UEFI</abbr>. Para lograr
esto último, consulte el <a class="reference internal" href="#bios-uefi"><span class="std std-ref">último apartado sobre migración a UEFI</span></a>.</p>
</li>
</ol>
<p>Otras acciones recurrentes con <strong class="command">sgdisk</strong> son:</p>
<ol class="arabic">
<li><p>Borrar una partición:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>/sbin/sgdisk<span class="w"> </span>-d<span class="w"> </span><span class="m">5</span><span class="w"> </span>/tmp/0.disk
</pre></div>
</div>
</li>
<li><p>Intercambiar la entrada de una partición por la de otra:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>/sbin/sgdisk<span class="w"> </span>-r<span class="w"> </span><span class="m">1</span>:3<span class="w"> </span>/tmp/0.disk
</pre></div>
</div>
<p>En este caso la partición primera partición pasa a estar definida en la
tercera entrada de la <abbr title="GUID Partition Table">GPT</abbr>, y la tercera, en la primera.</p>
</li>
<li><p>Copiar la <abbr title="GUID Partition Table">GPT</abbr> al final del disco, que puede sernos útil cuando hacemos una
copia cruda de un disco más pequeño en uno mayor:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>/sbin/sgdisk<span class="w"> </span>-e<span class="w"> </span>/tmp/0.disk
</pre></div>
</div>
</li>
<li><p>Copiar la tabla de particiones en un nuevo disco:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>/sbin/sgdisk<span class="w"> </span>-R<span class="w"> </span>/tmp/1.disk<span class="w"> </span>/tmp/0.disk
<span class="gp">$ </span>/sbin/sgdisk<span class="w"> </span>-G<span class="w"> </span>/tmp/1.disk
</pre></div>
</div>
<p>La segunda instrucción es necesaria para que cambien los UIDs de las
particiones en el segundo disco, ya que la copia que se hace de la <abbr title="GUID Partition Table">GPT</abbr> es
exacta.</p>
</li>
<li><p>Copiar la <abbr title="GUID Partition Table">GPT</abbr> en un fichero llamado <code class="file docutils literal notranslate"><span class="pre">GPT</span></code>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>/sbin/sgdisk<span class="w"> </span>-b<span class="w"> </span>GPT<span class="w"> </span>/tmp/0.disk
</pre></div>
</div>
<p>Y si se quiere restaurar en disco:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>/sbin/sgdisk<span class="w"> </span>-l<span class="w"> </span>GPT<span class="w"> </span>/tmp/0.disk
</pre></div>
</div>
</li>
<li><p>Borrar la tabla de particiones y la cabecera <abbr title="GUID Partition Table">GPT</abbr>, pero
respetando el <abbr title="Master Boot Record">MBR</abbr>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>/sbin/sgdisk<span class="w"> </span>-z<span class="w"> </span>/tmp/0.disk
</pre></div>
</div>
<p>o sin siquiera respetarlo:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>/sbin/sgdisk<span class="w"> </span>-Z<span class="w"> </span>/tmp/0.disk
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>En caso de que quisiéramos redefinir una tabla de particiones de cero,
sobre un disco que ya tuviera definidas particiones, <kbd class="kbd docutils literal notranslate">-z</kbd> podría ser
la primera opción antes de las demás que definan la nueva tabla.</p>
</div>
</li>
<li><p>Convertir de <abbr title="Disk Operating System">DOS</abbr> a <abbr title="GUID Partition Table">GPT</abbr>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>/sbin/sgdisk<span class="w"> </span>-g<span class="w"> </span>/tmp/dos.disk
</pre></div>
</div>
</li>
<li><p>Convertir de <abbr title="GUID Partition Table">GPT</abbr> a <abbr title="Disk Operating System">DOS</abbr>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>/sbin/sgdisk<span class="w"> </span>-m<span class="w"> </span><span class="m">3</span>:4:5<span class="w"> </span>/tmp/0.disk
</pre></div>
</div>
<p>En este caso, sólo se pasan la definición de las particiones 3, 4 y 5.</p>
</li>
</ol>
</section>
<section id="migracion-a-uefi">
<span id="bios-uefi"></span><h3><span class="section-number">5.1.3.2.2. </span>Migración a <abbr title="Unified Extensible Firmware Interface">UEFI</abbr><a class="headerlink" href="#migracion-a-uefi" title="Enlace permanente a este encabezado">¶</a></h3>
<p>Remataremos la exposición sobre particionado, describiendo cómo convertir
nuestro arranque <abbr title="Basic I/O System">BIOS</abbr> en arranque <abbr title="Unified Extensible Firmware Interface">UEFI</abbr> si tuvimos la previsión desde un
principio de crear particiones <abbr title="Globally Unique Identifier">GUID</abbr> e incluimos tanto la partición
«BIOS Boot Partiticion» como la <abbr title="EFI System Partition">ESP</abbr><a class="footnote-reference brackets" href="#id11" id="id5" role="doc-noteref"><span class="fn-bracket">[</span>5<span class="fn-bracket">]</span></a>. Si no fue así, tendremos que
preparar nuestro particionado para llegar a este punto, lo cual muy
probablemente incluya:</p>
<ul class="simple">
<li><p>La conversión de un particionado en otro (tanto <a class="reference internal" href="#gdisk-i"><span class="std std-ref">gdisk</span></a> como
<a class="reference internal" href="#sgdisk"><span class="std std-ref">sgdisk</span></a> lo permiten).</p></li>
<li><p>La creación de la <abbr title="EFI System Partition">ESP</abbr>, lo cual, suponga hacer hueco redimensinando alguna de
las particiones.</p></li>
</ul>
<p>Sea como sea, llegamos al punto en que disponemos de un particionado <abbr title="GUID Partition Table">GPT</abbr> con
particiones «Bios Boot Partition» (la cual supondremos <code class="file docutils literal notranslate"><span class="pre">sda1</span></code>) y <abbr title="Extensible Firmware Interface">EFI</abbr>
(<code class="file docutils literal notranslate"><span class="pre">sda2</span></code>) y un sistema que se instaló en modo <abbr title="Basic I/O System">BIOS</abbr> y, en consecuencia,
tiene inoperativa aún la partición <abbr title="Extensible Firmware Interface">EFI</abbr>.</p>
<p>Un procedimiento medianmente sencillo para lograr hacer que el sistema arranque
en modo <abbr title="Extensible Firmware Interface">EFI</abbr> es el siguiente:</p>
<ol class="arabic">
<li><p>Arrancar el sistema en modo <abbr title="Basic I/O System">BIOS</abbr> para:</p>
<ol class="loweralpha">
<li><p>Preparar la <abbr title="EFI System Partition">ESP</abbr>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp"># </span>apt<span class="w"> </span>install<span class="w"> </span>dosfstools
<span class="gp"># </span>mkfs.fat<span class="w"> </span>-F32<span class="w"> </span>/dev/sda2
<span class="gp"># </span>mkdir<span class="w"> </span>/boot/efi
<span class="gp"># </span><span class="nb">echo</span><span class="w"> </span><span class="s2">&quot;/dev/sda2 /boot/efi vfat defaults 0 2&quot;</span><span class="w"> </span>&gt;&gt;<span class="w"> </span>/etc/fstab
</pre></div>
</div>
</li>
<li><p>Instalar el grub compatible con <abbr title="Extensible Firmware Interface">EFI</abbr>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp"># </span>apt<span class="w"> </span>install<span class="w"> </span>grub-efi
</pre></div>
</div>
</li>
</ol>
</li>
<li><p>Reiniciar en modo <abbr title="Unified Extensible Firmware Interface">UEFI</abbr> usando un instalador moderno de debian y obtener una
consola:</p>
<ol class="loweralpha simple">
<li><p>Escoger «Opciones avanzadas» y dentro de ellas «Rescate».</p></li>
<li><p>Contestar las distintas preguntas y al llegar a la de elegir el sistema de
ficheros raíz, contestar que ninguno.</p></li>
<li><p>Escoger la opción para abrir la terminal.</p></li>
</ol>
</li>
<li><p>Hacer un <span class="xref std std-ref">chroot</span> a la debian instalada en el disco duro,
preparando previamente el sistema:</p>
<ol class="loweralpha">
<li><p>Si es necesario para nuestro sistema, preparar <abbr title="Redundant Array of Inexpensive Disks">RAID</abbr>s, cargar volúmenes
lógicos, descrifar sistemas cifrados, etc. En caso de que hayamos seguido
las recomendaciones para la <a class="reference internal" href="../99.instalacion/index.html#inst-servidor"><span class="std std-ref">instalación de un servidor</span></a>, deberemos hacer lo siguiente:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp"># </span>mdadm<span class="w"> </span>--assemble<span class="w"> </span>/dev/md0<span class="w"> </span>/dev/sda3
<span class="gp"># </span>vgchange<span class="w"> </span>-ay<span class="w"> </span>VGbuster
</pre></div>
</div>
</li>
<li><p>Montar al menos el sistema raíz y la <abbr title="EFI System Partition">ESP</abbr>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp"># </span>mount<span class="w"> </span>/dev/VGbuster/rauz<span class="w"> </span>/mnt
<span class="gp"># </span>mount<span class="w"> </span>/dev/sda2<span class="w"> </span>/mnt/boot/efi
</pre></div>
</div>
<p>Si nuestro sistema se compone de otras particiones, podemos montarlas
también, aunque no es imprescindible. Por ejemplo, para nuestra propuesta
de servidor:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp"># </span>mount<span class="w"> </span>/dev/VGbuster/log<span class="w"> </span>/mnt/var/log
<span class="gp"># </span>mount<span class="w"> </span>/dev/VGbuster/mysql<span class="w"> </span>/mnt/var/lib/mysql
<span class="gp"># </span>mount<span class="w"> </span>/dev/VGbuster/srv<span class="w"> </span>/mnt/srv
<span class="gp"># </span>mount<span class="w"> </span>/dev/VGbuster/home<span class="w"> </span>/mnt/home
</pre></div>
</div>
</li>
<li><p>Montar los sistemas especiales sobre el sistema de disco:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp"># </span>mount<span class="w"> </span>-t<span class="w"> </span>devtmpfs<span class="w"> </span>udev<span class="w"> </span>/mnt/dev
<span class="gp"># </span>mount<span class="w"> </span>-t<span class="w"> </span>devpts<span class="w"> </span>devpts<span class="w"> </span>/mnt/dev/pts
<span class="gp"># </span>mount<span class="w"> </span>-t<span class="w"> </span>proc<span class="w"> </span>proc<span class="w"> </span>/mnt/proc
<span class="gp"># </span>mount<span class="w"> </span>-t<span class="w"> </span>sysfs<span class="w"> </span>sysfs<span class="w"> </span>/mnt/sys
</pre></div>
</div>
</li>
<li><p>Entrar en la jaula:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp"># </span>chroot<span class="w"> </span>/mnt<span class="w"> </span>bash
</pre></div>
</div>
</li>
</ol>
</li>
<li><p>Instalar grub para el arranque <abbr title="Extensible Firmware Interface">EFI</abbr>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp"># </span>grub-install<span class="w"> </span>--recheck
</pre></div>
</div>
<p>Al estar montada la <abbr title="EFI System Partition">ESP</abbr> en <code class="file docutils literal notranslate"><span class="pre">/boot/efi</span></code>, <strong class="program">grub</strong> será capaz de
usarla sin necesidar de especiar nada más.</p>
</li>
<li><p>Comprobar que la entrada para <abbr title="GRand Unified Bootloader">GRUB</abbr> aparece como primera opción de
arranque:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp"># </span>efibootmgr
</pre></div>
</div>
</li>
<li><p>Salir y reiniciar<a class="footnote-reference brackets" href="#id12" id="id6" role="doc-noteref"><span class="fn-bracket">[</span>6<span class="fn-bracket">]</span></a>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp"># </span><span class="nb">exit</span>
<span class="gp"># </span>reboot
</pre></div>
</div>
</li>
</ol>
</section>
<section id="entradas">
<span id="efi-entradas-grub"></span><h3><span class="section-number">5.1.3.2.3. </span>Entradas<a class="headerlink" href="#entradas" title="Enlace permanente a este encabezado">¶</a></h3>
<p>Una instalación estándar de <em>debian</em> instala, simplemente, su <abbr title="GRand Unified Bootloader">GRUB</abbr> dentro de
<code class="file docutils literal notranslate"><span class="pre">/EFI/debian</span></code> y añade una entrada a la secuencia de arranque del
<em>firmware</em> con el identificado «<em>debian</em>». Podemos alterar la leyenda de la
secuencia de arranque, borrando la actual entrada «<em>debian</em>» y creando otra
distinta:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp"># </span>efibootmgr<span class="w">        </span><span class="c1"># Y miramos cuál es índice de la entrada (p.e. 7)</span>
<span class="gp"># </span>efibootmgr<span class="w"> </span>-Bb7
<span class="gp"># </span>efibootmgr<span class="w"> </span>-cgL<span class="w"> </span><span class="s2">&quot;Grub menu&quot;</span><span class="w"> </span>-d<span class="w"> </span>/dev/sda<span class="w"> </span>-p<span class="w"> </span><span class="m">2</span><span class="w"> </span>-l<span class="w"> </span><span class="s2">&quot;/EFI/debian/shimx64.efi&quot;</span>
</pre></div>
</div>
<p>Otra posibilidad, es hacer que la entrada en la secuencia para el
dispositivo de disco arranque nuestro <abbr title="GRand Unified Bootloader">GRUB</abbr>. Eso pasa porque se cree
<code class="file docutils literal notranslate"><span class="pre">/EFI/Boot/bootx64.efi</span></code> para lo cual podemos hacer:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp"># </span>grub-install<span class="w"> </span>--no-nvram<span class="w"> </span>--force-extra-removable
</pre></div>
</div>
<p>Otra posibilidad es crear una entrada que arranque directamente el sistema, lo
cual dejaremos para epígrafe aparte.</p>
</section>
<section id="arranque-directo">
<span id="efi-arranque-directo"></span><h3><span class="section-number">5.1.3.2.4. </span>Arranque directo<a class="headerlink" href="#arranque-directo" title="Enlace permanente a este encabezado">¶</a></h3>
<p>El núcleo de <em>debian</em> tiene <a class="reference external" href="https://wiki.archlinux.org/index.php/EFISTUB">EFIStub</a>, esto es, la
capacidad de ser cargado como un ejecutable directamente por el firmware <abbr title="Unified Extensible Firmware Interface">UEFI</abbr>,
sin necsidad de usar <abbr title="GRand Unified Bootloader">GRUB</abbr> u otro gestor de arranque. Ello supone copiar el
núcleo y el sistema de ficheros inicial (<em>initrd</em>) en la partición <abbr title="EFI System Partition">ESP</abbr> y, si
queremos que tanto lo uno como lo otro se actualicen al actualizar el núcleo,
añadir un par de <em>scripts</em>.</p>
<ol class="arabic">
<li><p>Crear el <em>script</em> para automatizar la copia del núcleo en la partición
<abbr title="EFI System Partition">ESP</abbr>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp"># </span>cat<span class="w"> </span>&gt;<span class="w"> </span>/etc/kernel/postinst.d/zz-update-efistub
<span class="gp">#</span>!/bin/sh

<span class="go">cp /vmlinuz /boot/efi/EFI/debian/</span>
</pre></div>
</div>
</li>
<li><p>Crear el <em>script</em> para automatizar la copia del <em>initrd</em> en la partición
<abbr title="EFI System Partition">ESP</abbr>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp"># </span>mkdir<span class="w"> </span>-p<span class="w"> </span>/etc/initramfs/post-update.d
<span class="gp"># </span>cat<span class="w"> </span>&gt;<span class="w"> </span>/etc/initramfs/post-update.d/zz-update-efistub
<span class="gp">#</span>!/bin/sh

<span class="go">cp /initrd.img /boot/efi/EFI/debian/</span>
</pre></div>
</div>
</li>
<li><p>Copiar manualmente el núcleo y la imagen <em>initrd</em>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp"># </span>/etc/kernel/postinst.d/zz-update-efistub
<span class="gp"># </span>/etc/initramfs/post-update.d/zz-update-efistub
</pre></div>
</div>
</li>
<li><p>Añadir una entrada al menú de arranque <abbr title="Unified Extensible Firmware Interface">UEFI</abbr>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp"># </span>efibootmgr<span class="w"> </span>-c<span class="w"> </span>-g<span class="w"> </span>-L<span class="w"> </span><span class="s2">&quot;Debian </span><span class="k">$(</span>/etc/debian_version<span class="k">)</span><span class="s2">&quot;</span><span class="w"> </span>-d<span class="w"> </span>/dev/sda<span class="w"> </span>-p2<span class="w"> </span>-l<span class="w"> </span>/EFI/debian/vmlinuz<span class="w"> </span><span class="se">\</span>
<span class="w">   </span>-u<span class="w"> </span><span class="s2">&quot;root=/dev/VGbuster/raiz ro quiet rootfstype=ext4 add_efi_memmap initrd=/EFI/debian/initrd.img&quot;</span>
</pre></div>
</div>
<p>donde se ha supuesto que la partición <abbr title="EFI System Partition">ESP</abbr> es <code class="file docutils literal notranslate"><span class="pre">/dev/sda2</span></code> y la raíz
del sistema se encuentra en el volumen <code class="file docutils literal notranslate"><span class="pre">/dev/VGbuster/raiz</span></code>.</p>
</li>
</ol>
<p class="rubric">Notas al pie</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id7" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id1">1</a><span class="fn-bracket">]</span></span>
<p>Para crear un fichero de un tamaño determinado hay tres alternativas:</p>
<ul class="simple">
<li><p><strong class="command">truncate</strong>, que es la más eficiente ya que hace un
<a class="reference internal" href="04.virt.html#lvm-aprovisionamiento"><span class="std std-ref">aprovisionamiento fino</span></a> del espacio.</p></li>
<li><p><em class="manpage"><a class="manpage reference external" href="https://manpages.debian.org/fallocate(1)">fallocate(1)</a></em>, que reserva efectivamente los bloqies necesarios,
pero que no escribe en disco.</p></li>
<li><p><a class="reference internal" href="../../02.conbas/02.informacion/04.devices.html#dd"><span class="std std-ref">dd</span></a>, que puede usarse para escribir el tamaño deseado de ceros
(tomándolos de <code class="file docutils literal notranslate"><span class="pre">/dev/zero</span></code>) y que es el método menos recomendable, ya
que, además de ocupar todo el espacio, escribe en el disco los ceros; y es,
por tanto, el más lento.</p></li>
</ul>
</aside>
<aside class="footnote brackets" id="id8" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id2">2</a><span class="fn-bracket">]</span></span>
<p>Es posible que después de alterar la tabla de particiones con <a class="reference internal" href="#fdisk"><span class="std std-ref">fdisk</span></a> o <a class="reference internal" href="#gdisk-i"><span class="std std-ref">gdisk</span></a> el <em>kernel</em> no actualice la tabla de
particiones porque haya algún proceso que lo impida, por ejemplo, porque hay
un sistema de ficheros montado o un <abbr title="Redundant Array of Inexpensive Disks">RAID</abbr> ensamblado. En esos caso, es
preciso primero, parar tal proceso y a continuación intentar releer la tabla
de particiones.</p>
</aside>
<aside class="footnote brackets" id="id9" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id3">3</a><span class="fn-bracket">]</span></span>
<p>Hasta la versión <em>2.25</em>, el propio <strong class="command">sfdisk</strong> suministraba una
opción <kbd class="kbd docutils literal notranslate">-I</kbd> para deshacer los cambios.</p>
</aside>
<aside class="footnote brackets" id="id10" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id4">4</a><span class="fn-bracket">]</span></span>
<p>Utilizaremos el fichero de 20G que propusimos crear anteriormente para
estas pruebas.</p>
</aside>
<aside class="footnote brackets" id="id11" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id5">5</a><span class="fn-bracket">]</span></span>
<p>En realidad, si nuestra intención es arrancar mediante <abbr title="Unified Extensible Firmware Interface">UEFI</abbr> y partimos
de un particionado <abbr title="Disk Operating System">DOS</abbr>, la «Bios Boot Partition» es ya absolutamente
irrelevante y podemos prescindir de ella.</p>
</aside>
<aside class="footnote brackets" id="id12" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id6">6</a><span class="fn-bracket">]</span></span>
<p>Al menos en la máquina virtual en la que se han hecho las pruebas (<a class="reference external" href="https://www.linux-kvm.org/page/Main_Page">kvm</a>
cuyo implementación de <abbr title="Unified Extensible Firmware Interface">UEFI</abbr> es la de <a class="reference external" href="https://github.com/tianocore/tianocore.github.io/wiki/OVMF">OVMF</a>), si el equipo se apaga
(<a class="reference internal" href="../../02.conbas/01.preliminares/index.html#poweroff"><span class="std std-ref">poweroff</span></a>) tras el cambio, no se guarda la nueva entrada.</p>
</aside>
</aside>
</section>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <div>
    <h3><a href="../../index.html">Tabla de contenido</a></h3>
    <ul>
<li><a class="reference internal" href="#">5.1.3. Aplicacion práctica</a><ul>
<li><a class="reference internal" href="#particionado-dos">5.1.3.1. Particionado <abbr title="Disk Operating System">DOS</abbr></a></li>
<li><a class="reference internal" href="#particionado-gpt">5.1.3.2. Particionado <abbr title="GUID Partition Table">GPT</abbr></a><ul>
<li><a class="reference internal" href="#aplicaciones-de-terminal">5.1.3.2.1. Aplicaciones de terminal</a></li>
<li><a class="reference internal" href="#migracion-a-uefi">5.1.3.2.2. Migración a <abbr title="Unified Extensible Firmware Interface">UEFI</abbr></a></li>
<li><a class="reference internal" href="#entradas">5.1.3.2.3. Entradas</a></li>
<li><a class="reference internal" href="#arranque-directo">5.1.3.2.4. Arranque directo</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>Tema anterior</h4>
    <p class="topless"><a href="02.boot/06.grub.html"
                          title="capítulo anterior"><span class="section-number">5.1.2.2.2. </span><abbr title="GRand Unified Bootloader">GRUB</abbr>.</a></p>
  </div>
  <div>
    <h4>Próximo tema</h4>
    <p class="topless"><a href="04.virt.html"
                          title="próximo capítulo"><span class="section-number">5.1.4. </span>Volúmenes lógicos</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>Esta página</h3>
    <ul class="this-page-menu">
      <li><a href="../../_sources/05.discos/01.division/03.pract.rst.txt"
            rel="nofollow">Mostrar el código</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Búsqueda rápida</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Ir a" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navegación</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="Índice General"
             >índice</a></li>
        <li class="right" >
          <a href="04.virt.html" title="5.1.4. Volúmenes lógicos"
             >siguiente</a> |</li>
        <li class="right" >
          <a href="02.boot/06.grub.html" title="5.1.2.2.2. GRUB."
             >anterior</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">documentación de Linuxnomicón - rolling</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" ><span class="section-number">5. </span>Dispositivos de almacenamiento</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="index.html" ><span class="section-number">5.1. </span>División del disco</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href=""><span class="section-number">5.1.3. </span>Aplicacion práctica</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Derechos de autor CC BY 4.0, 2016-2023, José Miguel Sánchez Alés.
      Creado usando <a href="https://www.sphinx-doc.org/">Sphinx</a> 5.3.0.
    </div>
  </body>
</html>