


<!DOCTYPE html>

<html lang="es">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>9.1.3.2. Cifrado de discos &#8212; documentación de Linuxnomicón - rolling</title>
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/custom.css" type="text/css" />
    
    <script id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
    <script src="../../../_static/jquery.js"></script>
    <script src="../../../_static/underscore.js"></script>
    <script src="../../../_static/doctools.js"></script>
    <script src="../../../_static/translations.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <link rel="index" title="Índice" href="../../../genindex.html" />
    <link rel="search" title="Búsqueda" href="../../../search.html" />
    <link rel="next" title="9.1.3.3. Protocolos seguros de red" href="03.ssl.html" />
    <link rel="prev" title="9.1.3.1. Firma digital" href="01.firma.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navegación</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="Índice General"
             accesskey="I">índice</a></li>
        <li class="right" >
          <a href="03.ssl.html" title="9.1.3.3. Protocolos seguros de red"
             accesskey="N">siguiente</a> |</li>
        <li class="right" >
          <a href="01.firma.html" title="9.1.3.1. Firma digital"
             accesskey="P">anterior</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">documentación de Linuxnomicón - rolling</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" ><span class="section-number">9. </span>Apéndices</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="../index.html" ><span class="section-number">9.1. </span>Criptografía</a> &#187;</li>
          <li class="nav-item nav-item-3"><a href="../03.aplicaciones.html" accesskey="U"><span class="section-number">9.1.3. </span>Aplicaciones de la criptografía</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href=""><span class="section-number">9.1.3.2. </span>Cifrado de discos</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="cifrado-de-discos">
<span id="disk-encrypt"></span><h1><span class="section-number">9.1.3.2. </span>Cifrado de discos<a class="headerlink" href="#cifrado-de-discos" title="Enlazar permanentemente con este título">¶</a></h1>
<p>Aunque ya hemos ilustrado <a class="reference internal" href="../02.algo.html#gnupg-1"><span class="std std-ref">cómo cifrar un archivo individual</span></a>,
este procedimiento sólo es útil si se quiere portar un archivo y es
absolutamente impracticable si lo que se pretende es almacenar archivos en
disco, ya que exige cada vez que se quiera realizar la modificación del
contenido, un descifrado y un cifrado manual. En la práctica, lo que se hace es
cifrar la totalidad o parte de un sistema de archivos a fin de que todo lo
incluido en esa zona este cifrado y no ser leído (o escrito) a menos que se
conozca la contraseña. Para ponerlo en práctica hay tres estrategias.</p>
<ol class="arabic simple">
<li><p>El cifrado de dispositivos de bloques completos (p.e. una partición), que usa
<abbr title="Linux Unified Key Setup">LUKS</abbr>.</p></li>
<li><p>El cifrado del contenido de un directorio arbitrario, que, junto a <a class="reference external" href="https://es.wikipedia.org/wiki/Sistema_de_archivos_en_el_espacio_de_usuario">FUSE</a>, es
la aproximación que usa software como:</p>
<ul class="simple">
<li><p><a class="reference external" href="https://github.com/vgough/encfs">encfs</a>, que ha sido el <em>software</em> más usado, pero que es actualmente
desaconsejable por sus problemas de seguridad.</p></li>
<li><p><a class="reference external" href="https://www.cryfs.org/">cryfs</a>, que tiene la limitación de <a class="reference external" href="https://github.com/cryfs/cryfs/issues/84">no permitir aún el cambio en la
contraseña de cifrado</a>.</p></li>
<li><p><a class="reference external" href="https://nuetzlich.net/gocryptfs/">gocryptfs</a>, que será el que utilicemos por no tener la limitación
anterior.</p></li>
</ul>
</li>
<li><p>Usar las capacidades de cifrado del propio sistema de archivos, si el que
usamos las tiene. En el caso de <em>ext4</em>, éste soporta cifrado desde la versión
4.1 del kernel de <em>Linux</em>.</p></li>
</ol>
<div class="section" id="cifrado-de-bloques-luks">
<h2><span class="section-number">9.1.3.2.1. </span>Cifrado de bloques (<abbr title="Linux Unified Key Setup">LUKS</abbr>)<a class="headerlink" href="#cifrado-de-bloques-luks" title="Enlazar permanentemente con este título">¶</a></h2>
<p>Mediante esta técnica el software hace de intermediario entre los bloques
físicos y los bloques de un dispositivo virtual cifrando en las escrituras y
descifrando en las lecturas.</p>
<img alt="../../../_images/dm-crypt.png" src="../../../_images/dm-crypt.png" />
<p>En consecuencia:</p>
<ul class="simple">
<li><p>Ciframos un dispositivo de bloques entero.</p></li>
<li><p>Como el cifrado es independiente del sistema de archivos, se puede utilizar
cualquier sistema de archivos.</p></li>
<li><p>Permite no sólo el cifrado de datos, sino el cifrado del sistema entero,
preparando convenientemente el sistema (caso que no abordaremos aquí, pero que
puede consultarse, por ejemplo, en un <a class="reference external" href="https://wiki.archlinux.org/index.php/Dm-crypt_(Espa%C3%B1ol)/Encrypting_an_entire_system_(Espa%C3%B1ol)#Modalidad_plain_de_dm-crypt">artículo de la wiki de Archlinux</a>).</p></li>
</ul>
<p>Abordaremos el caso más sencillo de querer cifrar una partición física, para lo
cual debemos primero instalar el <em>software</em> de cifrado:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> apt install cryptsetup
</pre></div>
</div>
<p class="rubric">Operativa manual</p>
<p>Lo primero es mapear una partición física<a class="footnote-reference brackets" href="#id4" id="id1">1</a> (p.e. <code class="file docutils literal notranslate"><span class="pre">/dev/sda6</span></code>) sobre
un dispositivo virtual:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> cryptsetup -y -v luksFormat /dev/sda6  <span class="c1"># Requerirá una contraseña</span>
<span class="gp">#</span> cryptsetup open /dev/sda6 cifrado      <span class="c1"># Debemos proporcionar la contraseña</span>
</pre></div>
</div>
<p>Esto generará el dispositivo virtual de bloques <code class="file docutils literal notranslate"><span class="pre">/dev/mapper/cifrado</span></code>,
sobre el cual podemos actuar como si se tratara de un dispositivo físico, o
sea:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> mkfs.ext4 -L DATOSECRETOS /dev/mapper/cifrado
<span class="gp">#</span> mount /dev/mapper/cifrado /mnt
</pre></div>
</div>
<p>Si en algún momento quisiéramos desmontar todo:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> umount /mnt
<span class="gp">#</span> cryptsetup close cifrado
</pre></div>
</div>
<p class="rubric">Operativa automatizada</p>
<p>Que el administrador deba llevar a cabo estas operaciones cada vez que se
arranca el sistema, no es algo operativo. Para semiautomatizar el montaje
durante el arranque podemos añadir la asociación entre el dispositivo físico y
el virtual en <code class="file docutils literal notranslate"><span class="pre">/etc/crypttab</span></code>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> <span class="nb">echo</span> <span class="s2">&quot;cifrado /dev/sda6 none&quot;</span> &gt;&gt; /etc/crypttab
</pre></div>
</div>
<p>y la asociación entre el dispositivo virtual y el punto de montaje en
<code class="file docutils literal notranslate"><span class="pre">/etc/fstab</span></code>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> <span class="nb">echo</span> <span class="s2">&quot;/dev/mapper/cifrado /mnt ext4 defaults 0 0&quot;</span> &gt;&gt; /etc/fstab
</pre></div>
</div>
<p>El montaje será semiautomático, porque durante el proceso de arranque deberemos
digitalizar la contraseña. Es posible, también, en vez de que la clave sea
interactiva, guardarla en un archivo. Es más, <abbr title="Linux Unified Key Setup">LUKS</abbr> dispone de ocho slots para
almacenar claves alternativas. Ahora mismo sólo habría una:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> cryptsetup luksDump /dev/sda6
<span class="go">LUKS header information</span>
<span class="go">Version:        2</span>
<span class="go">Epoch:          8</span>
<span class="go">Metadata area:  16384 [bytes]</span>
<span class="go">Keyslots area:  16744448 [bytes]</span>
<span class="go">UUID:           e26d3cf8-20a7-422f-ac8f-83340e63725f</span>
<span class="go">Label:          (no label)</span>
<span class="go">Subsystem:      (no subsystem)</span>
<span class="go">Flags:          (no flags)</span>

<span class="go">Data segments:</span>
<span class="go">  0: crypt</span>
<span class="go">        offset: 16777216 [bytes]</span>
<span class="go">        length: (whole device)</span>
<span class="go">        cipher: aes-xts-plain64</span>
<span class="go">        sector: 512 [bytes]</span>

<span class="hll"><span class="go">Keyslots:</span>
</span><span class="go">  0: luks2</span>
<span class="go">        Key:        512 bits</span>
<span class="go">        Priority:   normal</span>
<span class="go">        Cipher:     aes-xts-plain64</span>
<span class="go">        Cipher key: 512 bits</span>
<span class="go">        PBKDF:      argon2i</span>
<span class="go">        Time cost:  4</span>
<span class="go">        Memory:     98948</span>
<span class="go">        Threads:    1</span>
<span class="go">        Salt:       a0 a1 57 4c 30 6a af e5 de 76 d5 d8 a9 f0 11 b7</span>
<span class="go">                    ac b5 c6 90 d0 1d 4e 92 4d 1c 4b b5 4c 07 97 70</span>
<span class="go">        AF stripes: 4000</span>
<span class="go">        AF hash:    sha256</span>
<span class="go">        Area offset:32768 [bytes]</span>
<span class="go">        Area length:58048 [bytes]</span>
<span class="go">        Digest ID:  0</span>

<span class="go">Tokens:</span>
<span class="go">Digests:</span>
<span class="go">  0: pbkdf2</span>
<span class="go">        Hash:       sha256</span>
<span class="go">        Iterations: 39337</span>
<span class="go">        Salt:       2b c9 51 10 c7 29 4b 63 35 a4 83 63 bc 36 46 2f</span>
<span class="go">                    49 92 af dd 32 a8 7c 9d 19 08 51 80 1b 58 6f 56</span>
<span class="go">        Digest:     0c 52 b0 1d 8c 80 2e 6b 45 0a c8 ac 4a b2 e9 a2</span>
<span class="go">                    f4 bf 81 e6 5a 00 c4 42 af 10 21 9c 3a 92 fe 6c</span>
</pre></div>
</div>
<p>con lo que podemos añadir al mismo sistema otra clave que esté en un archivo.
Para ello, vamos primero a generar esa clave, constituida por 512 <em>bytes</em>
totalmente aleatorios:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> dd &lt; /dev/urandom &gt; /root/luks.key <span class="nv">bs</span><span class="o">=</span><span class="m">512</span> <span class="nv">count</span><span class="o">=</span><span class="m">1</span>
</pre></div>
</div>
<p>que, podemos consultar en formato hexadecimal, así:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> od -v -An -tx1 /root/luks.key  <span class="c1"># Consultamos la clave</span>
<span class="go">dc 12 ae d8 2c b5 4e 12 56 a9 35 b4 5f a6 29 b9</span>
<span class="go">[...]</span>
</pre></div>
</div>
<p>Con la clave ya en el archivo <code class="file docutils literal notranslate"><span class="pre">/root/luks.key</span></code>, podemos añadirla a un
<em>slot</em>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> cryptsetup luksAddKey /dev/sda6 /root/luks.key
<span class="gp">#</span> cryptsetup luksDump /dev/sda6
<span class="go">[...]</span>
<span class="go">Keyslots:</span>
<span class="go">  0: luks2</span>
<span class="go">        Key:        512 bits</span>
<span class="go">        Priority:   normal</span>
<span class="go">        Cipher:     aes-xts-plain64</span>
<span class="go">        Cipher key: 512 bits</span>
<span class="go">        PBKDF:      argon2i</span>
<span class="go">        Time cost:  4</span>
<span class="go">        Memory:     98948</span>
<span class="go">        Threads:    1</span>
<span class="go">        Salt:       a0 a1 57 4c 30 6a af e5 de 76 d5 d8 a9 f0 11 b7</span>
<span class="go">                    ac b5 c6 90 d0 1d 4e 92 4d 1c 4b b5 4c 07 97 70</span>
<span class="go">        AF stripes: 4000</span>
<span class="go">        AF hash:    sha256</span>
<span class="go">        Area offset:32768 [bytes]</span>
<span class="go">        Area length:258048 [bytes]</span>
<span class="go">        Digest ID:  0</span>
<span class="go">  1: luks2</span>
<span class="go">        Key:        512 bits</span>
<span class="go">        Priority:   normal</span>
<span class="go">        Cipher:     aes-xts-plain64</span>
<span class="go">        Cipher key: 512 bits</span>
<span class="go">        PBKDF:      argon2i</span>
<span class="go">        Time cost:  4</span>
<span class="go">        Memory:     100952</span>
<span class="go">        Threads:    1</span>
<span class="go">        Salt:       b1 63 a9 24 aa cc f5 9c b4 6c 8a 8b 27 7a cb 2c</span>
<span class="go">                    72 cd f8 d9 68 b9 1b f4 43 c7 d6 b5 20 81 47 c5</span>
<span class="go">        AF stripes: 4000</span>
<span class="go">        AF hash:    sha256</span>
<span class="go">        Area offset:290816 [bytes]</span>
<span class="go">        Area length:258048 [bytes]</span>
<span class="go">        Digest ID:  0</span>
<span class="go">[...]</span>
</pre></div>
</div>
<p>Por último, si en <code class="file docutils literal notranslate"><span class="pre">/etc/crypttab</span></code> modificamos la línea para que se use el
archivo:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">cifrado     /dev/sda6      /root/luks.key</span>
</pre></div>
</div>
<p>durante el arranque no se pedirá ninguna clave y el sistema se encontrará
montado al acabar la secuencia.</p>
<div class="admonition warning">
<p class="admonition-title">Advertencia</p>
<p>Ahora bien, ¿para qué ciframos una partición si dejamos la
clave para su descifrado en un archivo de otra partición sin cifrar?</p>
</div>
<p>Lo interesante de lo anterior es, simplemente, comprobar que se puede guardar la
clave en un archivo y usarlo para no tener que escribirla interactivamente. Y
ello es útil, si almacenamos el archivo en un dispositivo externo como un pincho
<abbr title="Universal Serial Bus">USB</abbr> que procuremos retirar y llevarnos lejos de la máquina cuando no la
usemos. Además, es conveniente ocultar ese archivo para que pase desapercibido
si alguien se hace con nuestro pincho. A este respecto, lo más juicioso es
guardar los 512 <em>bytes</em> de la clave en algún espacio libre del pincho <abbr title="Universal Serial Bus">USB</abbr> y
ajeno a los sistemas de archivos que pueda haber en él:</p>
<ul class="simple">
<li><p>Si el particionado es <abbr title="Disk Operating System">DOS</abbr>, podemos utilizar los últimos 512 bytes del espacio
entre el <abbr title="Master Boot Record">MBR</abbr> y la primera partición, ya que al principio de ese espacio
puede haber código de un gestor de arranque como <abbr title="GRand Unified Bootloader">GRUB</abbr>.</p></li>
<li><p>Si el particionado es <abbr title="GUID Partition Table">GPT</abbr>, podemos utilizar los últimos 512 bytes del espacio
que se reserva para definir particiones, ya que es bastante improbable que en
el pincho hayamos creado más de 124 particiones.</p></li>
</ul>
<p>Pongamos este segundo caso de ejemplo. En un disco <abbr title="GUID Partition Table">GPT</abbr>:</p>
<ul class="simple">
<li><p>El primer sector es un <abbr title="Master Boot Record">MBR</abbr> ficticio (512B)</p></li>
<li><p>El segundo sector es la cabecera <abbr title="GUID Partition Table">GPT</abbr> (512B)</p></li>
<li><p>A continuación hay espacio para 128 definiciones de particiones cada una
de las cuales ocupa 128 bytes (16KiB).</p></li>
</ul>
<p>En consecuencia el comienzo del disco ocupa 17KiB o lo que es lo mismo 34
sectores, así que podemos ocupar el sector <strong>34</strong> para almacenar nuestra clave,
con el único costo de que &quot;sólo&quot; podremos definir 124 particiones, lo cual,
ciertamente, no parece ningún problema.</p>
<p>Supongamos que el pincho se encuentra en <code class="file docutils literal notranslate"><span class="pre">/dev/sdb</span></code><a class="footnote-reference brackets" href="#id5" id="id2">2</a>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> gdisk -l /dev/sdb
<span class="go">[...]</span>
<span class="go">Number  Start (sector)    End (sector)  Size       Code  Name</span>
<span class="go">   1             416          103003   50.1 MiB    EF00  EFI System Partition</span>
<span class="go">   2          103008        30719966   14.6 GiB    0700  Microsoft basic data</span>
</pre></div>
</div>
<p>Vamos a crear una clave aleatoria de 512 bytes directamente sobre su sector
<strong>34</strong>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> dd &lt; /dev/urandom &gt; /dev/sdb <span class="nv">bs</span><span class="o">=</span><span class="m">512</span> <span class="nv">count</span><span class="o">=</span><span class="m">1</span> <span class="nv">seek</span><span class="o">=</span><span class="m">33</span>
</pre></div>
</div>
<p>y, creada, la añadimos a un <em>slot</em>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> <span class="o">{</span> <span class="nb">echo</span> <span class="s2">&quot;secreto&quot;</span> <span class="p">;</span> dd &lt; /dev/sdb <span class="nv">bs</span><span class="o">=</span><span class="m">512</span> <span class="nv">count</span><span class="o">=</span><span class="m">1</span> <span class="nv">skip</span><span class="o">=</span><span class="m">33</span><span class="p">;</span> <span class="o">}</span> <span class="p">|</span> cryptsetup luksAddKey /dev/sda6 -
</pre></div>
</div>
<p>donde «secreto» es la contraseña que introdujimos al crear el dispositivo
cifrado y que nos servía para hacer el montaje interactivo. Añadida esta clave,
podemos probar si funciona del siguiente modo:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> dd &lt; /dev/sdb <span class="nv">bs</span><span class="o">=</span><span class="m">512</span> <span class="nv">count</span><span class="o">=</span><span class="m">1</span> <span class="nv">skip</span><span class="o">=</span><span class="m">33</span> <span class="p">|</span> cryptsetup open /dev/sda6 cifrado --key-file<span class="o">=</span>-
</pre></div>
</div>
<p>que debe generar el dispositivo virtual y, si continua la línea en
<code class="file docutils literal notranslate"><span class="pre">/etc/fstab</span></code>, montarnos directamente la partición sobre <code class="file docutils literal notranslate"><span class="pre">/srv</span></code>. Ya
tenemos la mitad del trabajo hecho, ya que aún falta que al arrancar el sistema
busque el dispositivo, lo monte y lleve a cabo justamente esta operación.</p>
<p>Para ello, debemos crear una regla para <strong class="program">udev</strong>, que al detectar el
dispositivo <abbr title="Universal Serial Bus">USB</abbr> lance un script:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> cat &gt; /etc/udev/rules.d/70-usb.rules
<span class="go">SUBSYSTEMS==&quot;usb&quot;, ACTION==&quot;add&quot;, ATTRS{idVendor}==&quot;abcd&quot;, ATTRS{idProduct}==&quot;1234&quot;, \</span>
<span class="go">   KERNEL==&quot;sd?&quot;, SYMLINK+=&quot;usbkey&quot;, RUN+=&quot;/usr/local/bin/unlock.sh&quot;</span>
</pre></div>
</div>
<p>La regla identifica el dispositivo en el que hemos guardado la clave a través
de su <em>idVendor</em> e <em>idProduct</em> que se pueden consultar fácilmente al hacer:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> lsusb
<span class="go">[...]</span>
<span class="go">Bus 002 Device 002: ID abcd:1234 Unknown</span>
<span class="go">[...]</span>
</pre></div>
</div>
<p>Además, aprovechamos la regla para añadir un enlace simbólico <code class="file docutils literal notranslate"><span class="pre">/dev/usbkey</span></code> que apunte
al dispositivo. Con este nombre podremos referirnos al dispositivo dentro del <em>script</em>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span>!/bin/sh
<span class="go">RT=&quot;/dev/sda6&quot;</span>
<span class="go">DEVICE=&quot;/dev/usbkey&quot;</span>
<span class="go">ENCVOL=&quot;cifrado&quot;</span>
<span class="go">MOUNTP=&quot;/srv&quot;</span>

<span class="go">{</span>
<span class="go">   until [ -b &quot;$PART&quot; ]; do sleep .5; done</span>
<span class="go">   dd &lt; &quot;$DEVICE&quot; bs=512 count=1 skip=33 | \</span>
<span class="go">      cryptsetup open &quot;$PART&quot; &quot;$ENCVOL&quot; --key-file=-</span>
<span class="go">} &amp;</span>
</pre></div>
</div>
<p>Por último, en <code class="file docutils literal notranslate"><span class="pre">/etc/crypttab</span></code> no debe existir referencia alguna, ya
que es el <em>script</em> el que realiza la operación de crear el dispositivo cifrado.
En <code class="file docutils literal notranslate"><span class="pre">/etc/fstab</span></code>, sí podemos dejar la línea, pero añadiendo la opción
<em>nofail</em>, para que no falle el montaje y pare el arranque en caso de que no se
encuentre el pincho:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">/dev/mapper/cifrado /srv   ext4   defaults,nofail  0 0</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>Esta estrategia está tomada de <a class="reference external" href="https://possiblelossofprecision.net/?p=300">esta entrada de /dev/blog</a> y sólo es válida si se cifra
una partición de datos y no la partición del sistema. Si se lleva a cabo el
cifrado del sistema, es necesario recurrir a otra estrategia totalmente
distinta basada en manipular la imagen <a class="reference external" href="https://wiki.gentoo.org/wiki/Initramfs/Guide/es">initramfs</a>.</p>
</div>
</div>
<div class="section" id="cifrado-de-directorio-gocrypts">
<h2><span class="section-number">9.1.3.2.2. </span>Cifrado de directorio (<strong class="command">gocrypts</strong>)<a class="headerlink" href="#cifrado-de-directorio-gocrypts" title="Enlazar permanentemente con este título">¶</a></h2>
<p>Esta estrategia permite cifrar un directorio entero, de modo que todo sobre lo
que trabajemos dentro de él se almacenará cifrado de forma transparente. Se basa
en el uso de un <em>software</em> intermedio que, antes de almacenar datos en el
sistema de archivos o tras leerlos de él, cifra o descifra la información.</p>
<img alt="../../../_images/gocryptfs.png" src="../../../_images/gocryptfs.png" />
<p>En consecuencia:</p>
<ul class="simple">
<li><p>Cifrado sobre el sistema de archivos definido para un directorio.</p></li>
<li><p>El cifrado es también independiente del sistema de archivos.</p></li>
<li><p>Sólo nos permite cifrar datos, no el sistema operativo completo.</p></li>
</ul>
<p>Todo el <em>software</em> con este segundo enfoque se utiliza básicamente del mismo
modo, de modo que pueden identificarse las siguientes operaciones básicas:</p>
<ul class="simple">
<li><p>La creación del directorio cifrado, que exigirá el establecimiento de la clave
simétrica de cifrado.</p></li>
<li><p>El montaje de dicho directorio introduciendo la clave; y el desmontaje.</p></li>
<li><p>El cambio de la clave.</p></li>
</ul>
<p>Lo ilustraremos mediante <strong class="program">gocryptfs</strong>, para cuya instalación debemos
hacer:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> apt install gocryptfs fuse
</pre></div>
</div>
<p class="rubric">Operativa manual</p>
<p>Es sumamente sencilla. Suponiendo que el directorio cifrado sea
<code class="file docutils literal notranslate"><span class="pre">~/cipher</span></code>, podemos crearlo con:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> gocryptfs -init ~/cipher
</pre></div>
</div>
<p>que nos pedirá interactivamente la contraseña (la clave simétrica) con que se
cifrarán los datos. Con ella podremos realizar el montaje del siguiente modo:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> gocryptfs ~/cipher ~/plain
</pre></div>
</div>
<p>lo cual mostrará dentro de <code class="file docutils literal notranslate"><span class="pre">~/plain</span></code> los contenidos descifrados, después de
que facilitemos la clave. De esta forma, el usuario podrá trabajar de forma
transparente sobre <code class="file docutils literal notranslate"><span class="pre">~/plain</span></code>, mientras el <em>software</em> se encarga de almacenar
los datos cifrados dentro de <code class="file docutils literal notranslate"><span class="pre">~/cipher</span></code>. Al acabarse el trabajo, puede
desmontarse el directorio:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> fusermount -u ~/plain
</pre></div>
</div>
<p>Puede, además, modificarse la clave simétrica de cifrado (incluso cuando el
directorio está montado):</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> gocryptfs -passwd ~/cipher
</pre></div>
</div>
<p class="rubric">Operativa automatizada</p>
<p>Lo óptimo y cómodo, cuando se desea que los usuarios tengan la posibilidad de
tener un directorio cifrado, es que las operaciones se hagan de modo
automático, de manera que al acceder al sistema el usuario tenga montado el
directorio que da acceso a los datos sin cifrar y que al dejarlo, se produzca
el desmontaje. Para lograrlo puede plantearse la siguiente estrategia:</p>
<ol class="arabic simple">
<li><p>En la medida en que el usuario no opera sobre el directorio cifrado, se lo
ocultaremos anteponiendo a su nombre un punto. Por tanto, en vez de llamarlo
<code class="file docutils literal notranslate"><span class="pre">~/cipher</span></code> lo llamaremos, por ejemplo, <code class="file docutils literal notranslate"><span class="pre">~/.Cifrado</span></code>. Al
directorio que muestra los datos en claro, le daremos el mismo nombre pero
sin anteponer el punto (<code class="file docutils literal notranslate"><span class="pre">~/Cifrado</span></code>).</p></li>
<li><p>Haremos que la clave de cifrado coincida con la contraseña de usuario, lo
cual propicia que durante el proceso de autenticación con <a class="reference internal" href="../../../04.servidor/09.autenticacion/index.html#pam"><span class="std std-ref">PAM</span></a>
podamos usar la contraseña introducida para montar automáticamente el
directorio.</p></li>
</ol>
<p>Establecido esto, basta con escribir un <em>script</em> que se encargue de hacer estas
operaciones, cuyo <a class="reference download internal" download="" href="../../../_downloads/874afd2e08b433301a880863b155dc39/mgocryptfs"><code class="xref download docutils literal notranslate"><span class="pre">código</span> <span class="pre">se</span> <span class="pre">enlaza</span></code></a> y dejarlo en
<code class="file docutils literal notranslate"><span class="pre">/usr/local/bin/mgocryptfs</span></code>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> mv /patH/donde/este/mgocryptfs /usr/local/bin
<span class="gp">#</span> chmod +x /usr/local/bin/mgocryptfs
</pre></div>
</div>
<p>y preparar <abbr title="Pluggable Authentication Modules">PAM</abbr> para que se ejecute al abrir y cerrar sesión en el sistema. La
forma más limpia de hacerlo es creando un <a class="reference download internal" download="" href="../../../_downloads/b396978077381f50e3272115bfe98ec4/pam-gocryptfs"><code class="xref download docutils literal notranslate"><span class="pre">plugin</span> <span class="pre">de</span> <span class="pre">configuración</span>
<span class="pre">como</span> <span class="pre">éste</span></code></a> que puede habilitarse del siguiente modo:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> mv /path/donde/este/pam-gocryptfs /usr/share/pam-configs
<span class="gp">#</span> pam-auth-update
</pre></div>
</div>
<p>El <em>script</em>, además, incluye un aspecto accesorio más: sólo afecta a los
usuarios que pertenezcan al grupo <em>crypto</em>, de modo que si queremos que un
usuario monte automáticamente un directorio para guardar cifrados los datos,
necesitaremos antes haberlo incluido en este directorio.</p>
<p>Por último, está el problema del cambio de contraseña. Tal y como está
configurado por defecto, cuando un usuario del grupo <em>crypto</em> accede al sistema
y no tiene directorio de cifrado, éste se crea utilizando la contraseña de
acceso. En consecuencia, contraseña y clave de cifrado coinciden y todo
funciona correctamente. Ahora bien, si se nos antoja cambiar nuestra
contraseña, la clave de cifrado seguirá siendo la antigua, por lo que para que
el montaje automático continúe funcionado, también deberemos cambiar la clave
de forma separada. Para ello podemos crear un <em>script</em> que haga de envoltorio a
la orden que usemos para cambiar la contraseña. Por ejemplo, si es <a class="reference internal" href="../../../02.conbas/05.seguridad/05a.usuarios.html#passwd"><span class="std std-ref">passwd</span></a>, una posible solución (no demasiado elegante, todo sea dicho) es
<a class="reference download internal" download="" href="../../../_downloads/0c65d58229343072644b00d39df27c9a/passwd"><code class="xref download docutils literal notranslate"><span class="pre">ésta</span></code></a>.</p>
</div>
<div class="section" id="cifrado-de-directorio-con-ext4">
<span id="crypto-ext4"></span><h2><span class="section-number">9.1.3.2.3. </span>Cifrado de directorio (con <em>ext4</em>)<a class="headerlink" href="#cifrado-de-directorio-con-ext4" title="Enlazar permanentemente con este título">¶</a></h2>
<p>Desde la versión <em>4.1</em> del <em>kernel</em> de Linux, <em>ext4</em> soporta el cifrado
transparente, así que podemos utilizar las capacidades del propio sistema de
archivos para cifrar de forma transparente uno o alguno de sus directorios.</p>
<p>En consecuencia:</p>
<ul class="simple">
<li><p>Es el propio sistema de archivos el que se encarga del cifrado, lo que mejora
el rendimiento respecto a la solución anterior.</p></li>
<li><p>El sistema de archivos debe ser forzosamente <em>ext4</em>. Otros sistemas de
archivos también pueden soportar cifrado, pero en ese caso, tendremos que
estudiar cómo se cifra con ellos.</p></li>
<li><p>Como el anterior, es un método apropiado para cifrar datos de usuario.</p></li>
</ul>
<p>Antes de empezar es necesario:</p>
<ol class="arabic">
<li><p>Comprobar que el tamaño de página que usa el sistema y el tamaño de bloque
del sistema de archivos son iguales<a class="footnote-reference brackets" href="#id6" id="id3">3</a>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> getconf PAGE_SIZE
<span class="go">4096</span>
<span class="gp">#</span> tune2fs -l /dev/sda5 <span class="p">|</span> awk <span class="s1">&#39;$0 ~ /^Block size:/ {print $NF}&#39;</span>
<span class="go">4096</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>Suponemos que el sistema de archivos en el que queremos cifrar algunos
directorios es <code class="file docutils literal notranslate"><span class="pre">/home</span></code> y que éste se encuentra sobre la partición
<code class="file docutils literal notranslate"><span class="pre">/dev/sda5</span></code></p>
</div>
</li>
<li><p>Habilitar el cifrado para el sistema de archivos:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> tune2fs -l /dev/sda5 <span class="p">|</span> grep -q crypt <span class="o">&amp;&amp;</span> <span class="nb">echo</span> <span class="s2">&quot;Habilitado&quot;</span>
<span class="gp">#</span> tune2fs -O encrypt /dev/sda5
<span class="gp">#</span> tune2fs -l /dev/sda5 <span class="p">|</span> grep -q crypt <span class="o">&amp;&amp;</span> <span class="nb">echo</span> <span class="s2">&quot;Habilitado&quot;</span>
<span class="go">Habilitado</span>
</pre></div>
</div>
</li>
<li><p>Instalar el <em>software</em> adecuado:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> apt install fscrypt libpam-fscrypt
</pre></div>
</div>
<p>En puridad sólo necesitamos el primer paquete, pero el segundo permite
desbloquear de forma transparente los directorios cifrados al autenticarse el
usuario en el sistema.</p>
</li>
</ol>
<p class="rubric">Preparación</p>
<p>Antes de cifrar cualquier directorio es necesario crear las estructuras
necesarias:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> fscrypt setup
<span class="gp">#</span> fscrypt setup /
<span class="gp">#</span> fscrypt setup /home
</pre></div>
</div>
<p>La primera orden crea la configuración <code class="file docutils literal notranslate"><span class="pre">/etc/fscrypt.conf</span></code>, la segunda es
necesaria si se quiere usar la contraseña del propio usuario como clave para el
cifrado; y la tercera se requiere para poder usar otro tipo de claves para el
cifrado.</p>
<p class="rubric">Operativa</p>
<p>Para cifrar un directorio basta con que el usuario haga:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> mkdir ~/privado
<span class="gp">$</span> fscrypt encrypt ~/privado --source<span class="o">=</span>pam_passphrase
</pre></div>
</div>
<p>que usará como clave su propia contraseña de usuario. Además, de preparar el
directorio para que se almacenen los datos cifrados, lo <em>desbloquea</em>, lo que
significa que podremos escribir y leer dentro de él de forma transparente,
aunque lo datos se guarden cifrados:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> fscrypt status ~/privado
<span class="go">&quot;/home/usuario/privado/&quot; is encrypted with fscrypt.</span>

<span class="go">Policy:   822664193b8152b4</span>
<span class="go">Unlocked: Yes</span>

<span class="go">Protected with 1 protector:</span>
<span class="go">PROTECTOR         LINKED   DESCRIPTION</span>
<span class="go">1095888ae485002d  Yes (/)  login protector for usuario</span>
</pre></div>
</div>
<p>La ventaja de usar la contraseña de usuario es doble:</p>
<ul class="simple">
<li><p>Al autenticarse en el sistema, todos los directorios cifrados con la
contraseña de usuario, se desbloquearán automáticamente.</p></li>
<li><p>Al modificar la contraseña de usuario, cambiará solidariamente la clave de
cifrado de todos esos directorios.</p></li>
</ul>
<p>También puede usarse una clave distinta a la de usuario:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> mkdir ~/secreto
<span class="gp">$</span> fscrypt encrypt ~/secreto --source<span class="o">=</span>custom_passphrase
<span class="gp">$</span> fscrypt status ~/secreto
<span class="go">&quot;/home/usuario/secreto/&quot; is encrypted with fscrypt.</span>

<span class="go">Policy:   2aca13a317cf9195</span>
<span class="go">Unlocked: Yes</span>

<span class="go">Protected with 1 protector:</span>
<span class="go">PROTECTOR         LINKED  DESCRIPTION</span>
<span class="go">9572560fc543c9b5  No      custom protector &quot;1234&quot;</span>
</pre></div>
</div>
<p>En este caso se ha usado una frase personalizada de nombre «1234». En futuros
reinicios, el directorio estará bloqueado y habrá que desbloquearlo
explícitamente proporcionando la contraseña:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> fscrypt unlock ~/secreto
</pre></div>
</div>
<p>Por otro lado, si se quiere cambiar la contraseña, habrá que ejecutar lo
siguiente:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> fscrypt metadata change-passphrase --protector<span class="o">=</span>/home:9572560fc543c9b5
</pre></div>
</div>
<p class="rubric">Cifrado del propio directorio de usuario</p>
<p>Un caso muy socorrido es cifrar el directorio personal del usuario con la clave
del propio usuario. Esta tarea debe llevarla a cabo el administrador y es
conveniente que se lleve a cabo en el proceso de alta del usuario. En cualquier
caso, puede obrarse del siguiente modo:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> mkdir /home/usuario.new
<span class="gp">#</span> chown usuario:usuario /home/usuario.new
<span class="gp">#</span> fscrypt encrypt /home/usuario.new --user<span class="o">=</span>usuario
<span class="gp">#</span> cp -aT /home/usuario /home/usuario.new
<span class="gp">#</span> rm -rf /home/usuario
<span class="gp">#</span> mv /home/usuario.new /home/usuario
</pre></div>
</div>
<p>El tercer paso exige que el administrador proporcione la contraseña del usuario,
o sea, que la conozca. Esto en realidad no es problema, porque después de la
operación, el usuario podrá modificar la contraseña. El quinto paso, en puridad,
requeriría el uso de una herramienta como <strong class="program">shred</strong> para eliminar todo
rastro de los archivos sin cifrar.</p>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>Lo lógico si se desea que los usuarios tengan cifrado su directorio
es crear un <em>script</em> para que el alta incluya el cifrado de tal directorio.</p>
</div>
<p class="rubric">Notas al pie</p>
<dl class="footnote brackets">
<dt class="label" id="id4"><span class="brackets"><a class="fn-backref" href="#id1">1</a></span></dt>
<dd><p>También puede ser un volumen lógico de <abbr title="Logical Volume Management">LVM</abbr>.</p>
</dd>
<dt class="label" id="id5"><span class="brackets"><a class="fn-backref" href="#id2">2</a></span></dt>
<dd><p>Si se observa con atención, la primera partición no empieza en 34.
Sino más adelante. Es posible, puesto que la parte destinada a la definición
de particiones puede ser mayor. Sin embargo, ese <abbr title="Universal Serial Bus">USB</abbr> procede de una imagen
híbrida y es probable que empiece después, porque antes se ha situado el
código de un gestor de arranque. En cualquier, como <abbr title="GUID Partition Table">GPT</abbr> obliga a que como
mínimo se puedan definir 128 particiones, si escribimos en el sector 34,
no nos cargaremos nada.</p>
</dd>
<dt class="label" id="id6"><span class="brackets"><a class="fn-backref" href="#id3">3</a></span></dt>
<dd><p>Al crear el sistema de archivos, <span class="xref std std-ref">mkfs.ext4</span> escoge un
tamaño de bloque. Normalmente el tamaño es <strong>4096</strong>, pero puede ser menor, si
la partición es muy pequeña. En cualquier caso, puede forzarse el tamaño con
la opción <kbd class="kbd docutils literal notranslate"><kbd class="kbd docutils literal notranslate"></kbd>-<kbd class="kbd docutils literal notranslate">b</kbd></kbd>.</p>
</dd>
</dl>
</div>
</div>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../../../index.html">Tabla de contenido</a></h3>
  <ul>
<li><a class="reference internal" href="#">9.1.3.2. Cifrado de discos</a><ul>
<li><a class="reference internal" href="#cifrado-de-bloques-luks">9.1.3.2.1. Cifrado de bloques (<abbr title="Linux Unified Key Setup">LUKS</abbr>)</a></li>
<li><a class="reference internal" href="#cifrado-de-directorio-gocrypts">9.1.3.2.2. Cifrado de directorio (<strong class="command">gocrypts</strong>)</a></li>
<li><a class="reference internal" href="#cifrado-de-directorio-con-ext4">9.1.3.2.3. Cifrado de directorio (con <em>ext4</em>)</a></li>
</ul>
</li>
</ul>

  <h4>Tema anterior</h4>
  <p class="topless"><a href="01.firma.html"
                        title="capítulo anterior"><span class="section-number">9.1.3.1. </span>Firma digital</a></p>
  <h4>Próximo tema</h4>
  <p class="topless"><a href="03.ssl.html"
                        title="próximo capítulo"><span class="section-number">9.1.3.3. </span>Protocolos seguros de red</a></p>
  <div role="note" aria-label="source link">
    <h3>Esta página</h3>
    <ul class="this-page-menu">
      <li><a href="../../../_sources/09.apendice/01.cryto/03.aplicaciones/02.discos.rst.txt"
            rel="nofollow">Mostrar el código</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Búsqueda rápida</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Ir a" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navegación</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="Índice General"
             >índice</a></li>
        <li class="right" >
          <a href="03.ssl.html" title="9.1.3.3. Protocolos seguros de red"
             >siguiente</a> |</li>
        <li class="right" >
          <a href="01.firma.html" title="9.1.3.1. Firma digital"
             >anterior</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">documentación de Linuxnomicón - rolling</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" ><span class="section-number">9. </span>Apéndices</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="../index.html" ><span class="section-number">9.1. </span>Criptografía</a> &#187;</li>
          <li class="nav-item nav-item-3"><a href="../03.aplicaciones.html" ><span class="section-number">9.1.3. </span>Aplicaciones de la criptografía</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href=""><span class="section-number">9.1.3.2. </span>Cifrado de discos</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Derechos de autor CC BY 4.0, 2016-2021, José Miguel Sánchez Alés.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 3.4.3.
    </div>
  </body>
</html>