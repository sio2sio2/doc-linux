


<!DOCTYPE html>

<html lang="es">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>9.1.3. Aplicaciones de la criptografía &#8212; documentación de Linuxnomicón - rolling</title>
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
    
    <script id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/translations.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <link rel="index" title="Índice" href="../../genindex.html" />
    <link rel="search" title="Búsqueda" href="../../search.html" />
    <link rel="next" title="9.2. SAI" href="../07.sai/index.html" />
    <link rel="prev" title="9.1.2. Técnicas criptográficas" href="02.algo.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navegación</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="Índice General"
             accesskey="I">índice</a></li>
        <li class="right" >
          <a href="../07.sai/index.html" title="9.2. SAI"
             accesskey="N">siguiente</a> |</li>
        <li class="right" >
          <a href="02.algo.html" title="9.1.2. Técnicas criptográficas"
             accesskey="P">anterior</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">documentación de Linuxnomicón - rolling</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" ><span class="section-number">9. </span>Apéndices</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="index.html" accesskey="U"><span class="section-number">9.1. </span>Criptografía</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href=""><span class="section-number">9.1.3. </span>Aplicaciones de la criptografía</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="aplicaciones-de-la-criptografia">
<h1><span class="section-number">9.1.3. </span>Aplicaciones de la criptografía<a class="headerlink" href="#aplicaciones-de-la-criptografia" title="Enlazar permanentemente con este título">¶</a></h1>
<p>Hasta este epígrafe se han ilustrado los principios básicos de la criptografía y
las órdenes básicas para llevarlos a cabo. A partir de ahora, el tema estará
dedicado a exponer aplicaciones prácticas reales de la criptografía en el
cifrado, la comprobación de la integridad de los datos o la certificación de la
identidad del otro extremo (véanse los <a class="reference internal" href="01.intro.html#crypto-objetivos"><span class="std std-ref">objetivos de la criptografía</span></a>).</p>
<p>Trataremos tres:</p>
<ul class="simple">
<li><p>La <a class="reference internal" href="#firma-digital"><span class="std std-ref">firma digital</span></a>.</p></li>
<li><p>El <a class="reference internal" href="#disk-encrypt"><span class="std std-ref">cifrado de discos</span></a>.</p></li>
<li><p>Los <a class="reference internal" href="#ssl"><span class="std std-ref">protocolos seguros de red</span></a>.</p></li>
</ul>
<div class="section" id="firma-digital">
<span id="id1"></span><h2><span class="section-number">9.1.3.1. </span>Firma digital<a class="headerlink" href="#firma-digital" title="Enlazar permanentemente con este título">¶</a></h2>
<p>Una <em>firma digital</em> es al mundo digital lo que la firma manuscrita al papel, la
cual certifica la identidad de quien firma y que se está de acuerdo con los
términos de lo firmado.</p>
<p>Para llevar a cabo la <em>firma digital</em> de unos datos (un fichero o un mensaje de
correo, por ejemplo) se obra del siguiente modo:</p>
<ul class="simple">
<li><p>Se obtiene un resumen de los datos mediante una función <em>hash</em>.</p></li>
<li><p>Se cifra tal resumen con la clave privada del firmante.</p></li>
<li><p>Se envían los datos (o se almacena el fichero) junto al resumen cifrado.</p></li>
</ul>
<p>Ante esto, un tercero (por ejemplo, el destinatario de un mensaje de correo
firmado), es capaz de certificar que el origen es quien dice ser, ya que
descifrará el resumen con la clave pública de éste y, por otra parte, podrá
comprobar si los datos conservan su integridad gracias al propio resumen
descifrado.</p>
<p>Conceptualmente, pues, es bastante sencillo y podemos ilustrar los pasos
anteriores haciendo uso de la <a class="reference internal" href="02.algo.html#gnupg-1"><span class="std std-ref">orden gpg</span></a>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> <span class="nb">echo</span> <span class="s2">&quot;Este es el contenido del fichero que firmo&quot;</span> &gt; fichero.txt
<span class="gp">$</span> gpg --detach-sign --default-key mi_cuenta@example.com -o fichero.sig fichero.txt
</pre></div>
</div>
<p>De esta manera tenemos un fichero original (<code class="file docutils literal notranslate"><span class="pre">fichero.txt</span></code>) y su resumen
cifrado digitalmente con nuestra clave privada en <code class="file docutils literal notranslate"><span class="pre">fichero.sign</span></code>. Si
analizamos el fichero de firma:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> gpg --list-packets fichero.sign
<span class="go">:signature packet: algo 1, keyid 53175AA29C972B7B</span>
<span class="go">        version 4, created 1543050622, md5len 0, sigclass 0x00</span>
<span class="go">        digest algo 10, begin of digest 04 9e</span>
<span class="go">        hashed subpkt 33 len 21 (issuer fpr v4 040968BBC05C39A4DD2A43BD53175AA29C972B7B)</span>
<span class="go">        hashed subpkt 2 len 4 (sig created 2018-11-24)</span>
<span class="go">        hashed subpkt 28 len 23 (signer&#39;s user ID)</span>
<span class="go">        subpkt 16 len 8 (issuer key ID 53175AA29C972B7B)</span>
<span class="go">        data: [3071 bits]</span>
</pre></div>
</div>
<p>veremos algunas características de la firma, como:</p>
<ul>
<li><p>qué algoritmo de clave simétrica se usó, el <strong>1</strong>, que se corresponde con una
clave asimétrica <abbr title="Rivest, Shamir y Adleman">RSA</abbr>, válida tanto para firma como para cifrado. El
significado de los códigos puede encontrarse en el <span class="target" id="index-0"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc4880.html"><strong>RFC 4880</strong></a>, y en concreto
en la <a class="reference external" href="https://tools.ietf.org/html/rfc4880#section-9.1">sección 9.1</a>.</p></li>
<li><p>qué clave se usó: la <em>53175AA29C972B7B</em>, que efectivamente es la nuestra:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> gpg --keyid-format long -list-keys
<span class="go">/home/usuario/.gnupg/pubring.kbx</span>
<span class="go">--------------------------------</span>
<span class="hll"><span class="go">pub   rsa3072/53175AA29C972B7B 2018-11-21 [SC] [expires: 2020-11-20]</span>
</span><span class="go">      040968BBC05C39A4DD2A43BD53175AA29C972B7B</span>
<span class="go">uid                 [ unknown] Soy el que soy &lt;mi_cuenta@example.com&gt;</span>
<span class="go">      sub   rsa3072/4B1F09C9B84F038E 2018-11-21 [E] [expires: 2020-11-20]</span>
</pre></div>
</div>
</li>
<li><p>con qué algoritmo se resumió el fichero, el <strong>10</strong>, que es <em>SHA512</em> según
<a class="reference external" href="https://tools.ietf.org/html/rfc4880#section-9.4">la sección 9.4</a> del
<span class="target" id="index-1"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc4880.html"><strong>RFC 4880</strong></a>.</p></li>
</ul>
<p>Si hacemos llegar <strong>ambos</strong> archivos a un tercero, y éste posee nuestra clave
pública, podrá verificar nuestra identidad gracias al cifrado de la firma y la
integridad del fichero gracias al resumen que contiene esta:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> gpg --verify fichero.sign fichero.txt
<span class="go">[...]</span>
<span class="go">Primary key fingerprint: 0409 68BB C05C 39A4 DD2A  43BD 5317 5AA2 9C97 2B7B</span>
<span class="gp">$</span> <span class="nb">echo</span> <span class="nv">$?</span>
<span class="go">0</span>
</pre></div>
</div>
<p>Todo parece perfecto… pero hay un pequeño problema. ¿Cómo está seguro el
tercero de que la clave pública que posee es realmente de quien dice ser y no
otro que suplanta su identidad? Para subsanar este último escollo existen los
<em>certificados digitales</em>.</p>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>Retenga el adagio de que la clave pública del destinatario se usa para
cifrar, y la clave privada del emisor para firmar.</p>
</div>
<div class="section" id="certificado-digital">
<span id="cert-digital"></span><h3><span class="section-number">9.1.3.1.1. </span>Certificado digital<a class="headerlink" href="#certificado-digital" title="Enlazar permanentemente con este título">¶</a></h3>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>Tratamos los <em>certificados digitales de clave pública</em>, por lo que a
partir de ahora hablaremos, simplemente, de <em>certificados digitales</em>.</p>
</div>
<p>Un <em class="dfn">certificado digital</em> es un documento firmado digitalmente por una
<em>autoridad de certificación</em> que asocia unos datos de identificación con una
clave pública. Esto, pues, resuelve el problema de suplantación: sabemos que la
clave pública pertenece a quien dice pertenecer, porque un tercero, la autoridad
de certificación, en el que tenemos absoluta confianza, lo acredita y ha firmado
para ello.</p>
<p>Esquematizando, pues, un <em>certificado digital</em> se compone:</p>
<ul class="simple">
<li><p>Una pareja de claves.</p></li>
<li><p>La identidad del propietario de dichas claves.</p></li>
<li><p>La firma digital de una autoridad de certificación sobre la clave pública y
los datos identificativos.</p></li>
</ul>
<p>Así pues, cuando se firma con un certificado digital el receptor del mensaje
puede:</p>
<ul class="simple">
<li><p>Deducir de la clave pública que permite verificar la firma la identidad del
firmante con total seguridad, ya que la clave pública está refrendada (o sea,
firmada a su vez) por una autoridad de certificación.</p></li>
<li><p>Por supuesto, comprobar la integridad del mensaje gracias al resumen que
contiene la firma.</p></li>
</ul>
<p>Así todo queda resuelto. Ahora bien, ¿quién es esta autoridad de certificación y
por qué es digna de confianza? Una <em class="dfn">autoridad de certificación</em> (a partir
de ahora, <abbr title="Certification Authority">CA</abbr>) es aquella entidad de confianza encargada de emitir (y revocar)
certificados digitales.  Para llevar a cabo esta tarea la propia <abbr title="Certification Authority">CA</abbr> dispone de
un certificado, de manera que con su clave privada firma los certificados que
emite. La estructura es jerárquica y el certificado de una <abbr title="Certification Authority">CA</abbr> puede estar
avalado por la firma de otro <abbr title="Certification Authority">CA</abbr> de rango superior. Sin embargo, en la cúspide
se encuentran las <abbr title="Certification Authority">CA</abbr> raíz, cuyos certificados son autofirmado, lo que
significa que nadie certifica digitalmente la identidad de la <abbr title="Certification Authority">CA</abbr>. La garantía
de estos certificados viene avalada porque los propios sistemas operativos y
navegadores web incorporan los certificados raíz de estas autoridades, que
habrán avalado de algún modo su identidad. Por ejemplo, <em>Debian</em>, incluye el
paquete <a class="reference external" href="https://packages.debian.org/search?keywords=ca-certificates">ca-certificates</a>, que las
contiene.</p>
<p>Un ejemplo de esta jerarquía es el <a class="reference internal" href="../../07.serre/02.web/02.nginx/02.avanz/07.https.html#nginx-https"><span class="std std-ref">certificado gratuito para servidores
web</span></a> emitido por <a class="reference external" href="https://letsencrypt.org/">LetsEncrypt</a>, cuyo certificado a
su vez esta firmado por <a class="reference external" href="https://www.identrust.com/">Digital Signature Trust</a>, que sí es una <abbr title="Certification Authority">CA</abbr> raíz:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> openssl x509 -in cert.pem -text -noout <span class="p">|</span> egrep -E <span class="s1">&#39;^\s*(?Issuer|Subject):&#39;</span>
<span class="go">        Issuer: O = Digital Signature Trust Co., CN = DST Root CA X3</span>
<span class="go">        Subject: C = US, O = Let&#39;s Encrypt, CN = Let&#39;s Encrypt Authority X3</span>
</pre></div>
</div>
<p>Sea como sea, las <abbr title="Certification Authority">CA</abbr> generan certificados finales:</p>
<ul class="simple">
<li><p>Para otra <abbr title="Certification Authority">CA</abbr> subordinada.</p></li>
<li><p>Para una persona física.</p></li>
<li><p>Para una aplicación de <em>software</em></p></li>
<li><p>Para un servidor.</p></li>
</ul>
<p>Los certificados, no obstante, no son eternos: la <abbr title="Certification Authority">CA</abbr> los acredita por un
tiempo determinado, por lo que son sólo válidos entre una fecha inicial
(normalmente la fecha en que son acreditados) y una fecha final que varía según
el tiempo de validez por el que se certifiquen. Ambas fechas se incluyen dentro
de los datos identificativos.</p>
<p class="rubric">Certificados personales</p>
<p>El proceso típico de emisión de un certificado personal es el siguiente:</p>
<ol class="arabic simple">
<li><p>El interesado realiza una solicitud a la <abbr title="Certification Authority">CA</abbr>, por lo general a través de
un servicio web, en que se recogen los datos identificativos y se genera una
pareja de claves. Ahora bien, como la identidad del interesado no ha podido
verificarse, la <abbr title="Certification Authority">CA</abbr> genera una petición <abbr title="Certificate Signing Request">CSR</abbr>.</p></li>
<li><p>El interesado se acerca físicamente a la oficina de una <abbr title="Registration Authority">RA</abbr> (autoridad de
registro) a fin de confirmar ante ésta que es quien dice ser.</p></li>
<li><p>La <abbr title="Registration Authority">RA</abbr> notifica a la <abbr title="Certification Authority">CA</abbr> tal verificación, con lo que esta pone a
disposición del interesado (p.e. a través del servicio web que utilizó
primeramente) el certificado solicitado.</p></li>
<li><p>El interesado obtiene el certificado y lo instala en su sistema (navegador,
cliente de correo, etc).</p></li>
</ol>
<img alt="../../_images/certificados.png" src="../../_images/certificados.png" />
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>En España la autoridad de certificación que usan la inmensa mayoría de
las administraciones públicas es la <a class="reference external" href="http://www.cert.fnmt.es">Fábrica Nacional de Moneda y Timbre</a>.  Muchas particulares españoles también usan esta
autoridad para sus certificados personales, gracias a una <a class="reference external" href="http://mapaoficinascert.appspot.com/">extensa red de
oficinas de registro</a> (<abbr title="Registration Authority">RA</abbr>) que
incluye oficinas de la seguridad social, de la agencia tributaria o
ayuntamientos.</p>
</div>
<p>Por último, es necesario señalar que, para asegurar la validez de un
certificado, no basta sólo con comprobar si el certificado no ha caducado y
hacer uso de la firma pública de la <abbr title="Certification Authority">CA</abbr>. Un certificado puede haberse revocado
antes de caducar y, en consecuencia, dejar de ser válido antes de tiempo. Por
eso, las <abbr title="Certification Authority">CA</abbr> deben ofrecer un servicio para la comprobación de estas
revocaciones. Por ejemplo, la <abbr title="Fábrica Nacional de Moneda y Timbre">FNMT</abbr> ofrece este servicio de forma gratuita<a class="footnote-reference brackets" href="#id8" id="id2">1</a> mediante el protocolo estándar <abbr title="Online Certificate Status Protocol">OSCP</abbr> descrito en el <span class="target" id="index-2"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc6960.html"><strong>RFC 6960</strong></a>.</p>
<div class="admonition seealso">
<p class="admonition-title">Ver también</p>
<p>Ëchele un ojo a la <a class="reference external" href="http://blog.marcnuri.com/ocsp-validar-estado-de-revocacion-de-certificados-fnmt-mediante-protocolo-ocsp-y-openssl/">entrada de este blog donde habla del
asunto</a>
y se cuenta cómo verificar los certificados emitidos por la <abbr title="Fábrica Nacional de Moneda y Timbre">FNMT</abbr> usando
<strong class="command">openssl</strong>.</p>
</div>
<p class="rubric">Certificados de servidor</p>
<p>Estos certificados avalan que una determinada máquina (o conjunto de máquinas, si
el servidor es distribuido) tienen un determinado nombre en internet. Así,
cuando conectamos a la <a class="reference external" href="https://educacionyfp.gob.es">página oficial de Ministerio de Educación</a>, el certificado de servidor avala que la máquina
con la que conectamos es <kbd class="kbd docutils literal notranslate">educacionyfp.gob.es</kbd>. En este caso, existen
distintos niveles de acreditación, pero en el más básico es posible que la
autoridad teleacredite al servidor. Échele un ojo al <a class="reference internal" href="../../07.serre/02.web/02.nginx/02.avanz/07.https.html#nginx-https"><span class="std std-ref">procedimiento para
obtener certificados mediante el protocolo ACME</span></a>.</p>
</div>
<div class="section" id="correo-electronico">
<h3><span class="section-number">9.1.3.1.2. </span>Correo electrónico<a class="headerlink" href="#correo-electronico" title="Enlazar permanentemente con este título">¶</a></h3>
<p>La firma digital es muy usada en el correo electrónico, ya que si se firma el
conjunto de las cabeceras del mensaje, el cuerpo y los adjuntos, y finalmente
esa firma se adhiere al propio mensaje como adjunto adicional, el destinatario
puede tener seguridad al recibir un mensaje de que éste fue escrito por quien
dice y que no ha sido modificado por el camino.</p>
<p>Lo habitual, no obstante, es que no se usen certificados digitales, sino claves
<abbr title="Pretty Good Privacy">PGP</abbr> un estándar desarrollado para el cifrado y firma de mensajes de correos
electrónicos, cuya generación, importación y exportación de claves se
<a class="reference internal" href="02.algo.html#gpg-pgp"><span class="std std-ref">practicamos al tratar el cifrado asimétrico</span></a>. Obviamente, el
proceso de firma de un mensaje no exige la elaboración <em>artesanal</em> de la firma,
sino que los clientes de correo como <a class="reference internal" href="../../07.serre/03.mail/04-misc/02-cliente/05-mua.html#mutt"><span class="std std-ref">mutt</span></a> o <a class="reference external" href="https://www.thunderbird.net/es-ES/">Thunderbird</a> suelen
incorporar esa funcionalidad para que el proceso sea muy sencillo.</p>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>También es posible firmar y cifrar mensajes con determinados servicios
de <em>webmail</em> y la extensión adecuada del navegador. Por ejemplo, en
<strong class="program">Chrome</strong> existe la extensión <a class="reference external" href="https://www.mailvelope.com/en">Mailenvelope</a> que permite el cifrado de
mensajes para los principales sitios de webmail (<a class="reference external" href="https://gmail.google.com">Gmail</a>, <a class="reference external" href="https://mail.yahoo.com">Yahoo</a>, <a class="reference external" href="https://www.outlook.com">Outlook</a>,
etc.).</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">Ver también</p>
<p>Para ver cómo firmar mensajes de correo en <a class="reference internal" href="../../07.serre/03.mail/04-misc/02-cliente/05-mua.html#mutt"><span class="std std-ref">mutt</span></a> con
el certificado de la <abbr title="Fábrica Nacional de Moneda y Timbre">FNMT</abbr>, puede consultar <a class="reference internal" href="../../07.serre/03.mail/04-misc/02-cliente/05-mua.html#mutt-fnmt"><span class="std std-ref">este epígrafe</span></a>.</p>
</div>
</div>
</div>
<div class="section" id="cifrado-de-discos">
<span id="disk-encrypt"></span><h2><span class="section-number">9.1.3.2. </span>Cifrado de discos<a class="headerlink" href="#cifrado-de-discos" title="Enlazar permanentemente con este título">¶</a></h2>
<p>Aunque ya hemos ilustrado <a class="reference internal" href="02.algo.html#gnupg-1"><span class="std std-ref">cómo cifrar un fichero individual</span></a>,
este procedimiento sólo es útil si se quiere portar un fichero y es
absolutamente impracticable si lo que se pretende es almacenar ficheros en
disco, ya que exige cada vez que se quiera realizar la modificación del
contenido, un descifrado y un cifrado manual. En la práctica, lo que se hace es
cifrar la totalidad o parte de un sistema de ficheros a fin de que todo lo
incluido en esa zona este cifrado y no ser leído (o escrito) a menos que se
conozca la contraseña. Para ponerlo en práctica hay tres estrategias.</p>
<ol class="arabic simple">
<li><p>El cifrado de dispositivos de bloques completos (p.e. una partición), que usa
<abbr title="Linux Unified Key Setup">LUKS</abbr>.</p></li>
<li><p>El cifrado del contenido de un directorio arbitrario, que, junto a <a class="reference external" href="https://es.wikipedia.org/wiki/Sistema_de_archivos_en_el_espacio_de_usuario">FUSE</a>, es
la aproximación que usa software como:</p>
<ul class="simple">
<li><p><a class="reference external" href="https://github.com/vgough/encfs">encfs</a>, que ha sido el <em>software</em> más usado, pero que es actualmente
desaconsejable por sus problemas de seguridad.</p></li>
<li><p><a class="reference external" href="https://www.cryfs.org/">cryfs</a>, que tiene la limitación de <a class="reference external" href="https://github.com/cryfs/cryfs/issues/84">no permitir aún el cambio en la
contraseña de cifrado</a>.</p></li>
<li><p><a class="reference external" href="https://nuetzlich.net/gocryptfs/">gocryptfs</a>, que será el que utilicemos por no tener la limitación
anterior.</p></li>
</ul>
</li>
<li><p>Usar las capacidades de cifrado del propio sistema de ficheros, si el que
usamos las tiene. En el caso de <em>ext4</em>, éste soporta cifrado desde la versión
4.1 del kernel de linux.</p></li>
</ol>
<div class="section" id="cifrado-de-bloques-luks">
<h3><span class="section-number">9.1.3.2.1. </span>Cifrado de bloques (<abbr title="Linux Unified Key Setup">LUKS</abbr>)<a class="headerlink" href="#cifrado-de-bloques-luks" title="Enlazar permanentemente con este título">¶</a></h3>
<p>Mediante esta técnica el software hace de intermediario entre los bloques
físicos y los bloques de un dispositivo virtual cifrando en las escrituras y
descifrando en las lecturas.</p>
<img alt="../../_images/dm-crypt.png" src="../../_images/dm-crypt.png" />
<p>En consecuencia:</p>
<ul class="simple">
<li><p>Ciframos un dispositivo de bloques entero.</p></li>
<li><p>Como el cifrado es independiente del sistema de ficheros, se puede utilizar
cualquier sistema de ficheros.</p></li>
<li><p>Permite no sólo el cifrado de datos, sino el cifrado del sistema entero,
preparando convenientemente el sistema (caso que no abordaremos aquí, pero que
puede consultarse, por ejemplo, en un <a class="reference external" href="https://wiki.archlinux.org/index.php/Dm-crypt_(Espa%C3%B1ol)/Encrypting_an_entire_system_(Espa%C3%B1ol)#Modalidad_plain_de_dm-crypt">artículo de la wiki de Archlinux</a>).</p></li>
</ul>
<p>Abordaremos el caso más sencillo de querer cifrar una partición física, para lo
cual debemos primero instalar el <em>software</em> de cifrado:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> apt install cryptsetup
</pre></div>
</div>
<p class="rubric">Operativa manual</p>
<p>Lo primero es mapear una partición física<a class="footnote-reference brackets" href="#id9" id="id3">2</a> (p.e. <code class="file docutils literal notranslate"><span class="pre">/dev/sda6</span></code>) sobre
un dispositivo virtual:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> cryptsetup -y -v luksFormat /dev/sda6  <span class="c1"># Requerirá una contraseña</span>
<span class="gp">#</span> cryptsetup open /dev/sda6 cifrado      <span class="c1"># Debemos proporcionar la contraseña</span>
</pre></div>
</div>
<p>Esto generará el dispositivo virtual de bloques <code class="file docutils literal notranslate"><span class="pre">/dev/mapper/cifrado</span></code>,
sobre el cual podemos actuar como si se tratara de un dispositivo físico, o
sea:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> mkfs.ext4 -L DATOSECRETOS /dev/mapper/cirado
<span class="gp">#</span> mount /dev/mapper/cifrado /mnt
</pre></div>
</div>
<p>Si en algún momento quisiéramos desmontar todo:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> umount /mnt
<span class="gp">#</span> cryptsetup close cifrado
</pre></div>
</div>
<p class="rubric">Operativa automatizada</p>
<p>Que le administrador deba llevar a cabo estas operaciones cada vez que se arranca
el sistema, no es algo operativo. Para semiautomatizar el montaje durante el
arranque podemos añadir la asociación entre el dispositivo físico y el virtual
en <code class="file docutils literal notranslate"><span class="pre">/etc/crypttab</span></code>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> <span class="nb">echo</span> <span class="s2">&quot;cifrado /dev/sda6 none&quot;</span> &gt;&gt; /etc/crypttab
</pre></div>
</div>
<p>y la asociación entre el dispositivo virtual y el punto de montaje en
<code class="file docutils literal notranslate"><span class="pre">/etc/fstab</span></code>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> <span class="nb">echo</span> <span class="s2">&quot;/dev/mapper/cifrado /mnt ext4 defaults 0 0&quot;</span> &gt;&gt; /etc/fstab
</pre></div>
</div>
<p>El montaje será semiautomático, porque durante el proceso de arranque deberemos
digitalizar la contraseña. Es posible, también, en vez de que la clave sea
interactiva, guardarla en un fichero. Es más, <abbr title="Linux Unified Key Setup">LUKS</abbr> dispone de ocho slots para
almacenar claves alternativas. Ahora mismo sólo habría una:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> cryptsetup luksDump /dev/sda6
<span class="go">LUKS header information</span>
<span class="go">Version:        2</span>
<span class="go">Epoch:          8</span>
<span class="go">Metadata area:  16384 [bytes]</span>
<span class="go">Keyslots area:  16744448 [bytes]</span>
<span class="go">UUID:           e26d3cf8-20a7-422f-ac8f-83340e63725f</span>
<span class="go">Label:          (no label)</span>
<span class="go">Subsystem:      (no subsystem)</span>
<span class="go">Flags:          (no flags)</span>

<span class="go">Data segments:</span>
<span class="go">  0: crypt</span>
<span class="go">        offset: 16777216 [bytes]</span>
<span class="go">        length: (whole device)</span>
<span class="go">        cipher: aes-xts-plain64</span>
<span class="go">        sector: 512 [bytes]</span>

<span class="hll"><span class="go">Keyslots:</span>
</span><span class="go">  0: luks2</span>
<span class="go">        Key:        512 bits</span>
<span class="go">        Priority:   normal</span>
<span class="go">        Cipher:     aes-xts-plain64</span>
<span class="go">        Cipher key: 512 bits</span>
<span class="go">        PBKDF:      argon2i</span>
<span class="go">        Time cost:  4</span>
<span class="go">        Memory:     98948</span>
<span class="go">        Threads:    1</span>
<span class="go">        Salt:       a0 a1 57 4c 30 6a af e5 de 76 d5 d8 a9 f0 11 b7</span>
<span class="go">                    ac b5 c6 90 d0 1d 4e 92 4d 1c 4b b5 4c 07 97 70</span>
<span class="go">        AF stripes: 4000</span>
<span class="go">        AF hash:    sha256</span>
<span class="go">        Area offset:32768 [bytes]</span>
<span class="go">        Area length:58048 [bytes]</span>
<span class="go">        Digest ID:  0</span>

<span class="go">Tokens:</span>
<span class="go">Digests:</span>
<span class="go">  0: pbkdf2</span>
<span class="go">        Hash:       sha256</span>
<span class="go">        Iterations: 39337</span>
<span class="go">        Salt:       2b c9 51 10 c7 29 4b 63 35 a4 83 63 bc 36 46 2f</span>
<span class="go">                    49 92 af dd 32 a8 7c 9d 19 08 51 80 1b 58 6f 56</span>
<span class="go">        Digest:     0c 52 b0 1d 8c 80 2e 6b 45 0a c8 ac 4a b2 e9 a2</span>
<span class="go">                    f4 bf 81 e6 5a 00 c4 42 af 10 21 9c 3a 92 fe 6c</span>
</pre></div>
</div>
<p>con lo que podemos añadir al mismo sistema otra clave que esté en un fichero.
Para ello, vamos primero a generar esa clave, constituida por 512 <em>bytes</em>
totalmente aleatorios:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> dd &lt; /dev/urandom &gt; /root/luks.key <span class="nv">bs</span><span class="o">=</span><span class="m">512</span> <span class="nv">count</span><span class="o">=</span><span class="m">1</span>
</pre></div>
</div>
<p>que, podemos consultar en formato hexadecimal, así:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> od -v -An -tx1 /root/luks.key  <span class="c1"># Consultamos la clave</span>
<span class="go">dc 12 ae d8 2c b5 4e 12 56 a9 35 b4 5f a6 29 b9</span>
<span class="go">[...]</span>
</pre></div>
</div>
<p>Con la clave ya en el fichero <code class="file docutils literal notranslate"><span class="pre">/root/luks.key</span></code>, podemos añadirla a un
<em>slot</em>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> cryptsetup luksAddKey /dev/sda6 /root/luks.key
<span class="gp">#</span> cryptsetup luksDump /dev/sda6
<span class="go">[...]</span>
<span class="go">Keyslots:</span>
<span class="go">  0: luks2</span>
<span class="go">        Key:        512 bits</span>
<span class="go">        Priority:   normal</span>
<span class="go">        Cipher:     aes-xts-plain64</span>
<span class="go">        Cipher key: 512 bits</span>
<span class="go">        PBKDF:      argon2i</span>
<span class="go">        Time cost:  4</span>
<span class="go">        Memory:     98948</span>
<span class="go">        Threads:    1</span>
<span class="go">        Salt:       a0 a1 57 4c 30 6a af e5 de 76 d5 d8 a9 f0 11 b7</span>
<span class="go">                    ac b5 c6 90 d0 1d 4e 92 4d 1c 4b b5 4c 07 97 70</span>
<span class="go">        AF stripes: 4000</span>
<span class="go">        AF hash:    sha256</span>
<span class="go">        Area offset:32768 [bytes]</span>
<span class="go">        Area length:258048 [bytes]</span>
<span class="go">        Digest ID:  0</span>
<span class="go">  1: luks2</span>
<span class="go">        Key:        512 bits</span>
<span class="go">        Priority:   normal</span>
<span class="go">        Cipher:     aes-xts-plain64</span>
<span class="go">        Cipher key: 512 bits</span>
<span class="go">        PBKDF:      argon2i</span>
<span class="go">        Time cost:  4</span>
<span class="go">        Memory:     100952</span>
<span class="go">        Threads:    1</span>
<span class="go">        Salt:       b1 63 a9 24 aa cc f5 9c b4 6c 8a 8b 27 7a cb 2c</span>
<span class="go">                    72 cd f8 d9 68 b9 1b f4 43 c7 d6 b5 20 81 47 c5</span>
<span class="go">        AF stripes: 4000</span>
<span class="go">        AF hash:    sha256</span>
<span class="go">        Area offset:290816 [bytes]</span>
<span class="go">        Area length:258048 [bytes]</span>
<span class="go">        Digest ID:  0</span>
<span class="go">[...]</span>
</pre></div>
</div>
<p>Por último, si en <code class="file docutils literal notranslate"><span class="pre">/etc/crypttab</span></code> modificamos la línea para que se use el
fichero:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">cifrado     /dev/sda6      /root/luks.key</span>
</pre></div>
</div>
<p>durante el arranque no se pedirá ninguna clave y el sistema se encontrará
montado al acabar la secuencia.</p>
<div class="admonition warning">
<p class="admonition-title">Advertencia</p>
<p>Ahora bien, ¿para qué ciframos una partición si dejamos la
clave para su descifrado en un fichero de otra partición sin cifrar?</p>
</div>
<p>Lo interesante de lo anterior es, simplemente, comprobar que se puede guardar la
clave en un fichero y usarlo para no tener que escribirla interactivamente. Y
ello es útil, si almacenamos el fichero en un dispositivo externo como un pincho
<abbr title="Universal Serial Bus">USB</abbr> que procuremos retirar y llevarnos lejos de la máquina cuando no la
usemos. Además, es conveniente ocultar ese fichero para que pase desapercibido
si alguien se hace con nuestro pincho. A este respecto, lo más juicioso es
guardar las 512 <em>bytes</em> de la clave en algún espacio libre del pincho <abbr title="Universal Serial Bus">USB</abbr> y
ajeno a los sistemas de ficheros que pueda haber en él:</p>
<ul class="simple">
<li><p>Si el particionado es <abbr title="Disk Operating System">DOS</abbr>, podemos utilizar los últimos 512 bytes del espacio
entre el <abbr title="Master Boot Record">MBR</abbr> y la primera partición, ya que al principio de ese espacio
puede haber código de un gestor de arranque como <abbr title="GRand Unified Bootloader">GRUB</abbr>.</p></li>
<li><p>Si el particionado es <abbr title="GUID Partition Table">GPT</abbr>, podemos utilizar los últimos 512 bytes del espacio
que se reserva para definir particiones, ya que es bastante improbable que en
el pincho hayamos creado más de 124 particiones.</p></li>
</ul>
<p>Pongamos este segundo caso de ejemplo. En un disco <abbr title="GUID Partition Table">GPT</abbr>:</p>
<ul class="simple">
<li><p>El primer sector es un <abbr title="Master Boot Record">MBR</abbr> ficticio (512B)</p></li>
<li><p>El segundo sector es la cabecera <abbr title="GUID Partition Table">GPT</abbr> (512B)</p></li>
<li><p>A continuación hay espacio para 128 definiciones de particiones cada una
de las cuales ocupa 128 bytes (16KiB).</p></li>
</ul>
<p>En consecuencia el comienzo del disco ocupa 17KiB o lo que es lo mismo 34
sectores, así que podemos ocupar el sector <strong>34</strong> para almacenar nuestra clave,
con el único costo de que &quot;sólo&quot; podremos definir 124 particiones, lo cual,
ciertamente, no parece ningún problema.</p>
<p>Supongamos que el pincho se encuentra en <code class="file docutils literal notranslate"><span class="pre">/dev/sdb</span></code><a class="footnote-reference brackets" href="#id10" id="id4">3</a>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> gdisk -l /dev/sdb
<span class="go">[...]</span>
<span class="go">Number  Start (sector)    End (sector)  Size       Code  Name</span>
<span class="go">   1             416          103003   50.1 MiB    EF00  EFI System Partition</span>
<span class="go">   2          103008        30719966   14.6 GiB    0700  Microsoft basic data</span>
</pre></div>
</div>
<p>Vamos a crear una clave aleatoria de 512 bytes directamente sobre su sector
<strong>34</strong>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> dd &lt; /dev/urandom &gt; /dev/sdb <span class="nv">bs</span><span class="o">=</span><span class="m">512</span> <span class="nv">count</span><span class="o">=</span><span class="m">1</span> <span class="nv">seek</span><span class="o">=</span><span class="m">33</span>
</pre></div>
</div>
<p>y, creada, la añadimos a un <em>slot</em>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> <span class="o">{</span> <span class="nb">echo</span> <span class="s2">&quot;secreto&quot;</span> <span class="p">;</span> dd &lt; /dev/sdb <span class="nv">bs</span><span class="o">=</span><span class="m">512</span> <span class="nv">count</span><span class="o">=</span><span class="m">1</span> <span class="nv">skip</span><span class="o">=</span><span class="m">33</span><span class="p">;</span> <span class="o">}</span> <span class="p">|</span> cryptsetup luksAddKey /dev/sda6 -
</pre></div>
</div>
<p>donde «secreto» es la contraseña que introdujimos al crear el dispositivo
cifrado y que nos servía para hacer el montaje interactivo. Añadida esta clave,
podemos probar si funciona del siguiente modo:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> dd &lt; /dev/sdb <span class="nv">bs</span><span class="o">=</span><span class="m">512</span> <span class="nv">count</span><span class="o">=</span><span class="m">1</span> <span class="nv">skip</span><span class="o">=</span><span class="m">33</span> <span class="p">|</span> cryptsetup open /dev/sda6 cifrado --key-file<span class="o">=</span>-
</pre></div>
</div>
<p>que debe generar el dispositivo virtual y, si continua la línea en
<code class="file docutils literal notranslate"><span class="pre">/etc/fstab</span></code>. montarnos directamente la partición sobre <code class="file docutils literal notranslate"><span class="pre">/srv</span></code>. Ya
tenemos la mitad del trabajo hecho, ya que aún falta que al arrancar el sistema
busque el dispositivo, lo monte y lleve a cabo justamente esta operación.</p>
<p>Para ello, debemos crear una regla para <strong class="program">udev</strong>, que al detectar el
dispositivo <abbr title="Universal Serial Bus">USB</abbr> lance un script:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> cat &gt; /etc/udev/rules.d/70-usb.rules
<span class="go">SUBSYSTEMS==&quot;usb&quot;, ACTION==&quot;add&quot;, ATTRS{idVendor}==&quot;abcd&quot;, ATTRS{idProduct}==&quot;1234&quot;, \</span>
<span class="go">   KERNEL==&quot;sd?&quot;, SYMLINK+=&quot;usbkey&quot;, RUN+=&quot;/usr/local/bin/unlock.sh&quot;</span>
</pre></div>
</div>
<p>La regla, identifica el dispositivo en el que hemos guardado la clave a través
de su <em>idVendor</em> e <em>idProduct</em> que se pueden consultar fácilmente al hacer:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> lsusb
<span class="go">[...]</span>
<span class="go">Bus 002 Device 002: ID abcd:1234 Unknown</span>
<span class="go">[...]</span>
</pre></div>
</div>
<p>Además, aprovechamos la regla para añadir un enlace simbólico <code class="file docutils literal notranslate"><span class="pre">/dev/usbkey</span></code> que apunte
al dispositivo. Con este nombre podremos referirnos al dispositivo dentro del <em>script</em>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span>!/bin/sh
<span class="go">RT=&quot;/dev/sda6&quot;</span>
<span class="go">DEVICE=&quot;/dev/usbkey&quot;</span>
<span class="go">ENCVOL=&quot;cifrado&quot;</span>
<span class="go">MOUNTP=&quot;/srv&quot;</span>

<span class="go">{</span>
<span class="go">   until [ -b &quot;$PART&quot; ]; do sleep .5; done</span>
<span class="go">   dd &lt; &quot;$DEVICE&quot; bs=512 count=1 skip=33 | \</span>
<span class="go">      cryptsetup open &quot;$PART&quot; &quot;$ENCVOL&quot; --key-file=-</span>
<span class="go">} &amp;</span>
</pre></div>
</div>
<p>Por último, en <code class="file docutils literal notranslate"><span class="pre">/etc/crypttab</span></code> no debe existir referencia alguna, ya
que es el <em>script</em> el que realiza la operación de crear el dispositivo cifrado.
En <code class="file docutils literal notranslate"><span class="pre">/etc/fstab</span></code>, sí podemos dejar la línea, pero añadiendo la opción
<em>nofail</em>, para que no falle el montaje y pare el arranque en caso de que no se
encuentre el pincho:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">/dev/mapper/cifrado /srv   ext4   defaults,nofail  0 0</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>Esta estrategia está tomada de <a class="reference external" href="https://possiblelossofprecision.net/?p=300">esta entrada de /dev/blog</a> y sólo es válida si se cifra
una partición de datos y no la partición del sistema. Si se lleva a cabo el
cifrado del sistema, es necesario recurrir a otra estrategia totalmente
distinta basada en manipular la imagen <a class="reference external" href="https://wiki.gentoo.org/wiki/Initramfs/Guide/es">initramfs</a>.</p>
</div>
</div>
<div class="section" id="cifrado-de-directorio-gocrypts">
<h3><span class="section-number">9.1.3.2.2. </span>Cifrado de directorio (<strong class="command">gocrypts</strong>)<a class="headerlink" href="#cifrado-de-directorio-gocrypts" title="Enlazar permanentemente con este título">¶</a></h3>
<p>Esta estrategia permite cifrar un directorio entero, de modo que todo sobre lo
que trabajemos dentro de él se almacenará cifrado de forma transparente. Se basa
en el uso de un <em>software</em> intermedio que, antes de almacenar datos en el
sistema de ficheros o tras leerlos de él, cifra o descifra la información.</p>
<img alt="../../_images/gocryptfs.png" src="../../_images/gocryptfs.png" />
<p>En consecuencia:</p>
<ul class="simple">
<li><p>Cifrados sobre el sistema de ficheros existen un directorio.</p></li>
<li><p>El cifrado es también independiente del sistema de ficheros.</p></li>
<li><p>Sólo nos permite cifrar datos, no el sistema completo.</p></li>
</ul>
<p>Todo el <em>software</em> con este segundo enfoque se utiliza básicamente del mismo
modo, de modo que pueden identificarse las siguientes operaciones básicas:</p>
<ul class="simple">
<li><p>La creación del directorio cifrado, que exigirá el establecimiento de la clave
simétrica de cifrado.</p></li>
<li><p>El montaje de dicho directorio introduciendo la clave; y el desmontaje.</p></li>
<li><p>El cambio de la clave.</p></li>
</ul>
<p>Lo ilustraremos mediante <strong class="program">gocryptfs</strong>, para cuya instalación debemos
hacer:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> apt install gocryptfs fuse
</pre></div>
</div>
<p class="rubric">Operativa manual</p>
<p>Es sumamente sencilla. Suponiendo que el directorio cifrado sea
<code class="file docutils literal notranslate"><span class="pre">~/cipher</span></code>, podemos crearlo con:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> gocryptfs -init ~/cipher
</pre></div>
</div>
<p>que nos pedirá interactivamente la contraseña (la clave simétrica) con que se
cifrarán los datos. Con ella podremos realizar el montaje del siguiente modo:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> gocryptfs ~/cipher ~/plain
</pre></div>
</div>
<p>lo cual mostrará dentro de <code class="file docutils literal notranslate"><span class="pre">~/plain</span></code> los contenidos descifrados, después de
que facilitemos la clave. De esta forma, el usuario podrá trabajar de forma
transparente sobre <code class="file docutils literal notranslate"><span class="pre">~/plain</span></code>, mientras el <em>software</em> se encarga de almacenar
los datos cifrados dentro de <code class="file docutils literal notranslate"><span class="pre">~/cipher</span></code>. Al acabarse el trabajo, puede
desmontarse el directorio:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> fusermount -u ~/plain
</pre></div>
</div>
<p>Puede, además, modificarse la clave simétrica de cifrado (incluso cuando el
directorio está montado):</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> gocryptfs -passwd ~/cipher
</pre></div>
</div>
<p class="rubric">Operativa automatizada</p>
<p>Lo óptimo y cómodo, cuando se desea que los usuarios tengan la posibilidad de
tener un directorio cifrado, es que las operaciones se hagan de modo
automático, de manera que al acceder al sistema el usuario tenga montado el
directorio que da acceso a los datos sin cifrar y que al dejarlo, se produzca
el desmontaje. Para lograrlo puede plantearse la siguiente estrategia:</p>
<ol class="arabic simple">
<li><p>En la medida en que el usuario no opera sobre el directorio cifrado, se lo
ocultaremos anteponiendo a su nombre un punto. Por tanto, en vez de llamarlo
<code class="file docutils literal notranslate"><span class="pre">~/cipher</span></code> lo llamaremos, por ejemplo, <code class="file docutils literal notranslate"><span class="pre">~/.Cifrado</span></code>. Al
directorio que muestra los datos en claro, le daremos el mismo nombre pero
sin anteponer el punto (<code class="file docutils literal notranslate"><span class="pre">~/Cifrado</span></code>).</p></li>
<li><p>Haremos que la clave de cifrado coincida con la contraseña de usuario, lo
cual propicia que durante el proceso de autenticación con <a class="reference internal" href="../../04.servidor/09.autenticacion/index.html#pam"><span class="std std-ref">PAM</span></a>
podamos usar la contraseña introducida para montar automáticamente el
directorio.</p></li>
</ol>
<p>Establecido esto, basta con escribir un <em>script</em> que se encargue de hacer estas
operaciones, cuyo <a class="reference download internal" download="" href="../../_downloads/fd16c056a0c6ae388f416c450bb43556/mgocryptfs"><code class="xref download docutils literal notranslate"><span class="pre">código</span> <span class="pre">se</span> <span class="pre">enlaza</span></code></a> y dejarlo en
<code class="file docutils literal notranslate"><span class="pre">/usr/local/bin/mgocryptfs</span></code>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> mv /patH/donde/este/mgocryptfs /usr/local/bin
<span class="gp">#</span> chmod +x /usr/local/bin/mgocryptfs
</pre></div>
</div>
<p>y preparar <abbr title="Pluggable Authentication Modules">PAM</abbr> para que se ejecute al abrir y cerrar sesión en el sistema. La
forma más limpia de hacerlo es creando un <a class="reference download internal" download="" href="../../_downloads/d0af91f2d7d62901045df8a1aec64bbb/pam-gocryptfs"><code class="xref download docutils literal notranslate"><span class="pre">plugin</span> <span class="pre">de</span> <span class="pre">configuración</span>
<span class="pre">como</span> <span class="pre">éste</span></code></a> que puede habilitarse del siguiente modo:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> mv /path/donde/este/pam-gocryptfs /usr/share/pam-configs
<span class="gp">#</span> pam-auth-update
</pre></div>
</div>
<p>El <em>script</em>, además, incluye un aspecto accesorio más: sólo afecta a los
usuarios que pertenezcan al grupo <em>crypto</em>, de modo que si queremos que un
usuario monte automáticamente un directorio para guardar cifrados los datos,
necesitaremos antes haberlo incluido en este directorio.</p>
<p>Por último, está el problema del cambio de contraseña. Tal y como está
configurado por defecto, cuando un usuario del grupo <em>crypto</em> accede al sistema
y no tiene directorio de cifrado, éste se crea utilizando la contraseña de
acceso. En consecuencia, contraseña y clave de cifrado coinciden y todo
funciona correctamente. Ahora bien, si se nos antoja cambiar nuestra
contraseña, la clave de cifrado seguirá siendo la antigua, por lo que para que
el montaje automático continúe funcionado, también deberemos cambiar la clave
de forma separada. Para ello podemos crear un <em>script</em> que haga de envoltorio a
la orden que usemos para cambiar la contraseña. Por ejemplo, si es <a class="reference internal" href="../../02.conbas/05.seguridad/05a.usuarios.html#passwd"><span class="std std-ref">passwd</span></a>, una posible solución (no demasiado elegante, todo sea dicho) es
<a class="reference download internal" download="" href="../../_downloads/aa97394dc6a55a39fa7a70d1824278a2/passwd"><code class="xref download docutils literal notranslate"><span class="pre">ésta</span></code></a>.</p>
</div>
<div class="section" id="cifrado-de-directorio-con-ext4">
<span id="crypto-ext4"></span><h3><span class="section-number">9.1.3.2.3. </span>Cifrado de directorio (con <em>ext4</em>)<a class="headerlink" href="#cifrado-de-directorio-con-ext4" title="Enlazar permanentemente con este título">¶</a></h3>
<p>Desde la versión <em>4.1</em> del <em>kernel</em> de Linux, <em>ext4</em> soporta el cifrado
transparente, así que podemos utilizar lsa capacidades del propio sistema de
ficheros para cifrar de forma transparente uno o alguno de sus directorios.</p>
<p>En consecuencia:</p>
<ul class="simple">
<li><p>Es el propio sistema de ficheros el que se encarga del cifrado, lo que mejora
el rendimiento respecto a la solución anterior.</p></li>
<li><p>El sistema de ficheros debe ser forzosamente <em>ext4</em>. Otros sistemas de
ficheros también pueden soportar cifrado, pero en ese caso, tendremos que
estudiar cómo se cifra con ellos.</p></li>
<li><p>Como el anterior, es un método apropiado para cifrar datos de usuario.</p></li>
</ul>
<p>Antes de empezar es necesario:</p>
<ol class="arabic">
<li><p>Comprobar que el tamaño de página que usa el sistema y el tamaño de bloque
del sistema de archivos son iguales<a class="footnote-reference brackets" href="#id11" id="id5">4</a>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> getconf PAGE_SIZE
<span class="go">4096</span>
<span class="gp">#</span> tune2fs -l /dev/sda5 <span class="p">|</span> awk <span class="s1">&#39;$0 ~ /^Block size:/ {print $NF}&#39;</span>
<span class="go">4096</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>Suponemos que el sistema de archivos en el que queremos cifrar algunos
directorios es <code class="file docutils literal notranslate"><span class="pre">/home</span></code> y que éste se encuentra sobre la partición
<code class="file docutils literal notranslate"><span class="pre">/dev/sda5</span></code></p>
</div>
</li>
<li><p>Habilitar el cifrado para el sistema de archivos:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> tune2fs -l /dev/sda5 <span class="p">|</span> grep -q crypt <span class="o">&amp;&amp;</span> <span class="nb">echo</span> <span class="s2">&quot;Habilitado&quot;</span>
<span class="gp">#</span> tune2fs -O encrypt /dev/sda5
<span class="gp">#</span> tune2fs -l /dev/sda5 <span class="p">|</span> grep -q crypt <span class="o">&amp;&amp;</span> <span class="nb">echo</span> <span class="s2">&quot;Habilitado&quot;</span>
<span class="go">Habilitado</span>
</pre></div>
</div>
</li>
<li><p>Instalar el <em>software</em> adecuado:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> apt install fscrypt libpam-fscrypt
</pre></div>
</div>
<p>En puridad sólo necesitamos el primer paquete, pero el segundo permite
desbloquear de forma transparente los directorios cifrados al autenticarse el
usuario en el sistema.</p>
</li>
</ol>
<p class="rubric">Preparación</p>
<p>Antes de cifrar cualquier directorio es necesario crear las estructuras
necesarias:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> fscrypt setup
<span class="gp">#</span> fscrypt setup /
<span class="gp">#</span> fscrypt setup /home
</pre></div>
</div>
<p>La primera orden crea la configuración <code class="file docutils literal notranslate"><span class="pre">/etc/fscrypt.conf</span></code>, la segunda es
necesaria si se quiere usar la contraseña del propio usuario como clave para el
cifrado; y la tercera se requiere para poder usar otro tipo de claves para el
cifrado.</p>
<p class="rubric">Operativa</p>
<p>Para cifrar un directorio basta con que el usuario haga:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> mkdir ~/privado
<span class="gp">$</span> fscrypt encrypt ~/privado --source<span class="o">=</span>pam_passphrase
</pre></div>
</div>
<p>que usará como clave su propia contraseña de usuario. Además, de preparar el
directorio para que se almacenen los datos cifrados, lo <em>desbloquea</em>, lo que
significa que podremos escribir y leer dentro de él de forma transparente,
aunque lo datos se guarden cifrados:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> fscrypt status ~/privado
<span class="go">&quot;/home/usuario/privado/&quot; is encrypted with fscrypt.</span>

<span class="go">Policy:   822664193b8152b4</span>
<span class="go">Unlocked: Yes</span>

<span class="go">Protected with 1 protector:</span>
<span class="go">PROTECTOR         LINKED   DESCRIPTION</span>
<span class="go">1095888ae485002d  Yes (/)  login protector for usuario</span>
</pre></div>
</div>
<p>La ventaja de usar la contraseña de usuario es doble:</p>
<ul class="simple">
<li><p>Al autenticarse en el sistema, todos los directorios cifrados con la
contraseña de usuario, se desbloquearán automáticamente.</p></li>
<li><p>Al modificar la contraseña de usuario, cambiará solidariamente la clave de
cifrado de todos esos directorios.</p></li>
</ul>
<p>También puede usarse una clave distinta a la de usuario:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> mkdir ~/secreto
<span class="gp">$</span> fscrypt encrypt ~/secreto --source<span class="o">=</span>custom_passphrase
<span class="gp">$</span> fscrypt status ~/secreto
<span class="go">&quot;/home/usuario/secreto/&quot; is encrypted with fscrypt.</span>

<span class="go">Policy:   2aca13a317cf9195</span>
<span class="go">Unlocked: Yes</span>

<span class="go">Protected with 1 protector:</span>
<span class="go">PROTECTOR         LINKED  DESCRIPTION</span>
<span class="go">9572560fc543c9b5  No      custom protector &quot;1234&quot;</span>
</pre></div>
</div>
<p>En este caso se ha usado una frase personalizada de nombre «1234». En futuros
reinicios, el directorio estará bloqueadado y habrá que desbloquearlo
explícitamente proporcionando la contraseña:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> fscrypt unlock ~/secreto
</pre></div>
</div>
<p>Por otro lado, si se quiere cambiar la contraseña, habrá que ejecutar lo
siguiente:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> fscrypt metadata change-passphrase --protector<span class="o">=</span>/home:9572560fc543c9b5
</pre></div>
</div>
<p class="rubric">Cifrado del propio directorio de usuario</p>
<p>Un caso muy socorrido es cifrar el directorio personal del usuario con la clave
del propio usuario. Esta tarea debe llevarla a cabo el administrador y es
conveniente que se lleve a cabo en el proceso de de alta del usuario. En
cualquier caso, puede obrarse del siguiente modo:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> mkdir /home/usuario.new
<span class="gp">#</span> chown usuario:usuario /home/usuario.new
<span class="gp">#</span> fscrypt encrypt /home/usuario.new --user<span class="o">=</span>usuario
<span class="gp">#</span> cp -aT /home/usuario /home/usuario.new
<span class="gp">#</span> rm -rf /home/usuario
<span class="gp">#</span> mv /home/usuario.new /home/usuario
</pre></div>
</div>
<p>El tercer paso exige que el administrador proporcione la contraseña del usuario,
o sea, que la conozca. Esto en realidad no es problema, porque después de la
operación, el usuario podrá modificar la contraseña. El quinto paso, en puridad,
requeriría el uso de una herramienta como <strong class="program">shred</strong> para eliminar todo
rastro de los ficheros sin cifrar.</p>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>Lo lógico si se desea que los usuarios tengan cifrado su directorio
es crear un <em>script</em> para que el alta incluya el cifrado de tal directorio.</p>
</div>
</div>
</div>
<div class="section" id="protocolos-seguros-de-red">
<span id="proto-seguro"></span><h2><span class="section-number">9.1.3.3. </span>Protocolos seguros de red<a class="headerlink" href="#protocolos-seguros-de-red" title="Enlazar permanentemente con este título">¶</a></h2>
<p>Para la comunicación entre extremos se han desarrollado protocolos que cifran la
comunicación. y, por lo general, usan cifrado híbrido. Los más habituales son:</p>
<div class="section" id="ssh">
<h3><span class="section-number">9.1.3.3.1. </span><abbr title="Security SHell">SSH</abbr><a class="headerlink" href="#ssh" title="Enlazar permanentemente con este título">¶</a></h3>
<p>Surgió como reemplazo al protocolo <em>telnet</em> que se usaba para la administración
remota de servidores. Sin embargo, no se limita a esto y es capaz de ofrecer
otros servicios seguros como la <a class="reference internal" href="../../07.serre/01.ftp/03.ssh.html#ssh-ftp"><span class="std std-ref">transferencia de ficheros</span></a> o la
<a class="reference internal" href="../../04.servidor/10.ssh/03.tuneles.html#tunel-ssh"><span class="std std-ref">tunelización de otras comunicaciones</span></a> (funcionalidad esta análoga
a la que ofrece <a class="reference internal" href="#ssl"><span class="std std-ref">SSL</span></a>).</p>
<div class="admonition seealso">
<p class="admonition-title">Ver también</p>
<p>Hay <a class="reference internal" href="../../04.servidor/10.ssh/index.html#adm-rem"><span class="std std-ref">todo un epígrafe</span></a> dedicado a la configuración de un
servicio <abbr title="Security SHell">SSH</abbr>.</p>
</div>
</div>
<div class="section" id="vpn">
<h3><span class="section-number">9.1.3.3.2. </span><abbr title="Virtual Private Network">VPN</abbr><a class="headerlink" href="#vpn" title="Enlazar permanentemente con este título">¶</a></h3>
<p>No es propiamente un protocolo, sino una red privada virtual, esto es una
tecnología de comunicación entre redes de ordenadores que permite, a través de
una red pública (internet), la conexión segura punto a punto entre dos redes
locales de ordenadores. Esta conexión puede ser efectuada en capa 3, en cuyo
caso las dos redes extremas serán redes distintas; o en capa 2, en cuyo caso el
enlace conectará las dos redes extremas como dos segmentos de una misma red.</p>
<p>Para establecer una <abbr title="Virtual Private Network">VPN</abbr> no hay un único protocolo, sino toda pléyade de
protocolos que se pueden agrupar en tres familias: el obsoleto <abbr title="Point-tp-Point Tunneling Protocol">PPTP</abbr>, las que
usan <em>IPSec</em>, los que usan <abbr title="Secure Socket Layer">SSL</abbr> y otros que se basan en <a class="reference external" href="http://www.noiseprotocol.org/">Noise</a>.</p>
<div class="admonition seealso">
<p class="admonition-title">Ver también</p>
<p>Hay <a class="reference internal" href="../../07.serre/04.vpn/index.html#vpn"><span class="std std-ref">un extenso epígrade</span></a> dedicado a este tipo de
protocolos.</p>
</div>
</div>
<div class="section" id="ssl-tls">
<span id="ssl"></span><h3><span class="section-number">9.1.3.3.3. </span><abbr title="Secure Socket Layer">SSL</abbr>/<abbr title="Transport Layer Security">TLS</abbr><a class="headerlink" href="#ssl-tls" title="Enlazar permanentemente con este título">¶</a></h3>
<p>En realidad son el mismo protocolo, ya que <abbr title="Transport Layer Security">TLS</abbr> es el sucesor de <abbr title="Secure Socket Layer">SSL</abbr>, aunque
es común que se le siga denominando <abbr title="Secure Socket Layer">SSL</abbr>. Básicamente es un protocolo que
permite encapsular de modo seguro otro protocolo de red. Surgió en 1994 para
encapsular el protocolo <abbr title="HyperText Transfer Protocol">HTTP</abbr> (y crear <abbr title="HyperText Transfer Protocol">HTTP</abbr>s) en los navegadores <a class="reference external" href="https://es.wikipedia.org/wiki/Netscape_">Netscape</a>.</p>
<p><abbr title="Secure Socket Layer">SSL</abbr> es independiente del protocolo no seguro que cifre y, simplemente,
establece un encapsulamiento cifrado bajo el cual circula el protocolo plano sin
modificaciones. Su funcionamiento básicamente es el siguiente:</p>
<ul class="simple">
<li><p>Los extremos establecen la conexión segura intercambiando las claves según lo
explicado en el cifrado híbrido, de manera que cuando la clave simétrica se
encuentra en ambos extremos, el túnel está listo para funcionar.</p></li>
<li><p>En el cliente, la comunicación en el protocolo arbitrario se cifra gracias a
<abbr title="Secure Socket Layer">SSL</abbr> y se envía al servidor donde el protocolo <abbr title="Secure Socket Layer">SSL</abbr> se encarga de descifrar
y entregar la comunicación en claro al servidor.</p></li>
<li><p>La respuesta del servidor se cifra, se envía a través de la red, y al llegar
al cliente, se descifra y se entrega al cliente.</p></li>
</ul>
<p>Podemos pues considerar al protocolo <abbr title="Secure Socket Layer">SSL</abbr> como un mero intérprete que se
encarga de cifrar la comunicación al salir y descifrarla al entrar.</p>
<img alt="../../_images/ssl.png" src="../../_images/ssl.png" />
<p>Por tanto, servidor y cliente siguen comunicándose a través del mismo protocolo
en claro. Lo que suele ocurrir, no obstante, es que ambos, servidor y cliente,
lleven incorporada la capacidad de cifrar con <abbr title="Secure Socket Layer">SSL</abbr>. Por ejemplo, en una
comunicación <abbr title="HyperText Transfer Protocol">HTTP</abbr>s, que no es más que <abbr title="HyperText Transfer Protocol">HTTP</abbr> sobre <abbr title="Secure Socket Layer">SSL</abbr>, se comunican
directamente navegador con servidor web, porque son ellos dos mismos lo que
también cifran y descifran. Sin embargo, esto no tiene por qué ser así. Es
bastante común el siguiente esquema:</p>
<img alt="../../_images/https.png" src="../../_images/https.png" />
<p>en el que no es el servidor web el que cifra usando el protocolo <abbr title="Secure Socket Layer">SSL</abbr>, sino un
proxy web intermedio. Este proxy web inverso, se encuentra en la misma máquina
que el servidor o en una máquina de la misma red, por lo que no se compromete la
seguridad y facilita que se pueda colocar entre él y el servidor web, un proxy
de cacheo como <a class="reference external" href="https://varnish-cache.org/">varnish</a> que, con una buena política, permite agilizar el
servicio de páginas dinámicas.</p>
<p>Al basarse en <abbr title="Secure Socket Layer">SSL</abbr> en cifrado híbrido es necesario que el servidor disponga
de certificado digital para que se pueda realizar el cifrado asimétrico que
permite el intercambio de la clave de sesión y que, además, el cliente pueda
confirmar que un tercero no suplanta al servidor.</p>
<div class="admonition seealso">
<p class="admonition-title">Ver también</p>
<p>Consulte cómo <a class="reference internal" href="../../07.serre/02.web/02.nginx/02.avanz/07.https.html#certbot"><span class="std std-ref">obtener un certificado de servidor válido con
Let’s Encrypt</span></a>.</p>
</div>
<div class="section" id="sni">
<span id="id6"></span><h4><span class="section-number">9.1.3.3.3.1. </span><abbr title="Server Name Indication">SNI</abbr><a class="headerlink" href="#sni" title="Enlazar permanentemente con este título">¶</a></h4>
<p>Al cifrar <abbr title="Transport Layer Security">TLS</abbr> por completo el protocolo subyacente, es preciso que opere el
certificado antes de poder acceder a cualquier información. Esto supone un
problema cuando un servidor maneja varios certificados, cada uno asociado a un
nombre de máquina, y se precisa conocer de antemano qué nombre ha utilizado el
cliente al hacer la petición para que el servidor utilice el certificado
correspondiente. Como no hay modo de saber el nombre sin descifrar y no se puede
descifrar hasta no conocer cuál es el nombre de máquina.</p>
<p>Para sortear este inconveniente se creó la extensión <abbr title="Server Name Indication">SNI</abbr>, que permite incluir
sin cifrar el nombre de la máquina a la que se conecta el cliente, de modo que
el servidor pueda escoger el certificado adecuado. Todos los navegadores
modernos soportan esta extensión.</p>
</div>
<div class="section" id="starttls">
<span id="id7"></span><h4><span class="section-number">9.1.3.3.3.2. </span>STARTTLS<a class="headerlink" href="#starttls" title="Enlazar permanentemente con este título">¶</a></h4>
<p>El uso de <abbr title="Secure Socket Layer">SSL</abbr> tiene, sin embargo, un inconveniente: al tener que establecerse
previamente el túnel seguro, dentro del cual circula el protocolo en claro, es
necesario utilizar un puerto distinto de escucha, ya que o se escucha para
establecer una comunicación con el protocolo en claro o se escucha para
establecer un canal seguro. Esa es la razón por la que los servidores web
escuchan habitualmente en el puerto <strong>80</strong> (<abbr title="HyperText Transfer Protocol">HTTP</abbr>) y en el puerto <strong>443</strong>
(<abbr title="HyperText Transfer Protocol">HTTP</abbr>s).</p>
<table class="starttls docutils align-default" id="id12">
<caption><span class="caption-text"><strong>Puertos de escucha</strong></span><a class="headerlink" href="#id12" title="Enlace permanente a esta tabla">¶</a></caption>
<colgroup>
<col style="width: 23%" />
<col style="width: 21%" />
<col style="width: 56%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Puerto original</p></th>
<th class="head"><p>Puerto seguro</p></th>
<th class="head"><p>Propósito</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><abbr title="Simple Mail Transfer Protocol">SMTP</abbr>/25</p></td>
<td><p><abbr title="Simple Mail Transfer Protocol">SMTP</abbr>S/465</p></td>
<td><p>Envío de correo electrónico.</p></td>
</tr>
<tr class="row-odd"><td><p><abbr title="HyperText Transfer Protocol">HTTP</abbr>/80</p></td>
<td><p><abbr title="HyperText Transfer Protocol">HTTP</abbr>S/443</p></td>
<td><p>Servicio web.</p></td>
</tr>
<tr class="row-even"><td><p><abbr title="Post Office Protocol v3">POP3</abbr>/110</p></td>
<td><p><abbr title="Post Office Protocol v3">POP3</abbr>S/995</p></td>
<td><p>Buzón de correo electrónico.</p></td>
</tr>
<tr class="row-odd"><td><p><abbr title="Internet Message Access Protocol">IMAP</abbr>/143</p></td>
<td><p><abbr title="Internet Message Access Protocol">IMAP</abbr>S/993</p></td>
<td><p>Buzón de correo electrónico.</p></td>
</tr>
<tr class="row-even"><td><p><abbr title="Lightweight Directory Access Protocol">LDAP</abbr>/389</p></td>
<td><p><abbr title="Lightweight Directory Access Protocol">LDAP</abbr>S/636</p></td>
<td><p>Servicio de directorio.</p></td>
</tr>
</tbody>
</table>
<p>Para evitarlo, se ideó <em class="dfn">STARTTLS</em> que es una extensión para los protocolos
en claro (<abbr title="Simple Mail Transfer Protocol">SMTP</abbr>, <abbr title="Internet Message Access Protocol">IMAP</abbr>, <abbr title="Lightweight Directory Access Protocol">LDAP</abbr>, etc.) que permite negociar el cifrado, de
manera que servidor y cliente establecen comunicación con el protocolo
correspondiente y negocian para que la comunicación pase a cifrarse con <abbr title="Secure Socket Layer">SSL</abbr>.
Gracias a ello, no es necesario ocupar dos puertos distintos y la comunicación,
segura o no, puede realizarse siempre por el puerto tradicional. No obstante:</p>
<ul class="simple">
<li><p>A diferencia de lo que ocurre en el resto de protocolos, en la comunicación
web, sigue sin usarse STARTTLS. En los demás, se ha ido abandonando el uso del
protocolo seguro por la negociación del cifrado.</p></li>
<li><p>En el protocolo <abbr title="Simple Mail Transfer Protocol">SMTP</abbr> suelen usarse dos puertos: el <strong>25</strong> para comunicación
entre servidores, por lo general, sin autenticación; y el <strong>587</strong> para
comunicación con autenticación cliente-servidor. En cualquier caso, nada tiene
que ver esto con el cifrado, puesto que en ambos puertos se suele habilitar la
negociación del cifrado mediante STARTTLS.</p></li>
</ul>
</div>
<div class="section" id="pruebas-practicas">
<h4><span class="section-number">9.1.3.3.3.3. </span>Pruebas prácticas<a class="headerlink" href="#pruebas-practicas" title="Enlazar permanentemente con este título">¶</a></h4>
<p>Es posible ilustrar cómo funciona el protocolo <abbr title="Secure Socket Layer">SSL</abbr> en servidores con algunas
órdenes sencillas. Por ejemplo, para comunicarnos sin cifrado a un servidor que
usa un protocolo en claro, podemos usar, simplemente, <strong class="command">telnet</strong>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> telnet smtp.gmail.com <span class="m">587</span>
<span class="go">Trying 108.177.15.108...</span>
<span class="go">Connected to gmail-smtp-msa.l.google.com.</span>
<span class="go">Escape character is &#39;^]&#39;.</span>
<span class="go">220 smtp.gmail.com ESMTP r12sm6291342wrq.3 - gsmtp</span>
<span class="hll"><span class="go">EHLO localhost</span>
</span><span class="go">250-smtp.gmail.com at your service, [81.0.56.71]</span>
<span class="go">250-SIZE 35882577</span>
<span class="go">250-8BITMIME</span>
<span class="go">250-STARTTLS</span>
<span class="go">250-ENHANCEDSTATUSCODES</span>
<span class="go">250-PIPELINING</span>
<span class="go">250-CHUNKING</span>
<span class="go">250 SMTPUTF8</span>
<span class="hll"><span class="go">QUIT</span>
</span><span class="go">221 2.0.0 closing connection r12sm6291342wrq.3 - gsmtp</span>
<span class="go">Connection closed by foreign host.</span>
</pre></div>
</div>
<p>Si queremos conectarnos usando <abbr title="Secure Socket Layer">SSL</abbr> para que previamente se establezca el canal
seguro, podemos usar <strong class="command">openssl</strong>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> openssl s_client -connect smtp.gmail.com:465 -quiet
<span class="go">depth=2 OU = GlobalSign Root CA - R2, O = GlobalSign, CN = GlobalSign</span>
<span class="go">verify return:1</span>
<span class="go">depth=1 C = US, O = Google Trust Services, CN = Google Internet Authority G3</span>
<span class="go">verify return:1</span>
<span class="go">depth=0 C = US, ST = California, L = Mountain View, O = Google LLC, CN =</span>
<span class="go">smtp.gmail.com</span>
<span class="go">verify return:1</span>
<span class="go">220 smtp.gmail.com ESMTP h16sm24225437wrb.62 - gsmtp</span>
<span class="hll"><span class="go">EHLO localhost</span>
</span><span class="go">250-smtp.gmail.com at your service, [81.0.56.71]</span>
<span class="go">250-SIZE 35882577</span>
<span class="go">250-8BITMIME</span>
<span class="go">250-AUTH LOGIN PLAIN XOAUTH2 PLAIN-CLIENTTOKEN OAUTHBEARER XOAUTH</span>
<span class="go">250-ENHANCEDSTATUSCODES</span>
<span class="go">250-PIPELINING</span>
<span class="go">250-CHUNKING</span>
<span class="go">250 SMTPUTF8</span>
<span class="hll"><span class="go">QUIT</span>
</span><span class="go">221 2.0.0 closing connection h16sm24225437wrb.62 - gsmtp</span>
<span class="go">read:errno=0</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>Para incluir <abbr title="Server Name Indication">SNI</abbr> en la petición de <strong class="program">openssl</strong> puede añadirse
la opción <kbd class="kbd docutils literal notranslate"><kbd class="kbd docutils literal notranslate"></kbd>-<kbd class="kbd docutils literal notranslate">servername</kbd> <kbd class="kbd docutils literal notranslate">smtp.gmail.com</kbd></kbd>.</p>
</div>
<p>Si, por el contrario, queremos negociar el establecimiento del cifrado con
STARTTLS, podemos usar también <strong class="command">openssl</strong> indicándole que use STARTTLS:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> openssl s_client -connect smtp.gmail.com:587 -starttls smtp -quiet
<span class="go">depth=2 OU = GlobalSign Root CA - R2, O = GlobalSign, CN = GlobalSign</span>
<span class="go">verify return:1</span>
<span class="go">depth=1 C = US, O = Google Trust Services, CN = Google Internet Authority G3</span>
<span class="go">verify return:1</span>
<span class="go">depth=0 C = US, ST = California, L = Mountain View, O = Google LLC, CN =</span>
<span class="go">smtp.gmail.com</span>
<span class="go">verify return:1</span>
<span class="go">250 SMTPUTF8</span>
<span class="hll"><span class="go">EHLO localhost</span>
</span><span class="go">250-smtp.gmail.com at your service, [81.0.56.71]</span>
<span class="go">250-SIZE 35882577</span>
<span class="go">250-8BITMIME</span>
<span class="go">250-AUTH LOGIN PLAIN XOAUTH2 PLAIN-CLIENTTOKEN OAUTHBEARER XOAUTH</span>
<span class="go">250-ENHANCEDSTATUSCODES</span>
<span class="go">250-PIPELINING</span>
<span class="go">250-CHUNKING</span>
<span class="go">250 SMTPUTF8</span>
<span class="hll"><span class="go">QUIT</span>
</span><span class="go">221 2.0.0 closing connection 200sm9064552wmw.31 - gsmtp</span>
<span class="go">read:errno=0</span>
</pre></div>
</div>
<p class="rubric" id="stunnel">stunnel</p>
<p>Podemos ilustrar cómo <abbr title="Secure Socket Layer">SSL</abbr> cifra con independencia del protocolo en claro,
utilizando el <a class="reference external" href="https://www.stunnel.org/">proxy stunnel</a> y <a class="reference internal" href="../../02.conbas/99.misc/05.ordenes.html#netcat"><span class="std std-ref">netcat</span></a>. Es obvio que sí hacemos
en una máquina servidor:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> nc -l -p <span class="m">12345</span>
</pre></div>
</div>
<p>y en otra cliente:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> telnet servidor <span class="m">12345</span>
</pre></div>
</div>
<p>podremos establecer un diálogo entre ambas máquinas. El diálogo viajará
absolutamente en claro:</p>
<img alt="../../_images/nc-claro.png" src="../../_images/nc-claro.png" />
<p>Pero podemos interponer <strong class="program">stunnel</strong> para que se encargue de cifrar la
comunicación en ambos extremos:</p>
<img alt="../../_images/nc-cifrado.png" src="../../_images/nc-cifrado.png" />
<p>De esta forma, el cliente se comunica con la parte cliente de
<strong class="program">stunnel</strong>, éste con su parte servidor y, finalmente, esta parte servidor
con el <strong class="program">netcat</strong> servidor.</p>
<p>Como en el <strong>servidor</strong> necesitaremos un certificado, debemos instalar:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> apt install stunnel4 ssl-cert
</pre></div>
</div>
<p>y lo usamos para crear un certificado autofirmado:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> make-ssl-cert /usr/share/ssl-cert/ssleay.cnf /etc/stunnel/stunnel.pem
</pre></div>
</div>
<p>Hecho lo cual, podemos crear esta configuración dentro de
<code class="file docutils literal notranslate"><span class="pre">/etc/stunnel/nc.conf</span></code> (el nombre es irrelevante: basta con su extensión
sea <em>.conf</em>):</p>
<div class="highlight-ini notranslate"><div class="highlight"><pre><span></span><span class="k">[netcat-ssl]</span>
<span class="na">cert</span> <span class="o">=</span> <span class="s">/etc/stunnel/stunnel.pem</span>
<span class="na">accept</span> <span class="o">=</span> <span class="s">IP.DEL.SERVIDOR:12345</span>
<span class="na">connect</span> <span class="o">=</span> <span class="s">127.0.0.1:12345</span>
</pre></div>
</div>
<p>De esta forma, <strong class="program">stunnel</strong> acepta datos cifrados en el puerto <strong>12345</strong>
de la interfaz real, los descifra y los entrega en claro en el mismo puerto de
la interfaz de <em>loopback</em>. En el sentido inverso, recibe datos en claro
procedentes de esta interfaz y los cifra antes de enviarlos al cliente.</p>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>En <em>Stretch</em> es neceseario también habilitar explicitamente el
servicio editando el fichero <code class="file docutils literal notranslate"><span class="pre">/etc/default/stunnel4</span></code>:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="nv">ENABLED</span><span class="o">=</span><span class="m">1</span>
</pre></div>
</div>
</div>
<p>Hecha la configuración, podemos reiniciar el servicio:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> invoke-rc.d stunnel4 restart
</pre></div>
</div>
<p>Además debemos ejecutar <strong class="command">netcat</strong>, haciendo que escuche únicamente en la
interfaz de <em>loopback</em>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> nc -l -p <span class="m">12345</span> -s <span class="m">127</span>.0.0.1
</pre></div>
</div>
<p>En el <strong>cliente</strong> debemos también instalar <strong class="program">stunnel</strong> y arrancarlo con
esta configuración:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">[netcat-ssl]</span>
<span class="go">client = yes</span>
<span class="go">accept = 127.0.0.1:12345</span>
<span class="go">connect = IP.DEL.SERVIDOR:12345</span>
</pre></div>
</div>
<p>Finalmente, para comunicarnos de modo seguro con el <strong class="command">netcat</strong> servidor,
conectamos <strong class="command">telnet</strong> al <strong class="program">stunnel</strong> cliente:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> telnet localhost <span class="m">12345</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>En este caso, en que simplemente establecemos una sesión cruda con el
servidor, podríamos habernos ahorrado la instalación de <strong class="program">stunnel</strong> en
el cliente y haber usado <strong class="command">openssl</strong>, que es capaz de hacer hacer el
proceso de cifrado, además de habilitar la conversación cruda:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> openssl s_client -connect IP.DEL.SERVIDOR:12345 -quiet
</pre></div>
</div>
</div>
<div class="admonition warning">
<p class="admonition-title">Advertencia</p>
<p>Aunque la comunicación se lleva a cabo perfectamente, hay, sin
embargo, una muy grande diferencia respecto a cuando hicimos la conexión
directa (y sin cifrar): el <strong class="program">netcat</strong> servidor siempre conecta con el
<strong class="program">stunnel</strong> local con lo que para él todas las conexiones son locales
y desconoce por completo cuál es la <abbr title="Internet Protocol">IP</abbr> del cliente con el que se está
comunicando. En el cliente ocurre otro tanto, aunque en este caso es menos
importante y, además, podemos usar <strong class="command">openssl</strong> que sí conecta
directamente con la máquina servidor. Para paliar esto, <strong class="command">stunnel</strong>
debería ejecutarse como un <a class="reference internal" href="../../07.serre/05.proxies/03.reverse/02.transparencia.html#proxy-transparente"><span class="std std-ref">proxy transparente</span></a>.</p>
</div>
<p class="rubric">Notas al pie</p>
<dl class="footnote brackets">
<dt class="label" id="id8"><span class="brackets"><a class="fn-backref" href="#id2">1</a></span></dt>
<dd><p>Gratuito actualmente. Durante mucho el servicio fue de pago y
restringido.</p>
</dd>
<dt class="label" id="id9"><span class="brackets"><a class="fn-backref" href="#id3">2</a></span></dt>
<dd><p>También puede ser un volumen lógico de <abbr title="Logical Volume Management">LVM</abbr>.</p>
</dd>
<dt class="label" id="id10"><span class="brackets"><a class="fn-backref" href="#id4">3</a></span></dt>
<dd><p>Si se observa con atención, la primera partición no empieza en 34.
Sino más adelante. Es posible, puesto que la parte destinada a la definición
de particiones puede ser mayor. Sin embargo, ese <abbr title="Universal Serial Bus">USB</abbr> procede de una imagen
híbrida y es probable que empiece después, porque antes se ha situado el
código de un gestor de arranque. En cualquier, como <abbr title="GUID Partition Table">GPT</abbr> obliga a que como
mínimo se puedan definir 128 particiones, si escribimos en el sector 34,
no nos cargaremos nada.</p>
</dd>
<dt class="label" id="id11"><span class="brackets"><a class="fn-backref" href="#id5">4</a></span></dt>
<dd><p>Al crear el sistema de archivos, <span class="xref std std-ref">mkfs.ext4</span> escoge un
tamaño de bloque. Normalmente el tamaño es <strong>4096</strong>, pero puede ser menor, si
la pertición es muy pequeña. En cualquier caso, puede forzarse el tamaño con
la opción <kbd class="kbd docutils literal notranslate"><kbd class="kbd docutils literal notranslate"></kbd>-<kbd class="kbd docutils literal notranslate">b</kbd></kbd>.</p>
</dd>
</dl>
</div>
</div>
</div>
</div>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../../index.html">Tabla de contenido</a></h3>
  <ul>
<li><a class="reference internal" href="#">9.1.3. Aplicaciones de la criptografía</a><ul>
<li><a class="reference internal" href="#firma-digital">9.1.3.1. Firma digital</a><ul>
<li><a class="reference internal" href="#certificado-digital">9.1.3.1.1. Certificado digital</a></li>
<li><a class="reference internal" href="#correo-electronico">9.1.3.1.2. Correo electrónico</a></li>
</ul>
</li>
<li><a class="reference internal" href="#cifrado-de-discos">9.1.3.2. Cifrado de discos</a><ul>
<li><a class="reference internal" href="#cifrado-de-bloques-luks">9.1.3.2.1. Cifrado de bloques (<abbr title="Linux Unified Key Setup">LUKS</abbr>)</a></li>
<li><a class="reference internal" href="#cifrado-de-directorio-gocrypts">9.1.3.2.2. Cifrado de directorio (<strong class="command">gocrypts</strong>)</a></li>
<li><a class="reference internal" href="#cifrado-de-directorio-con-ext4">9.1.3.2.3. Cifrado de directorio (con <em>ext4</em>)</a></li>
</ul>
</li>
<li><a class="reference internal" href="#protocolos-seguros-de-red">9.1.3.3. Protocolos seguros de red</a><ul>
<li><a class="reference internal" href="#ssh">9.1.3.3.1. <abbr title="Security SHell">SSH</abbr></a></li>
<li><a class="reference internal" href="#vpn">9.1.3.3.2. <abbr title="Virtual Private Network">VPN</abbr></a></li>
<li><a class="reference internal" href="#ssl-tls">9.1.3.3.3. <abbr title="Secure Socket Layer">SSL</abbr>/<abbr title="Transport Layer Security">TLS</abbr></a><ul>
<li><a class="reference internal" href="#sni">9.1.3.3.3.1. <abbr title="Server Name Indication">SNI</abbr></a></li>
<li><a class="reference internal" href="#starttls">9.1.3.3.3.2. STARTTLS</a></li>
<li><a class="reference internal" href="#pruebas-practicas">9.1.3.3.3.3. Pruebas prácticas</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>Tema anterior</h4>
  <p class="topless"><a href="02.algo.html"
                        title="capítulo anterior"><span class="section-number">9.1.2. </span>Técnicas criptográficas</a></p>
  <h4>Próximo tema</h4>
  <p class="topless"><a href="../07.sai/index.html"
                        title="próximo capítulo"><span class="section-number">9.2. </span><abbr title="Sistema de alimentación ininterrumpida">SAI</abbr></a></p>
  <div role="note" aria-label="source link">
    <h3>Esta página</h3>
    <ul class="this-page-menu">
      <li><a href="../../_sources/09.apendice/01.cryto/03.aplicaciones.rst.txt"
            rel="nofollow">Mostrar el código</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Búsqueda rápida</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Ir a" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navegación</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="Índice General"
             >índice</a></li>
        <li class="right" >
          <a href="../07.sai/index.html" title="9.2. SAI"
             >siguiente</a> |</li>
        <li class="right" >
          <a href="02.algo.html" title="9.1.2. Técnicas criptográficas"
             >anterior</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">documentación de Linuxnomicón - rolling</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" ><span class="section-number">9. </span>Apéndices</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="index.html" ><span class="section-number">9.1. </span>Criptografía</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href=""><span class="section-number">9.1.3. </span>Aplicaciones de la criptografía</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Derechos de autor CC BY 4.0, 2016-2021, José Miguel Sánchez Alés.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 3.4.3.
    </div>
  </body>
</html>