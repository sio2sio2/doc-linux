


<!DOCTYPE html>

<html lang="es">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>9.5.2.3.1. Operativa básica &#8212; documentación de Linuxnomicón - rolling</title>
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/custom.css" type="text/css" />
    
    <script id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
    <script src="../../../_static/jquery.js"></script>
    <script src="../../../_static/underscore.js"></script>
    <script src="../../../_static/doctools.js"></script>
    <script src="../../../_static/translations.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <link rel="index" title="Índice" href="../../../genindex.html" />
    <link rel="search" title="Búsqueda" href="../../../search.html" />
    <link rel="next" title="9.5.2.3.2. Construcción" href="03.constr.html" />
    <link rel="prev" title="9.5.2.3. Docker" href="../03.docker.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navegación</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="Índice General"
             accesskey="I">índice</a></li>
        <li class="right" >
          <a href="03.constr.html" title="9.5.2.3.2. Construcción"
             accesskey="N">siguiente</a> |</li>
        <li class="right" >
          <a href="../03.docker.html" title="9.5.2.3. Docker"
             accesskey="P">anterior</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">documentación de Linuxnomicón - rolling</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" ><span class="section-number">9. </span>Apéndices</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="../index.html" ><span class="section-number">9.5. </span>Virtualización</a> &#187;</li>
          <li class="nav-item nav-item-3"><a href="../03.docker.html" accesskey="U"><span class="section-number">9.5.2.3. </span>Docker</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href=""><span class="section-number">9.5.2.3.1. </span>Operativa básica</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="operativa-basica">
<h1><span class="section-number">9.5.2.3.1. </span>Operativa básica<a class="headerlink" href="#operativa-basica" title="Enlazar permanentemente con este título">¶</a></h1>
<div class="section" id="introduccion">
<h2><span class="section-number">9.5.2.3.1.1. </span>Introducción<a class="headerlink" href="#introduccion" title="Enlazar permanentemente con este título">¶</a></h2>
<p>Antes de entrar en harina, es preciso distinguir entre los conceptos de <em>imagen</em>
y <em>contenedor</em>:</p>
<dl>
<dt><em class="dfn">Imagen</em></dt><dd><p>Es una entidad inmutable constituida por una serie de archivos (que
constituyen un sistema de archivos) y una metainformación que describe
algunos aspectos de la virtualización.</p>
</dd>
<dt><em class="dfn">Contenedor</em></dt><dd><p>Es la instanciación de una <em>imagen</em> para su uso. En el mundo de
<strong class="program">Docker</strong> una <em>imagen</em> es a un <em>contenedor</em> lo que una <em>clase</em> a un
<em>objeto</em> en el mundo de la <abbr title="Programación Orientada a Objetos">POO</abbr>.</p>
<p>Así pues, una imagen es una plantilla con la que se crean uno o más
contenedores, que serán aquellos dentro de los cuales correrá la aplicación
que hayamos «<em>dockerizado</em>».</p>
</dd>
</dl>
<p>Además, es necesario entender que <strong class="program">Docker</strong> dispone fundamentalmente de
tres componentes:</p>
<dl>
<dt><em class="dfn">Demonio</em></dt><dd><p>Que es la base de todo, ya que es el que se encarga de gestionar y construir
imágenes y contenedores. Por tanto, es él el que sostiene toda la lógica del
asunto. Por ejemplo, cuando se da la orden de crear y ejecutar un contenedor
a partir de una imagen es este demonio el que toma la imagen de su
repositorio local y genera el contenedor.</p>
</dd>
<dt><em class="dfn">Cliente</em></dt><dd><p>Es la herramienta encargada de comunicarse con el demonio para transmitirle
las órdenes que estimemos pertinentes. Puede encontrarse en la misma máquina
que el demonio (y en ese caso se comunicará con éste a través del <em>socket</em>
<code class="file docutils literal notranslate"><span class="pre">/var/run/docker.sock</span></code>) o en una máquina remota para lo cual el demonio
dispone una <abbr title="Application Programming Interface">API</abbr> REST a la cual se puede acceder por <abbr title="HyperText Transfer Protocol">HTTP</abbr><a class="footnote-reference brackets" href="#id5" id="id1">1</a>.</p>
<p>El cliente habitual es la órden <abbr title="Command Line Interface">CLI</abbr> <strong class="program">docker</strong> que usaremos en esta
pequeña introducción, pero existen muchos otros como, por ejemplo, <a class="reference external" href="https://www.portainer.io/">Portainer</a>, que usa una interfaz <em>web</em>.</p>
</dd>
<dt><em class="dfn">Registro</em></dt><dd><p>Es el servicio donde se almacenan imágenes que puede descargar el demonio
en su repositorio local a fin de utilizarlas para generar contenedores. Por
lo general, es <a class="reference external" href="https://hub.docker.com/">Docker Hub</a>, aunque puede establecerse otro distinto a
través del uso de <a class="reference external" href="https://docs.docker.com/engine/reference/commandline/login/">docker login</a>.</p>
</dd>
</dl>
<img alt="../../../_images/componentes.png" src="../../../_images/componentes.png" />
<p>Para disponer de <strong class="program">Docker</strong>, podemos <strong>instalar</strong> <a class="reference external" href="https://docs.docker.com/install/linux/docker-ce/debian/">la edición de la
comunidad según las instrucciones oficiales</a> o, simplemente,
los paquetes disponibles en la propia <em>Debian</em> a partir de <em>Buster</em>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> apt install docker.io
<span class="gp">#</span> docker version
<span class="go">Client:</span>
<span class="go"> Version:           19.03.6</span>
<span class="go"> API version:       1.40</span>
<span class="go"> Go version:        go1.13.8</span>
<span class="go"> Git commit:        369ce74</span>
<span class="go"> Built:             Wed, 26 Feb 2020 11:20:11 +1100</span>
<span class="go"> OS/Arch:           linux/amd64</span>
<span class="go"> Experimental:      false</span>

<span class="go">Server:</span>
<span class="go"> Engine:</span>
<span class="go">  Version:          19.03.6</span>
<span class="go">  API version:      1.40 (minimum version 1.12)</span>
<span class="go">  Go version:       go1.13.8</span>
<span class="go">  Git commit:       369ce74</span>
<span class="go">  Built:            Wed Feb 26 00:20:11 2020</span>
<span class="go">  OS/Arch:          linux/amd64</span>
<span class="go">  Experimental:     false</span>
<span class="go"> containerd:</span>
<span class="go">  Version:          19.03.6</span>
<span class="go">  GitCommit:        7c1e88399ec0b0b077121d9d5ad97e647b11c870</span>
<span class="go"> runc:</span>
<span class="go">  Version:          1.0.0~rc10+dfsg1</span>
<span class="go">  GitCommit:        1.0.0~rc10+dfsg1-1</span>
<span class="go"> docker-init:</span>
<span class="go">  Version:          0.18.0</span>
<span class="go">  GitCommit:</span>
</pre></div>
</div>
<p>El paquete instala en nuestro máquina tanto el demonio como el cliente oficial,
de manera que éste último conecta con el primero a través del <em>scoket</em> ya
referido, y usará como registro <a class="reference external" href="https://hub.docker.com/">Docker Hub</a>.</p>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>El demonio almacena imágenes y contenedores dentro de
<code class="file docutils literal notranslate"><span class="pre">/var/lib/docker</span></code>. Esto supone que dentro de ese directorio acabará
habiendo una gran cantidad de datos, por lo que quizás puede que nos interese
montar ese directorio en un sistema de archivos independiente.</p>
</div>
</div>
<div class="section" id="imagenes">
<span id="docker-image"></span><h2><span class="section-number">9.5.2.3.1.2. </span>Imágenes<a class="headerlink" href="#imagenes" title="Enlazar permanentemente con este título">¶</a></h2>
<p>Como ya se ha establecido, las <em class="dfn">imágenes</em> son las plantillas a partir de
las cuales se crean los contenedores. Hay tres métodos para obtenerlas:</p>
<ol class="arabic simple">
<li><p>Construyéndolas nosotros mismos con <a class="reference internal" href="03.constr.html#docker-build"><span class="std std-ref">docker build</span></a>.</p></li>
<li><p>Generando una a partir de un contenedor con <a class="reference internal" href="03.constr.html#docker-commit"><span class="std std-ref">docker commit</span></a>.</p></li>
<li><p>Obteniéndo las imágenes de un <a class="reference external" href="https://docs.docker.com/registry/">registro de imágenes</a>. El registro existente más importante es
<a class="reference external" href="https://hub.docker.com/">Docker Hub</a>.</p></li>
</ol>
<p>Dejaremos el estudio de los dos primeros métodos al tratar la <a class="reference internal" href="03.constr.html#docker-const"><span class="std std-ref">construcción
de imáganes</span></a> y bajo este epígrafe nos centraremos en cómo obtener
imágenes de <a class="reference external" href="https://hub.docker.com/">Docker Hub</a>. Si nos registramos en el sitio tendremos la
posibilidad de crear nuestros propios repositorios con imágenes creadas por
nosotros mismos a través de las dos vías citadas anteriormente, pero sin
necesidad de registro podemos usar los repositorios públicos que distintos
usuarios y organizaciones mantienen en el sitio. Por ejemplo:</p>
<div class="highlight-console notranslate" id="docker-image-pull"><span id="docker-pull"></span><div class="highlight"><pre><span></span><span class="gp">#</span> docker image pull debian
</pre></div>
</div>
<p>obtiene y almacena en nuestro repositorio local la imagen oficial oficial:</p>
<div class="highlight-console notranslate" id="docker-image-ls"><div class="highlight"><pre><span></span><span class="gp">#</span> docker image ls
<span class="go">REPOSITORY        TAG              IMAGE ID         CREATED       SIZE</span>
<span class="go">debian            latest           971452c94376     4 weeks ago   114MB</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>Con el subcomando <kbd class="kbd docutils literal notranslate">ls</kbd> podemos usar un patron con comodines
como los que se usan en la <em>shell</em> (p.e. <kbd class="kbd docutils literal notranslate"><kbd class="kbd docutils literal notranslate">docker</kbd> <kbd class="kbd docutils literal notranslate">image</kbd> <kbd class="kbd docutils literal notranslate">ls</kbd> <kbd class="kbd docutils literal notranslate">de*</kbd></kbd>).</p>
</div>
<p>Como vemos ya tenemos descargada la imagen de <em>Debian</em> en nuestro repositorio
local, lista para ser usada en la creación de contenedores. La imagen se ha
obtenido de <cite>Docker Hub</cite>. Ahora bien, ¿cómo sabemos que existe esta imagen en el
repositorio? La respuesta es obvia: buscando previamente en el registro. Y del
mismo que, por ejemplo, existe <a class="reference internal" href="../../../02.conbas/09.admbasica/08.paqueteria.html#apt-cache"><span class="std std-ref">apt-cache search</span></a> para buscar
paquetes disponibles en <em>Debian</em>, existe <kbd class="kbd docutils literal notranslate"><kbd class="kbd docutils literal notranslate">docker</kbd> <kbd class="kbd docutils literal notranslate">search</kbd></kbd> para buscar
imágenes en <a class="reference external" href="https://hub.docker.com/">Docker Hub</a>:</p>
<div class="highlight-console notranslate" id="docker-search"><div class="highlight"><pre><span></span><span class="gp">#</span> docker search debian
</pre></div>
</div>
<p>aunque tenemos también la alternativa de visitar la web y hacer la búsqueda
directamente en ella. Escogida cuál es la imagen que deseamos utilizar es
importante tener presente qué significa la etiqueta (<em>TAG</em>) que acompaña al
nombre. La etiqueta identifica distintas versiones del contenedor que pueden
responder bien a distintas versiones del paquete que contienen, bien a qué es lo
que realmente contienen. Por ejemplo, acabamos de instalar la imagen
<em>debian:latest</em> (porque al no indicar etiqueta se sobrentiende que es la más
reciente, o sea, la latest). Si investigamos la imagen avewriguaremos que esta
imagen coincide con la que se hace para <em>Buster</em> que es la actual estable:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> docker image pull debian:buster
<span class="gp">#</span> docker image ls
<span class="go">REPOSITORY        TAG              IMAGE ID         CREATED       SIZE</span>
<span class="go">debian            latest           971452c94376     4 weeks ago   114MB</span>
<span class="go">debian            buster           971452c94376     4 weeks ago   114MB</span>
</pre></div>
</div>
<p>Lo cual se hace evidente, porque no hemos tenido que esperar la descarga de la
imagen y el identificador de la imagen es exactamente el mismo. Por supuesto
también existe <em>debian:bullseye</em> o <em>debian:stretch</em>; pero también hay versiones
<em>slim</em> que incluyen menos <em>software</em> y, por tanto, son más ligeras:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> docker image pull debian:buster-slim
<span class="gp">#</span> docker image ls *buster*
<span class="go">debian            buster-slim      2f14a0fb67b9     4 weeks ago   69.2MB</span>
<span class="go">debian            buster           971452c94376     4 weeks ago   114MB</span>
</pre></div>
</div>
<p>Como con las imágenes de <em>Debian</em>, sucede con otras muchas. Por ejemplo, <abbr title="PHP HyperText Preprocessor">PHP</abbr>
tiene sus propias imágenes, muchísimas en realidad porque varía en ellas desde
la versión de <abbr title="PHP HyperText Preprocessor">PHP</abbr> usada a cuál es la distribución base que han utilizado
(<em>Debian Buster</em>, <a class="reference external" href="https://alpinelinux.org/">Alpine</a>) o qué software adicional se ha incluido dentro (p.e.
el propio servidor <a class="reference external" href="http://apache.org/">Apache</a>). Esta variadad de imágenes es bastante lógica si
atendemos a que una de las principales funciones de <em>Docker</em> es proporcionar un
método portable para distribuir aplicaciones y servicios.</p>
<p>Antes de continuar, es muy productivo parar un momento a analizar cómo funcionan
las órdenes del cliente:</p>
<ul>
<li><p>En cualquier punto podemos utilizar el argumento <kbd class="kbd docutils literal notranslate"><kbd class="kbd docutils literal notranslate"></kbd>-<kbd class="kbd docutils literal notranslate"></kbd>-<kbd class="kbd docutils literal notranslate">help</kbd></kbd> para conocer
qué es lo que podemos añadir a continuación. Por ejemplo, para saber qué
subcomandos podemos usar para manipular imágenes:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> docker image --help
<span class="go">Usage:  docker image COMMAND</span>

<span class="go">Manage images</span>

<span class="go">Commands:</span>
<span class="go">  build       Build an image from a Dockerfile</span>
<span class="go">  history     Show the history of an image</span>
<span class="go">  import      Import the contents from a tarball to create a filesystem image</span>
<span class="go">  inspect     Display detailed information on one or more images</span>
<span class="go">  load        Load an image from a tar archive or STDIN</span>
<span class="go">  ls          List images</span>
<span class="go">  prune       Remove unused images</span>
<span class="go">  pull        Pull an image or a repository from a registry</span>
<span class="go">  push        Push an image or a repository to a registry</span>
<span class="go">  rm          Remove one or more images</span>
<span class="go">  save        Save one or more images to a tar archive (streamed to STDOUT by default)</span>
<span class="go">  tag         Create a tag TARGET_IMAGE that refers to SOURCE_IMAGE</span>
</pre></div>
</div>
<p>De los expuestos hemos usado ya los subcomandos <kbd class="kbd docutils literal notranslate">pull</kbd> y <kbd class="kbd docutils literal notranslate">ls</kbd>, e
incluso con estos hay distintas opciones que no hemos llegado a usar:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> docker image ls --help
<span class="go">Usage:  docker image ls [OPTIONS] [REPOSITORY[:TAG]]</span>

<span class="go">List images</span>

<span class="go">Aliases:</span>
<span class="go">  ls, images, list</span>

<span class="go">Options:</span>
<span class="go">  -a, --all             Show all images (default hides intermediate images)</span>
<span class="go">      --digests         Show digests</span>
<span class="go">  -f, --filter filter   Filter output based on conditions provided</span>
<span class="go">      --format string   Pretty-print images using a Go template</span>
<span class="go">      --no-trunc        Don&#39;t truncate output</span>
<span class="go">  -q, --quiet           Only show numeric IDs</span>
</pre></div>
</div>
</li>
</ul>
<ul>
<li><p>El primer subcomando (o sea, el subcomando inmediatamente posterior a
<strong class="program">docker</strong>) indica sobre qué entidad se lleva a cabo la orden. En
nuestro caso, estamos usando. <kbd class="kbd docutils literal notranslate">image</kbd> puesto que estamos actuando sobre
imágenes. Sin embargo, esta no fue la filosofía inicial de la orden, por lo
que se mantiene tambien una sintaxis antigua que no seguí esta filosofía. Por
ese motivo:</p>
<table class="docker-eq docutils align-default">
<colgroup>
<col style="width: 42%" />
<col style="width: 58%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Sintaxis</p></th>
<th class="head"><p>Sintaxis simplificada</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>docker image pull</p></td>
<td><p>docker pull</p></td>
</tr>
<tr class="row-odd"><td><p>docker image push</p></td>
<td><p>docker push</p></td>
</tr>
<tr class="row-even"><td><p>docker image rm</p></td>
<td><p>docker rmi</p></td>
</tr>
<tr class="row-odd"><td><p>docker image build</p></td>
<td><p>docker build</p></td>
</tr>
</tbody>
</table>
<p>El resto de entidades también tienen asociadas órdenes con sintaxis reducida.</p>
</li>
</ul>
<p>Algunos otras órdenes sobre imágenes las trataremos al examinar cómo se
construyen. Ahora, sin embargo, es interesante saber cómo eliminarlas:</p>
<div class="highlight-console notranslate" id="docker-rmi"><span id="docker-image-rm"></span><div class="highlight"><pre><span></span><span class="gp">#</span> docker image rm debian:buster-slim
</pre></div>
</div>
<p>para lo cual puede usarse el nombre (con la etiqueta) o el identificador. Es
importante notar que para poder borrar una imagen no puede existir un contenedor
que se haya generado con ella. Para fozar el borrado de la imagen y de todos los
contenedores creados a partir de ella, puede usarse la opción <kbd class="kbd docutils literal notranslate"><kbd class="kbd docutils literal notranslate"></kbd>-<kbd class="kbd docutils literal notranslate">f</kbd></kbd>.
Relacionado con las opciones de borrado está:</p>
<div class="highlight-console notranslate" id="docker-image-prune"><div class="highlight"><pre><span></span><span class="gp">#</span> docker image prune
</pre></div>
</div>
<p>que borra todas las imagenes que no tienen contenedores asociados.</p>
<p>Para consultar las características de la imagen podemos usar <kbd class="kbd docutils literal notranslate">inspect</kbd>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> docker image inspect debian:buster-slim
</pre></div>
</div>
<p>que las devuelve en formato <abbr title="JavaScript Object Notation">JSON</abbr>. Al inspeccionar puede interesarnos obtener
sólo una parte de la información para lo cual puede usarse la opción <kbd class="kbd docutils literal notranslate"><kbd class="kbd docutils literal notranslate"></kbd>-<kbd class="kbd docutils literal notranslate">f</kbd></kbd>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> docker image inspect -f <span class="s1">&#39;{{json .Config.Cmd}}&#39;</span> debian:buster-slim
<span class="go">[&#39;bash&#39;]</span>
<span class="gp">#</span> docker image inspect -f <span class="s1">&#39;{{json .RootFS}}&#39;</span> debian:buster-slim
<span class="go">{&quot;Type&quot;:&quot;layers&quot;,&quot;Layers&quot;:[&quot;sha256:f2cb0ecef392f2a630fa1205b874ab2e2aedf96de04d0b8838e4e728e28142da&quot;]}</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>Al realizar una operación sobre una imagen (lo mismo ocurre con otras
entidades) podemos referirnos a ella por su nombre o por su identificador
único.</p>
</div>
</div>
<div class="section" id="contenedores">
<h2><span class="section-number">9.5.2.3.1.3. </span>Contenedores<a class="headerlink" href="#contenedores" title="Enlazar permanentemente con este título">¶</a></h2>
<p>Una imagen es, simplemente, una plantilla para crear contenededores que ejecutan
aplicaciones. Por ello, un contenedor se crea instanciando una imagen e
indicando cuál es la aplicación que deseamos ejecutar. Por ejemplo:</p>
<div class="highlight-console notranslate" id="docker-container-run"><span id="docker-run"></span><div class="highlight"><pre><span></span><span class="gp">#</span> docker run -ti debian:buster-slim bash
<span class="gp">root@fd65c6309e43:/#</span> <span class="nb">echo</span> <span class="s2">&quot;Estoy ejecutando bash en el contenedor&quot;</span>
<span class="go">Estoy ejecutando bash en el contenedor</span>
<span class="gp">root@fd65c6309e43:/#</span> <span class="nb">exit</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>No es necesario descargar la imagen previamente con <kbd class="kbd docutils literal notranslate"><kbd class="kbd docutils literal notranslate">docker</kbd> <kbd class="kbd docutils literal notranslate">image</kbd>
<kbd class="kbd docutils literal notranslate">pull</kbd></kbd>. Si la imagen que se invoca con <kbd class="kbd docutils literal notranslate"><kbd class="kbd docutils literal notranslate">docker</kbd> <kbd class="kbd docutils literal notranslate">run</kbd></kbd> (o el <kbd class="kbd docutils literal notranslate"><kbd class="kbd docutils literal notranslate">docker</kbd>
<kbd class="kbd docutils literal notranslate">create</kbd></kbd> que veremos después) no existe en el repositorio local, se descargará
del registro automáticamente.</p>
</div>
<p><kbd class="kbd docutils literal notranslate"><kbd class="kbd docutils literal notranslate">docker</kbd> <kbd class="kbd docutils literal notranslate">run</kbd></kbd> es el encargado de ello, aunque es la sintaxis simplificada de
<kbd class="kbd docutils literal notranslate"><kbd class="kbd docutils literal notranslate">docker</kbd> <kbd class="kbd docutils literal notranslate">container</kbd> <kbd class="kbd docutils literal notranslate">run</kbd></kbd>. En la consola de <strong class="program">bash</strong> que se ejecuta
dentro del contenedor, el sistema de ficheros es una superposición de los
archivos que proporciona la imagen y los archivos que puedan generarse durante
la ejecución del contenedor<a class="footnote-reference brackets" href="#id6" id="id2">2</a>.</p>
<p>En la orden hay tres argumentos posiciones:</p>
<ul>
<li><p><kbd class="kbd docutils literal notranslate"><kbd class="kbd docutils literal notranslate"></kbd>-<kbd class="kbd docutils literal notranslate">ti</kbd></kbd> que en realidad son las opciones <kbd class="kbd docutils literal notranslate"><kbd class="kbd docutils literal notranslate"></kbd>-<kbd class="kbd docutils literal notranslate">t</kbd></kbd> y <kbd class="kbd docutils literal notranslate"><kbd class="kbd docutils literal notranslate"></kbd>-<kbd class="kbd docutils literal notranslate">i</kbd></kbd> y
posibilta el uso interactivo, que es lo que realizamos a continuación. En
contraposición <kbd class="kbd docutils literal notranslate"><kbd class="kbd docutils literal notranslate"></kbd>-<kbd class="kbd docutils literal notranslate">d</kbd></kbd> se usa cuando el contenedor levanta un servicio y
queremos que se libere la línea de órdenes del anfitrión.</p></li>
<li><p>La imagen de la que deseamos crear un contenedor.</p></li>
<li><p>Qué programa queremos arrancar con el contenedor. El que digamos que
<strong class="program">bash</strong>, posibilita que obtengamos una consola interactiva en la que
podríamos haber llevado a cabo varias acciones, entre las cuales podría
haberse encontrado instalar <em>software</em> adicional usando <a class="reference internal" href="../../../02.conbas/09.admbasica/08.paqueteria.html#apt"><span class="std std-ref">apt</span></a>.</p>
<p>Las imágenes, sin embargo, pueden predefinir un comando, de modo que si al
crear un contenedor, no se especifica comando alguno, será el predefinido el
que se ejecute. En este caso:</p>
<div class="highlight-console notranslate" id="docker-image-inspect"><div class="highlight"><pre><span></span><span class="gp">#</span> docker image inspect -f <span class="s1">&#39;{{.Config.Cmd}}&#39;</span> debian:buster-slim
<span class="go">[bash]</span>
</pre></div>
</div>
<p>Esa orden ya era <strong class="program">bash</strong>, así que podríamos habernos ahorrado la
expresión de la orden.</p>
</li>
</ul>
<p>Es importante tener presente que el contenedor sólo tiene sentido como
contenedor del programa que se pretende correr. Por ese motivo, el contenedor
está en ejecución mientras dura nuestra sesión de <strong class="program">bash</strong> y al salir de
ella (como hemos hecho con <a class="reference internal" href="../../../02.conbas/01.preliminares/index.html#exit"><span class="std std-ref">exit</span></a>), el contenedor se para. Por ese
motivo, <kbd class="kbd docutils literal notranslate"><kbd class="kbd docutils literal notranslate">docker</kbd> <kbd class="kbd docutils literal notranslate">ps</kbd></kbd> (o <kbd class="kbd docutils literal notranslate"><kbd class="kbd docutils literal notranslate">docker</kbd> <kbd class="kbd docutils literal notranslate">container</kbd> <kbd class="kbd docutils literal notranslate">ls</kbd></kbd>):</p>
<div class="highlight-console notranslate" id="docker-container-ls"><span id="docker-ps"></span><div class="highlight"><pre><span></span><span class="gp">#</span> docker ps
</pre></div>
</div>
<p>no devuelve contenedor alguno, a pesar de haberse creado. Esto es debido a que,
en principio, sólo se muestran los contenedores en ejecución. En cambio, si
añadimos la opción <kbd class="kbd docutils literal notranslate"><kbd class="kbd docutils literal notranslate"></kbd>-<kbd class="kbd docutils literal notranslate">a</kbd></kbd>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> docker ps -a
<span class="go">CONTAINER ID   IMAGE               COMMAND  CREATED        STATUS                      PORTS  NAMES</span>
<span class="go">fd65c6309e43   debian:buster-slim  &quot;bash&quot;   25 minutes ago Exited (0) 23 minutes ago          vigorous_greider</span>
</pre></div>
</div>
<p>en donde podemos leer un resumen de las características del contenedor.
Obsérvese que el identificador de la máquina coincide con el nombre de <em>host</em>
y que aparece en el <em>prompt</em> de la sesión interactiva que abrimos anteriormente.
Además, el demonio ha asignado un nombre generado aleatoriamente al contenedor
(<em>vigorous_greater</em>). A partir de ahora, podremos referirnos al contenedor tanto
usando su nombre como su identificador. Todo esto puede cambiar, pero antes de
intentar hacerlo, notemos que <kbd class="kbd docutils literal notranslate"><kbd class="kbd docutils literal notranslate">docker</kbd> <kbd class="kbd docutils literal notranslate">run</kbd></kbd> no arranca un contenedor, sino
que lo crea y lo arranca. Si hubiéramos querido crearlo sin llegar a arrancar,
podríamos haber usado <kbd class="kbd docutils literal notranslate"><kbd class="kbd docutils literal notranslate">docker</kbd> <kbd class="kbd docutils literal notranslate">container</kbd> <kbd class="kbd docutils literal notranslate">create</kbd></kbd> o, simplemente,
<kbd class="kbd docutils literal notranslate"><kbd class="kbd docutils literal notranslate">docker</kbd> <kbd class="kbd docutils literal notranslate">create</kbd></kbd>:</p>
<div class="highlight-console notranslate" id="docker-container-create"><span id="docker-create"></span><div class="highlight"><pre><span></span><span class="gp">#</span> docker create -ti debian:buster-slim
<span class="gp">#</span> docker ps -a
<span class="go">CONTAINER ID   IMAGE               COMMAND  CREATED        STATUS                      PORTS  NAMES</span>
<span class="go">c2e42d8b9b94   debian:buster-slim  &quot;bash&quot;   2 seconds ago  Created                            trusting_babbage</span>
<span class="go">fd65c6309e43   debian:buster-slim  &quot;bash&quot;   25 minutes ago Exited (0) 23 minutes ago          vigorous_greider</span>
</pre></div>
</div>
<p>que, como vemos, se ejecuta igual, aunque hemos obviado la orden de ejecución,
porque ya sabemos que será <strong class="program">bash</strong>.</p>
<p>Para arrancar un contenedor previamente parado, debemos usar <kbd class="kbd docutils literal notranslate"><kbd class="kbd docutils literal notranslate">docker</kbd> <kbd class="kbd docutils literal notranslate">start</kbd></kbd>,
(o <kbd class="kbd docutils literal notranslate"><kbd class="kbd docutils literal notranslate">docker</kbd> <kbd class="kbd docutils literal notranslate">container</kbd> <kbd class="kbd docutils literal notranslate">start</kbd></kbd>) que retomará las opciones con las que creamos
el contenedor:</p>
<div class="highlight-console notranslate" id="docker-container-start"><span id="docker-start"></span><div class="highlight"><pre><span></span><span class="gp">#</span> docker start -i vigorous_greider
<span class="gp">root@fd65c6309e43:/#</span>
</pre></div>
</div>
<p>Ahora, en cambio, no acabamos la sesión de <strong class="program">bash</strong> y consecuentemente el
contenedor seguirá en ejecución. Cuando esto ocurre, podemos hacer dos cosas:</p>
<ul>
<li><p>Ejecutar algún comando adicional. Por ejemplo:</p>
<div class="highlight-console notranslate" id="docker-container-exec"><span id="docker-exec"></span><div class="highlight"><pre><span></span><span class="gp">#</span> docker <span class="nb">exec</span> fd65c6309e43 hostname
<span class="go">fd65c6309e43</span>
</pre></div>
</div>
</li>
<li><p>Parar el contenedor:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">.. _docker-stop:</span>
<span class="go">.. _docker-container-stop:</span>
</pre></div>
</div>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> docker stop vigorous_greider
<span class="go">vigorous_greider</span>
</pre></div>
</div>
</li>
</ul>
<p>que provocará la salida automática de la sesión interactiva de <strong class="program">bash</strong>
que dejamos pendiente.</p>
<p>Por otra parte, cuando se crea un contenedor podemos definir tanto el nombre del
contenedor como el nombre de la máquina:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> docker run --rm -ti --name<span class="o">=</span>debiandock --hostname<span class="o">=</span>debiandock debian:buster-slim
<span class="gp">root@debiandock:/#</span> <span class="nb">echo</span> <span class="s2">&quot;Este contenedor es efímero&quot;</span>
<span class="gp">root@debiandock:/#</span> <span class="nb">exit</span>
</pre></div>
</div>
<p>En este caso, además, hemos incluido la opción <kbd class="kbd docutils literal notranslate"><kbd class="kbd docutils literal notranslate"></kbd>-<kbd class="kbd docutils literal notranslate"></kbd>-<kbd class="kbd docutils literal notranslate">rm</kbd></kbd> que provoca que el
contenedor se destruya en cuanto acabe la ejecución de la aplicaciói
(<strong class="program">bash</strong> en este caso).</p>
<p>Utilicemos una imagen distinta para ilustrar otras posibilidad al ejecutar un
contenedor:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> docker run --rm -d --name<span class="o">=</span>nginx-test -p <span class="m">8080</span>:80 nginx:alpine
<span class="go">818ba206cb7158a9fe44c58649f9e47b39c11ede9a9fd9deb62174838f7c6420</span>
</pre></div>
</div>
<p>En este caso, ejecutamos un contenedor oficial de <a class="reference internal" href="../../../07.serre/02.web/02.nginx/index.html#n-ginx"><span class="std std-ref">nginx</span></a>
construido sobre <a class="reference external" href="https://alpinelinux.org/">Alpine</a> (lo cual nos asegura que su tamaño es mínimo). Como el
contenedor ejecuta un servidor web utilizamos <kbd class="kbd docutils literal notranslate"><kbd class="kbd docutils literal notranslate"></kbd>-<kbd class="kbd docutils literal notranslate">d</kbd></kbd> para evitar que se quede
ocupada la terminal del sistema anfitrión<a class="footnote-reference brackets" href="#id7" id="id3">3</a> y publicanmos el puerto <strong>80</strong>
del contenedor en el <strong>8080</strong> del sistema anfitrión<a class="footnote-reference brackets" href="#id8" id="id4">4</a>. Si en estas
condiciones, hacemos, por ejemplo:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> wget -qS --spider http://localhost:8080
<span class="go">  HTTP/1.1 200 OK</span>
<span class="go">  Server: nginx/1.17.9</span>
<span class="go">  Date: Thu, 26 Mar 2020 18:42:48 GMT</span>
<span class="go">  Content-Type: text/html</span>
<span class="go">  Content-Length: 612</span>
<span class="go">  Last-Modified: Tue, 03 Mar 2020 17:36:53 GMT</span>
<span class="go">  Connection: keep-alive</span>
<span class="go">  ETag: &quot;5e5e95b5-264&quot;</span>
<span class="go">  Accept-Ranges: bytes</span>
</pre></div>
</div>
<p>accederemos a la página que ofrezca el servidor web. Si nuestra intención es
montar un sitio web con esta imagen tendremos, obviamente, que hacer algo más,
pero ahora no es el momento. Podemos comprobar eso sí, el mapeo de puertos que
hace este contenedor:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> docker port nginx-test
<span class="go">80/tcp -&gt; 0.0.0.0:8080</span>
</pre></div>
</div>
<p>En realidad, la publicación del puerto <strong>80</strong> es posible porque al crear la
imagen el autor expuso el puerto <strong>80</strong>. No así el <strong>443</strong> (de hecho, la imagen
no tiene ningún certificado), por lo que no puede publicarse tal puerto. Una
alternativa es pedirle al demonio que publique todos los puertos que mandó
exponer el autor en puertos libres escogidos aleatoriamente:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> docker run --rm -d --name<span class="o">=</span>nginx-test -P nginx:alpine
<span class="gp">#</span> docker port nginx-test
<span class="go">80/tcp -&gt; 0.0.0.0:32768</span>
</pre></div>
</div>
<p>En este caso, es imperioso consultar el puerto para saber cómo conectar al
servidor web. Finalmente, para eliminar un contenedor podemos simplemente usar
<kbd class="kbd docutils literal notranslate"><kbd class="kbd docutils literal notranslate">docker</kbd> <kbd class="kbd docutils literal notranslate">rm</kbd></kbd> o <kbd class="kbd docutils literal notranslate"><kbd class="kbd docutils literal notranslate">docker</kbd> <kbd class="kbd docutils literal notranslate">container</kbd> <kbd class="kbd docutils literal notranslate">rm</kbd></kbd>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> docker rm nginx-test
</pre></div>
</div>
<p>Ahora bien, si el contenedor se encuentra arrancada, entonces será necesario o
pararlo primero o forzar su borrado:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> docker rm -f nginx-test
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>Un truco para eliminar todas las imágenes y contenedores es:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> docker container rm -fv <span class="sb">`</span>docker container ls -aq<span class="sb">`</span>
<span class="gp">#</span> docker image rm prune
</pre></div>
</div>
<p>donde además de <kbd class="kbd docutils literal notranslate"><kbd class="kbd docutils literal notranslate"></kbd>-<kbd class="kbd docutils literal notranslate">f</kbd></kbd> hemos utilizado la opción <kbd class="kbd docutils literal notranslate"><kbd class="kbd docutils literal notranslate"></kbd>-<kbd class="kbd docutils literal notranslate">v</kbd></kbd> para borrar
también los volúmenes asociados a contenedores. Veremos este concepto en el
próximo epígrafe.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>Hay un aspecto muy importante de los contenedores que no hemos
tratado: su <strong>política de ejecución</strong>. Dado que un contenedor de
<strong class="program">Docker</strong> se crea para la ejecución de una aplicación, hay que
arrancar manualmente el contenedor para poner en ejecución la aplicación y,
cuando la aplicación acaba, el contenedor se para. Esto hecho, sin embargo,
puede ser que no nos interese, sobre todo si esa aplicación es un servidor.
Por ejemplo, podría interesarnos que ante un falló que haga colapsar la
máquina, el demonio de <strong class="program">Docker</strong> reinicio el servidor, o bien, que
ante un reinicio del propio demonio, también se reinicie el contenedor.
Trataremos esto al ver los <a class="reference internal" href="05.ejemplos.html#docker-ejemplos"><span class="std std-ref">ejemplos finales</span></a>.</p>
</div>
<p>Debe tenerse presente que al borrarse el contenedor, desaparecen todos los datos
que pudiera contener.</p>
</div>
<div class="section" id="volumenes">
<span id="docker-volume"></span><h2><span class="section-number">9.5.2.3.1.4. </span>Volúmenes<a class="headerlink" href="#volumenes" title="Enlazar permanentemente con este título">¶</a></h2>
<p>Un <em class="dfn">volumen</em> es un directorio externo montado en el contenedor. Por ello,
lo datos que se almacenan en un <em>volumen</em>, aunque accesibles, no forman parte
del contenedor y ni desaparecen al borrarse el contenedor ni estñan sujetos al
control de almacenamiento que lleva a cabo el demonio. Son útiles para:</p>
<ul class="simple">
<li><p>Hacer la información persistente más allá de la vida del contenedor.</p></li>
<li><p>Servir de almacenamiento cuando se está constantemente escribiendo, ya que los
contenedores están pensados para que se escriban en ellos pocos datos. Por
ejemplo, un <em>volumen</em> sería muy adecuado si quisiéramos almacenar los <em>logs</em> de
un servicio.</p></li>
<li><p>Compartir datos entre el anfitrión y los contenedores.</p></li>
</ul>
<p>Hay dos tipos de volúmenes</p>
<dl class="simple">
<dt><em class="dfn">Volumen de host</em></dt><dd><p>es, simplemente, un directorio ya existente en el anfitrión que se monta
sobre un contenedor para que ambos puedan compartir la información.</p>
</dd>
<dt><em class="dfn">Volumen de datos</em></dt><dd><p>es un directorio creado expresamente para ser montado en los contenedores.
Se gestionan mediante <kbd class="kbd docutils literal notranslate"><kbd class="kbd docutils literal notranslate">docker</kbd> <kbd class="kbd docutils literal notranslate">volumen</kbd></kbd>, como ya veremos; y, obviamente,
acaban resultado también directorios del anfitrión creandos dentro de
<code class="file docutils literal notranslate"><span class="pre">/var/lib/docker</span></code>. La diferencia es que los <em>volúmenes de host</em>, aunque
directorios del anfitrión, tienen existencia justificada al margen de
<strong class="program">Docker</strong>.</p>
</dd>
</dl>
<p>Para ilustrar el uso de ambos podemos usar <a class="reference external" href="https://www.portainer.io/">Portainer</a> que es un
contenedor que contiene un cliente web para el demonio de <strong class="program">Docker</strong>. El
cliente necesita dos cosas:</p>
<ul class="simple">
<li><p>Por un lado, debe comunicarse con el demonio o lo que es lo mismo, acceder al
socket <code class="file docutils literal notranslate"><span class="pre">/var/run/docker.sock</span></code> del anfitrión. Esto podemos resolverlo con
un <em>volumen de host</em>.</p></li>
<li><p>Por otro, la aplicación necesita manejar una base de datos y ello implica
escrituras. Para hacerlas, se usa, en este caso, un <em>volumen de datos</em> creado
para ese efecto.</p></li>
</ul>
<p>Así pues, el uso de tal aplicación puede hacerse así:</p>
<div class="highlight-console notranslate" id="docker-volume-create"><div class="highlight"><pre><span></span><span class="gp">#</span> docker volume create portainer_data
<span class="gp">#</span> docker run -d -P --name<span class="o">=</span>portainer --restart<span class="o">=</span>unless-stopped <span class="se">\</span>
      -v /var/run/docker.sock:/var/run/docker.sock <span class="se">\</span>
      -v portainer_data:/data <span class="se">\</span>
      portainer/portainer
<span class="go">5bab0fd1699832eb30310e4a5fb6ccd19b7e3171ead2df84e3426b67ef10b6cb</span>
<span class="gp">#</span> docker port portainer
<span class="go">9000/tcp -&gt; 0.0.0.0:32768</span>
</pre></div>
</div>
<p>donde primero se crea el <em>volumen de datos</em> y después se crea y ejecuta el
contenedor utilizan este volumen y haciendo que el <em>socket</em> se comparta como
<em>volumen de host</em>. La aplicación escucha en el puerto <strong>9000</strong> del container que
se ha mapeado al <strong>32768</strong> del anfitrión. Listo. Desde el navegador,
conectándonos a <em>http://localhost:32768</em> podremos gestionar el demonio mediante
una interfaz web.</p>
<p>Hay, no obstante, una precisión que hacer respecto a cómo se declara los
volúmenes. Ambos tipos se declaran mediante la opción <kbd class="kbd docutils literal notranslate"><kbd class="kbd docutils literal notranslate"></kbd>-<kbd class="kbd docutils literal notranslate">v</kbd></kbd> y la sintaxis
para establecer el volumen y el punto de montaje es la misma. La forma que tiene
el demonio de distinguir un tipo de volumen de otro es la forma en la que
expresamos el origen:</p>
<ul class="simple">
<li><p>Si se declara una <strong>ruta obsoluta</strong>, se trata de un <em>volumen de host</em>.</p></li>
<li><p>Si se trata de un <strong>nombre</strong>. debe ser el nombre de un <em>volumen de datos</em> que,
en caso de no existir, se creará. De lo que se deduce que podríamos
habernos ahorrado la primera orden de creación.</p></li>
<li><p>Si sólo se expresa el punto de montaje (sin siquiera los dos puntos), se
sobreentiende un <em>volumen de datos</em> al que se le asigna un nombre
aleatorio. A estos volúmenes se les denomina <em class="dfn">volúmenes de datos
anónimos</em>.</p></li>
</ul>
<p>Además de crear volúmenes, podemos llevar a cabo otras acciones básicas con
ellos:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> docker volume --help

<span class="go">Usage:  docker volume COMMAND</span>

<span class="go">Manage volumes</span>

<span class="go">Commands:</span>
<span class="go">  create      Create a volume</span>
<span class="go">  inspect     Display detailed information on one or more volumes</span>
<span class="go">  ls          List volumes</span>
<span class="go">  prune       Remove all unused local volumes</span>
<span class="go">  rm          Remove one or more volumes</span>
</pre></div>
</div>
<p>que no requieren demasiada explicación. Si es interesante, tener claro que al
borrar un contenedor no se borran los volúmenes que se hayan podido crear como
consecuencia de su creación. Existe, sin embargo, la opción <kbd class="kbd docutils literal notranslate"><kbd class="kbd docutils literal notranslate"></kbd>-<kbd class="kbd docutils literal notranslate">v</kbd></kbd> para que al
borrarse un contenedor se borren todos los volúmenes de datos anónimos asociados
a él:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> docker rm -v contenedor_con_volumenes_anonimos
</pre></div>
</div>
</div>
<div class="section" id="redes">
<span id="docker-network"></span><h2><span class="section-number">9.5.2.3.1.5. </span>Redes<a class="headerlink" href="#redes" title="Enlazar permanentemente con este título">¶</a></h2>
<p><strong class="program">Docker</strong> dispone tres tipos fundamentales de controlador de red:</p>
<div class="highlight-console notranslate" id="docker-network-ls"><div class="highlight"><pre><span></span><span class="gp">#</span> docker network ls
<span class="go">NETWORK ID          NAME                DRIVER              SCOPE</span>
<span class="go">201d5e901e39        bridge              bridge              local</span>
<span class="go">377c54f52aa3        host                host                local</span>
<span class="go">bed15cc78e24        none                null                local</span>
</pre></div>
</div>
<p>para cada uno de los cuales hay ya creado un nombre de red. El significado de
cada driver es el siguiente:</p>
<div class="section" id="tipos">
<h3><span class="section-number">9.5.2.3.1.5.1. </span>Tipos<a class="headerlink" href="#tipos" title="Enlazar permanentemente con este título">¶</a></h3>
<dl>
<dt><strong>bridge</strong></dt><dd><p>Crea los contenedores dentro una red interna que se conecta con el exterior a
través de una interfaz <em>bridge</em> en el anfitrión. Para la red homónima
<em>bridge</em> ya definida esta interfaz es <em>docker0</em>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> ip link show dev docker0
<span class="go">4: docker0: &lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt; mtu 1500 qdisc noqueue state DOWN mode DEFAULT group default</span>
<span class="go">    link/ether 02:42:7f:40:be:40 brd ff:ff:ff:ff:ff:ff</span>
</pre></div>
</div>
<p>Este tipo de red (que se corresponde con el tipo «<em>Red NAT</em>» de
<a class="reference internal" href="../01.virtualbox.html#virtualbox"><span class="std std-ref">Virtualbox</span></a>) es la predeterminada para los contenedores
que se crean, por lo que todos los ejemplos que hemos estado mostrando la
usaban:</p>
<div class="highlight-console notranslate" id="docker-network-inspect"><div class="highlight"><pre><span></span><span class="gp">#</span> docker network inspect -f <span class="s1">&#39;{{json .IPAM.Config}}&#39;</span> bridge
<span class="go">[{&quot;Subnet&quot;:&quot;172.17.0.0/16&quot;,&quot;Gateway&quot;:&quot;172.17.0.1&quot;}]</span>
<span class="gp">#</span> docker run --rm -ti alpine
<span class="go">/ # hostname -i</span>
<span class="go">172.17.0.2</span>
<span class="go">/ # ip route show</span>
<span class="go">default via 172.17.0.1 dev eth0</span>
<span class="go">172.17.0.0/16 dev eth0 scope link  src 172.17.0.2</span>
</pre></div>
</div>
<p>Si crearamos otro contenedor, estaría también en la red <em>bridge</em> y recibiría
una dirección <abbr title="Internet Protocol">IP</abbr> de la misma red <em>172.17.0.0/16</em>. Al estar todas estos
contenedores en una red interna, la forma de hacer accesibles sus servicios
es mediante la publicación de los puertos expuestosi al crear el contenedor,
como ya se ilustró al <a class="reference internal" href="#docker-volume-create"><span class="std std-ref">tratar Portainer</span></a>. En
aquella ocasión se usó la opción <kbd class="kbd docutils literal notranslate"><kbd class="kbd docutils literal notranslate"></kbd>-<kbd class="kbd docutils literal notranslate">P</kbd></kbd> que escoge un puerto cualquiera
del anfitrión. Puede también usarse la opción <kbd class="kbd docutils literal notranslate"><kbd class="kbd docutils literal notranslate"></kbd>-<kbd class="kbd docutils literal notranslate">p</kbd></kbd> que permite indicar
cuál será el puerto en concreto:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> docker run --rm -d --name<span class="o">=</span>nginx-test -p <span class="m">8080</span>:80 nginx:alpine
</pre></div>
</div>
<p>En este caso, el puerto expuesto <strong>80</strong> se publica en el <strong>8080</strong> de la
máquina anfitrión.</p>
<p>Es posible crear otra red distinta con este mismo controlador de manera que
todos los contenedoes asociados a esa red estará dentro de ella y conectados
entre sí, pero sin aislados de los contenedores asociados a la red
predefinida. Lo trataremos <a class="reference internal" href="#docker-network-create"><span class="std std-ref">más adelante</span></a>.</p>
</dd>
<dt><strong>host</strong></dt><dd><p>Cuando se utiliza este contralador, el contenedor usa la misma red que el
administrador. Por tanto, el contendor:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> docker run --rm -ti --network host alpine
</pre></div>
</div>
<p>compartirá las interfaces con el anfitrión, por lo que cualquier servicio
será directamente accesible. Así pues, se levantamos un servidor web en el
contenedor, éste ocupará directamente el puerto 80 del anfitrión.</p>
</dd>
<dt><strong>null</strong></dt><dd><p>Simplemente, aisla al contenedor de la red. En este caso el contenedor sólo
dispondrá de la interfaz de <em>loopback</em>.</p>
</dd>
</dl>
<p>Además de estos tres tipos de redes, existen otras. Una interesante en sistemas
locales es la asociada al <em>driver</em> <strong>macvlan</strong> que permite incluir el contenedor
en la misma red a la que pertenece el anfitrión, por lo que sería lo más
aproximado al tipo «<em>Adaptador puente</em>» de <a class="reference internal" href="../01.virtualbox.html#virtualbox"><span class="std std-ref">Virtualbox</span></a>.
Ilustraremos su uso bajo el próximo epígrafe,</p>
</div>
<div class="section" id="gestion-de-redes">
<h3><span class="section-number">9.5.2.3.1.5.2. </span>Gestión de redes<a class="headerlink" href="#gestion-de-redes" title="Enlazar permanentemente con este título">¶</a></h3>
<p>Las redes se pueden gestionar a través de <kbd class="kbd docutils literal notranslate"><kbd class="kbd docutils literal notranslate">docker</kbd> <kbd class="kbd docutils literal notranslate">network</kbd></kbd>. Por ejemplo,
podemos crear una nueva red de tipo <em>bridge</em>:</p>
<div class="highlight-console notranslate" id="docker-network-create"><div class="highlight"><pre><span></span><span class="gp">#</span> docker network create -d bridge bridge1
<span class="gp">#</span> docker network inspect -f <span class="s1">&#39;{{json .IPAM.Config}}&#39;</span> bridge1
<span class="go">[{&quot;Subnet&quot;:&quot;172.18.0.0/16&quot;,&quot;Gateway&quot;:&quot;172.18.0.1&quot;}]</span>
</pre></div>
</div>
<p>Gracias a ello y al uso de <kbd class="kbd docutils literal notranslate"><kbd class="kbd docutils literal notranslate"></kbd>-<kbd class="kbd docutils literal notranslate"></kbd>-<kbd class="kbd docutils literal notranslate">network</kbd></kbd> al crear el contenedor, podremos
incluir contenedores dentro de esta otra red llamada <em>bridge1</em> que se comporta
como la predefinida:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> docker run --rm -ti --network bridge1 alpine
<span class="go">/ # hostname -i</span>
<span class="go">172.18.0.2</span>
</pre></div>
</div>
<p>Al crear la red no hemos especificado cuál es la red ni qué dirección hará de
puerta de enlace. Estos datos, sin embargo, pueden especificarse a través de
<kbd class="kbd docutils literal notranslate"><kbd class="kbd docutils literal notranslate"></kbd>-<kbd class="kbd docutils literal notranslate"></kbd>-<kbd class="kbd docutils literal notranslate">subnet</kbd></kbd> (la red), <kbd class="kbd docutils literal notranslate"><kbd class="kbd docutils literal notranslate">ip</kbd>-<kbd class="kbd docutils literal notranslate">range</kbd></kbd> (el rango de <abbr title="Internet Protocol">IP</abbr>s dinámicas) o
<kbd class="kbd docutils literal notranslate"><kbd class="kbd docutils literal notranslate"></kbd>-<kbd class="kbd docutils literal notranslate"></kbd>-<kbd class="kbd docutils literal notranslate">gateway</kbd></kbd> (la dirección de la puerta de enlace). Por ejemplo, si la red
del anfitrión es <em>192.168.0.0/24</em>. la puerta de enlace <em>192.168.0.1</em> y la
interfaz física <em>eth0</em>, podemos usar el <em>driver</em> <strong>macvlan</strong> del siguiente
modo:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> docker network create -d macvlan -o <span class="nv">parent</span><span class="o">=</span>eth0
<span class="go">   --subnet 192.168.0.0/24 --ip-range=192.168.0.128/25 --gateway=192.168.0.1</span>
<span class="go">   redreal</span>
<span class="gp">#</span> docker run --rm -ti --network redreal alpine
</pre></div>
</div>
<p>De asignar direcciones dinámicas a las interfaces de los contenedores se encarga
el demonio, por lo que es conveniente escoger un rango que estimemos que no será
concendido por el servidor <abbr title="Dynamic Host Configuration Protocol">DHCP</abbr> de la red.</p>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>El driver <strong>macvlan</strong> se caracteriza porque no puede comunicarse con
la interfaz física a la que está asociada, por lo que en este caso el
contenedor podrá cominicarse con el resto de la red, pero no con el
anfitrión. Para evitar esta circunstancia, podría configurarse la dirección
del anfitrión en otra interfaz <em>macvlan</em>, en vez de sobre <em>êth0</em>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> The primary network interface
<span class="go">allow-hotplug enp1s0</span>
<span class="go">iface enp1s0 inet manual</span>
<span class="go">   up   ip link set dev $IFACE up</span>
<span class="go">   down ip link set dev $IFACE down</span>

<span class="go">auto host</span>
<span class="go">iface host inet dhcp</span>
<span class="go">   pre-up    ip link add link enp1s0 $IFACE type macvtap mode bridge</span>
<span class="go">   post-down ip link del dev $IFACE</span>
</pre></div>
</div>
</div>
<p>Es posible también conectar contenedores a dos u más redes <em>bridge</em> utilizando
los subcomandos <kbd class="kbd docutils literal notranslate">connect</kbd> y <kbd class="kbd docutils literal notranslate">disconnect</kbd>:</p>
<div class="highlight-console notranslate" id="docker-network-disconnect"><span id="docker-network-connect"></span><div class="highlight"><pre><span></span><span class="gp">#</span> docker create -ti alpine
<span class="gp">#</span> docker network connect bridge1
</pre></div>
</div>
<p>De esta manera el contenedor tendrá una interfaz en la red <em>bridge</em> y otra en la
red <em>bridge1</em>.</p>
<p>Como pueden crearse, pueden borrarse redes también:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> docker network rm bridge1
</pre></div>
</div>
</div>
</div>
<div class="section" id="limitaciones">
<span id="docker-limit"></span><h2><span class="section-number">9.5.2.3.1.6. </span>Limitaciones<a class="headerlink" href="#limitaciones" title="Enlazar permanentemente con este título">¶</a></h2>
<p>Al crear un contenedor también pueden establecerse limitaciones en el uso de los
recursos, en particular, al uso de la memoria y el procesador.</p>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>Es probable que al hacer <kbd class="kbd docutils literal notranslate"><kbd class="kbd docutils literal notranslate">docker</kbd> <kbd class="kbd docutils literal notranslate">info</kbd></kbd> obtengamos el mensaje:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>WARNING: Noswaplimitsupport
</pre></div>
</div>
<p>Si ese es el mensaje, es necesario añadir dos parámetros al arranque del
núcleo, para lo cual debemos editar el fichero <code class="file docutils literal notranslate"><span class="pre">/etc/default/grub</span></code>:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="nv">GRUB_CMDLINE_LINUX</span><span class="o">=</span><span class="s2">&quot;cgroup_enable=memory swapaccount=1&quot;</span>
</pre></div>
</div>
</div>
<div class="section" id="memoria">
<h3><span class="section-number">9.5.2.3.1.6.1. </span>Memoria<a class="headerlink" href="#memoria" title="Enlazar permanentemente con este título">¶</a></h3>
<p>Hay varias opciones que limitan la memoria:</p>
<table class="docker-limit-params docutils align-default">
<colgroup>
<col style="width: 42%" />
<col style="width: 58%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Parámetro</p></th>
<th class="head"><p>Descripción</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>-m, –memory=numero[bkmg]</p></td>
<td><p>Establece un límite estricto al uso de memoria.</p></td>
</tr>
<tr class="row-odd"><td><p>–memory-reservation=numero[bkmg]</p></td>
<td><p>Esteblece un límite suave al uso de memoria.</p></td>
</tr>
<tr class="row-even"><td><p>–memory-swap=numero[bkmg]</p></td>
<td><p>Establece un límite al uso de memoria swap.</p></td>
</tr>
</tbody>
</table>
<p>Por ejemplo:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> docker run --rm -d -m 256m --name<span class="o">=</span>nginx nginx:alpine
<span class="gp">#</span> docker container stats --no-stream --format <span class="s1">&#39;{{.MemUsage}}&#39;</span> nginx
<span class="go">4.945MiB / 256MiB</span>
</pre></div>
</div>
</div>
<div class="section" id="procesador">
<h3><span class="section-number">9.5.2.3.1.6.2. </span>Procesador<a class="headerlink" href="#procesador" title="Enlazar permanentemente con este título">¶</a></h3>
<p>Existen varias opciones relativas al uso del procesador. Por ejemplo:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> docker run --rm -d --cpus<span class="o">=</span><span class="m">1</span> --name<span class="o">=</span>nginx nginx:alpine
</pre></div>
</div>
<p>limitará el uso del contenedor a una <abbr title="Central Processing Unit">CPU</abbr>. Puede también especificarse qué
<abbr title="Central Processing Unit">CPU</abbr> exactamente:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span>  docker run --rm -d --cpuset-cpus<span class="o">=</span><span class="m">0</span>,2 --name<span class="o">=</span>nginx nginx:alpine
</pre></div>
</div>
<p>que limitará el uso al primer y tercer procesador.</p>
<p>Si se tienen varios contenedores simultáneamente, puede también repartirse el
consumo máximo de <abbr title="Central Processing Unit">CPU</abbr> entre todos ellos mediante la opción <kbd class="kbd docutils literal notranslate"><kbd class="kbd docutils literal notranslate"></kbd>-<kbd class="kbd docutils literal notranslate"></kbd>-<kbd class="kbd docutils literal notranslate">cpu</kbd>-<kbd class="kbd docutils literal notranslate">shares</kbd></kbd>
cuyo valor predeterminado es <strong>1024</strong>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> cat /sys/fs/cgroup/cpu/docker/cpu.shares
<span class="go">1024</span>
</pre></div>
</div>
<p>De esto modo, si arrancamos estos tres contenedores:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span>  docker run --rm -d --cpuset-cpus<span class="o">=</span><span class="m">0</span> --name<span class="o">=</span>nginx nginx:alpine
<span class="gp">#</span>  docker run --rm -d --cpuset-cpus<span class="o">=</span><span class="m">0</span> --cpu-share<span class="o">=</span><span class="m">512</span> --name<span class="o">=</span>php php:alpine
<span class="gp">#</span>  docker run --rm -d --cpuset-cpus<span class="o">=</span><span class="m">0</span> --cpu-share<span class="o">=</span><span class="m">512</span> --name<span class="o">=</span>mysql mysql:alpine
</pre></div>
</div>
<p>El primer contenedor podrá consumir hasta el 50% de la <abbr title="Central Processing Unit">CPU</abbr> y los otros dos
hasta el 25%.</p>
<p class="rubric">Notas al pie</p>
<dl class="footnote brackets">
<dt class="label" id="id5"><span class="brackets"><a class="fn-backref" href="#id1">1</a></span></dt>
<dd><p>La configuración por defecto es que demonio y cliente se encuentran en la
misma máquina y la comunicacion se hace a través de un <em>spcket</em>. No queda
pues el demonio escuchando en ningún puerto, para lo cual habría que hacer
<cite>configuración adicional en el demonio
&lt;https://success.docker.com/article/how-do-i-enable-the-remote-api-for-dockerd&gt;</cite>
y en el cliente.</p>
</dd>
<dt class="label" id="id6"><span class="brackets"><a class="fn-backref" href="#id2">2</a></span></dt>
<dd><p>Para ello se usar el driver <a class="reference external" href="https://en.wikipedia.org/wiki/OverlayFS">OverlayFS</a> en las versiones modernas de
<em>Docker</em>.</p>
</dd>
<dt class="label" id="id7"><span class="brackets"><a class="fn-backref" href="#id3">3</a></span></dt>
<dd><p>Esta imagen de <a class="reference internal" href="../../../07.serre/02.web/02.nginx/index.html#n-ginx"><span class="std std-ref">nginx</span></a> escribe el registro de los accesos y
los errores en la salida de errores, por lo que si nuestra intención es
leerlos, nos interesará quitar la opción <kbd class="kbd docutils literal notranslate"><kbd class="kbd docutils literal notranslate"></kbd>-<kbd class="kbd docutils literal notranslate">d</kbd></kbd> para que empiecen a
aparecer esos registros en la terminal ocupada.</p>
</dd>
<dt class="label" id="id8"><span class="brackets"><a class="fn-backref" href="#id4">4</a></span></dt>
<dd><p>En este caso se sobrentiende que los puertos son <abbr title="Transmission Control Protocol">TCP</abbr>. Si hubieran sido
<abbr title="User Datagram Protocol">UDP</abbr>, habría sido necesario especificarlo) por ejemplo, <kbd class="kbd docutils literal notranslate"><kbd class="kbd docutils literal notranslate"></kbd>-<kbd class="kbd docutils literal notranslate">p</kbd> <kbd class="kbd docutils literal notranslate">53:53/udp</kbd></kbd>.</p>
</dd>
</dl>
</div>
</div>
</div>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../../../index.html">Tabla de contenido</a></h3>
  <ul>
<li><a class="reference internal" href="#">9.5.2.3.1. Operativa básica</a><ul>
<li><a class="reference internal" href="#introduccion">9.5.2.3.1.1. Introducción</a></li>
<li><a class="reference internal" href="#imagenes">9.5.2.3.1.2. Imágenes</a></li>
<li><a class="reference internal" href="#contenedores">9.5.2.3.1.3. Contenedores</a></li>
<li><a class="reference internal" href="#volumenes">9.5.2.3.1.4. Volúmenes</a></li>
<li><a class="reference internal" href="#redes">9.5.2.3.1.5. Redes</a><ul>
<li><a class="reference internal" href="#tipos">9.5.2.3.1.5.1. Tipos</a></li>
<li><a class="reference internal" href="#gestion-de-redes">9.5.2.3.1.5.2. Gestión de redes</a></li>
</ul>
</li>
<li><a class="reference internal" href="#limitaciones">9.5.2.3.1.6. Limitaciones</a><ul>
<li><a class="reference internal" href="#memoria">9.5.2.3.1.6.1. Memoria</a></li>
<li><a class="reference internal" href="#procesador">9.5.2.3.1.6.2. Procesador</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>Tema anterior</h4>
  <p class="topless"><a href="../03.docker.html"
                        title="capítulo anterior"><span class="section-number">9.5.2.3. </span>Docker</a></p>
  <h4>Próximo tema</h4>
  <p class="topless"><a href="03.constr.html"
                        title="próximo capítulo"><span class="section-number">9.5.2.3.2. </span>Construcción</a></p>
  <div role="note" aria-label="source link">
    <h3>Esta página</h3>
    <ul class="this-page-menu">
      <li><a href="../../../_sources/09.apendice/99.virtual/03.docker/02.uso.rst.txt"
            rel="nofollow">Mostrar el código</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Búsqueda rápida</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Ir a" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navegación</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="Índice General"
             >índice</a></li>
        <li class="right" >
          <a href="03.constr.html" title="9.5.2.3.2. Construcción"
             >siguiente</a> |</li>
        <li class="right" >
          <a href="../03.docker.html" title="9.5.2.3. Docker"
             >anterior</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">documentación de Linuxnomicón - rolling</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" ><span class="section-number">9. </span>Apéndices</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="../index.html" ><span class="section-number">9.5. </span>Virtualización</a> &#187;</li>
          <li class="nav-item nav-item-3"><a href="../03.docker.html" ><span class="section-number">9.5.2.3. </span>Docker</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href=""><span class="section-number">9.5.2.3.1. </span>Operativa básica</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Derechos de autor CC BY 4.0, 2016-2021, José Miguel Sánchez Alés.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 3.4.1.
    </div>
  </body>
</html>