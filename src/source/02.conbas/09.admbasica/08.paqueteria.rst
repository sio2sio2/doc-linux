.. _paqueteria:

Gestión del software
********************
La mayor parte del *software* del que se constituyen los sistemas linux es
*software* libre, disponible en la red, de ahí que las distribuciones se
encarguen de seleccionarlo, adaptarlo y facilitarlo. Por ello, *Debian* dispone
de un sistema de paquetes ``.deb`` que facilita la instalación, actualización y
borrado del software.

En general, la instalación de *software* en un sistema *Linux* puede hacerse por
distintas vías:

#. Paquetería propia:

   El sistema de paquetes proporcionado por la distribución debe ser la **vía
   preferente**, puesto que asegura la integración y compatibilidad de la
   aplicación con el resto del sistema, minimiza la duplicidad de *software
   intermedio* (librerías) y permite una cómoda actualización.

#. Paquetería universal:

   Existen varias alternativas que proveen a *Linux* de un sistema de paquetes
   independiente de la distribución. Estos sistemas se basan en proveer todas
   las dependencias necesarias para las aplicaciones sin tener en cuenta el
   *software* ya instalado a través de la paquetería propia de la distribución;
   y realizan la instalación de todos los archivos necesarios en un lugar de disco
   que no interfiera con ella. Proporcionan la posibilidad de gestionar los
   paquetes instalados y las actualizaciones, por lo que son relativamente
   cómodos, aunque tiene varios **inconvenientes** respecto a los paquetes de la
   distribución:

   + Menor integración con el sistema.
   + Duplicidad de librerías, ya que no utilizarán las ya instaladas en el
     sistema de manera regular (a través del sistema de paquetes de la
     distribución).

   Pese a ello son una excelente alternativa si:

   + La distribución no dispone del paquete (improbable si la distribución es de
     las mayoritarias).
   + Necesitamos una versión de la aplicación distinta de la que ofrece la
     distribución. Por ejemplo, una nueva versión que aún no haya sido portada
     al sistema de paqueteas.
   + La distribución carece de las dependencias adecuadas. Por ejemplo, una
     aplicación aún escrita en *Python2* para la que ya no habrá soporte en las
     distribuciones modernas que han migrado ya todas a *Python3*.

   Hay varias alternativas:

   + Flatpak_, promovida por freedesktop.org_. Sus paquetes comparten una base
     común de bibliotecas principales, por lo que es costoso en espacio instalar
     el primer paquete, pero no tanto los demás.
   + Snap_, promovida por *Canonical*, la empresa detrás de *Ubuntu*. No dispone
     de esa base común, de manera que tiene a incluir todas sus dependencias+
     dentro del paquete.
   + AppImage_, que desarrolla el mismo concepto que los archivos ``app`` de
     *MacOS*: el archivo contiene todas las dependencias necesarias para que se
     ejecute la aplicación y no se instala: al ejecutarlo se monta su contenido
     y arranca el programa. Eliminar la aplicación consiste básicamente en
     eliminar el archivo.
   + :ref:`Docker <docker>`, que no es propiamente una solución para instalar
     *software*, sino que desarrolla el concepto de :ref:`contenedor de
     aplicación <contenedor-aplicacion>`, pero que puede utilizarse puntualmente
     para tal fin. Por ejemplo, `este contenedor
     <https://hub.docker.com/r/kasmweb/gimp>`_ permite utilizar Gimp_ a través
     del navegador.

   .. seealso:: Échele un vistado al artículo `AppImage, Snap Y Flatpak…. ¿todos
      o ninguno? <https://atareao.es/opinion/appimage-snap-flatpak/>`_ que
      desarrolla las características de estos tres gestores universales de
      paquetes.

#. Instalación manual:

   Si no hay oportunidad de usar ninguna de las dos vías anteriores, sólo será
   posible instalar la aplicación de modo manual. Este vía sólo puede ser el
   último recurso, porque no sólo es la que presenta una instalación más
   complicada, sino también una mantenimiento y actualización manual, lo que la
   vuelve engorrosa y fuertemente desaconsejable.
   
   .. note:: El *software* privativo por lo general es instalable por esta
      vía, aunque a veces, si es gratuito, se nos ofrece un repositorio de
      alguna de las dos vías anteriores.

   La casuística de esta tercera vía es muy grande:

   + En ocasiones, se nos ofrecen en forma de *paquete* del sistema propio
     de paquetería que utiliza nuestro sistema o de un sistema universal de
     paquetería. Esta es la fórmula más sencilla para la instalación, aunque
     puede estar sujeta a incompatibilidades (fallos de dependencias como ya
     entenderemnos) y se carecerá de actualización a través del gestor de
     paquetes.

     .. note:: Cuando se nos ofrece, no un paquete aislado de *software*, sino
        un repositorio del que obtener el paquete, estamos ante una situación
        intermedia entre uno de los dos y éste; ya que la instalación no es
        manual y el repositorio puede estar siendo mantenido por alguien que se
        encarga de actualizarlo periódicamente, pero a la vez no tenemos garantía
        de que estas actualización estén sincronizadas con el ritmo de actualización
        del sistema de paquetería. Para entender todo esto deberá completar la
        :ref:`lectura sobre los sistemas de paquetes <conceptos-paquetes>`
        incluida más abajo.`

   + Se proporciona un archivo que, mediante un *script* de instalación, instala
     la aplicación en el sistema. Esto presenta todos los inconvenientes
     posibles:

     + Puede haber incompatibilidad de dependencias.
     + No controlaremos la instalación, puesto que ningún gestor de *software*
       será capaz de detectar que la aplicación está instalada y, por supuesto,
       tampoco será capaz de desinstalarla. Afortunadamente, estos archivos
       suelen proporcionar también un *script* de desinstalación.
     + El mantenimiento y actualización debe ser manual.

   + Finalmente, también puede darse el caso de que de la aplicación sólo se
     proprocione el código fuente y tengamos que ser nosotros mismos los que la
     compilemos leyendo la documentación. Es la instalación más ardua porque
     este paso no siempre es trivial y, además, una vez completado nos
     encontraremos en uno de los dos casos anteriores (paquete aislado o
     *script* de instalación)

.. _conceptos-paquetes:

.. rubric:: Los sistemas de paquetes

El *software* tanto el propio como el universal se basa en el concepto de
sistema de paquetes que conviene tener claro antes de proseguir.

:dfn:`Sistema de paquetes` (o :dfn:`sistema de paquetería`)
   Es un conjunto de aplicaciones, organizadas en paquetes y
   accesibves a través de servidores, que se estructuran de modo que se
   facilite su instalación, mantenimiento y actualización.

:dfn:`Paquete`
   Es una colección de archivos binarios, de documentación o de configuraciń
   relacionados entre sí por constituir una aplicación o parte de una aplicación.
   Existen distintos formatos de paquete. El propio de *Debian* y todas sus
   distribuciones derivadas es *.deb*\ [#]_.

:dfn:`Repositorio` o :dfn:`réplica`
   Es un lugar (cdrom, servidor web, servidor |FTP|) donde se almacenan
   paquetes, con el propósito de hacerlos accesibles a los sistemas clientes
   y que estos puedan, de modo sencillo, descargarlos e instalarlos o
   actualizarlos.

:dfn:`Gestor de paquetes`
   Es el *sotfware* encargado de gestionar la instalación, eliminación,
   actualización y mantenimiento de los paquetes.

Tanto a la paquetería propia (de la distribución) como la paquetería universal
se le pueden aplicar estos conceptos. Hay, sin embargo, una diferencia
importante de una respecto a la otra: mientras que la paquetería universal
se instala de modo que no interfiera con el resto del sistema, la paquetería de
la distribución lo hará ocupando los directorios que se espera que ocupen los
archivos dependiendo de su naturaleza (p.e. un ejecutable se instalará en
:file:`/usr/bin/`, por ejemplo. Esto supone que no pueda haber en un mismo
sistema paqueterías de distribución (p.e. que intentemos compaginar el sistema
de paquetes de *Debian* con el de *Red Hat*), en cambio sí es posible compaginar
el sistema de paquetes de nuestra distribución y uno o más sistemas de paquetes
universales.

Por último, es importante tener claro que los paquetes no son independientes
unos de otros, sino que establece una compleja relación de dependencias entre
ellos, ya que se empaqueta las dependencias (librerías, por ejemplo) en paquetes
separados de los paquetes de aplicación final a fin de que las dependencias no
se instalen duplicadas. De este modo, los dos paquetes de sendas aplicaciones
finales, que dependan de una misma librería, no requerirán incluir dicha
librería dentro de sí, sino únicamente una dependencia al paquete que instala
la librería. Esto elimina, pues, duplicidades, pero introduce relaciones entre
los distintos paquetes y provoca que el sistema de paquetes evoluciones como un
conjunto. Así, la actualización a una nueva versión de esa librería, provocará
que los paquetes de esas dos aplicaciones finales relacionadas también se
actualicen.

.. rubric:: Gestores de paquetes

Descontada la última vía manual, la instalación y mantenimiento de *software* se
basa en paquetes para los cuales cada sistema proporciona el suyo. Trataremos
este concepto más adelante, pero ahora es preciso recalcar que existen:

:dfn:`Gestores`
   propiamente dichos, que son aquellos que gestionan un sistema de paquetes
   concreto. Por ejemplo, |APT| que gestiona el sistema de paquetes de
   *Debian* o :program:`flatpak`, que gestiona el sistema homónimo de paquetes
   universales.

:dfn:`Multigestores` (terminología propia)
   que son aquellos capaces de interactuar con distintos sistemas de paquetes,
   de manera que propocionan una única interfaz de usuario, sea cual sea el
   sistema de paquetes que se use como *backend*.

   .. note:: Esta posibilidad es debida a que el proyecto freedesktop.org_ ha
      definido un estándar de interoperatividad para los sistemas de paquetes
      y una librería (AppStream_) que lo implementa, por lo que cualquier
      sistema que lo cumpla es susceptible de poder ser manejado por uno de
      estos multigestores.

   Por otra parte, ya dejamos establecido que en un mismo sistema podemos
   conjugar varios sistemas de paquetes (siempre que haya un sólo sistema
   propio de distribución). A los *multigestores* capaces de compatibilizar
   la gestión de varios sistemas de paquetería los llamaremos :dfn:`agregadores`
   (terminología también propia). Los multigestores más conocidos son:

   + PackageKit_, independiente del entorno de escritorio e incluso con interfaz
     |CLI|. Soporta únicamente algunos sistemas de paquetes de distribución y,
     por tanto, no es un agregador. Aunque puede ser utilizado directamente,
     proporciona una :abbr:`API (Application Programming Interface)` para que
     los entornos de escritorio puedan construir aplicaciones gráficas de
     gestión de paquetes.

   + `Gnome Software`_, agregador para el escritorio *Gnome*, que permite
     compatibilizar los paquetes de la distribución en la que se instale con
     Snap_ y Flatpak_. Otros agregadores semejantes como :program:`Ubuntu
     Software` o el :program:`Centro de Guadalinex` son simples derivados de
     éste.

   + Discover_, agregador con las mismas posibilidades que `Gnome Software`_,
     pero para el escritorio |KDE|.

   Todos estos multigestores se caracterizan por abstraer aún más a los usuarios
   del propio sistema de empaquetado y, aunque traten con paquetes de
   distribución, sólo muestran los paquetes de aplicación final, adquiriendo así
   la apariencia de una "*tienda de aplicaciones*" al modo de las que hay en
   *Windows*, *Android* o *iOS*.

   .. note:: Tanto Discover_ como `Gnome Software`_ usan internamente la |API|
      de PackageKit_ para manejar los paquetes de distribución.

.. _paquetes-deb:

Paquetería propia
=================
.. warning:: Este apartado es hasta tal punto dependiente de la distribución que
   es absolutamente inútil su lectura si no se utiliza una distribución basada
   en *Debian*.

.. _ramas:

Ramas
-----
.. warning:: Este subapartado, en concreto, es específico para *Debian*
   Si se utiliza una distribución basada en *Debian*, pero no *Debian* misma,
   sáltelo sin escrúpulo.

*Debian* está dividida en tres grandes ramas:

#. La distribución estable (*stable*) orientada al uso en servidores,
   durante cuya vida sólo recibe actualizaciones para correción de *bugs*
   y problemas de seguridad.

#. La distribución en pruebas (*testing*), que se actualiza regularmente con
   nuevo software y versiones más recientes del software ya existente.
   Conceptualmente, es una :ref:`distribución rolling <seg-act-linux>`.

#. La distribución inestable (*unstable*), que se actualiza aún con mayor
   celeridad y que sirve como alimentación a la rama en pruebas.

Por tradición\ [#]_, las diferentes versiones de *Debian* reciben el nombre de
un personaje de la serie de películas de animación *Toy Story*. La actual
estable, la versión 8\ [#]_, tiene por nombre *Jessie*; la de pruebas,
*Stretch*; y la inestable es la única que no cambia su nombre y se llama siempre
*Sid* (el chico que rompía los juguetes).

El ciclo de vida es el siguiente:

#. La distribución inestable recibe constantemente paquetes con las últimas
   versiones de software.

#. También constantemente, la rama en pruebas va recibiendo paquetes
   procedentes de la rama inestable, según se vea que no producen errores
   graves en el sistema.

#. La rama estable, ajena a todas estas actualizaciones, mantiene las
   versiones de los paquetes con la que salió. Sólo recibe actualizaciones
   que corrijan problemas detectados.

#. En un momento determinado (últimamente es cada dos años), se congela la
   rama en pruebas, de manera que deja de recibir actualizaciones de paquetes
   procedentes de *sid* y el equipo de desarrollo se centra en la tarea de
   eliminar *bugs* importantes. Este proceso es lento y suele llevar más de
   seis meses.

#. Cuando no existen errores graves detectados, la rama estable pasa a ser
   la vieja estable (*oldstable*), y la rama en pruebas congelada se desdobla
   de manera que, por un lado, pasa a ser la estable, llevándose el nombre
   consigo; y, por otro, se rebautiza con un nuevo personaje de *Toy Story* y
   comienza de nuevo a admitir actualizaciones procedentes de *sid*.

#. Por su parte, la vieja inestable sigue recibiendo soporte oficial de
   *Debian* durante al menos tres años más, de manera que se llegue al menos
   a los cinco años de vida: los dos que tuvo como distribución estable y
   estos tres años adicionales de soporte.

Además de las tres distribuciones de desarrollo principales, existen otras tres
de interés:

#. La vieja estable (*oldstable*) que ya se ha explicado.

#. La *experimental*, que no es una distribución completa, sino un
   repositorio de pruebas donde se sube *software* nuevo o versiones nuevas de
   *software* existente y que, por lo general, o no funciona o no lo hace
   totalmente, pero se incluye como paso previo a poder entrar en la
   distribución inestable.

#. Los *backports* para la versión estable, que es un repositorio con
   software más moderno que aquel del que se dispone en la estable. Tengamos
   en cuenta que entre la fase de congelación y el tiempo que tenga ya como
   estable, nos podemos encontrar con software que tiene casi tres años de
   antigüedad. Obviamente, la estabilidad y seguridad de los paquetes de la
   *backports* no es comparable con la de aquellos que se encuentran en la
   estable, así que el administrador debe sopesar si elige actualizar a
   versiones más modernas corriendo el riesgo de encontrar bugs adicionales.

Por otro lado, a causa de su licencia, dentro de una distribución los paquetes
se distribuyen en tres componentes o secciones:

**main**
   Paquetes que cumplen los requisitos para ser considerados por *Debian*
   *software* libre y que, además, sólo tienen dependencia de paquetes que
   también pertenecen a este componente.

**contrib**
   Paquetes que son *software* libre, pero tiene dependencia de paquetes que no
   son software libre.

**non-free**
   Paquetes que no son *software* libre a criterio de *Debian*.

.. note:: Las instalaciones de *Debian* suelen incluir por defecto sólo el
   componente *main*, aunque podemos añadir los otros dos posteriormente sin
   problemas.

Gestores
--------
Para el control de paquetes, *Debian* dispone de varias herramientas:

**dpkg**
   No es propiamente un gestor, sino la herramienta básica para la instalación,
   borrado y actualización de un paquete y, consecuentemente, es utilizada por
   los gestores de los que se hablará a continuación.

**apt-\***
   Familia de órdenes (:command:`apt-get`, :command:`apt-cache`) que gestiona
   paquetes desde la línea de comandos. Fue durante mucho tiempo el gestor más
   usado. 

**apt**
   La familia anterior tiene el inconveniente de que, dependiendo de la
   operación que queramos realizar, debemos usar uno u otro comando. Para paliar
   esto, se creó la orden :command:`apt` a secas que reúne las operaciones más
   habituales. Modernamente, es la herramienta recomendada.

**dselect**
   Fue el primer *front-end* para la gestión de paquetes. Apenas se usa ya.

**aptitude**
   Como :program:`dselect` provee de una interfaz para la gestión de paquetes,
   aunque la mayor parte de los usuarios lo utilice pasando directamente las
   opciones necesarias a través de la línea de comandos. De esta última forma,
   tiene muchas similitudes con :program:`apt-get`. Tiene como ventaja sobre
   este último que es capaz de hacer sugerencias, cuando por algún problema de
   incompatibilidades no es posible instalar algún paquete o actualizar el
   sistema completo.

   A partir de *Stretch* no viene instalado de serie.

**synaptic**
   Gestor gráfico de paquetes no ligado a un escritorio concreto.

En el manual basaremos las explicaciones en :command:`apt`, aunque daremos
también las explicaciones de cómo gestionar con la antigua familia apt-\*.

.. _deb-repo:

Repositorios
------------
Antes de realizar cualquier operación sobre paquetes es importante
cerciorarse de cómo se obtendrán. Lo habitual es que éstos se obtengan de
internet, lo que exige tener definidos los repositorios en el fichero
:file:`/etc/apt/sources.list`. Un contenido típico es el siguiente:

.. include:: docs/sources.list
   :literal:

Cada línea del fichero representa una fuente de obtención de paquetes y su
sintaxis es la siguiente::

   deb|deb-src URL distribución componente1 [componente2 [componente3]]

En particular, el significado de cada campo es el siguiente.

#. Las línea que empiezan por *deb* representan fuentes para paquetes
   compilados, mientras que las líneas que empiezan por *deb-src*, fuentes
   para paquetes de código fuente que necesitan compilarse. Por lo
   general, los paquetes compilados tienen un correspondiente sin compilar
   por si deseamos hacer esta operación nosotros mismos. No es lo habitual
   y, de hecho, en el ejemplo, están comentadas las líneas (anteponiendo
   en ellas una almohadilla) para que no tengan efecto.

#. La URL indica la dirección del repositorio. Hay muchísimos repartidos por
   todo el mundo. La lista completa puede obtenerse de `la página de Debian
   <https://www.Debian.org/mirror/list>`_.

#. En el campo referente a la distribución puede incluirse o el nombre de la
   distribución (el personaje de *Toy Story*) o el nombre de la rama
   (*oldstable*, *stable*, *testing*, *unstable*, *experimental*, etc.)\ [#]_

#. El componente hace referencia a *main*, *contrib* o *non-free*. Lo
   habitual es tener *main*, que contiene el grueso de los paquetes, y de
   forma accesoria *contrib* y *non-free*.

.. warning:: Si se hizo una instalación a partir de un cdrom, es muy probable que el
   propio cdrom esté incluido como fuente. Es más que recomendable
   eliminar la línea (o comentarla) para evitar el tedio de soportar que
   el gestor nos pida el cdrom.

Además de este fichero, puedes crearse otros ``.list`` dentro de
:file:`/etc/apt/sources.list.d` con repositorios más específicos.

.. warning:: No es buena idea mezclar distintas ramas (testing, sid) en un mismo
   sistema a menos que se haga con cuidado, lo cual implica hacer :ref:`uso del
   apt-pinning <apt-mix>`.

.. _paq-bas:
.. _apt:
.. index:: apt

Operaciones básicas
-------------------
Cerciorados de que se dispone de un repositorio válido, la primera acción es
*bajar* la lista de paquetes disponibles o actualizarla si ya se realizó antes
la operación::

   # apt update

Esto se debe a que, :command:`apt` usa para la gestión de paquetes una copia de
la lista del paquetes disponibles no la lista de paquetes propiamente contenida
en el repositorio. La operación es recomendable hacerla siempre antes de
instalar un paquete (a menos de que se acabe de instalar otro antes), ya que
desde la última obtención de la lista, los paquetes disponibles en el
repositorio han podido cambiar.

.. warning:: La acción anterior no actualiza el sistema, sólo la lista de
   paquetes disponibles.

Actualizada la lista, es posible instalar un paquete individual o actualizar los
paquetes a su versión más reciente. Esta última acción tiene dos variables::

   # apt upgrade

que hace una actualización *no traumática*, es decir, sólo realiza las
actualizaciones que no implican un cambio significativo en la composición de
nuestros paquetes instalados. Estos cambios significativos pueden deberse al
hecho de que le mantenedor de una aplicación haya decidido restructurar los
paquetes relacionados con ella, de manera que una actualización implique borrar
paquetes. Como consecuencia, pueden quedar paquetes retenidos sin actualizar. La
variante que provoca una actualización completa\ [#]_ es::

   # apt dist-upgrade

Si nuestra intención es instalar *software*, por ejemplo, el paquete :ref:`pv
<pv>`::

   # apt install pv

Para desinstalar existen dos posibilidades:

#. Hacerlo de modo que no se eliminen los fichero de configuración::

   # apt remove pv

#. Hacerlo sin que quede rastro de ellos::

   # apt purge pv

También es posible instalar y desinstalar en una misma acción añadiendo los
signos :kbd:`+` o :kbd:`-` tras el nombre del paquete::

   #. apt install vim+ vim-tiny-

Cuando un paquete se instala, es común que dependa de otros paquetes que no
están instalados y, como consecuencia que el sistema, se vea obligado a instalar
más de un paquete. En este caso, :command:`apt` nos informará y nos pedirá que
confirmemos la operación. Si deseamos responder sí automáticamente, basta con
incluir la opción ``-y``::

   # apt install -y vim+ vim-tiny-

Del mismo modo, al desinstalar un paquete es posible que paquetes que se
instalaron solamente para satisfacer las dependencias de éste, queden sin razón
de ser en el sistema. Esto es conocido por el gestor porque cuando
instala un paquete lo marca como instalado **manual**\ mente o instalado
**auto**\ máticamente.

Por último, :kbd:`apt install` permite también instalar paquetes :file:`.deb`
descargados previamente\ [#]_. En este caso, para que la herramienta distinga un
archivo de un paquete de repositorio, es necesario que en al expresar el archivo
se incluya una ruta absoluta o relativa::

   # apt install /tmp/AutoFirma_1_6_5.deb
   # apt install ./AutoFirma_1_6_5.deb


Cuando se hacen operaciones de borrado (:kbd:`remove`) y purga (:kbd:`purge`),
pero también de actualización (:kbd:`upgrade`) o, incluso, de instalación
(:kbd:`install`), puede ocurrir que resulten paquetes huérfanos, esto es,
paquetes instalados automáticamente, pero que ya no son necesarios puesto
que ningún paquete que requiera de su presencia, está ya instalado. En este
caso, existe un comando específico para eliminarlos (que se nos sugerirá cuando
el sistema detecte su presencia)::

   # apt autoremove

Sin embargo, podemos ahorrarnos esta operación si incluímos la opción
:kbd:`--autoremove` en cualquira de las operaciones anteriormente referidas
(*install*, *remove*, *upgrade* o *purge*)::

   # apt --autoremove remove nginx

Cuando se instala (*install*) o se actualiza el sistema (*upgrade*,
*dist-upgrade*), se van descargando los paquetes necesarios y almacenando dentro
de :file:`/var/cache/apt/archives`. Esa es la razón por la que si cancelamos la
orden y la proseguimos después, seguirá la descarga en el punto en que quedó.

.. warning:: Antes de instalar o actualizar es muy, muy conveniente actualizar
   la lista de paquetes, porque podemos tenerla obsoleta y que los paquetes
   existentes en el repositorio no sean los mismos que nuestro sistema cree. De
   hecho, si intentamos instalar un paquete y el sistema nos informa de que éste
   no existe, supuesto que tengamos bien la conexión a internet, la razón casi
   segura es que estamos trabajando con una lista obsoleta y haya que
   actualizarla.

.. note:: Dado que que conveniente actualizar la lista antes de instalar es muy
   común escribir líneas como esta::

      # apt update && apt install -y pv

Para buscar paquetes adecuados para una determinada tarea son útiles dos
comandos::

   $ apt search términos de búsqueda

que nos devolverá los paquetes relacionados con los términos de búsqueda que se
incluyan. Y cuando se duda si instalar un paquete o no, puede mirarse la
descripción completa del mismo a través de::

   $ apt show pv

Es también muy útil saber cuál es la lista de paquetes disponibles::

   $ apt list

que sin ningún argumento das devolverá todos los paquetes existentes, instalados
o no. Podemos afinar esta lista utiliziando :ref:`patrones <comodines>`\ [#]_,
como por ejemplo::

   $ apt list 'p[av]*'

que mostrará todos los paquetes cuyo nombre empieze por "pa" o "pv". Además se
puede añadir las opciones :kbd:`--installed` (sólo paquetes instalados) o
:kbd:`--upgradable` (sólo paquetes con versión más reciente en los
repositorios). Por ejemplo::

   $ apt list --installed 'n*'

devuelve todos los paquetes instalados cuyo nombre empieza por "n".

.. _apt-get:
.. index:: apt-get

La familia :program:`apt-`
--------------------------
Es, sin duda, preferible :program:`apt` ya que reducen a una sola orden las
operaciones básicas de gestión de *software* y, además, ofrece un aspecto
mejorado (colores, barra de progresión, etc.). No obstante, resumimos aquí las
equivalencia entre la orden :command:`apt` y las órdenes de esta familia:

========================= ===========================
  Orden :command:`apt`    Familia :program:`apt-*`   
========================= ===========================
  :kbd:`apt install`      :kbd:`apt-get install`     
  :kbd:`apt remove`       :kbd:`apt-get remove`      
  :kbd:`apt purge`        :kbd:`apt-get purge`       
  :kbd:`apt update`       :kbd:`apt-get update`      
  :kbd:`apt upgrade`      :kbd:`apt-get upgrade`     
  :kbd:`apt full-upgrade` :kbd:`apt-get dist-upgrade`
  :kbd:`apt autoremove`   :kbd:`apt-get autoremove`  
  :kbd:`apt search`       :kbd:`apt-cache search`    
  :kbd:`apt show`         :kbd:`apt-cache show`      
  :kbd:`apt list`         :kbd:`dpkg -l`             
========================= ===========================

Es, no obstante, muy importante hacer una precisión. Las acciones que implican
descargar paquetes del repositorio (*install*, *upgrade*) no borran estos
paquetes descargados al completarse con éxito, a diferencia de :ref:`apt <apt>`,
sino que estos archivos *.deb* se van acomulando en el directorio
:file:`/var/cache/apt`. Por ello, tras la acción, es preciso borrar la caché
con::

   # apt-get clean.

Otras operaciones
-----------------
Bajo este epígrafe se enumerarán algunas otras operaciones relacionadas con los
paquetes y la gestión de paquetes, pero que se realizan con menor frecuencia.

Acciones sobre paquetes
"""""""""""""""""""""""
Es muy útil conocer cuáles son los ficheros que contiene un paquete::

   $ dpkg -L <paquete>

o a qué paquete pertenece un determinado fichero. Por ejemplo, si quisiéramos
saber qué paquete instala el comando :ref:`cp <cp>`::

   $ dpkg -S $(which cp)

.. warning:: Desde *Buster* esta consulta no funcionará en ocasiones, cuando el
   paquete haya instalado el ejecutable bajo :file:`/bin`. Esto es debido a que
   a partir de esta versión :file:`/bin` es un enlace simbólico a
   :file:`/usr/bin` y, en consecuencia, :ref:`which <which>` devolverá como ruta
   esta segunda localización. Es el caso del ejemplo sugerido.

.. note:: Obsérvese que se ha preferido incluir la ruta completa
   (:file:`/bin/cp`) frente al nombre solo (:ref:`cp <cp>`). Esto es debido a
   que la búsqueda funciona de tal forma que se devuelve un paquete como
   resultado cuando contiene un fichero cuya ruta completa incluye el argumento.
   Por tanto, si hubiéramos hecho :code:`dkpg -S cp` se habrían devuelto
   infinidad de resultados.  Hágase la prueba.

:command:`dpkg` puede también ser útil cuando instalamos a mano un paquete
``.deb`` descargado, por ejemplo, de una web que lo proporciona en este
formato::

   # dpkg -i paquete.deb

Cuando se obra así, muy comúnmente, tal paquete necesita de otros que no están
aún instalados en el sistema. Como de resolver dependencias se encarga
:command:`apt`, pero no :command:`dpkg`, el paquete quedará a medio instalar e
inusable. Para resolverlo y que automáticamente se instalen las dependencias
basta con hacer::

   # apt -f install

.. note:: En cualquier caso, es preferible la orden::

      # apt install ./paquete.deb

   que se encargará no sólo de instalar el paquete, sino de satisfacer sus
   dependencias.

Acciones sobre el sistema de paquetes
"""""""""""""""""""""""""""""""""""""
En ocasiones es conveniente saber cuáles son las dependencias de un paquete::

   $ apt depends pv
   pv
     Depende: libc6
     Sugiere: doc-base

Y en otras qué paquetes dependen de él::

   $ apt rdepends pv
   pv
   Reverse Depends:
     btrbk
     xvidenc
     h264enc
     divxenc
     vzctl

.. note:: Existen también :kbd:`apt-cache depends` y :kbd:`apt-cache rdepends`.

.. _apt-mark:
.. index:: apt-mark

Hay un aspecto de los paquetes interesante también que aún no se ha mencionado:
las *marcas*, que operan en dos aspectos distintos:

* Un paquete puede estar marcado como de instalación **manual** o **auto**\
  mática. Lo primero quiere decir que el paquete fue explícitamente instalado,
  mientras que lo segundo que se instaló para resolver una dependencia. Tiene
  importancia, porque en el segundo caso, si se eliminan los paquetes
  dependientes de él, alguno de los cuales provocó su instalación, el sistema
  nos sugerirá que lo desinstantemos (con :code:`apt autoremove`). Estas marcas
  las establece el gestor de paquetes sin nuestra intervención, pero nosotros
  podemos forzar que el paquete la cambie.

* Un paquete puede estar marcado como retenido (*hold*). Si es así, no se
  actualizará ni se eliminará jamás, a menos que revoquemos la marca (*unhold*).

Para manejar las marcas, disponemos del comando :program:`apt-mark`:

#. Marca como automáticamente el paquete *pv*::

   # apt-mark auto pv

#. Marca como instalado manualmente el paquete *pv*::

   # apt-mark manual pv

#. Muestra todos los paquetes instalados manualmente::

   $ apt-mark showmanual

#. Muestra todos los paquetes instalados automáticamente::

   $ apt-mark showauto

#. Marca el paquete *pv* como retenido::

   # apt-mark hold pv

#. Desmarca el paquete *pv* como retenido::

   # apt-mark unhold pv

#. Muestra los paquetes retenidos::

   # apt-mark showhold

Además, con :program:`apt-mark` podemos saber los paquetes instalados
(*showinstall*), eliminados (*showremove*) y purgados (*showpurge*).

Adición de repositorios extraoficiales
""""""""""""""""""""""""""""""""""""""
En ocasión nos encontramos con la necesidad de añadir repositorios
extraoficiales que empaquetan alguna utilidad interesante. Por ejemplo, este que
permite instalar un paquete para `Google Earth
<https://www.google.es/earth/index.html>`_::

   # cat >> /etc/apt/sources.list.d/google.list
   deb http://dl.google.com/linux/earth/deb/ stable main

El problema de ello es que los repositorios está firmados con :ref:`certificados
PGP <openpgp>` y al intentar actualizar las listas de paquetes es bastante
probable que nuestro :program:`apt` no disponga de la clave pública y no tenga
confianza. En consecuencia, se malogrará la descarga de la lista de paquetes
disponibles en el repositorio y nos quedaremos sin poder instalar los paquetes
que proporciona::

   # apt update
   [...] 
   W: Error de GPG: http://dl.google.com/linux/earth/deb stable Release: Las firmas siguientes
   no se pudieron verificar porque su clave pública no está disponible: NO_PUBKEY 1397BC53640DB551
   E: El repositorio «http://dl.google.com/linux/earth/deb stable Release» no está firmado.
   N: No se puede actualizar de un repositorio como este de forma segura y por tanto
   está deshabilitado por omisión.
   [...]

Para solucionarlo basta con importar la clave pública requerida a nuestro
anillo personal de claves y, hecho esto, exportarla al anillo de
:program:`apt`. Use el identificador que proporciona el propio :program:`apt`
(en el ejemplo, **1397BC53640DB551**)::

   # gpg --keyserver keys.gnupg.net --recv-key 1397BC53640DB551
   # gpg -a --export 1397BC53640DB551 | apt-key add -

.. seealso:: Consulte cómo funciona el :ref:`cifrado PGP <openpgp>`.

Mezclando ramas y arquitecturas
"""""""""""""""""""""""""""""""
Lo habitual es que nuestro sistema esté constituido por paquetes de una sola
arquitectura (muy pòsiblemente, *amd64*) y una única rama (*stable*, *testing*,
etc.). En ocasiones, sin embargo, necesitamos mezclar, lo cual es posible, pero
exige ser bastante cuidadoso.

Mezcla de arquitecturas
'''''''''''''''''''''''
Lo normal es disponer de un sistema con paquetes compilados para *amd64*, pero
puede darse el caso de que necesitemos instalar un paquete que no es *software*
libre y sólo está compilado para 32 *bits* (*i386*). Dado que son arquitecturas
compatibles (un ejecutable de 32 *bits* se puede ejecutar en una plataforma de
64 *bits*), no hay ningún problema con el programa; el problema real es que este
programa necesitara muy probablemente librerías de 32 *bits* que se encuentran
en otros paquetes; y, aunuqe dispongamos de las correspondientes de 64 *bits*,
no servirá.

Para conocer la arquitectura principal de nuestro sistema podemos ejecutar lo
siguiente::

   $ dpkg --print-architecture
   amd64

Así que si quisiéramos añadir la arquitectura *i386*::

   # dpkg --add-architecture I386

Para que el cambio tenga efecto, es necesario refrescar la lista de paquetes::

   # apt-get update

De lo cual resulta::

   $ dpkg --print-architecture
   amd64
   $ dpkg --print-foreign-architectures
   i386

Es decir, tenemos un sistema cuya arquitectura principal es *amd64*, y que tiene
como arquitectura adicional *i386*. Esto significa que cuando pidamos instalar o
eliminar un paquete, se presupondrá que nos referimos a la arquitectura *amd64*
y que sólo en caso de que especifiquemos instalaremos (o eliminaremos) un
paquete para arquitectura *i386*::

   # apt-get install pv:i386

Si en algún momento quiere eliminarse la arquitectura adicional, se deben borrar
todos los paquetes para tal arquitectura, antes de eliminarla::

   # apt-get purge '.*:i386'
   # dpkg --remove-architecture I386

.. _apt-mix:

Mezcla de ramas
'''''''''''''''
Otra posibilidad de mezcla es la de mezclar distintas ramas. Debe haber una
verdadera razón para ello y no dejarse a la ligera, porque puede traer
problemas.

Antes de embarcarse en ello, es necesario conocer precisamente cuál es el
criterio que sigue *Debian* para instalar unos paquetes frente a otros::

   $ man apt_preferences

Aquí expondremos de ello un pequeño resumen y algunas reglas útiles.

En principio, si en nuestro :file:`/etc/apt/sources.list` sólo incluímos
repositorios de una rama (que es lo habitual), obviamente, sólo se instalarán
repositorios de tal rama, puesto que los únicos paquetes de los que tendrá
conocimiento nuestro sistema serán sus paquetes. Ahora bien, ¿qué ocurre si
nuestro *sources.list* es el siguiente?:

.. literalinclude:: docs/sources-mixed.list
   :language: bash
   :linenos:

Como vemos, tenemos en el sistema la rama estable junto a sus actualizaciones,
los backports y, además, la distribución de pruebas. Un batiburrillo, que hay
que saber gestionar.

Para pronosticar qué ocurre, es necesario saber primero que todos los paquetes
llevan asociada una *prioridad*, que se calcula según las siguientes reglas:

.. table:: **Prioridades predefinidas**

   +-----------+-------------------------------------------------------------------------+
   | Prioridad | Paquetes                                                                |
   +===========+=========================================================================+
   | **1**     | Ramas\ [#]_ con la opción :kbd:`NotAutomatic: yes`\ [#]_, pero sin la   |
   |           | opción :kbd:`ButAutomaticUpgrades: yes`.                                |
   +-----------+-------------------------------------------------------------------------+
   | **100**   | Paquetes instalados.                                                    |
   |           +-------------------------------------------------------------------------+
   |           | Ramas\ [#]_ con las opciones :kbd:`NotAutomatic: yes` y                 |
   |           | :kbd:`ButAutomaticUpgrades: yes`.                                       |
   +-----------+-------------------------------------------------------------------------+
   | **500**   | Ramas que no sean las anteriores ni la rama objetivo. Lo habitual es    |
   |           | la rama objetivo no esté definida.                                      |
   +-----------+-------------------------------------------------------------------------+
   | **990**   | Rama objetivo.                                                          |
   +-----------+-------------------------------------------------------------------------+

Y las reglas para decidir si un paquete se instala o no son estas:

#. Se instala el paquete con mayor prioridad, aunque para que se instale un
   paquete de una versión más reciente a la instalada, se exige además que
   tenga una prioridad de al menos *1000*.

#. Si coinciden las prioridades, se instala el paquete más reciente.

Sabido esto, podemos volver a la nuestro *sources.list* de ejemplo. Resulta que
en él todas las ramas tienen prioridad *500*, excepto la de *backports* que
tiene prioridad *100*. Consecuentemente, cada vez que intentemos instalar un
paquete, se evitará la rama *backports* y se instalará aquel más reciente, que
se encontrarán normalmente en las ramas de actualización y seguridad.

¿Cómo podemos entonces instalar un paquete de *backports*? Muy sencillo: basta
con hacer tal rama, la rama objetivo para esa instalación. Eso se hace añadiendo
la opción ``-t`` a la orden::

   # apt-get install -t jessie-backports nginx 

.. warning:: Este comando no implica sólo instalar el paquete *nginx* de
   *backports*, sino él y todas sus dependencias. Si entre sus dependencias hay
   librerías, incluso las más básicas, entonces se instalarán (o actualizarán)
   también. Por lo general, *backports* está pensada para que haya versiones
   más recientes de software, pero que estas versiones se hayan
   compilado con las mismas librerías básicas que usa la estable. Por tanto, al
   realizar esta operación, sólo actualizaremos los paquetes más intimamente
   ligados con la aplicación que queremos actualizar. Pero esto no es aplicable
   a la rama *testing* ni a la *inestable*.

El fichero, tal y como está, guarda bastante equilibrio: instalaremos paquetes
de la estable, convenientemente actualizada con paquetes de seguridad, y sólo si
explícitamente pedimos la actualización de un paquete que haya en *backports* se
llevará a cabo. Ahora bien, ¿qué ocurre si descomentamos la línea referente a la
rama en pruebas? Que el equilibrió se romperá: los paquetes de la rama en
pruebas también tienen prioridad *500*, pero en su mayoría serán versiones más
recientes y que, además, están en constante actualización. La consecuencia será
que si actualizamos todo el sistema, pasaremos de tener la rama estable a
tener la rama en pruebas y que todos los paquetes que instalemos serán de esta
última versión. Es decir, que el resto de líneas de *sources.list* sobrarán por
completo.

Para tener mayor control, *apt* permite alterar las prioridades predefinidas.
Esto se hace modificando (o creando el fichero :file:`/etc/apt/preferences`\
[#]_), dentro del cual se incluyen estructuras del siguiente tipo separadas por
una línea en blanco::

   Package: <expr_paquete>
   Pin: <selector>
   Pin-Priority: <N>

es decir, en cada estructura definimos una expresión que escoge los paquetes
para los que se hace la definición, un selector que indica para qué ejemplares
del paquete (versión, rama a la que pertenece, etc.) y, por último, la prioridad
que le pensamos otorgar.

Línea **Package**
   Para *expresar el paquete* hay varias posibilidades. Las dos más simples son
   indicar el nombre exacto del paquete o escribir un :kbd:`*`, que (como es
   lo habitual) significa cualquier paquete. Las otras dos son:

   * Espresiones *glob*, esto es, las expresiones que se usan en :program:`bash`.
     Por ejemplo, :kbd:`python3-*` haría referencia a todos los paquetes que
     comienza por ``python3-``.

   * :ref:`Expresiones regulares <regex>` que deben delimitarse entre barras.
     POr ejemplo, :kbd:`/py/` refiere todos los paquetes que contengan la
     subcadena ``py``.

Línea **Pin**
   La *selección* del ejemplar del paquete la determina el contenido del campo
   *Pin*. Hay diferentes criterios para realizar esta selección:

   * La versión del propio paquete::

      Pin: version 1.10*

     En este caso, no se especifica una versión concreta exacta, sino cualquier
     version que empiece por *1.10*.

   * El origen del paquete, esto es, de dónde se descarga::

      Pin: origin "ftp.cica.es"

     Si se usa una cadena vacía (:kbd:`origin ""`), el paquete se descarga de un
     sitio local.

   * Las propiedades de la distribución a la que pertenece el paquete. Son
     diversas y se pueden consultar el los ficheros ``*Release``, citados
     en una de las notas al pie. Se enumeran aquí algunas propiedades,
     expresando el nombre del campo con que se enuncian en tal fichero:

     * La rama con su nombre genérico *stable*, *testing*, etc. (*Suite*)::

        Pin: release a=testing

     * La rama con su nombre clave (*Codename*)::

        Pin: release n=stretch

     * La versión de la distribución (*Version*)::

        Pin: release v=8

       Nótese que sólo las versiones estables tienen asignada una versión, por lo que
       sólo podremos referir la versión estable en curso o anteriores.

     * El componente::

        Pin: release c=main

     * La distribución (*Debian*, *ubuntu*) relacionada con dos etiquetas
       *Label*::
      
        Pin: release l=Ubuntu

       y *Origin*::

        Pin: release o=Ubuntu

Línea **Pin-Priority**:
   Símplemente hay que indicar la prioridad numérica. Para fijar una adecuada,
   conviene tener en cuenta que, de acuerdo con las prioridades predeterminadas,
   el comportamiento de un paquete ante la instalación o la actualización será
   el siguiente (*P* es su prioridad):

   **P>=1000**:
      El paquete se instala en cualquier caso, incluso aunque haya una versión
      instalada más reciente.

   **990<=P<1000**:
      El paquete se instala por encima incluso de los provenientes de la rama
      objetivo. No lo hará unicamente si hay una versión más reciente instalada.

   **500<=P<990**:
      El paquete se instala a menos que la versión instalada sea más reciente o
      haya un ejemplar disponible en la rama objetivo.

   **100<=P<500**:
      Sólo se instala el paquete si no hay otro ejemplar disponible en alguna rama
      y es más reciente que el instalado.

   **0<P<100**:
      Sólo se instala si no hay ninguna versión disponible ni instalada.

   **P<0**:
      El paquete no se instalará jamás.

Teniendo en cuenta todo esto, una posibilidad para conciliar tener a la vez como
fuente *testing* y *stable* sería esta::

   Package: *
   Pin: release a=testing
   Pin-Priority: 99

De este modo, al hacer::

   # apt-get install paquete

Sólo se instalaría un paquete de la rama *en pruebas* si no estuviera disponible
en la rama estable. Eso sí, si necesitara versiones de librerías posteriores a
las que se encuentran en  la estable, no se llegaría a instalar, porque no se
podría satisfacer sus dependencias. Si en este caso hiciéramos::

   # apt-get install -t testing paquete

Esto sí se instalaría a costa de instalar también versiones en pruebas de
ciertas librerías. Esto, sin embargo, no es recomendable, porque pueda dar pie
a problemas. En este caso, sería más recomendable descargar el paquete fuente de
*testing* e intentar compilarlo con las librerías de la estable.

.. _apt-show-versions:
.. index:: apt-show-versions

Por último, cuando  se mezclan distintas ramas es conveniente saber para un
paquete qué versión proporciona cada una de ellas. Para ello es muy útil el
comando :program:`apt-show-versions` disponible en el paquete del mismo nombre
(no viene instalado por defecto)::

   $ apt-show-versions -a -p pv
   pv:amd64 1.5.7-2 install ok installed
   pv:amd64 1.5.7-2 stable  ftp.cica.es
   No stable-updates version
   pv:amd64 1.6.0-1 testing ftp.cica.es
   pv:amd64/stable 1.5.7-2 uptodate

Se ha ejecutado la orden en un sistema que se provee de la estable y *testing* y
con las preferencias ajustadas tal y como se ha indicado (los paquetes de
*testing* tiene prioridad *99*). En estas condiciones la orden nos informa de
que tenemos intalada la versión *1.5.7*, que es justamente, la de la versión
estable; que hay otra versión más moderna (*1.6.0*) en *testing*, pero que
estamos actualizados (*uptodate*). Y lo estamos justamente por el hecho de haber
definido la prioridad.

Compilación de paquetes
-----------------------

Aunque no es algo habitual y además resulta engorroso de mantener\ [#]_, es
bastante sencillo compilar una código fuente para obtener los paquetes
compilados. Lo primero es añadir a :file:`/etc/apt/sources.list` la línea que
nos permite acceder a los paquetes de las fuentes. Por ejemplo::

   deb-src http://ftp.cica.es/Debian/ stretch main

Y, hecho esto, se deberá actualizar la lista de paquetes::

   # apt update

y añadir las herramientas para compilar::

   # apt install build-essential

Con todo esto la compilación es muy sencilla. Requiere descargar los paquetes
que exige la compìlación del que pretendemos compilar\ [#]_ (supongamos que *pv*)::

   # apt-get build-dep pv

y descargar el paquete con el código fuente::

   # cd /usr/src
   # apt-get source pv

E ir al directorio donde se almacena y compilar::

   # cd pv-1.6.0
   # dpkg-buildpackage -us -uc

Si la compilación acaba sin problemas, el paquete ``.deb`` estará en el
directorio superior y bastará con instalarlo::

   # cd ..
   # dpkg -i pv_1.6.0-1_amd64.deb

.. note:: Puede ocurrir que la compilación del paquete genere varios paquetes
   compilados.

.. note:: El directorio :file:`/usr/src` quedará lleno de ficheros relacionados
   con la compilación y el código fuente que pueden borrarse cuando acaba el
   proceso.

.. _dpkg-repack:
.. index:: dpkg-repack

No relacionado con la compilación, pero sí con la obtención de un paquete
``.deb`` es el caso en que queremos reconstruir el paquete a partir de los
ficheros que tenemos instalados en el disco duro, bien porque no encontramos
cómo hacernos con el ``.deb`` original, bien porque hemos cambiado sus ficheros
de configuración y queremos empaquetarlo en el estado en el que está en nuestro
sistema para trasladarlo a otro. En ese caso es muy útil la orden
:program:`dpkg-repack` que hay que instalar primero::

   # apt install dpkg-repack
   # dpkg-repack pv

Destripando paquetes
--------------------

Los ficheros ``.deb`` son empaquetados comprimidos de ficheros que, además de
poder instalarse, pudeden descomprimirse y desempaquetarse a fin de poder
acceder a su interior. Para lograr esto, es conveniente instalar

.. _fakeroot:
.. index:: fakeroot

:program:`fakeroot`
   Simula que el usuario es el administrador dentro de un entorno en el que se
   manipulan ficheros.

Para acceder al contenido de un ``.deb``, lo primero es conseguir uno.
Consigámoslo, descargando el fichero con :program:`apt-get`, pero sin llegar a
instalarlo::

   # apt install -d pv

La orden habrá almacenado el fichero descargado en
:file:`/var/cache/apt/archives`. Podemos analizar el contenido de este fichero
haciendo uso del comando:`ar`::

   $ ar t /var/cache/apt/archives/pv_*.deb
   Debian-binary
   control.tar.gz
   data.tar.xz

Contiene tres ficheros, el primero guarda simplemente la versión del formato
``.deb`` y los otros dos son archivos empaquetados y comprimidos, uno
(:file:`data.tar.xz`) guarda los ficheros en sí que constituyen el paquete  y el
otro (:file:`control.tar.gz`) los ficheros de metainformación, es decir, los
ficheros que sirven para identificar cuál es el paquete, qué ficheros debe
contener o qué acciones hay que realizar cuando se instala o se elimina el
paquete del sistema. No entraremos a describir cuáles son estos ficheros
control, pero puede leerse información al respecto `aquí
<https://Debian-handbook.info/browse/stable/sect.package-meta-information.html>`_). 

No obstante, no segujiremos por este camino, puesto que el propio
:command:`dpkg` tiene las herramientas necesarias para desempaquetar el fichero::

   $ cd /tmp
   $ mkdir CACA
   $ dpkg -x /var/cache/apt/archives/pv_*.deb CACA
   $ dpkg -e /var/cache/apt/archives/pv_*.deb CACA/DEBIAN

Usamos como directorio para almacenar el contenido :file:`/tmp/CACA`. La primera
operación descomprime los ficheros en sí dentro de tal directorio, de manera que
estos forman la misma estructura que tienen cuando se instalan en el sistema,
mientras que la segunda almacena dentro de un subdirectorio llamado
:file:`DEBIAN` los ficheros de metainformación. En este punto podríamos realizar
modificaciones de tanto de los ficheros de datos como de los de control (¡ojo!
que el fichero de control :file:`md5sums` almacena las comprobaciones de la
integridad de los ficheros).

Si en algún momnento quisiéramos reconstruir el fichero, podríamos hacer lo
siguiente::

   $ cd /tmp/CACA
   $ dpkg-deb -b . ../pv_1.5.7-2_amd64.deb

.. note::
   En realidad, conociendo cuáles son los ficheros de control y cómo se
   escriben, es posible crear nuestros propios ficheros ``.deb``. Basta con
   reproducir la estructura que hemos visto al descomprimir el fichero y
   empaquetar todo con :program:`dpkg-deb`.

.. _ej-softw:

.. include:: /99.ejercicios/080-software.rst

.. _paquetes-flatpak:

Paquetería universal (Flatpak_)
===============================
Los paquetes de Flatpak_ sólo deben usarse si dentro de los paqutes de la
distribución no hay solución posible para el *software* que necesitamos. En ese
caso, echar mano de estos paquetes universales es una buena solución, pero
habrá primero que preparar el sistema instalado::

   # apt install flatpak

y añadiendo el repositorio oficial de paquetes::

   # flatpak remote-add --if-not-exists flathub https://flathub.org/repo/flathub.flatpakrepo

Hecho esto, ya estaremos en disposición de instalar paquetes directamente del
repositorio que hemos denominado "flathub" (el repositorio oficial por otra
parte). Ahora podemos buscar *software* de todos los repositorios que tengamos definidos::

   # flatpak search firefox

e instalarlo::

   # flatpak install flathub org.mozilla.firefox

Es probable que la instalación de esta aplicación sea enormemente pesada, ya
que, si es la primera de Flatpak_ que instalamos, no habrá ninguna dependencia
satisfecha; y será necesario descargarlas todas.

Para ejecutar la aplicación deberemos usar también Flatpak_::

   $ flatpak run org.mozilla.firefox

Las aplicaciones puede ser facilmente listadas con::

   $ flatpak list --app

actualizadas::

   $ flatpak update

o borradas::

   $ flatpak uninstall org.mozilla.firefox

.. note:: Esta paquetería permite la instalación de paquetes exclusivamente para
   un usuario añadiendo la opción :kbd:`--user`.

.. seealso:: Para más información, consulte `Usando Flatpak
   <https://docs.flatpak.org/en/latest/using-flatpak.html>`_

.. rubric:: Notas al pie

.. [#] Existen otros farmatos de ficheros y, en general, cada distribución
   *madre*  tiene su propio formato: *Red Hat* (y *SuSE*) usa ficheros ``.rpm``,
   *Archinux*, ficheros ``.pkg.tar.xz``; *Gentoo*, paquetes ``ebuild``; y
   *Slackware*, ``.tgz``.

.. [#] En realidad, la tradición se debe a que el segundo líder del proyecto
   *Debian*, Bruce Perens, participó en la realización de la película *Toy Story
   2* e inició la costumbre a partir de la versión 1.1, a la que llamó *Buzz*.

.. [#] En la revisión del epígrafe, la versión estable es la **10**, *Buster*; y
   las posteriores se llamarán *Bullseye* (**11**), *Bookworm* (**12**) y
   *Trixie* (**13**).

.. [#] La diferencia entre tener los nombres clave o los nombres de la rama está
   exclusivamente en el momento en que se produzca un cambio de versión. Si, por
   ejemplo, colocamos hoy el nombre de la actual distribución en pruebas
   (*stretch*), tendremos instalada en nuestra máquina la distribuciín en pruebas,
   pero después de que esta se congele y pase a ser la distribución estable,
   pasaremos a tener instalada la estable. En cambio, si lo que colocamos es la
   palabra *testing*, al abrirse de nuevo la distribución en pruebas a las
   actualizaciones de *sid* nuestro sistema se actualizará y continuaremos, como
   en un principio, teniendo instalada la distribución en pruebas.

.. [#] En la distribución estable, al ser las actualizaciones sólo de seguridad
   o de corrección de errores, no se producen casos de paquetes retenidos.

.. [#] O sea, paquetes que no se encuentren en los repositorios, sino que los
   hayamos descargado manualmente de la web. Por ejemplo, el programa
   :program:`AutoFirma` que ofrece para `descarga el Gobierno de España
   <https://firmaelectronica.gob.es/Home/Descargas.html>`_.

.. [#] Acuérdese de proteger el patrón para no correr el riesgo de que lo
   interpretre el propio :program:` bash`.

.. [#] Es el caso de la rama *experimental*.

.. [#] Para saber cuáles son las opciones que tiene fijadas una rama se puede ir
   al directorio :file:`/var/lib/apt/lists` dentro del cual encontraremos los
   ficheros descargados por la orden :code:`apt-get update`. Cada línea del
   *sources.list* genera varios ficheros uno de los cuales tiene por nombre
   ``*Release``. Dentro se podrá ver cuáles son las opciones de la rama.

.. [#] Es el caso de la rama *backports*.

.. [#] Como es habitual, también existe un directorio llamado
   :file:`/etc/apt/preferences.d` en el que podemos crear diferentes ficheros
   para hacer más modular la configuración.

.. [#] Engorroso, porque para que una nueva versión del paquete no machacara
   nuestra compilación, deberíamos marcar como *hold* el paquete y luego ir
   periódicamente repitiendo la compilación según salgan nuevas fuentes. Tiene
   algo más de sentido, si compilamos un paquete de una rama con versiones más
   modernas (*testing*, si tenemos *stable*; o *sid*, si *testing*), porque
   podremos compilar el paquete nuevo y, después, esperar sin miedo a que
   nuestra rama alcance esa versión. Cuando la supere, se machacará nuestra
   compilación, pero con una versión más moderna.

.. [#] Los paquetes que se instalan mediante este procedimiento se marcan como
   instalados manualmente, cuando es más conveniente que se marcaran como
   instalados automáticamente para que después de la compilación, se borraran,
   puesto que no se necesitan más. Para solucionarlo, se puede anterar la
   confiruación de *apt* del siguiente modo::

      # echo 'APT::Get::Build-Dep-Automatic "true";' > /etc/apt/apt,conf.d/99buildep

.. |APT| replace:: :abbr:`APT (Advanced Packaging Tool)`
.. |CLI| replace:: :abbr:`CLI (Command Line Interface)`
.. |KDE| replace:: :abbr:`KDE (K[ool] Desktop Environment)`
.. |API| replace:: :abbr:`API (Application Programming Interface)`

.. _Flatpak: https://flatpak.org/
.. _Snap: https://snapcraft.io/
.. _AppImage: https://appimage.org/
.. _freedesktop.org: https://www.freedesktop.org/
.. _AppStream: https://www.freedesktop.org/wiki/Distributions/AppStream/
.. _PackageKit: https://en.wikipedia.org/wiki/PackageKit
.. _Gnome Software: https://es.wikipedia.org/wiki/GNOME_Software
.. _Discover: https://apps.kde.org/es/discover
.. _Gimp: https://www.gimp.org/
