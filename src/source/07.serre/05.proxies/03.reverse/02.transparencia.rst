.. _proxy-transparente:

*************
Transparencia
*************
En ocasiones, por ejemplo cuando se han habilitido mecanismos para restringir el
acceso según el origen o se desea limitar el número de accesos, es imprescindible
para los servidores conocer cuál es el cliente que lleva a cabo la petición. Sin
embargo, un *proxy* inverso provoca que la peticion original del cliente se
capture y se replique dirigiéndola al servidor y que, por tanto, sea en realidad
el *proxy* el que está llevando a cabo la petición. En consecuencia, el servidor
final sólo recibirá peticiones originadas por una única máquina (el *proxy*) y
será incapaz de tomar decisiones en base al origen de la petición.

Para paliar este problema existen dos soluciones:

- Que el protocolo de capa de aplicación articule un mecanismo para informar al
  servidor final de que la petición se hacen a través de un *proxy* y de cuál
  es el cliente en realidad. Tal es el caso en |HTTP| de la cabecera
  :ref:`X-Forwarder-For <xforwardedfor>`, gracias a la cual el servidor *web*
  será capaz de saber cuál es en realidad el cliente, aunque la |IP| de origen
  de los paquetes sea la del *proxy*, El tratamiento de esta cabecera en
  :ref:`nginx <n-ginx>`, se lleva a cabo en :ref:`su epígrafe correspondiente
  <nginx-tras-proxy>`.

- La que nos ocupa que es hacer el *proxy* realmente **transparente**, esto es,
  que en los paquetes de la petición que replica la |IP| de origen sea la del
  cliente y no la suya.

.. _proxy-transparente-req:

Requisitos
**********
Para hacer un transparente un *proxy* es necesario:

+ Una configuración extra de la máquina en la que se ejecuta de forma
  transparente el *proxy*.

+ Que las respuestas del servidor, que obviamente tendrán como destino el
  cliente, puedan ser interceptadas por el *proxy* para que sea él quien las
  despache hacia el cliente original. Así pues, el servidor final no puede estar
  dispuesto en cualquier lugar, sino en uno cuyo camino de regreso pase por el
  proxy.

.. todo:: Imagen explicativa.

.. _proxy-transparente-sol-gen:

Solución general
****************
Desde la versión 2.2 del núcleo, *Linux* es capaz de comportarse como un *proxy*
transparente, para lo cual se requiere:

#. Que la aplicación *proxy* esté **preparada para ello** y utilice un *socket*
   transparente. Este requisito debe cumplirlo la aplicación, por lo que como
   administradores sólo podemos comprobar si es apta o no. Ahora bien, poder
   crear un *socket* transparente se le exige a la aplicación la capacidad (véase
   :manpage:`capabilities(7)`) ``CAP_NET_ADMIN``. Esto puede lograrse:

   - Ejecutando la aplicación como *root*.
   - Conceder la capacidad al ejecutable (p.e. `vea cómo hacerlo
     <https://github.com/yrutschle/sslh/blob/master/doc/config.md>`_).

   Cómo se configure la aplicación para que pueda actuar transparentemente es
   particular de cada una: el siguiente epígrafe estará dedicado a la
   configuración de algunas.

#. Como el *proxy* debe interceptar también el tráfico de vuelta procedente del
   servidor final, **debe encontrarse en el camino de regreso**, ya que al no
   cambiar el *proxy* la |IP| del cliente original, el servidor final intentará
   devolver la respuesta al cliente.

   Para cumplir con este requisito debemos escoger el lugar donde situar el
   *proxy*.

#. Finalmente, al pasar los paquetes de respuesta por el *proxy* éste debe
   procesarlos, aunque la |IP| de destino sea la del cliente. Para ello debe
   **manipularse el encaminamiento**. Este es el único requisito que sí podemos
   configurar de forma general y al que dedicaremos el resto del epígrafe.

   Para que los paquetes de respuesta dirigidos al cliente pasen por la aplicación
   de *proxy* debe lograrse que éstos se encaminen a través de la interfaz de
   *loopback*. Para ello:

   a. Se indica al núcleo que haga posible el encaminamiento a través de la
      interfaz de *loopback*\ [#]_::

         # sysctl -w net.ipv4.conf.default.route_localnet=1
         # sysctl -w net.ipv4.conf.all.route_localnet=1

   #. Se alteran las reglas de encaminamiento para que el tráfico marcado (con, por
      ejemplo, *0xff*) vaya a la interfaz de *loopback*::

         # ip rule add fwmark 0xff lookup 100
         # ip route add local 0.0.0.0/0 dev lo table 100

   #. Hacemos que el tráfico que debe volver a pasar por el *proxy* esté marcado
      con la marca anterior (la *0xff*), para lo cual podemos utilizar el
      cortafuegos. Cómo deba utilizarse el cortafuegos depende de si donde se
      encuentre el servidor final:

      a. Cuando está ien la misma máquina que el *proxy*\ [#]_, podemos usar la
         estrategia de que el éste redirija los paquetes a una dirección local
         particular (p.e. la *127.1.1.1*, en la que por supusto debe responder tal
         servidor).  De esta forma, lograremos marcar sólo los paquetes dirigidos
         al servidor que proceden del *proxy*::

            # iptables -t raw -A PREROUTING ! -i lo -d 127.0.0.0/8 -j DROP
            # iptables -t mangle -A POSTROUTING ! -o lo -s 127.0.0.0/8 -j DROP

            # iptables -t nat -A OUTPUT -d 127.1.1.1 -j CONNMARK --set-mark 0xff
            # iptables -t mangle -A OUTPUT -m connmark --mark 0xff -j CONNMARK --restore-mark

      #. Cuando está en una máquina distinta, la estrategia es marcar en el *proxy*
         los paquetes entrantes (que son los de vuelta) cuyo destino es un proxy
         transparente::

            # iptables -t mangle -A PREROUTING -m socket --transparent -j MARK --set-mark 0xff

         .. warning:: Por alguna razón en mi sistema, :program:`nftables` es
            incapaz de traducir la sentencia anterior, pero existe equivalente::

               # nft add table mangle
               # nft add chain mangle PREROUTING "{ type filter hook prerouting priority -150; }"
               # nft add rule mangle PREROUTING socket transparent 1 meta mark set 0xff

.. https://github.com/ahupowerdns/tproxydoc/blob/master/tproxy.md
.. https://github.com/yrutschle/sslh/blob/master/doc/config.md
.. https://www.kernel.org/doc/Documentation/networking/tproxy.txt

Soluciones particulares
***********************
La intención es aplicar la solución antes descrita para que actúen como
*proxies* transparentes aplicaciones utilizados en este manual: :ref:`stunnel
<stunnel>`, :ref:`sslh <sslh>`, :ref:`haproxy <haproxy>` y :ref:`nginx
<n-ginx>`. Ahora bien, para comprobar si, efectivamente, el *proxy* actúa de
modo transparente, es necesario que el servidor final nos muestre cuál es la
|IP| del cliente. Un modo muy sencillo es usar como servidor final
:program:`nginx` con esta configuración:

.. code-block:: nginx

   server {
      listen 80;  // Puerto y dirección de escucha pueden cambiar según el caso.
       
      location / {
         return 200 "Saludos desde '$hostname'. Te conectas desde $remote_addr:$remote_port.\n";
      }
   }

y que desde el cliente se haga la consulta\ [#]_::

   # wget --no-check-certificate -qO- https://destino
   Saludos desde 'servidor'. Te conectas desde 192.168.0.20:43123.

donde el destino será el proxy (probablemente) y el protocolo dependerá de qué
papel juegue el *proxy*. Si el proxy inverso es explícito veremos la |IP| del *proxy*,
pero si es transparente --como pretendemos--, aparecerá la |IP| del propio cliente.

.. _stunnel-transparente:

stunnel
=======
:ref:`stunnel <stunnel>` permite encapsular con |SSL| cualquier tipo de tráfico;
y, si queremos que el servidor final conozca la dirección del cliente original y
no la |IP| de la parte servidor de :program:`stunnel` debemos hacer que éste se
comporte de forma transparente. 

Podemos poner en práctica la :ref:`solución general
<proxy-transparente-sol-gen>`, a la cual sólo le falta desarrollar la primera
parte, esto es, la relativa a la propia aplicación *proxy*. Es configuración
(partido del :ref:`ejemplo ilustrativo en que se expuso qué es stunnel <stunnel>`),
puede ser esta, si el servidor final se encuentra en la misma máquina:

.. code-block:: ini
   :emphasize-lines: 2, 5

   ; La IP de la interfaz física del servidor es 192.168.0.14

   [netcat-ssl]
   transparent = source
   cert = /etc/stunnel/stunnel.pem
   accept = 192.168.0.14:443
   connect = 127.1.1.1:80

donde las novedades son la particular dirección local del servidor final
(coherente con la que se cita en la :ref:`solución general para proxy
transparente <proxy-transparente-sol-gen>`), y la línea en que indicamos a
:program:`stunnel` que mantenga la |IP| original del cliente.

En caso de que el servidor final estuviera en una máquina distinta, la última
línea deberíamos cambiarla por algo así:

.. code-block:: ini

   ; El servicio final se encuentra en otra máquina (192.168.255.10)
   connect = 192.168.255.100:80

.. warning:: Tenga presente que, además de toda la configuración de cortafuegos
   y reglas de encaminamiento, debemos asegurarnos de que :program:`stunnel`
   tiene capacidad para crear el *socket* transparente y que la vuelta de los
   paquetes pasará por la máquina con :program:`stunnel`.

.. _sslh-transparente:

SSLH
====
A la :ref:`solución general <proxy-transparente-sol-gen>`, basta añadirle la
configuración particular del :program:`sslh`, que podría ser la siguiente en
:file:`/etc/default/sslh`:

.. code-block:: bash 

   RUN=yes  # SSLH corre permanentemente, no a través de inetd.

   [...]

   DAEMON_OPTS="--transparent --user sslh --listen 172.22.0.2:443 \
                --ssh 127.1.1.1:22 --ssl 127.1.1.1:443 --openvpn 127.1.1.1:1194 \
                --pidfile /var/run/sslh/sslh.pid"

donde se indica que se quiere hacer transparente el servicio, y se redirige el
tráfico a una interfaz local particular. 

.. note:: En este caso, no se tiene que ejecutar como administrador porque
   *Debian* compilar el programa con la opción ``USELIBCAP=1``.

.. _nginx-transparente:

nginx
=====
La configuración para hacer que :program:`nginx` se comporte como proxy
*transparente* pasa por ejecutarlo como administrador:

.. code-block:: nginx

   # Esto es nginx.conf

   user root

   [...]

   stream {
      server {
         listen 80;

         proxy_bind $remote_addr transparent;
         proxy_pass 127.1.1.1;
      }
   }

que supone que el servidor final está en la propia máquina. Esta configuración
de proxy |TCP|, a menos que fuera con |SSL| y se usara |SNI| para discriminar
los tráficos, resulta un poco inútil. La transparencia también puede practicarse
en un *proxy* |HTTP|:

.. code-block:: nginx

   upstream backend {
      server 192.168.0.100;
      server 192.168.0.200;
   }

   server {
      listen 80;

      location / {
         proxy_bind $remote_addr transparent;
         proxy_pass http://$backend$uri;
      }
   }

.. seealso:: Échele un ojo a una `entrada sobre el asunto
   <https://www.nginx.com/blog/ip-transparency-direct-server-return-nginx-plus-transparent-proxy/>`
   en el blog oficial.

.. _haproxy-transparent:

haproxy
=======
A la :ref:`solución general <proxy-transparente-sol-gen>`, basta añadirle estos
pequeños cambios en la configuración:

* Comentar en la sección *global* los líneas que impiden que
  :program:`haproxy` se ejecute con permisos de administrador:

  .. code-block:: bash

     #user haproxy
     #group haproxy

* Añadir a todos los servidores con los que se quiere actuar como proxy
  transparente una directiva más para que se envíen los paquetes utilizando
  la |IP| del cliente como origen. Por ejemplo:

  .. code-block:: bash
     :emphasize-lines: 3

     backend ssh
        mode tcp
        source 0.0.0.0 usesrc clientip
        server ssh 127.1.1.1:22

  .. note:: Si los servidores están en la misma máquina recuerde hacer
     referencia a ellos usando una |IP| local no habitual como la *127.1.1.1*
     sugerida en la solución general.

  .. note:: En el caso del servidor web, como se conserva la |IP| del cliente,
     no es necesario alterar la cabecera `X-Forwarded-For`, pero sí la referente
     al protocolo, que cambia de |HTTP|\ s a |HTTP|:

     .. code-block:: bash
        :emphasize-lines: 3, 4

        backend http
           mode http
           #option forwardfor
           source 0.0.0.0 usesrc clientip
           reqadd X-Forwarded-Proto:\ https
           server nginx 127.1.1.1:80


.. rubric:: Notas al pie

.. [#] Si queremos hacer permanente el cambio, podemos incluir la definición de
   los parámentros en :file:`/etC/sysctl.conf` como ya se ha hecho en otros
   epígrafes de este manual.

.. [#] Si *stunnel* no se ejecuta como administrador, sino con su propio usuario,
   entonces podemos identificar el tráfico, no por el destino, sino por el usuario
   que lo ejecuta::

      # iptables -t nat -A OUTPUT -m owner --uid-owner stunnel -j CONNMARK --set-mark 0xff

.. [#] Se añade :kbd:`--no-check-certificate` para evitar problemas si en
   nuestras pruebas usamos certificados autofirmados.

.. [#] Esta configuración requiere que el núcleo se haya compilado con el módulo
   ``NETFILTER_XT_MATCH_SOCKET``, pero esto es así en las *debian* modernas::

      # grep -i match_socket /boot/config-`uname -r`
      CONFIG_NETFILTER_XT_MATCH_SOCKET=m

.. |SSL| replace:: :abbr:`SSL (Secure Socket Layer)`
.. |SNI| replace:: :abbr:`SNI (Server Name Indication)`
.. |TCP| replace:: :abbr:`TCP (Transmission Control Protocol)`
