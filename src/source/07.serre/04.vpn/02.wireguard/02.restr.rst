Redes restringidas
******************
Cuando nuestro *guerrero de la carretera* se encuentra dentro de una red
restringida que no controlamos nos toparemos muy probablemente con el problema
de que seremos incapaces de acceder al puerto |UDP| en que hayamos dejado
escuchando el servidor (el *1194* en nuestra propuesta).

En estas redes restringidas, lo habitual es que sólo podemos:

- Hacer consultas |DNS| (*53/UDP*).
- Navegar (puertos *80/TCP* y *443/TCP*).

Podríamos dejar escuchando el servicio en el puerto *53/UDP*, pero es común que
en estas redes restringidas las consultas |DNS| se limiten a algún servidor
interno, con lo cual es una solución que no será efectiva en todas las redes.

La solución general es usar los puertos para tráfico web, pero nos topamos con
el problema de que por motivos de rendimiento :program:`wireguard` sólo se ha
implementado para |UDP|. Una solución para solucionar este inconveniente es
tunelizador el trafico mediante `Websockets <https://v0ctor.me/websocket>`. Como
forma parte del estándar |HTML|\ 5, no deberiamos tener problemas con el proxy
web, aun usando |HTTP| y no |HTTP|\ s. Además, no recifrar con |SSL| aminorará
la pérdida de rendimiento de tener que tunelizar :program:`wireguard`.

:program:`wstunnel`
===================
Para lograr nuestro objetivo podemos usar `wstunnel
<https://github.com/erebe/wstunnel>`_, el cual es capaz de tunelizar mediante
*Websockets* tráfico |UDP|. No existe paquete para *Debian*\ [#]_, pero podemos
descargar el ejecutable del propio repositio de *Github*. Su uso es bastante
sencillo. Descargamos en dos máquinas el ejecutable y:

* En la máquina servidor lo ejecutamos de esta forma::

   # /usr/local/bin/wstunnel -v --server ws://0.0.0.0 --restrictTo 127.0.0.1:1194

  lo cual supone que la aplicación escuche en el puerto *80* los datos
  que se pretenden tunelizar. Además, sólo se aceptará tráfico que el cliente
  indique que va dirigido al puerto *1194* de la interfaz de loopback.

* En la máquina cliente, rematamos el otro extremo del túnel con::

   # /usr/local/bin/wstunnel -v --udp --udpTimeoutSec -1 -L 127.0.0.1:12345:127.0.0.1:1194 ws://203.0.113.1

  que conecta con el puerto 80 del servidor (hemos supuesto que *203.0.113.1* es
  su dirección |IP|) y envía los datos que recibe por el puerto *12345/UDP*
  de la interfaz de *loopback* al puerto *1194/UDP* de la interfaz de *loopback*
  del servidor (esto último coincide con lo que se indicó con
  :kbd:`--restrictTo` en el servidor).

Con ello ya tendremos establecido el tunel dentro del cual circula el tráfico
|UDP|. Si queremos probarlo, podemos hacer::

   servidor$ netcat -u -l -p 1194

y en el cliente::

   cliente$ netcat -u localhost 12345

Ambos :ref:`netcat <netcat>` deberían comunicarse a través del *websocket*.

.. note:: Para que el tráfico hubiera sido cifrado (y por el puerto 443) habría
   bastado con usar :kbd:`wss` en vez de :kbd:`ws`.

Encapsulando :program:`wireguard`
=================================
Podemos aplicar lo expuesto bajo el epígrafe anterior al caso *sede-equipo
móvil* en el que el equipo móvil se halla dentro de una red restringida.

.. rubric:: Servidor

La configuración de :program:`wireguard` es exactamente la misma pero con el
añadido de que junto a la interfaz debemos arrancar o parar la parte de servidor
de :program:`wstunnel` que redirige el tráfico recibido hacia el propio
:program:`wireguard`:

.. code-block:: ini

   [Interface]
   Address = 10.8.0.1/24
   ListenPort = 1194
   PrivateKey = kEANNMfztMtzgwFyyaWOou7+c8ZPD/lyGhmcM7oFtXA=
   PreUp = /etc/wireguard/wstunnel.sh up %i
   PostDown = /etc/wireguard/wstunnel.sh down %i

   [Peer]
   PublicKey = f2CH3QXHiXwFhdATcDi42DU+PUOC9Ky8BgkHBigY5H4=
   AllowedIPs = 10.8.0.2/32

La automatización de :program:`wstunnel` se logra gracias al :download:`script
wstunnel.sh <files/wstunnel.sh>`, que debe guardarse con permisos de ejecución
en :file:`/etc/wireguard`. El *script*, además, lee un fichero de configuración
:file:`/etc/wireguard/wg0.wstunnel` en el que pueden definirse (con la sintaxis
de :command:`sh`) algunas variables:

.. code-block:: bash

   SECURE=1                   # Para usar wss, en vez de ws.
   LISTEN_ADDRESS=127.0.0.1   # IP de escucha de wstunnel. Por defecto, 0.0.0.0.
   LISTEN_PORT=8080           # Por si se desea cambiar el predefinido: ws=80; wss=443

Como para este caso, no cifraremos y queremos que el tunel creado por
:program:`wstunnel` escuche en la interfaz física, **no definiremos ninguna
variable**.

.. note:: Como el :program:`wireguard` sigue escuchando en el puerto 1194 de
   todas las interfaces, incluida la física, los clientes podrán seguir
   conectándose, si tienen la posibilidad, sin necesidad de :program:`wstunnel`.

.. rubric:: Cliente

Mientras en el cliente, debemos crear un archivo :file:`/etc/wireguard/wgt0.conf`
con el siguiente contenido:

.. code-block:: ini

   [Interface]
   Address = 10.8.0.2/24
   PrivateKey = WB4TAWIIlaOyULudlcdhqctTl/pdzO7m+6x4DhAP+0k=
   PreUp = /etc/wireguard/wstunnel.sh up %i
   PostUp = /etc/wireguard/wstunnel.sh route %i
   PostDown = /etc/wireguard/wstunnel.sh down %i

   [Peer]
   PublicKey = /Pr37VgN7GVvizJw9FpCL62DSwocdNEf7lwfdDRZXj8=
   Endpoint = 127.0.0.1:1194
   AllowedIPs = 0.0.0.0/0

que utiliza :download:`el mismo script <files/wstunnel.sh>` para crear la parte
cliente de :program:`wstunnel`. Lo habitual, en el caso de redes restringidas,
es que queramos usar el túnel para salir son cortapisas a internet, de ahí el
valor de :kbd:`AllowedIPs`.

Para esta parte cliente sí es necesario el fichero de configuración del tunel en
el que puede definirse:

.. code-block:: bash

   SECURE=1             # Si queremos usar wss, en vez ws.
   RHOST=203.0.113.1    # Obligatorio. Dirección del servidor.
   WG_PORT=1194         # Puesto en el que escucha la parte servidor de wireguard.

Entiéndase que :var:`RHOST` es la dirección donde escucha el otro extremo de
:program:`wstunnel`. En consecuencia, si se usó en la configuración del servidor
:var:`LISTEN_PORT` para alterar el puerto predeterminado y se dejó este
escuchando en la interfaz física, es más que probable que tenga que incluir
el puerto al definir :var:`RHOST`:

.. code-block:: bash

   RHOST=203.0.113.1:8080

.. warning:: Si deseamos acceder al servidor mediante nombre y no mediante |IP|,
   nos toparemos con el problema de que para establecer el túnel, necesitamos
   resolver el nombre, pero para resolver el nombre con un |DNS| externo,
   tenemos que haber completado el establecimiento del túnel.  Como usar el
   nombre y no la |IP| sólo cobra importancia, cuando utilizamos un proxy
   *inverso* en el servidor, trataremos este problema :ref:`al añadir nginx a la
   ecuación <wg-nginx>`.

En cuanto a :var:`WG_PORT` coincidirá con el valor de :kbd:`ListenPort` definido
en el servidor.

Para resolver nuestro caso, dejaremos esta configuración:

.. code-block:: bash

   # /etc/wireguard/wgt0.wstunnel

   RHOST=203.0.113.1
   WG_PORT=1194

.. _wg-nginx:

Añadiendo :program:`nginx` a la ecuación
========================================
Poner a escuchar en la interfaz física a :program:`wstunnel` imposibilita
a la máquina hacer también de servidor web. Si este es el caso, la solución
consiste en disponer un *proxy* inverso que redirija el tráfico hacia el
servidor web o hacia :program:`wstunnel` según convenga.

.. image:: files/wg+nginx.png

Servidor
--------
La actuación en el servidor consiste en configurar:

- :program:`wireguard` con :program:`wstunnel`.
- :ref:`nginx <n-ginx>` como proxy inverso.

:program:`wireguard` con :program:`wstunnel`
   Debemos poner a  escuchar a :program:`wstunnel` en la interfaz de *loopback*,
   usando *ws* y en un puerto (*8080*) que no moleste al servidor *web*. La
   configuración de la interfaz (:file:`/etc/wireguard/wg0.conf`, será la siguiente):

   .. code-block:: ini

      [Interface]
      Address = 10.8.0.1/24
      ListenPort = 1194
      PrivateKey = kEANNMfztMtzgwFyyaWOou7+c8ZPD/lyGhmcM7oFtXA=
      PreUp = /etc/wireguard/wstunnel.sh up %i
      PostDown = /etc/wireguard/wstunnel.sh down %i

      [Peer]
      PublicKey = f2CH3QXHiXwFhdATcDi42DU+PUOC9Ky8BgkHBigY5H4=
      AllowedIPs = 10.8.0.2/32

   y la del túnel (`/etc/wireguard/wg0.wstunnel`):

   .. code-block:: bash

      LISTEN_ADDRESS=127.0.0.1
      LISTEN_PORT=8080

   Con esta configuración, podemos acceder sin encapsulación al extremo servidor de
   la |VPN| conectándonos al puerto *1194*. En cambio, la encapsulación con
   :program:`wstunnel` escucha en *localhost:8080* y no es directamente accesible, ya que
   usaremos como intermediario a :program:`nginx`.

:program:`nginx`
   Debemos crear un fichero con la configuración pertinente llamado
   :file:`snippets/websocket.conf`:

   .. code-block:: nginx

      proxy_http_version 1.1;
      proxy_set_header Upgrade $http_upgrade;
      proxy_set_header Connection $connection_upgrade;

      proxy_set_header X-Forwarded-Host $host;
      proxy_set_header X-Forwarded-Proto $x_forwarded_proto;
      proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
      proxy_set_header Host $http_host;

   Si hemos usado el nombre *vpn.example.net* para identificar la conexión,
   entonces podremos definir el sitio como:

   .. code-block:: nginx

      map $http_upgrade $connection_upgrade {
         default upgrade;
         '' close;
      }

      map $https $x_forwarded_proto {
         default http;
         on      https;
      }

      server {
         listen 80;
         listen 443 ssl;

         server_name vpn.example.net;

         include snippets/snakeoil.conf;

         if ($https = "on") {
            proxy_set_header X-Forwarded-Proto https;
         }

         location / {
            proxy_pass http://127.0.0.1:8080;
            include snippets/websocket.conf;
         }
      }

   .. note:: En caso de no haber usado el nombre de máquina para identificar la
      conexión |VPN| y haber echado mano de la ruta :file:`/wireguard/`, basta con
      usar tal localización en la configuración de :program:`nginx`:

      .. code-block:: nginx

         location ^~ /wireguard/ {
            proxy_pass http://127.0.0.1:8080;
            include snippets/websocket.conf;
         }

      En la parte relativa al cliente está explicado como incorporar la ruta a
      la petición. 

Cliente
-------
En el clientes las actuaciones consisten en configurar:

- :program:`wireguard` con :program:`wstunnel`
- :ref:`dnsmasq <dnsmasq>` para poder usar un nombre para el servidor en vez de
  su |IP|.

:program:`wireguard` con :program:`wstunnel`
   En cada cliente podemos tener dos configuraciones: una para cuando el cliente
   no se encuentre en una red restringida y que conecta directamente con el puerto
   *1194* y otra para cuando se encuentra restricciones y debe usar el *websocket*
   para burlarlas.

   La primera configuración la asociaremos con la interfaz *wg0* y tendrá este
   fichero de configuración (:file:`/etc/wireguard/wg0.conf`):

   .. code-block:: ini

      [Interface]
      Address = 10.8.0.2/24
      PrivateKey = WB4TAWIIlaOyULudlcdhqctTl/pdzO7m+6x4DhAP+0k=

      [Peer]
      PublicKey = /Pr37VgN7GVvizJw9FpCL62DSwocdNEf7lwfdDRZXj8=
      Endpoint = 203.0.113.1:1194
      AllowedIPs = 0.0.0.0/0

   La segunda encapsula hacienda uso de :program:`wstunnel` y la asociaremos
   a dos interfaces distintas: *wgt0* para usar *websocket* utilizando |HTTP|
   y *wgts0* para usar *websocket* utilizando |HTTP|\ s. La primera es preferible,
   ya que evita añadir una capa más de cifrado que afectará al rendimiento de la
   conexión, pero la segundo podría ser necesaria en caso de que el proxy de la red
   nos impida el uso de la primera.

   El fichero :file:`/etc/wireguard/wgt0.conf` debe ser el siguiente:

   .. code-block:: ini

      [Interface]
      Address = 10.8.0.2/24
      PrivateKey = WB4TAWIIlaOyULudlcdhqctTl/pdzO7m+6x4DhAP+0k=
      PreUp = /etc/wireguard/wstunnel.sh up %i
      PostUp = /etc/wireguard/wstunnel.sh route %i
      PostDown = /etc/wireguard/wstunnel.sh down %i

      [Peer]
      PublicKey = /Pr37VgN7GVvizJw9FpCL62DSwocdNEf7lwfdDRZXj8=
      Endpoint = 127.0.0.1:1194
      AllowedIPs = 0.0.0.0/0

   y el del túnel (:file:`/etc/wireguard/wgt0.wstunnel`):

   .. code-block:: ini

      RHOST=vpn.example.net
      WG_PORT=1194

   .. note:: Desde el clientamos con :program:`nginx`, no con wl
      :program:`wstunnel` del otro extremo, de ahí que no haya habido que hacer
      mención al puerto *8080*.

   La configuración para la interfaz alternativa *wgts0* es prácticamente la misma,
   salvo porque :program:`wstunnel` debería utlizar *wss* y no *ws*. Por ello,
   el fichero de configuración de la interfaz es exactamente el mismo::

      # cd /etc/wireguard
      # ln -s wgt0.conf wgts0.conf

   y el de configuración del túnel (:file:`/etc/wireguard/wgts0.wstunnel`) no tiene
   más que declarar que se usará canal seguro:

   .. code-block:: bash

      SECURE=1
      . /etc/wireguard/wgt0.wstunnel

   .. note:: Suponemos que la conexión al *websocket* se hace usando el nombre
      *vpn.example.net*, lo que nos permitirá identificarla en :program:`nginx`.
      En caso de no ser posible y sólo tener la posibilidad de conectar a través
      de la |IP|, aún podemos distinguir la conexión |VPN| del tráfico |HTTP|
      a través de la ruta. Para ellos debemos añadir a la configuración del
      túnel la variable :var:`WPATH`:

      .. code-block:: ini

         RHOST=203.0.113.1
         WG_PORT=1194
         WPATH=/wireguard/

:program:`dnsmasq`
   Necesitamos usar :program:`dnsmasq` para asegurarnos de que el nombre del
   servidor es resoluble cuando el túnel no ha acabado de establecirse. La
   argucia consiste en incluir manualmente la resolución en un fichero de *hosts*
   y utilizar :program:`dnsmasq` para que la consulta no salga de la propia
   máquina. La receta mínima (hay una amplia sección dedicada a la configuración
   de :ref:`dnsmasq <dnsmasq>`) es la siguiente:

   #. Instalar :program:`dnsmasq`::

         # apt install dnsmasq

   #. Añadir el fichero :file:`/etc/dnsmasq.d/dns.conf` con el siguiente
      contenido:

      .. code-block:: bash

         no-resolv
         server=1.1.1.1    # O Los servidores DNS que prefiramos.
         server=1.0.0.1
         addn-hosts=/etc/hosts.d/
         
   #. Añadir a :file:`/etc/hosts.d/vpn` la resolución del servidor |VPN|::

         203.0.113.1       vpn.example.net

   #. Reiniciar :program:`dnsmasq`::

         # invore-rc.d dnsmasq restart

   #. Modificar :file:`/etc/resolv.conf` para que sea nuestra propia máquina (o
      sea, :program:`dnsmasq`) el servidor de consulta::

         nameserver 127.0.0.1

.. rubric:: Notas al pie

.. [#] Sí existe paquete para `websockify
   <https://github.com/novnc/websockify>`_, pero éste sólo permite encapsular
   tráfico |TCP|.

.. |UDP| replace:: :abbr:`UDP (User Datagram Protocol)`
.. |TCP| replace:: :abbr:`TCP (Transmission Control Protocol)`
.. |HTML| replace:: :abbr:`HTML (HyperText Markup Language)`
.. |SSL| replace:: :abbr:`SSL (Secure Sockets Layer)`
